[{"id":"b785373ff41b86c86fee988839b61307","title":"你好，欢迎到访团子的博客","content":"一名在路上的WebGiser，记录学习之路\n","slug":"你好，欢迎到访团子的博客 copy","date":"2022-12-02T04:39:41.997Z","categories_index":"welcome","tags_index":"hello","author_index":"团子"},{"id":"838ae74e3a76757d637de803a615bfd9","title":"MySQL","content":"前言. 数据库1.数据库的意义\n\n\n\n\n\n\n\n\n数据库就是存放数据的仓库\n想像一下, 在没有计算机之前, 我们如何统计人口数据的, 通常都是用纸和笔登记, 填写像这样的一张表格.\n\n再将这些表格按照一定的顺序整理\n\n最后放到一个档案室里集中管理\n\n这个档案室实际上就是一个存放数据的仓库.\n但是这种管理方式是非常低效的, 如果要从100万人中找出某一个人的信息, 是非常慢的.\n数据库的产生实际上就是利用计算机, 方便高效的管理数据.\n\n\n\n\n\n\n\n\n\n数据库是信息系统的重要组成部分\n任何信息系统都离不开对数据的处理.\n比如\n\n新闻系统最核心的是一篇一篇的文章, 文章也就是数据\n电商系统最核心的是商品, 商品也可以用数据来描述, 比如价格, 颜色, 重量…\n\n2.数据库的基本概念数据库最基本的组成单元就是一条一条数据记录, 这个就是数据行\n为了让数据更加方便管理, 通常我们会使用表格来描述, 这个就是数据表\n很多数据表放在一起就形成数据库\n3.数据库的基本操作\n\n\n\n\n\n\n\n\n添加操作\n我们还是以人口统计为例. \n比如, 一个小孩出生了, 我们需要给小孩上户口. \n从数据库的角度就是将小孩的信息添加到数据库中保存起来. \n可能是保存在某一张表里(假设叫人口表)\n一般都有哪些信息呢? 姓名, 性别, 籍贯, 身份证, 户口所在地…这些就是字段, 也就是表头\n\n\n\nid\n姓名\n性别\n籍贯\n户口所在地\n\n\n\n1\n张三\n男\n武汉\n北京\n\n\n2\n\n\n\n\n\n\n3\n\n\n\n\n\n\n4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n更新操作\n又有一天, 小孩上大学了, 户口要迁移到学校, 需要修改户口所在地信息. \n从数据库的角度就是找到对应的小孩的信息, 更新户口所在地\n\n\n\n\n\n\n\n\n\n删除操作\n比如, 某个老人过世了, 需要删除这个老人的信息.\n从数据库的角度就是找到对应的信息, 删除\n\n\n\n\n\n\n\n\n\n查询操作\n有的时候, 需要查询张三这个人的具体的信息, 怎么办?\n每个人都有身份证号, 身份证号是唯一的. 每个人都不同, 可以根据身份证号做为查询条件, 查找张三的全部信息\n一. MySQL概述1.什么是MySQL\n\n\n\n\n\n\n\n\n定义\nMySQL是一种关系型数据库软件, 基于C/S架构\n\n数据库: 存储数据的仓库\n关系型: 数据与数据之间存在关系\nC/S架构: Client(客户端)和Server(服务端)\n\n2.为什么学MySQL对于后端工程师, 数据库是必备技能. \n对于前端工程师, 会一些数据库方面的知识\n\n可以在接口联调的时候占主动\n可以向全栈发展\n\nMySQL是数据库中使用最广范的, 学了MySQL后再学其他的数据库也是非常容易的\n\n数据来源于: StackOverflow2020调查报告\n3.如何理解关系型\n\n\n\n\n\n\n\n\n关系型数据库有明确的库/表/行的关系\n数据库由数据表组成\n数据表由数据行(记录)组成\n\n4.MySQL的安装1) 安装MySQL服务端\n\n\n\n\n\n\n\n\n演示\n2) 安装MySQL客户端MySQL的客户端有很多种. 这里, 我主要使用的是Navicate\n5.如何理解C/S架构MySQL分为MySQL客户端和MySQL服务端\n不管是客户端还是服务端, 本质上依然是一个程序\n服务端: 提供服务的程序\n客户端: 连接服务端执行操作的程序\n\n\n\n\n\n\n\n\n\n演示\n\n\n在命令行中输入mysql -uroot -p, 连接服务端, 因此, 当前的这个窗口就是一个MySQL的客户端\n\n\n\n\n\n\n\n\n\n思考\nMySQL主要操作是在哪些完成的? 客户端!\n二. MySQL基本操作一般MySQL操作都是在操作MySQL客户端\n这里, 我们可以使用一些图形化的软件, 如Navicate/MySQL-Front. \n如果需要操作MySQL, 需要先使用MySQL客户端连接到服务端\n\n1.客户端连接与基本操作1) 连接数据库\n点击后弹出如下窗口\n\n2) 创建数据库3) 选择数据库\n两种操作\n\n双击\n右键-&gt;打开数据库\n\n3) 建库建表看演示\n2.SQL概念(了解)1) 什么是SQLStructured Query Language 结构化查询语言\n2) SQL的作用\n是一种所有关系型数据库的查询规范, 不同的数据库都支持\n通用的数据库操作语言, 可以用在不同的数据库中\n\n3) SQL语句分类\nData Definition Language(DDL数据定义语言) 如: 建库, 建表\nData Manipulation Language(DML 数据操纵语言) 如: 对表记录的增/删/改\nData Query Language(DQL 数据查询语言) 如: 对表的查询操作\nData Control Language(DCL 数据控制语言) 如: 对用户权限的设置\n\n使用频率\nCURD(增删改查)占到了数据库操作80%\n查询占到CURD的80%\n4) MySQL的语法\n每条语句以分号结尾\nSQL中不区分大小写, 推荐关键字大写以区分\n\n三. 数据类型0.前言在现实世界中, 数据的种类有很多, \n比如, 人的姓名(字符), 人的年龄(整型), 人的身高(小数), 出生日期(日期)\n而MySQL就是用来保存这些数据的, 所以在 MySQL中, 将数据分为三大类: \n\n数值型\n字符串\n日期与时间\n\n\n\n\n\n\n\n\n\n\n学习目的\n通过学习, 大概了解怎么选择合适的数据类型\n\n1.数值–整型\n\n\n类型\n名称\n说明\n无符号范围\n有符号范围\n\n\n\n整型\ntinyint\n微整型, 占8位二进制\n0~255\n-127~128\n\n\n\nsmallint\n小整型, 占16位二进制\n0~65535(6万)\n-32767~32768\n\n\n\nint\n整型\n0~42亿\n\n\n\n\nbigint\n大整型\n0~200亿亿\n\n\n\n\n\n\n\n\n\n\n\n\n选型\n一个人的年龄:  tinyint\n小型blog的序号: smallint\n大学一个学校的学生序号: int\n大型电商网站的商品表的序号: int\n马云的资产: bigint\n\n\n\n\n\n\n\n\n\n说明\n在mysql中, 默认的整型是带符号的, 如果要定义无符号整型, 需要加上unsigned\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_int&#96; (\n    age tinyint unsigned,\n    stu_sn smallint unsigned,\n    goods_sn int unsigned,\n    mayun bigint\n);\n\n2.数值–小数小数分为\n\n浮点\n单精度\n双精度\n\n\n定点\n\n浮点型的数据不精确, 所以一般表示价格, 我们使用定点型\n\n\n\n类型\n名称\n说明\n\n\n\n小数\nfloat(m,d)\nm(精度), 表示总位数, d(标度), 表示小数点后的位数\n\n\n\ndouble(m,d)\nm(精度), 表示总位数, d(标度), 表示小数点后的位数\n\n\n\ndecimal(m,d)\nm(精度), 表示总位数, d(标度), 表示小数点后的位数\n\n\n\n\n\n\n\n\n\n\n\n选型\n距离: 3.4 km float(10,2) \n人的体重: 80.5kg  float(5,2)\n价格: 9.9 RMB decimal(10,2)\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_float&#96; (\n    distance float(10,2),\n    weight float(5,2),\n    price decimal(10,2)\n);\n\n3.字符串\n\n\n类型\n名称\n说明\n\n\n\n字符型\nchar(M)定长\n无论使用几个字符都占满全部, 范围0~255字符\n\n\n\nvarchar(M)变长\n使用几个字符就占用几个, 理论范围0~65535字符\n\n\n\ntext\n允许长度 0~65535 字节\n\n\n\nenum(集合)\n枚举, 集合表示选项, 以逗号隔开\n\n\n\n\n\n\n\n\n\n\n\n选型\nchar类型: 固定长度, 一般用于存储固定长度的字符串, 如\n\n手机号 char(11)\n通过md5加密后的密码值char(32)\n\nvarchar类型: 可变长度, 存储长度不确定的字符字符串, 如\n\n姓名 varchar(16)\n邮箱 varchar(255)\n\ntext类型: 存储大段内容, 如\n\n文章内容 text\n\nenum类型: 单选, 如\n\n性别\n\n\n\n\n\n\n\n\n\n\n说明\nchar与varchar的区别\n\nchar是固定的长度 char(5) 保存 abc, 实际占用的空间5个\nvarchar最大长度 varchar(5)保存abc, 实际占用的空间3个\n\nvarchar用多少就占多少\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_char&#96; (\n    phone char(11),\n    password char(32),\n    name varchar(16),\n    email varchar(255),\n    content text,\n    sex enum(&#39;男&#39;,&#39;女&#39;)\n);\n\n\n\n\n\n\n\n\n\n\n说明\nchar(M)与varchar(M)中的M表示的字符数\n4.日期与时间\n\n\n类型\n名称\n说明\n\n\n\n日期\ndate\n范围1000-01-01~9999-12-31\n\n\n\ndatetime\n范围1000-01-01 00:00:00~9999-12-31 23:59:59\n\n\n\ntimestamp\n从1970年开始至今的秒数\n\n\n\n\n\n\n\n\n\n\n\n选型\n出生日期: date\n商品抢购的开始结束时间: datetime\n文章的创建更新时间: timestamp(时间戳)\n\n\n\n\n\n\n\n\n\n说明\n时间戳: 从1970年1月1日0时0分0秒到当前时间的秒数(整数)\n一般时间类型更常见的是保存时间戳, 时间戳就是一个整型数, 为什么保存时间戳呢?\n\n效率更高\n方便处理\n\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_time&#96; (\n    birthday date,\n    start_time datetime,\n    end_time datetime,\n    created_time timestamp\n);\n\n\n\n六. 字段属性字段属性又叫字段约束, 通常用来限定(约束)当前列\n\n能否为空\n默认值\n\n1.能否为空如果需要当前字段不能为空, 默认情况下是可以为空的\n\n\n\n\n\n\n\n\n\n关键词\nnot null\n\n\n\n\n\n\n\n\n\n语法\nCREATE TABLE &#96;表名&#96; (\n    字段 字段类型 not null\n);\n\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_null&#96; (\n    id int,\n    name varchar(16) not null\n);\n\n\n\n2.默认值有些情况下，我们希望某个字段拥有默认值，比如\n\n性别的字段，拥有默认值为“男”\n籍贯的字段，拥有默认值为“汉”\n\n\n\n\n\n\n\n\n\n\n关键词\ndefault\n\n\n\n\n\n\n\n\n\n语法\nCREATE TABLE &#96;表名&#96; (\n    字段 字段类型 default 默认值\n);\n\n\n\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_default&#96; (\n    name varchar(16),\n    sex enum(&#39;男&#39;,&#39;女&#39;) default &#39;男&#39;\n);\n\n3.主键如果我们可以通过某一列进行唯一的标识每一条记录，我们就可以把这个字段当做主键\n\n\n\n\n\n\n\n\n\n关键词\nprimary key\n\n\n\n\n\n\n\n\n\n语法\nCREATE TABLE &#96;表名&#96; (\n    字段 字段类型 primary key\n);\n\n4.自增如果数据表中的某个字段，需要进行自动增长，我们可以将其定义为自动增长, 一般自增跟主键连用\n\n\n\n\n\n\n\n\n\n关键词\nauto_increment\n\n\n\n\n\n\n\n\n\n语法\nCREATE TABLE &#96;表名&#96; (\n    字段 字段类型 primary key auto_increment\n);\n\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_primary&#96; (\n    id int primary key auto_increment\n);\n\n5.备注在创建字段时, 一般需要给一定的说明\n\n\n\n\n\n\n\n\n\n关键词\ncomment\n\n\n\n\n\n\n\n\n\n语法\nCREATE TABLE &#96;表名&#96; (\n    字段 字段类型 字段属性 comment &#39;备注&#39;\n);\n\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_comment&#96; (\n    id int primary key auto_increment comment &#39;主键&#39;,\n    name varchar(16) not null comment &#39;姓名&#39;\n);\n\n\n\n\n\n\n\n\n\n\n完整的建表语句\nCREATE TABLE &#96;表名&#96; (\n    字段1 字段类型1 字段属性1 字段属性2 字段属性3,\n    ...\n);\n\n七. 综合建表案例1.文章表blog\n\n\n\n\n\n\n\n\n分析\nblog表需要哪些字段\n\n主键id\n作者(author)\n标题(title)\n内容(content)\n浏览数(click)\n评论数(comment)\n发布时间(publish_time)\n\nCREATE TABLE &#96;blog&#96; (\n  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,\n  &#96;title&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;标题&#39;,\n  &#96;content&#96; text NOT NULL COMMENT &#39;内容&#39;,\n  &#96;author&#96; varchar(32) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;作者&#39;,\n  &#96;click&#96; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;浏览数&#39;,\n  &#96;comment&#96; smallint(6) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;评论数&#39;,\n  &#96;publish_time&#96; date DEFAULT NULL COMMENT &#39;发布日期&#39;,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;\n\n\n\n2.商品表goods\n\n\n\n\n\n\n\n\n分析\ngoods表需要哪些字段\n\n主键id\n分类id(cate_id)\n商品名称(goods_name)\n本店价格(shop_price)\n市场价格(market_price)\n商品数量(goods_number)\n点击数(click)\n\nCREATE TABLE &#96;goods&#96; (\n    id int unsigned primary key auto_increment comment &#39;主键&#39;,\n    cate_id int not null comment &#39;所属分类&#39;,\n    goods_name varchar(255) not null comment &#39;商品品称&#39;,\n    shop_price decimal(10,2) not null default 0 comment &#39;本店价格&#39;,\n    market_price decimal(10,2) not null default 0 comment &#39;市场价格&#39;,\n    goods_number int not null comment &#39;商品数量&#39;,\n    click int not null default 0 comment &#39;点击数&#39;\n);\n\n\n\n3.学生表stu\n\n\n\n\n\n\n\n\n分析\nstu表需要哪些字段\n\n主键id\n学号(sn) \n姓名(name)\n性别(sex) enum\n学科(subject)\n身高(height) float\n\nCREATE TABLE &#96;stu&#96; (\n    id int unsigned primary key auto_increment comment &#39;主键&#39;,\n    sn char(8) unique not null comment &#39;学号&#39;,\n    name varchar(32) not null comment &#39;姓名&#39;,\n    sex enum(&#39;男&#39;, &#39;女&#39;) not null default &#39;男&#39; comment &#39;性别&#39;,\n    subject varchar(16) not null comment &#39;学科&#39;,\n    height float(3,2) not null comment &#39;身高&#39;\n);\n\n八. 数据的写操作(重点)0.前言MySQL最主要的功能是管理数据, 也就是增/删/改/查, 也叫CURD, 从大的方面划分就是写操作和读操作\n首先, 我们来学习写操作\n1.添加操作1) 基本用法把握3点\n\n插入哪张表?\n插入表的哪些列(字段)?\n这些列的值?\n\n\n\n\n\n\n\n\n\n\n语法\nINSERT INTO &#96;表名&#96;\n(&#96;字段1&#96;, ... &#96;字段n&#96;)\nVALUES\n(值1, 值2, 值n)\n\n\n\n\n\n\n\n\n\n\n示例一. 插入单条记录\n# 先选择db1数据库\nUSE &#96;db1&#96;;\n# 向t1表中添加一条数据\nINSERT INTO &#96;t1&#96;\n(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;)\nVALUES\n(1, &#39;xiaoming&#39;, 20);\n\n如何查看数据是否添加成功?\n先了解一个基本的查询操作\n# 查询表中的所有记录\nselect * from &#96;表名&#96;;\n\n\n\n\n\n\n\n\n\n\n示例二. 一次插入多条记录\n# 向t1表中一次添加多条记录\nINSERT INTO &#96;t1&#96;\n(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;)\nVALUES\n(2, &#39;xiaomei&#39;, 18),\n(3, &#39;xiaoqiang&#39;, 22);\n\n一个() : 代表一条记录\n多个()使用,隔开\n\n\n\n\n\n\n\n\n\n扩展\n如果已经在db1数据库下, 不用执行USE命令, 也可以显式的指定库名, 如\nINSERT INTO db1.t1\n(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;)\nVALUES\n(1, &#39;xiaoming&#39;, 20);\n\n\n\n2) 允不允许只插入部分字段和值?\n\n\n\n\n\n\n\n\n尝试\nINSERT INTO &#96;student&#96;\n(&#96;name&#96;, &#96;age&#96;)\nVALUES\n(&#39;xiaomei&#39;, 18);\n\n结论: _____________\n3) 允不允许不写字段?\n\n\n\n\n\n\n\n\n尝试\nINSERT INTO &#96;student&#96;\nVALUES\n(&#39;laowang&#39;, 30);\n\n\n\n\n\n\n\n\n\n\n尝试\nINSERT INTO &#96;student&#96;\nVALUES\n(null, &#39;laowang&#39;, 30);\n\n结论: _________\n4) 添加案例\n超出整型范围\n\nINSERT INTO &#96;t_int&#96; (age) VALUES (300);\n\n\n浮点型精度丢失问题\n\nINSERT INTO &#96;t_float&#96; VALUES (12345678.12, 123.12, 12345678.12);\n\n\n插入中文数据\n\nINSERT INTO &#96;t_char&#96; (name) VALUES (&#39;小明&#39;);\n\n\n如果插入的字符串超过长度, 会怎样?\n\nINSERT INTO &#96;t_char&#96; (phone) VALUES (&#39;130123456789&#39;);\n\n\n如果插入的值不在enum的选型类, 会怎样?\n\nINSERT INTO &#96;t_char&#96; (sex) VALUES (&#39;女博士&#39;);\n\n\n如果字段类型是字符型, 插入的数据是整型或者小数型会怎样?\n\nINSERT INTO &#96;t_char&#96; (phone) VALUES (13012345678);\nINSERT INTO &#96;t_char&#96; (phone) VALUES (123456789.1);\n\n\n如果字段不能为null, 但是添加的时候没有指定会怎样?\n\nINSERT INTO &#96;t_null&#96; (id) VALUES (1);\n\n设置了not null的字段, 在插入数据时必须出现在字段列表中\n\n如果设置了默认值, 但是添加的时候没有指定会怎样?\n\nINSERT INTO &#96;t_default&#96; (name) VALUES (&#39;xiaoming&#39;);\n\n\n\n\n\n\n\n\n\n\n添加案例小结\n\n插入数据的类型最好与要求的类型一致\n插入的数据必须在有效范围内\n插入的数据为null时给默认值\n自增会在原来的基础上+1\n\n2.修改操作4点\n\n修改哪张表?\n修改表的哪些列(字段)?\n这些列的值?\n条件\n\n\n\n\n\n\n\n\n\n\n语法\nUPDATE &#96;表名&#96;\nSET\n&#96;字段1&#96;&#x3D;值1,\n&#96;字段2&#96;&#x3D;值2,\n...\nWHERE 条件\n\n\n\n\n\n\n\n\n\n\n示例\nUPDATE &#96;student&#96;\nSET\n&#96;name&#96;&#x3D;&#39;xiaoming-new&#39;\nWHERE &#96;id&#96;&#x3D;1;\n\n\n\n\n\n\n\n\n\n\n演示\n3.删除操作2点\n\n删除哪张表?\n删除哪些行?\n\n\n\n\n\n\n\n\n\n\n语法\nDELETE FROM &#96;表名&#96; WHERE 条件\n\n\n\n\n\n\n\n\n\n\n示例\nDELETE FROM &#96;student&#96; WHERE &#96;id&#96;&#x3D;3;\n\n\n\n\n\n\n\n\n\n\n演示\n九. 查询–基本查询相对于写操作, 读操作(查询操作)使用的更为频繁, 大部分的业务都体现在读操作上, 内容比较多\n我们先学习基本查询\n1.基本用法1) 基本查询3点:\n\n查哪张表的数据?\n查哪些列的数据?\n条件\n\n\n\n\n\n\n\n\n\n\n语法\nSELECT 字段1, 字段2, ...字段n \nFROM 表名\n[WHERE 条件]\n\n\n\n\n\n\n\n\n\n\n示例1–查询指定的列\n# 查询t1表中的name和age字段\nSELECT &#96;name&#96;, &#96;age&#96; FROM &#96;t1&#96;;\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n\n\n\n\n\n\n\n示例2–查询所有的列\n# 查询t1表中的所有数据\nSELECT * FROM &#96;t1&#96;;\n\n\n* : 表示所有字段\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n\n\n\n\n\n\n\n示例3–根据条件查询\n# 查询xiaomei的年龄\nSELECT &#96;age&#96; FROM &#96;t1&#96; WHERE &#96;name&#96;&#x3D;&#39;xiaomei&#39;;\n\n\n\n\n\n\n\n\n\n\n演示\n2) 别名可以给指定的列取一个别名, 一般用于多表查询中\n\n\n\n\n\n\n\n\n\n语法\nSELECT 字段1 as 别名1, 字段2 as 别名2 FROM 表名 as 表别名\n\n其中, as关键字可以省略\n\n\n\n\n\n\n\n\n\n示例\nSELECT &#96;name&#96; as &#96;username&#96; FROM &#96;t1&#96; as stu;\n\n\n\n\n\n\n\n\n\n\n演示\n2.查询模型1) 基本点3个点\n\n列当作变量\n列可以参与计算\nwhere条件判断真假\n\n\n\n\n\n\n\n\n\n\n如何理解\n逐行比较, 当where条件为真的时候, 把列(变量)的值取出来\n\n\n\n\n\n\n\n\n\n示例\nSELECT name, age FROM &#96;student&#96;;\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n\n\n\n\n\n\n\n示例2\n# 查询本店价比市场价低多少(计算差价)\nSELECT market_price - shop_price FROM &#96;goods&#96;;\n\n\n\n\n\n\n\n\n\n\n演示\n3) where条件MySQL中常用的运算符如下表:\n\n\n\n运算符\n说明\n\n\n\n&gt;, &lt;, &lt;=, &gt;=, =, &lt;&gt;\n&lt;&gt;表示不等于, 也可以使用!=\n\n\nBETWEEN…AND\n在某个范围内, between 100 and 200, 包含100和200, 闭区间[100, 200]\n\n\nIN (1,2, … n)\n集合表示多个值，使用逗号分隔\n\n\nLIKE\n模糊查询\n\n\nis null\n查询某一列为null\n\n\nis not null\n查询某一列不为null\n\n\n\n\n\n逻辑运算符\n说明\n\n\n\nand 或者 &amp;&amp;\n与， SQL 中建议使用前者，后者并不通用\n\n\nor 或者 ||\n或\n\n\nnot 或者 !\n非\n\n\n\n\n\n通配符\n说明\n\n\n\n%\n匹配任意多个字符\n\n\n_\n匹配一个字符\n\n\n3.查询案例以商品表为例, 做如下查询练习\n1.1 查询主键id为32的商品\nSELECT * FROM &#96;goods&#96; WHERE &#96;id&#96;&#x3D;32;\n\n1.2 不属第3栏目的所有商品id和名称\nSELECT &#96;id&#96;, &#96;goods_name&#96;, &#96;cate_id&#96;\nFROM &#96;goods&#96;\nWHERE &#96;cate_id&#96; !&#x3D; 3;\n\n1.3 本店价格高于3000元的商品\nSELECT &#96;goods_name&#96;, &#96;shop_price&#96;\nFROM &#96;goods&#96;\nWHERE &#96;shop_price&#96; &gt; 3000;\n\n1.4 本店价格低于或等于100元的商品\nSELECT &#96;goods_name&#96;, &#96;shop_price&#96;\nFROM &#96;goods&#96;\nWHERE &#96;shop_price&#96; &lt;&#x3D; 100;\n\n1.5 取出第4栏目或第11栏目的商品(使用or或者使用in)\n# 使用or\nSELECT &#96;goods_name&#96;, &#96;cate_id&#96;\nFROM &#96;goods&#96;\nWHERE &#96;cate_id&#96;&#x3D;4 or &#96;cate_id&#96;&#x3D;11;\n\n# 不使用or\nSELECT &#96;goods_name&#96;, &#96;cate_id&#96;\nFROM &#96;goods&#96;\nWHERE &#96;cate_id&#96; in (4, 11);\n\n1.6 取出100&lt;=本店价格&lt;=500的商品(使用and或者between)\n# 使用and\nSELECT &#96;goods_name&#96;, &#96;shop_price&#96;\nFROM &#96;goods&#96;\nWHERE &#96;shop_price&#96; &gt;&#x3D; 100 and &#96;shop_price&#96; &lt;&#x3D; 500;\n\n# 不使用and\nSELECT &#96;goods_name&#96;, &#96;shop_price&#96;\nFROM &#96;goods&#96;\nWHERE &#96;shop_price&#96; between 100 and 500;\n\n1.7 取出不属于第3栏目且不属于第11栏目的商品(使用and或使用not in分别实现)\n# 使用and\nSELECT &#96;goods_name&#96;, &#96;cate_id&#96;\nFROM &#96;goods&#96;\nWHERE &#96;cate_id&#96; !&#x3D; 3 and &#96;cate_id&#96; !&#x3D; 11;\n\n# 使用 not in\nSELECT &#96;goods_name&#96;, &#96;cate_id&#96;\nFROM &#96;goods&#96;\nWHERE &#96;cate_id&#96; not in (3, 11);\n\n1.8 取出第3个栏目下面价格&lt;1000或&gt;3000,并且点击量&gt;5的商品\nSELECT &#96;goods_name&#96;, &#96;cate_id&#96;, &#96;shop_price&#96;, &#96;click_count&#96;\nFROM &#96;goods&#96;\nWHERE &#96;cate_id&#96;&#x3D;3\nand (&#96;shop_price&#96; &lt; 1000 or &#96;shop_price&#96; &gt; 3000)\nand &#96;click_count&#96; &gt; 5;\n\n1.9 取出名字以”诺基亚”开头的商品\nSELECT &#96;goods_name&#96;\nFROM &#96;goods&#96;\nWHERE &#96;goods_name&#96; LIKE &#39;诺基亚%&#39;;\n\n1.10 取出名字为”诺基亚Nxx”的手机\nSELECT &#96;goods_name&#96;\nFROM &#96;goods&#96;\nWHERE &#96;goods_name&#96; LIKE &#39;诺基亚N__&#39;;\n\n十. 进阶查询操作(select子句)0.前言MySQL除了能做基本的条件查询操作外, 还可以用来过滤数据, 比如分组统计, 排序等\n通过, SELECT的子句, 可以完成复杂的操作, 除了where子句, 还有如下4个, 一般称select 子句\n\ngroup by\nhaving\norder by\nlimit\n\n\n\n\n\n\n\n\n\n\n注意\n子句的顺序不能颠倒, 如下\nSELECT 字段 FROM 数据表  \nwhere子句  \ngroup by子句  \nhaving子句  \norder by 子句  \nlimit 子句;\n\n1.group by子句分组的目的是为了统计, 因此分组通常和聚合函数连用\n\n\n\n\n\n\n\n\n\n聚合函数\n\ncount: 计算总数\nsum: 求和\nmax: 最大值\nmin: 最小值\navg: 平均值\n\n\n\n\n\n\n\n\n\n\n聚合函数用法示例\n查出最贵的商品价格\nSELECT max(shop_price) FROM &#96;goods&#96;;\n\n查出最便宜的商品的价格\nSELECT min(shop_price) FROM &#96;goods&#96;;\n\n查询该店所有商品的库存总量\nSELECT sum(goods_number) FROM &#96;goods&#96;;\n\n查询所有商品的平均价\nSELECT avg(shop_price) FROM &#96;goods&#96;;\n\n查询该店一共有多少种商品\nSELECT count(*) FROM &#96;goods&#96;;\n\nSELECT sex, count(*) FROM &#96;stu&#96; GROUP BY &#96;sex&#96;; &#x2F;&#x2F; 更推荐\nSELECT sex, count(sex) FROM &#96;stu&#96; GROUP BY &#96;sex&#96;;\n\n\n\n\n\n\n\n\n\n\n练习\n需求: 统计每个栏目下最贵的商品\n思路:\n\n第一步: 按照栏目(cate_id)对所有的数据进行分组\n第二步: 使用聚合函数求最大值\n\n\n\n\n\n\n\n\n\n\n分组统计\n第一步: 分组\nSELECT cate_id FROM goods group by cate_id;\n\n第二步: 统计\nSELECT &#96;cate_id&#96;, max(shop_price)\nFROM &#96;goods&#96;\nGROUP BY &#96;cate_id&#96;;\n\n\n\n2.having子句having跟where一样, 用来做条件的判断和数据的筛选过滤\n在MySQL中，我们可以使用where进行条件的过滤, 也可以使用having.\n\n\n\n\n\n\n\n\n\n示例\n# 可以用where也可以用having\nSELECT * FROM &#96;t1&#96; WHERE &#96;age&#96; &gt; 18;\nSELECT * FROM &#96;t1&#96; HAVING &#96;age&#96; &gt; 18;\n\n\n\n\n\n\n\n\n\n\n演示\nwhere和having的区别\n\nwhere中的条件是表字段\nhaving中的条件是结果集\n\n\n\n\n\n\n\n\n\n\n示例\n查询差价&gt;200的商品信息\n# 使用where\nSELECT &#96;goods_name&#96;,  market_price-shop_price as &#96;chajia&#96;\nFROM &#96;goods&#96;\nWHERE market_price-shop_price &gt; 200;\n\n# 使用having\nSELECT &#96;goods_name&#96;,  market_price-shop_price as &#96;chajia&#96;\nFROM &#96;goods&#96;\nHAVING chajia &gt; 200;\n\n\n\n\n\n\n\n\n\n\ngroup和having综合示例\n查询该店每个栏目下面积压的总货款\nSELECT &#96;cate_id&#96;, sum(goods_number*shop_price) as &#96;jiya&#96;\nFROM &#96;goods&#96;\nGROUP BY &#96;cate_id&#96;;\n\n查询积压货款&gt;1000的栏目\nSELECT &#96;cate_id&#96;, sum(goods_number*shop_price) as &#96;jiya&#96;\nFROM &#96;goods&#96;\nGROUP BY &#96;cate_id&#96;\nHAVING &#96;jiya&#96;&gt;1000;\n\n\n\n\n\n\n\n\n\n\n结论\n\nhaving通常和group by连用\nhaving的判断条件是结果集\n\n3.order by子句order by就是实现对数据的排序操作. 一共有两种情况:\n\n一种是升序排列(asc)\n一种是降序排列(desc)\n\n应用场景:\n各种排序场合,如新闻按点击量排序, 商品按价格排序, 文章按更新时间排序等\n\n\n\n\n\n\n\n\n\n示例\n按价格由高到低排序\nSELECT &#96;goods_name&#96;, &#96;shop_price&#96;\nFROM &#96;goods&#96;\nORDER BY &#96;shop_price&#96; desc;\n\n\n\n\n\n\n\n\n\n\n多个字段同时排序\n按栏目由低到高排序,栏目内部按价格由高到低排序\nSELECT &#96;cate_id&#96;, &#96;goods_name&#96;, &#96;shop_price&#96;\nFROM &#96;goods&#96;\nORDER BY &#96;cate_id&#96; asc, &#96;shop_price&#96; desc;\n\n\n\n4.limit 子句limit子句用于限定数目\n应用场景:\n最新的5遍文章, 成绩倒数3名的学生, 点击量最高的10件商品\n分页!!!\nlimit子句有两种语法\n\n\n\n\n\n\n\n\n\n语法\n# 带一个参数, 表示显示多少条\nlimit N\n# 带二个参数, 表示从N条(偏移量)开始, 显示M条\nlimit N,M\n\n\n\n\n\n\n\n\n\n\n示例\n查询价格最高的前三的商品\nSELECT &#96;goods_name&#96;, &#96;shop_price&#96;\nFROM &#96;goods&#96;\nORDER BY &#96;shop_price&#96; DESC\nLIMIT 3;\n\n\n\n\n\n\n\n\n\n\n分页示例\n每页5件商品, 显示第2页的数据\nSELECT &#96;id&#96;, &#96;goods_name&#96;\nFROM &#96;goods&#96;\nLIMIT 5,5;\n\n分页公式: 偏移量 = (当前页码-1) * 每页显示数\n\n\n\n\n\n\n\n\n\n尝试\n每页3件商品, 显示第4页的数据\nSQL: _________\n十一. E-R实体关系模型1.什么是实体E: entity(实体)\nR: relation(关系)\n1) 实体\n\n\n\n\n\n\n\n\n实体的定义\n​    客观存在并相互区别的一个事物称为实体（Entity）\n举例: 如一个学生、一件商品、一个部门、一个课程, 相当于数据表中一条记录\n2) 实体属性\n\n\n\n\n\n\n\n\n属性的定义\n​    实体的某些特性称为实体的属性（Attribute），一个实体可以拥有多个属性\n举例: 如学生有学号、姓名、性别、出生日期等, 相当于字段\n\n3) 实体集\n\n\n\n\n\n\n\n\n定义\n​    实体的集合, 相当于一张表\n2.关系表与表之间的关系一共有4种\n\n一对一\n一对多\n多对一\n多对多\n\n1) 一对一关系\n\n\n\n\n\n\n\n\n定义\n一张表的一条记录对应另一张表的一条记录\n\n\n\n\n\n\n\n\n\n举例\n看如下两张表\n用户表(user)和用户详情表(user_info)\nuser表中的一条记录, 比如xiaoming, 对应的user_info的一条记录\n\n\n\n\n\n\n\n\n\n关联条件\nuser.id=user_info.user_id\n2) 一对多关系\n\n\n\n\n\n\n\n\n定义\n一张表的一条记录对应另一张表的多条记录\n\n\n\n\n\n\n\n\n\n举例\n看如下两张表\n用户表(user)和文章表(article)\nuser表中的一条记录, 比如xiaoming, 对应的article中的多条记录\n说明: 一个用户可以拥有(has)多篇文章 hasMany\n\n\n\n\n\n\n\n\n\n关联条件\nuser.id=article.user_id\n3) 多对一关系\n\n\n\n\n\n\n\n\n定义\n一张表的多条记录对应另一张表的一条记录\n\n\n\n\n\n\n\n\n\n举例\n看如下两张表\n用户表(user)和国家表(country)\nuser表中的多条记录, 对应的country中的一条记录\n说明: 多个用户属于(belongsto)一个国家\n\n\n\n\n\n\n\n\n\n关联条件\nuser.country=country.id\n4) 多对多关系\n\n\n\n\n\n\n\n\n定义\n表A的一条记录对应表B的多条记录\n同时, 表B的一条记录也对应表A的多条记录\n\n\n\n\n\n\n\n\n\n举例\n看如下两张表\n用户表(user)和角色表(role)\n说明: 一个用户拥有多个角色, 一个角色也拥有多个用户\n\n\n\n\n\n\n\n\n\n关联条件\n建立中间表, 将多对多转换成两个一对多处理\n父表: 一的那方叫做父表\n子表: 多的那方叫做子表\n在子表中建立一个字段, 让这个字段=父表的id, 那么在子表中建立的这个字段就叫做外键\n","slug":"MySQL","date":"2022-12-01T13:13:57.870Z","categories_index":"数据库","tags_index":"sql","author_index":"团子"},{"id":"757df1fd86f1866fcfb8bc703ef31782","title":"javaScript高级","content":"1 - 预编译概念1) 什么是预编译首先, 我们要知道Javascript是解释性语言\n\n解释性: 逐行解析, 逐行执行\n\n那么, 什么是预编译呢?\n在Javascript真正被解析之前, js解析引擎会首先把整个文件进行预处理, 以消除一些歧义. 这个预处理的过程就被称为预编译\n\n\n\n\n\n\n\n\n\n示例\nconsole.log(a)\nvar a &#x3D; 123\nconsole.log(a)\nfunction a() &#123;\n  console.log(a)\n&#125;\na()\n\n这是一段奇怪的代码, 大家可以先思考一下, 三个console.log分别会打印出什么\n如果要完全理解, 我们就需要深入的分析js引擎到底是如何工作的!!!\n2) 全局对象GO\n\n\n\n\n\n\n\n\n全局对象\n全局对象(Global Object): \n\n在浏览器环境中, js引擎会整合所有的&lt;script&gt;标签中的内容, 产生window对象, 这个window对象就是全局对象\n在node环境中, 会产生global对象\n\n全局变量在&lt;script&gt;标签中声明的变量为全局变量, 全局变量会作为window对象的属性存在!!\n\n\n\n\n\n\n\n\n\n示例\nvar a &#x3D; 100\nconsole.log(a)\nconsole.log(window.a)\n\n这里打印a实际上相当于打印window对象的a属性\n\n\n\n\n\n\n\n\n\n扩展\n啥叫整合?\n\n\n\n\n\n\n\n\n\n示例\n&lt;script&gt;\n  var a &#x3D; 100\n  console.log(a)\n  console.log(window.a)\n&lt;&#x2F;script&gt;\n&lt;script&gt;\n  &#x2F;&#x2F; 在这里能访问到a吗???\n  console.log(a)\n&lt;&#x2F;script&gt;\n\n\n可以, 因为js引擎会把所有的&lt;script&gt;标签整合到一起, 生成一个window对象\n\n全局函数在&lt;script&gt;标签中声明的函数为全局函数, 全局函数会作为window对象的方法存在!!\n\n\n\n\n\n\n\n\n\n示例\nfunction a() &#123;\n  console.log(&#39;111&#39;)\n&#125;\nconsole.log(window.a)\n\n\n\n那么问题来了, 当同时定义变量a和函数a时, 会发生什么呢?\n就像我们看到的奇怪代码里一样, 而预编译就是为了处理类似的这些冲突\n3) 活动对象AO\n\n\n\n\n\n\n\n\n活动对象\n活动对象(Activation Object): 也叫激活对象\n\n在函数被调用时产生, 用来保存当前函数内部的执行环境(Execution Context), 也叫执行期上下文\n在函数调用结束时销毁\n\n局部变量在函数内部声明的变量叫局部变量, 局部变量做为AO对象的属性存在\n\n\n\n\n\n\n\n\n\n示例\nfunction a() &#123;\n  var i &#x3D; 0\n  console.log(i)\n&#125;\na()\n\n\n\n\n\n\n\n\n\n\n\n如何理解局部\n在函数a的外部, 不能访问变量i, 变量i只在函数a的范围内才能使用. 其实, 这也就是作用域的由来, skr~\n\n如果不执行函数, 不会产生AO对象, 就不会存在i属性\n如果执行函数, 就会产生AO对象, 并将变量i作为AO对象的属性\n函数执行完后, AO对象被销毁, 也就意味着不能使用i属性\n\n局部函数在函数内部声明的函数叫局部函数, 局部函数做为AO对象的方法存在\n\n\n\n\n\n\n\n\n\n示例\nfunction a() &#123;\n  function b() &#123;\n    console.log(222)\n  &#125;\n  b()\n&#125;\na()\n\n\n2 - 全局预编译1) 流程\n查找变量声明, 作为GO对象的属性名, 值为undefined\n查找函数声明, 作为GO对象的属性名, 值为function\n\n\n\n\n\n\n\n\n\n\n变量声明\n通过var关键字声明变量\nvar a &#x2F;&#x2F; 变量声明\nvar a &#x3D; 111 &#x2F;&#x2F; 变量声明+变量赋值\n\n\n\n\n\n\n\n\n\n\n函数声明\n通过function关键字声明函数\nfunction a () &#123;&#125; &#x2F;&#x2F; 函数声明\nvar a &#x3D; function () &#123;&#125; &#x2F;&#x2F; 函数表达式, 不是函数声明\n\n\n\n\n\n\n\n\n\n\n示例\nconsole.log(a)\nvar a &#x3D; 100\nconsole.log(a)\nfunction a() &#123;\n  console.log(111)\n&#125;\nconsole.log(a)\n\n\n\n2) 结论如果存在同名的变量和函数, 函数的优先级高\n3 - 函数预编译1) 流程\n在函数被调用时, 为当前函数产生AO对象\n查找形参和变量声明作为AO对象的属性名, 值为undefined\n使用实参的值改变形参的值\n查找函数声明, 作为AO对象的属性名, 值为function\n\n2) 示例\n\n\n\n\n\n\n\n\n示例一\nfunction a(test) &#123;\n  var i &#x3D; 0\n  function b() &#123;\n    console.log(222)\n  &#125;\n  b()\n&#125;\na(1)\n\n\n\n在函数a的AO对象中, 存在三个属性\n\ntest: 形参, 值为1\ni: 局部变量, 值为0\nb: 局部函数\n\n\n\n\n\n\n\n\n\n\n示例二\nfunction a(test) &#123;\n  console.log(b)\n  var b &#x3D; 0\n  console.log(b)\n  function b() &#123;\n    console.log(222)\n  &#125;\n&#125;\na(1)\n\n\n\n当局部变量与局部函数同名时, 函数的优先级高\n\n\n\n\n\n\n\n\n\n示例三\nfunction a(b, c) &#123;\n  console.log(b)\n  var b &#x3D; 0\n  console.log(b)\n  function b() &#123;\n    console.log(222)\n  &#125;\n  console.log(c)\n&#125;\na(1)\n\n\n\n\n\n\n\n\n\n\n\n\n示例四\nfunction a(i) &#123;\n  var i\n  console.log(i)\n&#125;\na(1)\n\n3) 结论只要声明了局部函数, 函数的优先级最高\n没有声明局部函数, 实参的优先级高\n整体来说: 局部函数 &gt; 实参 &gt; 形参和局部变量\n4 - 作用域与作用域链4.1 作用域概念及分类概述通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。\n\nJavaScript（es6前）中的作用域有两种：\n\n\n全局作用域\n局部作用域（函数作用域）    \n\n分类全局作用域作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件。\n\n局部作用域作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。\n\n块级作用域\n块作用域由 { } 包括。\n\n在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码：    \njava有块级作用域：\nif(true)&#123;\n  int num &#x3D; 123;\n  system.out.print(num);  &#x2F;&#x2F; 123\n&#125;\nsystem.out.print(num);    &#x2F;&#x2F; 报错\n\n以上java代码会报错，是因为代码中 { } 即一块作用域，其中声明的变量 num，在 “{ }” 之外不能使用；\n而与之类似的JavaScript代码，则不会报错：\n\n\n  Js中没有块级作用域（在ES6之前）\n  if(true)&#123;\n  var num &#x3D; 123;\n  console.log(123); &#x2F;&#x2F;123\n&#125;\nconsole.log(123);   &#x2F;&#x2F;123\n\n4.2 作用域链概念及机制只要是代码都一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据在**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链\n\n案例分析1function f1() &#123;\n    var num &#x3D; 123;\n    function f2() &#123;\n        console.log( num );\n    &#125;\n    f2();\n&#125;\nvar num &#x3D; 456;\nf1();\n\n案例分析2作用域链：采取就近原则的方式来查找变量最终的值。\nvar a &#x3D; 1;\nfunction fn1() &#123;\n    var a &#x3D; 2;\n    var b &#x3D; &#39;22&#39;;\n    fn2();\n    function fn2() &#123;\n        var a &#x3D; 3;\n        fn3();\n        function fn3() &#123;\n            var a &#x3D; 4;\n            console.log(a); &#x2F;&#x2F;a的值 ?\n            console.log(b); &#x2F;&#x2F;b的值 ?\n        &#125;\n    &#125;\n&#125;\nfn1();\n\n4.3 作用域本质分析1) 域\n\n\n\n\n\n\n\n\n域: 范围, 区域\n在js中, 作用域分为全局作用域和局部作用域\n\n全局作用域: 由&lt;script&gt;标签产生的区域, 从计算机的角度可以理解为window对象\n局部作用域: 由函数产生的区域, 从计算机的角度可以理解为该函数的AO对象\n\n2) 作用域链在js中, 函数存在一个隐式属性[[scopes]], 这个属性用来保存当前函数在执行时的环境(上下文), 由于在数据结构上是链式的, 也被称为作用域链. 我们可以把它理解成一个数组\n\n\n\n\n\n\n\n\n\n函数类型存在[[scopes]]属性\nfunction a() &#123;&#125;\n\nconsole.dir(a) &#x2F;&#x2F; 打印内部结构\n\n输出\n[[scopes]]属性在函数声明时产生, 在函数被调用时更新\n[[scopes]]属性记录当前函数的执行环境\n在函数被调用时, 将该函数的AO对象压入到[[scopes]]中\n\n\n\n\n\n\n\n\n\n示例\nfunction a() &#123;\n  console.dir(a)\n  function b() &#123;\n    console.dir(b)\n    function c() &#123;\n      console.dir(c)\n    &#125;\n    c()\n  &#125;\n  b()\n&#125;\na()\n\n\n\n\n\n\n\n\n\n\n演示\n[[scopes]]属性是一个数组的形式\n0: 是函数b的AO对象\n1: 是GO对象\n3 作用作用域链有什么作用呢?\n在访问变量或者函数时, 会在作用域链上依次查找, 最直观的表现是: \n\n内部函数可以使用外部函数声明的变量\n\n\n\n\n\n\n\n\n\n\n示例\nfunction a() &#123;\n  var aa &#x3D; 111\n  function b() &#123;\n    console.log(aa)\n  &#125;\n  b()\n&#125;\na()\n\n\n在函数a中声明定义了变量aa\n在函数b中没有声明, 却可以使用\n\n\n\n\n\n\n\n\n\n\n思考\n如果在函数b中, 也定义同名变量aa会怎样\n\n\n\n\n\n\n\n\n\n示例\nfunction a() &#123;\n  var aa &#x3D; 111\n  function b() &#123;\n    var aa &#x3D; 222\n    console.log(aa)\n  &#125;\n  b()\n&#125;\na()\n\n第一个问题: 函数a和函数b里的变量aa是不是同一个变量?\n第二个问题: 函数b里打印的aa是用的谁?\n\n\n\n\n\n\n\n\n\n结论\n内部函数可以使用外部函数的变量\n外部函数不能使用内部函数的变量\n5 - 原型和this指向5.1对象的三种创建方式–复习\n字面量方式\nvar obj &#x3D; &#123;&#125;;\nnew关键字\nvar obj &#x3D; new Object();\n构造函数方式\nfunction Person(name,age)&#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n&#125;\nvar obj &#x3D; new Person(&#39;zs&#39;,12);\n\n5.2静态成员和实例成员5.2.1实例成员实例成员就是构造函数内部通过this添加的成员 如下列代码中uname age sing 就是实例成员,实例成员只能通过实例化的对象来访问\n function Star(uname, age) &#123;\n     this.uname &#x3D; uname;\n     this.age &#x3D; age;\n     this.sing &#x3D; function() &#123;\n     console.log(&#39;我会唱歌&#39;);\n    &#125;\n&#125;\nvar ldh &#x3D; new Star(&#39;刘德华&#39;, 18);\nconsole.log(ldh.uname);&#x2F;&#x2F;实例成员只能通过实例化的对象来访问\n\n5.2.2静态成员静态成员 在构造函数本身上添加的成员  如下列代码中 sex 就是静态成员,静态成员只能通过构造函数来访问\n function Star(uname, age) &#123;\n     this.uname &#x3D; uname;\n     this.age &#x3D; age;\n     this.sing &#x3D; function() &#123;\n     console.log(&#39;我会唱歌&#39;);\n    &#125;\n&#125;\nStar.sex &#x3D; &#39;男&#39;;\nvar ldh &#x3D; new Star(&#39;刘德华&#39;, 18);\nconsole.log(Star.sex);&#x2F;&#x2F;静态成员只能通过构造函数来访问\n\n5.3构造函数的问题构造函数方法很好用，但是存在浪费内存的问题。\n\n5.4构造函数原型prototype构造函数通过原型分配的函数是所有对象所共享的。\nJavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。\n我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。\nfunction Star(uname, age) &#123;\n    this.uname &#x3D; uname;\n    this.age &#x3D; age;\n&#125;\nStar.prototype.sing &#x3D; function() &#123;\n\tconsole.log(&#39;我会唱歌&#39;);\n&#125;\nvar ldh &#x3D; new Star(&#39;刘德华&#39;, 18);\nvar zxy &#x3D; new Star(&#39;张学友&#39;, 19);\nldh.sing();&#x2F;&#x2F;我会唱歌\nzxy.sing();&#x2F;&#x2F;我会唱歌\n\n\n\n5.5对象原型对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。\n__proto__对象原型和原型对象 prototype 是等价的\n__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype\n\n\n\n\n\n5.6constructor构造函数对象原型（ __proto__）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。\nconstructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。\n\t\t\t一般情况下，对象的方法都在构造函数的原型对象中设置。\n\n5.7原型链​    每一个实例对象又有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有__proto__属性，这样一层一层往上找就形成了原型链。\n5.8构造函数实例和原型对象三角关系1.构造函数的prototype属性指向了构造函数原型对象\n2.实例对象是由构造函数创建的,实例对象的__proto__属性指向了构造函数的原型对象\n3.构造函数的原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数\n\n\n\n\n\n5.9原型链和成员的查找机制任何对象都有原型对象,也就是prototype属性,任何原型对象也是一个对象,该对象就有__proto__属性,这样一层一层往上找,就形成了一条链,我们称此为原型链;\n当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。\n如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。\n如果还没有就查找原型对象的原型（Object的原型对象）。\n依此类推一直找到 Object 为止（null）。\n__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。\n\n5.10原型对象中this指向构造函数中的this和原型对象的this,都指向我们new出来的实例对象\nfunction Star(uname, age) &#123;\n    this.uname &#x3D; uname;\n    this.age &#x3D; age;\n&#125;\nvar that;\nStar.prototype.sing &#x3D; function() &#123;\n    console.log(&#39;我会唱歌&#39;);\n    that &#x3D; this;\n&#125;\nvar ldh &#x3D; new Star(&#39;刘德华&#39;, 18);\n&#x2F;&#x2F; 1. 在构造函数中,里面this指向的是对象实例 ldh\nconsole.log(that &#x3D;&#x3D;&#x3D; ldh);&#x2F;&#x2F;true\n&#x2F;&#x2F; 2.原型对象函数里面的this 指向的是 实例对象 ldh\n\n\n5.11通过原型为数组扩展内置方法Array.prototype.sum &#x3D; function() &#123;\n  var sum &#x3D; 0;\n  for (var i &#x3D; 0; i &lt; this.length; i++) &#123;\n  sum +&#x3D; this[i];\n  &#125;\n  return sum;\n&#125;;\n&#x2F;&#x2F;此时数组对象中已经存在sum()方法了  可以始终 数组.sum()进行数据的求\n\n6 - 函数进阶6.1函数的定义方式\n方式1 函数声明方式 function 关键字 (命名函数)\nfunction fn()&#123;&#125;\n方式2 函数表达式(匿名函数)\nvar fn &#x3D; function()&#123;&#125;\n方式3 new Function() \nvar f &#x3D; new Function(&#39;a&#39;, &#39;b&#39;, &#39;console.log(a + b)&#39;);\nf(1, 2);\n\nvar fn &#x3D; new Function(&#39;参数1&#39;,&#39;参数2&#39;..., &#39;函数体&#39;)\n注意\n&#x2F;*Function 里面参数都必须是字符串格式\n第三种方式执行效率低，也不方便书写，因此较少使用\n所有函数都是 Function 的实例(对象)  \n函数也属于对象\n*&#x2F;\n\n6.2函数的调用&#x2F;* 1. 普通函数 *&#x2F;\nfunction fn() &#123;\n\tconsole.log(&#39;人生的巅峰&#39;);\n&#125;\n fn(); \n&#x2F;* 2. 对象的方法 *&#x2F;\nvar o &#x3D; &#123;\n  sayHi: function() &#123;\n  \tconsole.log(&#39;人生的巅峰&#39;);\n  &#125;\n&#125;\no.sayHi();\n&#x2F;* 3. 构造函数*&#x2F;\nfunction Star() &#123;&#125;;\nnew Star();\n&#x2F;* 4. 绑定事件函数*&#x2F;\n btn.onclick &#x3D; function() &#123;&#125;;   &#x2F;&#x2F; 点击了按钮就可以调用这个函数\n&#x2F;* 5. 定时器函数*&#x2F;\nsetInterval(function() &#123;&#125;, 1000);  这个函数是定时器自动1秒钟调用一次\n&#x2F;* 6. 立即执行函数(自调用函数)*&#x2F;\n(function() &#123;\n\tconsole.log(&#39;人生的巅峰&#39;);\n&#125;)();\n\n6.3函数内部的this指向这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同\n一般指向我们的调用者.\n6.4改变函数内部 this 指向call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向\nvar o &#x3D; &#123;\n\tname: &#39;andy&#39;\n&#125;\n function fn(a, b) &#123;\n      console.log(this);\n      console.log(a+b)\n&#125;;\nfn(1,2)&#x2F;&#x2F; 此时的this指向的是window 运行结果为3\nfn.call(o,1,2)&#x2F;&#x2F;此时的this指向的是对象o,参数使用逗号隔开,运行结果为3\n\n以上代码运行结果为:\n6.5.高阶函数高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。\n此时fn 就是一个高阶函数\n函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。\n同理函数也可以作为返回值传递回来\n7 - 闭包7.1变量的作用域复习变量根据作用域的不同分为两种：全局变量和局部变量。\n\n函数内部可以使用全局变量。\n函数外部不可以使用局部变量。\n当函数执行完毕，本作用域内的局部变量会销毁。\n\n7.2什么是闭包闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。 \n7.3闭包的作用作用：延伸变量的作用范围。\n function fn() &#123;\n   var num &#x3D; 10;\n   function fun() &#123;\n       console.log(num);\n \t&#125;\n    return fun;\n &#125;\nvar f &#x3D; fn();\nf();\n\n7.4闭包的案例闭包应用-3秒钟之后,打印所有li元素的内容\n for (var i &#x3D; 0; i &lt; lis.length; i++) &#123;\n   (function(i) &#123;\n     setTimeout(function() &#123;\n     console.log(lis[i].innerHTML);\n     &#125;, 3000)\n   &#125;)(i);\n&#125;\n\n8 - let和const8.1 letES6中新增了用于声明变量的关键字\nlet声明的变量只在所处于的块级有效 if (true) &#123; \n     let a &#x3D; 10;\n &#125;\nconsole.log(a) &#x2F;&#x2F; a is not defined\n\n注意：使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。\n不存在变量提升console.log(a); &#x2F;&#x2F; a is not defined \nlet a &#x3D; 20;\n\n暂时性死区利用let声明的变量会绑定在这个块级作用域，不会受外界的影响\nvar tmp &#x3D; 123;\nif (true) &#123; \n    tmp &#x3D; &#39;abc&#39;;\n    let tmp; \n&#125; \n\n经典面试题var arr &#x3D; [];\nfor (var i &#x3D; 0; i &lt; 2; i++) &#123;\n    arr[i] &#x3D; function () &#123;\n        console.log(i); \n    &#125;\n&#125;\narr[0]();\narr[1]();\n\n\n\n\n经典面试题图解：此题的关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值。\nlet arr &#x3D; [];\nfor (let i &#x3D; 0; i &lt; 2; i++) &#123;\n    arr[i] &#x3D; function () &#123;\n        console.log(i); \n    &#125;\n&#125;\narr[0]();\narr[1]();\n\n\n\n\n经典面试题图解：此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值.\n小结\nlet关键字就是用来声明变量的\n使用let关键字声明的变量具有块级作用域\n在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的\n防止循环变量变成全局变量\n使用let关键字声明的变量没有变量提升\n使用let关键字声明的变量具有暂时性死区特性\n\n8.2 const声明常量，常量就是值（内存地址）不能变化的量\n具有块级作用域 if (true) &#123; \n     const a &#x3D; 10;\n &#125;\nconsole.log(a) &#x2F;&#x2F; a is not defined\n\n声明常量时必须赋值const PI; &#x2F;&#x2F; Missing initializer in const declaration\n\n常量赋值后，值不能修改const PI &#x3D; 3.14;\nPI &#x3D; 100; &#x2F;&#x2F; Assignment to constant variable.\n\nconst ary &#x3D; [100, 200];\nary[0] &#x3D; &#39;a&#39;;\nary[1] &#x3D; &#39;b&#39;;\nconsole.log(ary); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;]; \nary &#x3D; [&#39;a&#39;, &#39;b&#39;]; &#x2F;&#x2F; Assignment to constant variable.\n\n小结\nconst声明的变量是一个常量\n既然是常量不能重新进行赋值，如果是基本数据类型，不能更改值，如果是复杂数据类型，不能更改地址值\n声明 const时候必须要给定值\n\n8.3 let、const、var 的区别\n使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象\n使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升\n使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值\n\n1 Script对象与Block对象let和const声明的变量不会挂载到GO(window)对象上, 而是做为Script对象的属性存在\n\n\n\n\n\n\n\n\n\n块作用域\n由&#123;&#125;形成块作用域, 会形成一个Block对象\n在&#123;&#125;里通过let和const声明的变量做为Block对象的属性\n\n\n\n\n\n\n\n\n\n示例\nlet i &#x3D; 1\n&#123;\n  let i &#x3D; 2\n  console.log(i)\n&#125;\nconsole.log(i)\n\n\n\n\n\n\n\n\n\n\n演示\n2 不能重复声明在同一个Script和同一个Block下, 不能重复声明, 会报语法错误\n\n\n\n\n\n\n\n\n\n示例\nlet i &#x3D; 1\n&#123;\n  let i &#x3D; 2\n  const i &#x3D; 3 &#x2F;&#x2F; 会报语法错误\n  console.log(i)\n&#125;\nconsole.log(i)\n\n3 声明前不能使用(TDZ)在变量声明前是不能使用的\n\n\n\n\n\n\n\n\n\n示例\nconsole.log(i) &#x2F;&#x2F; 在script作用域下, 声明前不能使用\nlet i &#x3D; 1\n&#123;\n  let i &#x3D; 2\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\nlet i &#x3D; 1\n&#123;\n  console.log(i) &#x2F;&#x2F; 在block作用域下, 声明前不能使用\n  let i &#x3D; 2\n&#125;\n\n我们通过也把这个区域叫做暂时性死区TDZ\n4 在for循环中使用let\n\n\n\n\n\n\n\n\n示例\nconst arr &#x3D; []\nfor (let i &#x3D; 0; i &lt; 3; i++) &#123;\n  arr[i] &#x3D; function () &#123;\n    console.log(i)\n  &#125;\n&#125;\narr[0]()\n\n\n\n\n\n\n\n\n\n\n演示\n看这里的作用域链\n所以, 当调用arr[0]时, 在自己的作用域链上查找, 先找到Block作用域中i的值0\n9 - 解构赋值ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构\n9.1 数组解构 let [a, b, c] &#x3D; [1, 2, 3];\n console.log(a)&#x2F;&#x2F;1\n console.log(b)&#x2F;&#x2F;2\n console.log(c)&#x2F;&#x2F;3\n&#x2F;&#x2F;如果解构不成功，变量的值为undefined\n\n9.2 对象解构let person &#x3D; &#123; name: &#39;zhangsan&#39;, age: 20 &#125;; \nlet &#123; name, age &#125; &#x3D; person;\nconsole.log(name); &#x2F;&#x2F; &#39;zhangsan&#39; \nconsole.log(age); &#x2F;&#x2F; 20\n\nlet &#123;name: myName, age: myAge&#125; &#x3D; person; &#x2F;&#x2F; myName myAge 属于别名\nconsole.log(myName); &#x2F;&#x2F; &#39;zhangsan&#39; \nconsole.log(myAge); &#x2F;&#x2F; 20\n\n\n9.3 小结\n解构赋值就是把数据结构分解，然后给变量进行赋值\n如果结构不成功，变量跟数值个数不匹配的时候，变量的值为undefined\n数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用逗号隔开\n利用解构赋值能够让我们方便的去取对象中的属性跟方法\n\n10 - 箭头函数10.1语法ES6中新增的定义函数的方式。\n() &#x3D;&gt; &#123;&#125; &#x2F;&#x2F;()：代表是函数； &#x3D;&gt;：必须要的符号，指向哪一个代码块；&#123;&#125;：函数体\nconst fn &#x3D; () &#x3D;&gt; &#123;&#125;&#x2F;&#x2F;代表把一个函数赋值给fn\n\n函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号\nfunction sum(num1, num2) &#123; \n    return num1 + num2; \n&#125;\n&#x2F;&#x2F;es6写法\nconst sum &#x3D; (num1, num2) &#x3D;&gt; num1 + num2; \n\n\n如果形参只有一个，可以省略小括号\n function fn (v) &#123;\n     return v;\n &#125; \n&#x2F;&#x2F;es6写法\n const fn &#x3D; v &#x3D;&gt; v;\n\n\n箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this\nconst obj &#x3D; &#123; name: &#39;张三&#39;&#125; \n function fn () &#123; \n     console.log(this);&#x2F;&#x2F;this 指向 是obj对象\n     return () &#x3D;&gt; &#123; \n         console.log(this);&#x2F;&#x2F;this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象\n     &#125; \n &#125; \n const resFn &#x3D; fn.call(obj); \n resFn();\n\n\n10.2 小结\n箭头函数中不绑定this，箭头函数中的this指向是它所定义的位置，可以简单理解成，定义箭头函数中的作用域的this指向谁，它就指向谁\n箭头函数的优点在于解决了this执行环境所造成的一些问题。比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题\n\n10.3 面试题var age &#x3D; 100;\n\nvar obj &#x3D; &#123;\n\tage: 20,\n\tsay: () &#x3D;&gt; &#123;\n\t\talert(this.age)\n\t&#125;\n&#125;\n\nobj.say();&#x2F;&#x2F;箭头函数this指向的是被声明的作用域里面，而对象没有作用域的，所以箭头函数虽然在对象中被定义，但是this指向的是全局作用域\n\n11 promise11.1 为什么需要promise像写同步代码一样写异步代码\n11.2 Promise的基本使用Promise是一个构造函数, 通过new关键字实例化对象\n\n\n\n\n\n\n\n\n\n语法\nnew Promise((resolve, reject)&#x3D;&gt;&#123;&#125;)\n\n\nPromise接受一个函数作为参数\n在参数函数中接受两个参数\nresolve: 成功函数\nreject: 失败函数\n\n\n\n\n\n\n\n\n\n\n\n\npromise实例\npromise实例有两个属性\n\nstate: 状态\nresult: 结果\n\n1) promise的状态第一种状态: pending(准备, 待解决, 进行中)\n第二种状态: fulfilled(已完成, 成功)\n第三种状态: rejected(已拒绝, 失败)\n2) promise状态的改变通过调用resolve()和reject()改变当前promise对象的状态\n\n\n\n\n\n\n\n\n\n示例\nconst p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; resolve(): 调用函数, 使当前promise对象的状态改成fulfilled\n  resolve()\n&#125;)\nconsole.dir(p) &#x2F;&#x2F; fulfilled\n\n\n\n\n\n\n\n\n\n\n示例\nconst p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; resolve(): 调用函数, 使当前promise对象的状态改成fulfilled\n  &#x2F;&#x2F; reject(): 调用函数, 使当前promise对象的状态改成rejected\n\n  &#x2F;&#x2F; resolve()\n  reject()\n&#125;)\nconsole.dir(p)\n\n\nresolve(): 调用函数, 使当前promise对象的状态改成fulfilled\nreject(): 调用函数, 使当前promise对象的状态改成rejected\n\n\n\n\n\n\n\n\n\n\npromise状态的改变是一次性的, 单向不可逆\n3) promise的结果\n\n\n\n\n\n\n\n\n示例\nconst p &#x3D; new Promise((resolve, reject)&#x3D;&gt; &#123;\n  &#x2F;&#x2F; 通过调用resolve, 传递参数, 改变 当前promise对象的 结果\n  resolve(&#39;成功的结果&#39;)\n  &#x2F;&#x2F;reject(&#39;失败的结果&#39;)\n&#125;)\nconsole.dir(p)\n\n11.3 Promise的方法then方法\n\n\n\n\n\n\n\n\n示例\nconst p &#x3D; new Promise((resolve, reject)&#x3D;&gt; &#123;\n  &#x2F;&#x2F; 通过调用resolve, 传递参数, 改变 当前promise对象的 结果\n  resolve(&#39;成功的结果&#39;)\n  &#x2F;&#x2F;reject(&#39;失败的结果&#39;)\n&#125;)\n\n&#x2F;&#x2F; then方法函数\n&#x2F;&#x2F; 参数\n&#x2F;&#x2F; 1. 是一个函数\n&#x2F;&#x2F; 2. 还是一个函数\n&#x2F;&#x2F; 返回值: 是一个promise对象\np.then(()&#x3D;&gt;&#123;\n  &#x2F;&#x2F; 当promise的状态是fulfilled时, 执行\n  console.log(&#39;成功时调用&#39;)\n&#125;, () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 当promise的状态是rejected时, 执行\n  console.log(&#39;失败时调用&#39;)\n&#125;)\nconsole.dir(p)\n\n\n\n\n\n\n\n\n\n\n示例\nconst p &#x3D; new Promise((resolve, reject)&#x3D;&gt; &#123;\n  &#x2F;&#x2F; 通过调用resolve, 传递参数, 改变 当前promise对象的 结果\n  &#x2F;&#x2F;resolve(&#39;123&#39;)\n  reject(&#39;失败的结果&#39;)\n&#125;)\n\n&#x2F;&#x2F; then方法函数\n&#x2F;&#x2F; 参数\n&#x2F;&#x2F; 1. 是一个函数\n&#x2F;&#x2F; 2. 还是一个函数\n&#x2F;&#x2F; 返回值: 是一个promise对象\np.then((value)&#x3D;&gt;&#123;\n  &#x2F;&#x2F; 当promise的状态是fulfilled时, 执行\n  console.log(&#39;成功时调用&#39;, value)\n&#125;, (err) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 当promise的状态是rejected时, 执行\n  console.log(&#39;失败时调用&#39;, err)\n&#125;)\nconsole.dir(p)\n\n\n在then方法的参数函数中, 通过形参使用promise对象的结果\n\n\n\n\n\n\n\n\n\n\nthen方法返回一个新的promise实例, 状态是pending\nconst p &#x3D; new Promise((resolve, reject)&#x3D;&gt; &#123;\n  &#x2F;&#x2F; 通过调用resolve, 传递参数, 改变 当前promise对象的 结果\n  resolve(&#39;123&#39;)\n  &#x2F;&#x2F;reject(&#39;失败的结果&#39;)\n&#125;)\n\n&#x2F;&#x2F; then方法函数\n&#x2F;&#x2F; 参数\n&#x2F;&#x2F; 1. 是一个函数\n&#x2F;&#x2F; 2. 还是一个函数\n&#x2F;&#x2F; 返回值: 是一个promise对象\nconst t &#x3D; p.then((value)&#x3D;&gt;&#123;\n  &#x2F;&#x2F; 当promise的状态是fulfilled时, 执行\n  console.log(&#39;成功时调用&#39;, value)\n&#125;, (reason) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 当promise的状态是rejected时, 执行\n  console.log(&#39;失败时调用&#39;, reason)\n&#125;)\nconsole.dir(t)\n\n\n\n\n\n\n\n\n\n\npromise的状态不改变, 不会执行then里的方法\n&#x2F;&#x2F; 如果promise的状态不改变, then里的方法不会执行\nnew Promise((resolve, reject) &#x3D;&gt; &#123;\n\n&#125;).then((value) &#x3D;&gt; &#123;\n  console.log(&#39;成功&#39;)\n&#125;, (reason) &#x3D;&gt; &#123;\n  console.log(&#39;失败&#39;)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n在then方法中, 通过return将返回的promise实例改为fulfilled状态\n&#x2F;&#x2F; 如果promise的状态不改变, then里的方法不会执行\nconst p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  resolve()\n&#125;)\n\nconst t &#x3D; p.then((value) &#x3D;&gt; &#123;\n  console.log(&#39;成功&#39;)\n  &#x2F;&#x2F; 使用return可以将t实例的状态改成fulfilled\n  return 123\n&#125;, (reason) &#x3D;&gt; &#123;\n  console.log(&#39;失败&#39;)\n&#125;)\n\nt.then((value) &#x3D;&gt; &#123;\n  console.log(&#39;成功2&#39;, value)\n&#125;, (reason) &#x3D;&gt; &#123;\n  console.log(&#39;失败&#39;)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n如果在then方法中, 出现代码错误, 会将返回的promise实例改为rejected状态\n&#x2F;&#x2F; 如果promise的状态不改变, then里的方法不会执行\nconst p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  resolve()\n&#125;)\n\nconst t &#x3D; p.then((value) &#x3D;&gt; &#123;\n  console.log(&#39;成功&#39;)\n  &#x2F;&#x2F; 使用return可以将t实例的状态改成fulfilled\n  &#x2F;&#x2F;return 123\n\n  &#x2F;&#x2F; 如果这里的代码出错, 会将t实例的状态改成rejected\n  console.log(a)\n\n&#125;, (reason) &#x3D;&gt; &#123;\n  console.log(&#39;失败&#39;)\n&#125;)\n\nt.then((value) &#x3D;&gt; &#123;\n  console.log(&#39;成功2&#39;, value)\n&#125;, (reason) &#x3D;&gt; &#123;\n  console.log(&#39;失败&#39;, reason)\n&#125;)\n\n","slug":"JavaScript高级","date":"2022-12-01T13:05:46.773Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"67fd54f357341c37b5e6f85e86c46aff","title":"33_Todo小项目完成","content":"昨日回顾1,搭建基本环境\n2,后台查询所有的功能\n3,解决时间显示问题\n4,抽取数据库配置信息单独放在一个文件中\n5,异常处理\n\n\n\n后台实现查询一个\n\t对参数进行判断\n新增\n\t返回新增后的数据\n\t\t先新增,然后拿到新增的id进行查询,将查询的数据返回\n修改\n\t跟之前一样,只需要修改内容\n删除\n\t实际是调用修改的sql语句,修改deleted_time\n\n\n\n前台实现1,主界面搭建\n\t\n2,查询所有\n\t * 思路\n     * 发送ajax请求,获取数据,遍历拼接\n3,新增\n *     思路:\n *          监听文本框的键盘事件\n *          判断文本框的内容是否为空,为空给出提示,并且返回\n *          不为空,发送ajax请求,获取数据\n *          拿到数据,根据code进行判断,成功,重新获取所有列表,失败就弹出提示信息\n\n4,修改\n * 思路\n *      1,监听li元素的点击,点击li元素的时候,使用input将p标签替换\n *      2,阻止input和span的冒泡事件\n *      3,监听新创建的input框的回车和失去焦点事件\n *      4,当回车或者焦点事件被触发的时候,判断是否有内容,有的话就更新数据库,否则就返回\n\n5,删除\n * 思路\n *      通过a标签向上找到li元素绑定的id\n *      发送请求,到数据库中删除代办\n *      请求成功之后,获取所有代办\n\n\n\n","slug":"day33_课堂笔记","date":"2022-12-01T14:20:58.395Z","categories_index":"项目","tags_index":"Todolist","author_index":"团子"},{"id":"0fc374236e6bc7b1f82600ab48634b27","title":"综合案例-Todo小项目","content":"老板: 立项产品经理: 需求分析-&gt; 需求文档: \n\n需求点(文字形式的描述)\n原型图(图形的描述)\n\nUI设计师: 原型图 -&gt; 静态产品图技术经理: 技术分析 -&gt; 设计文档\n\n流程图\n数据库设计\n接口设计\n\n项目成员: 编码实现测试人员: 编码测试运维人员: 部署/上线\n一. 需求分析评估工期, 敏捷开发(最小原型, 快速迭代)时间/人力/质量\n1.需求点1. 添加待办\n在文本框内输入内容\n\n按回车添加代办\n\n如果文本框中没有内容，提示’内容不能为空’\n\n如果文本框中有内容, 添加到最上方\n\n添加完之后，清空文本框的内容\n2. 修改待办\n点击待办内容, 能够修改其中的内容\n\n修改完成, 按Enter(回车键) 或者 失去焦点时, 更新内容, 同时更新时间\n\n更新的内容不能为空\n3. 删除待办\n点击删除按钮, 删除对应的todo待办事项\n2.原型图二. 技术分析技术评估\n\n\n\n人力成本: 项目团队的人员配置(1~2前端, 1后端, 1个UI, 1测试, 1运维) 全栈(全干)\n\n进度: 项目目标分解成里程碑\n\n经济成本: 人月 58K3月 = 120K = 12W\n1. 技术选型平台\n\n操作系统: windows 10\n\n开发平台: VSCode V16.2\n\n测试平台: Chrome/FireFox – 是否兼容IE6/7/8\n\n文档平台: 语雀/ApiFox/Swagger\n\n代码平台: github/gitee9\n\n\n框架\n\n前端jQuery\n后端Express\n\n技术栈\n\n前端: H5+CSS+jQuery\nnode+Express+MySQL2. 数据库设计\n\n\n\n\n\n\n\n\nxzd_todos表\n\n\n\n\n\n字段名\n类型\n属性\n备注\n\n\n\nid\nint\n主键, 自增\nid\n\n\ncontent\nvarchar(255)\n非空, 默认值’’\n待办事项的内容\n\n\ncreated_time\ndatetime\nCURRENT_TIMESTAMP\n创建时间\n\n\nupdated_time\ndatetime\nCURRENT_TIMESTAMP, on UPDATE  CURRENT_TIMESTAMP\n更新时间\n\n\ndeleted_time\ndatetime\n\n默认值为null, 删除时记录删除时间\n\n\nCREATE TABLE &#96;xzd_todos&#96; (\n  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键id&#39;,\n  &#96;content&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;待办事项内容&#39;,\n  &#96;created_time&#96; timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;updated_time&#96; timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,\n  &#96;deleted_time&#96; timestamp NULL DEFAULT NULL COMMENT &#39;默认值为null, 表示没有删除; 如果存在时间, 说明在时间被删除&#39;,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;\n\n3. 接口设计1) baseURLhttp:&#x2F;&#x2F;localhost:3000\n\n2) 待办模块获取所有待办\n\n\n\n\n\n\n\n\n请求\n请求方式: GET\n请求URL: /todos\nGET &#x2F;todos\n\n\n\n\n\n\n\n\n\n\n成功的响应\n&#123;\n  &quot;code&quot;: 0,\n  &quot;msg&quot;: &quot;获取所有待办成功&quot;,\n  &quot;result&quot;: [\n    &#123;&quot;id&quot;:1, &quot;content&quot;: &quot;待办1&quot;, &quot;updated_time&quot;: &quot;2021-11-26 11:15:23&quot;&#125;\n  ]\n&#125;\n\n\n\n\n\n\n\n\n\n\n错误的响应\n&#123;\n  &quot;code&quot;: 100101,\n  &quot;message&quot;: &quot;获取所有待办失败&quot;,\n  &quot;result&quot;: &#123;\n    &quot;code&quot;: &quot;ER_BAD_FIELD_ERROR&quot;,\n    &quot;errno&quot;: 1054,\n    &quot;sqlMessage&quot;: &quot;Unknown column &#39;delete_time&#39; in &#39;where clause&#39;&quot;,\n    &quot;sqlState&quot;: &quot;42S22&quot;,\n    &quot;index&quot;: 0,\n    &quot;sql&quot;: &quot;select id, content, updated_time from xzd_todos where delete_time is null&quot;\n  &#125;\n&#125;\n根据id获取单个待办\n\n\n\n\n\n\n\n\n请求\n请求方式 GET\n请求地址 /todos/:id\nGET &#x2F;todos&#x2F;:id\nGET &#x2F;todos&#x2F;1\n\n\n\n\n\n\n\n\n\n\n成功的响应\n&#123;\n  &quot;code&quot;: 0,\n  &quot;msg&quot;: &quot;获取待办成功&quot;,\n  &quot;result&quot;: &#123;&quot;id&quot;:1, &quot;content&quot;: &quot;待办1&quot;, &quot;updated_time&quot;: &quot;2021-11-26 11:15:23&quot;&#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n失败的响应\n&#123;\n  &quot;code&quot;: 100102,\n  &quot;message&quot;: &quot;查询单个待办失败&quot;,\n  &quot;result&quot;: &#123;\n    &quot;code&quot;: &quot;ER_NO_SUCH_TABLE&quot;,\n    &quot;errno&quot;: 1146,\n    &quot;sqlMessage&quot;: &quot;Table &#39;db2201.xzd_todo&#39; doesn&#39;t exist&quot;,\n    &quot;sqlState&quot;: &quot;42S02&quot;,\n    &quot;index&quot;: 0,\n    &quot;sql&quot;: &quot;select id, content, updated_time from xzd_todo where id&#x3D;1 and deleted_time is null&quot;\n  &#125;\n&#125;\n\n&#123;\n  &quot;code&quot;: 100103,\n  &quot;message&quot;: &quot;id对应的数据不存在&quot;,\n  &quot;result&quot;: &quot;&quot;\n&#125;\n\n&#123;\n  &quot;code&quot;: 100104,\n  &quot;message&quot;: &quot;id必须为数字&quot;,\n  &quot;result&quot;: &quot;&quot;\n&#125;\n添加待办\n\n\n\n\n\n\n\n\n请求\n请求方式 POST\n接口地址 /todos\nPOST &#x2F;todos\n\n请求参数\n&#123;\n\t&quot;content&quot;: &quot;待办2&quot;\n&#125;\n\n\n\n\n\n\n\n\n\n\n响应\n&#123;\n  &quot;code&quot;: 0,\n  &quot;msg&quot;: &quot;添加成功&quot;,\n  &quot;result&quot;: &#123;&quot;id&quot;:1, &quot;content&quot;: &quot;待办1&quot;, &quot;updated_time&quot;: &quot;2021-11-26 11:15:23&quot;&#125;\n&#125;\n\n修改待办\n\n\n\n\n\n\n\n\n请求\n请求方式 PUT\n请求地址 /todos/1\nPUT &#x2F;todos&#x2F;:id\nPUT &#x2F;todos&#x2F;1\n\n请求参数\n&#123;\n\t&quot;content&quot;: &quot;待办2&quot;\n&#125;\n\n\n\n\n\n\n\n\n\n\n响应\n&#123;\n  &quot;code&quot;: 0,\n  &quot;msg&quot;: &quot;更新成功&quot;,\n  &quot;result&quot;: &#123;&quot;id&quot;:1, &quot;content&quot;: &quot;待办1&quot;, &quot;updated_time&quot;: &quot;2021-11-26 11:15:23&quot;&#125;\n&#125;\n\n删除待办\n\n\n\n\n\n\n\n\n请求\n请求方式 DELETE\n请求地址 /todos/:id\nDELETE &#x2F;todos&#x2F;:id\nDELETE &#x2F;todos&#x2F;1\n\n\n\n\n\n\n\n\n\n\n响应\n&#123;\n  &quot;code&quot;: 0,\n  &quot;msg&quot;: &quot;删除成功&quot;,\n  &quot;result&quot;: &#39;&#39;\n&#125;\n三. 后端实现1 搭建项目通过express脚手架创建一个项目, 默认运行在3000端口\nexpress --no-view api\n2 安装依赖在后端项目的根目录下, api目录, 执行如下命令(最好进入api目录下   cd api  )\n1) 开发环境依赖npm i nodemon -D\n\n2) 安装mysql依赖npm i mysql\n\n3) 安装cors中间件npm i cors\n\n4) 安装所有依赖npm install\n\n3 启动项目修改package.json, 使用nodemon启动项目\n&quot;scripts&quot;: &#123;\n\t&quot;start&quot;: &quot;nodemon .&#x2F;bin&#x2F;www&quot;\n&#125;,\n\n运行\nnpm run start\n\n测试\n\n4 注册cors中间件修改app.js\n&#x2F;&#x2F; 导入cors中间件的包\nconst cors &#x3D; require(&#39;cors&#39;)\n\n&#x2F;&#x2F; 注册全局中间件\napp.use(cors())\n\n\n\n\n\n\n\n\n\n示例\n\n5 规划路由1) 创建路由模块在routes目录下, 创建todos.js文件\n&#x2F;&#x2F; 一. 导入express\n&#x2F;&#x2F; 二. 实例化router对象\n&#x2F;&#x2F; 三. 编写路由规则\n&#x2F;&#x2F; 四. 导出router对象\n\n\n\n\n\n\n\n\n\n示例\n\n&#x2F;&#x2F; 一. 导入express\nconst express &#x3D; require(&#39;express&#39;)\n&#x2F;&#x2F; 二. 实例化router对象\nconst router &#x3D; express.Router()\n&#x2F;&#x2F; 三. 编写路由规则\nrouter.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;\n  res.send(&#39;todos&#39;)\n&#125;)\n&#x2F;&#x2F; 四. 导出router对象\nmodule.exports &#x3D; router\n2) 导入路由对象在app.js中导入路由对象\n&#x2F;&#x2F; 导入todosRouter对象\nconst todosRouter &#x3D; require(&#39;.&#x2F;routes&#x2F;todos&#39;)\n&#x2F;&#x2F; 注册路由\napp.use(&#39;&#x2F;todos&#39;, todosRouter)\n\n\n\n\n\n\n\n\n\n\n示例\n\n\n\n\n\n\n\n\n\n\n测试\n(略)\n6 复用数据库模块把db模块复制到目录下\n在todos.js文件中, 加载数据库操作的方法\n&#x2F;&#x2F; 导入数据库操作的方法\nconst &#123; getAll, getById, exec &#125; &#x3D; require(&#39;..&#x2F;db&#39;)\n7 实现接口1) 获取所有待办在todos.js文件中, 编写对应的路由\n&#x2F;**\n * 获取所有待办\n * GET &#x2F;todos\n *&#x2F;\nrouter.get(&#39;&#x2F;&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 操作数据库\n  let sql &#x3D; &#96;select id, content, updated_time from xzd_todos where deleted_time is null&#96;\n\n  try &#123;\n    &#x2F;&#x2F; 需要测试的代码\n    const data &#x3D; await getAll(sql)\n    res.send(&#123;\n      code: 0,\n      message: &#39;获取所有待办成功&#39;,\n      result: data,\n    &#125;)\n  &#125; catch (err) &#123;\n    &#x2F;&#x2F; 处理异常情况(错误处理)\n    res.send(&#123;\n      code: 100101, &#x2F;&#x2F; 10: 第一个版; 01: todos模块; 01: 错误\n      message: &#39;获取所有待办失败&#39;,\n      result: debug ? err : &#39;&#39;,\n    &#125;)\n  &#125;\n&#125;)\n实现 debug的配置.创建config/index.js文件, 内容如下\nmodule.exports &#x3D; &#123;\n  debug: true,\n  mysql: &#123;\n    host: &#39;127.0.0.1&#39;,\n    port: 3306,\n    user: &#39;root&#39;,\n    password: &#39;123456&#39;,\n    database: &#39;db2201&#39;,\n    timezone: &#39;SYSTEM&#39;, &#x2F;&#x2F; 解决 时间 显示的 格式问题\n  &#125;,\n&#125;\n在数据库层, db/index.js改造如下\n&#x2F;&#x2F; 导入配置文件(给mysql对象起别名)\nconst &#123; mysql: dbconfig &#125; &#x3D; require(&#39;..&#x2F;config&#39;)\n\n&#x2F;&#x2F; 2. 创建连接\nconst con &#x3D; mysql.createConnection(dbconfig)\n2) 根据id获取单个待办&#x2F;**\n * 根据id获取todo\n * GET &#x2F;todos&#x2F;:id\n *&#x2F;\nrouter.get(&#39;&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  console.log(req.params)\n  &#x2F;&#x2F; 一. 解析请求数据(id)\n  const &#123; id &#125; &#x3D; req.params\n\n  &#x2F;&#x2F; 对请求的参数格式进行校验\n  const reg &#x3D; &#x2F;^\\d+$&#x2F;\n\n  if (!reg.test(id)) &#123;\n    res.send(&#123;\n      code: 100104,\n      message: &#39;id必须为数字&#39;,\n      result: &#39;&#39;,\n    &#125;)\n    return\n  &#125;\n\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;select id, content, updated_time from xzd_todos where id&#x3D;$&#123;id&#125; and deleted_time is null&#96;\n  console.log(sql)\n  &#x2F;&#x2F; 三. 返回结果\n  try &#123;\n    var data &#x3D; await getById(sql)\n  &#125; catch (err) &#123;\n    res.send(&#123;\n      code: 100102,\n      message: &#39;查询单个待办失败&#39;,\n      result: debug ? err : &#39;&#39;,\n    &#125;)\n  &#125;\n\n  &#x2F;&#x2F; 判断...\n  if (data) &#123;\n    &#x2F;&#x2F; 成功\n    res.send(&#123;\n      code: 0,\n      message: &#39;查询单个待办成功&#39;,\n      result: data,\n    &#125;)\n  &#125; else &#123;\n    &#x2F;&#x2F; 根据id没有查询到结果\n    res.status(404).send(&#123;\n      code: 100103,\n      message: &#39;id对应的数据不存在&#39;,\n      result: &#39;&#39;,\n    &#125;)\n  &#125;\n&#125;)\n3) 添加待办&#x2F;**\n * 新增todo\n * POST &#x2F;todos &#123;content: &#39;todo-test&#39;&#125;\n *&#x2F;\nrouter.post(&#39;&#x2F;&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析请求数据(body)\n  const &#123; content &#125; &#x3D; req.body\n  &#x2F;&#x2F; console.log(content)\n  &#x2F;&#x2F; 请求参数的校验, 不能为空\n  if (!content) &#123;\n    &#x2F;&#x2F; 出错!! content &#x3D;&#x3D; undefined\n    res.send(&#123;\n      code: 100105,\n      message: &#39;content格式错误&#39;,\n      result: &#39;&#39;,\n    &#125;)\n    return\n  &#125;\n\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;insert into xzd_todos (content) values (&#39;$&#123;content&#125;&#39;)&#96;\n  try &#123;\n    var &#123; insertId &#125; &#x3D; await exec(sql)\n  &#125; catch (err) &#123;\n    res.send(&#123;\n      code: 100106,\n      message: &#39;添加待办失败&#39;,\n      result: debug ? err : &#39;&#39;,\n    &#125;)\n    return\n  &#125;\n  sql &#x3D; &#96;select id, content, updated_time from xzd_todos where id&#x3D;$&#123;insertId&#125;&#96;\n  try &#123;\n    const data &#x3D; await getById(sql)\n    &#x2F;&#x2F; 三. 结果返回\n    res.send(&#123;\n      code: 0,\n      message: &#39;添加待办成功&#39;,\n      result: data,\n    &#125;)\n  &#125; catch (err) &#123;\n    res.send(&#123;\n      code: 100106,\n      message: &#39;添加待办失败&#39;,\n      result: debug ? err : &#39;&#39;,\n    &#125;)\n  &#125;\n&#125;)\n4) 更新待办&#x2F;**\n * 修改todo\n * PUT &#x2F;todos&#x2F;:id &#123;content: &#39;todo-new&#39;&#125;\n *&#x2F;\nrouter.put(&#39;&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析请求参数\n  const &#123; id &#125; &#x3D; req.params\n  const &#123; content &#125; &#x3D; req.body\n  &#x2F;&#x2F; todo: 参数的校验\n\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;update xzd_todos set content&#x3D;&#39;$&#123;content&#125;&#39; where id&#x3D;$&#123;id&#125;&#96;\n  await exec(sql)\n\n  res.send(&#123;\n    code: 0,\n    message: &#39;更新待办成功&#39;,\n    result: &#123;\n      id: id,\n      content: content,\n    &#125;,\n  &#125;)\n&#125;)\n5) 删除待办&#x2F;**\n * 删除todo\n * DELETE &#x2F;todos&#x2F;:id\n *&#x2F;\nrouter.delete(&#39;&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析请求数据\n  const &#123; id &#125; &#x3D; req.params\n  &#x2F;&#x2F; todo: 请求参数的校验\n\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;update xzd_todos set deleted_time &#x3D; NOW() where id&#x3D;$&#123;id&#125;&#96;\n  await exec(sql)\n\n  &#x2F;&#x2F; 三. 返回结果\n  res.send(&#123;\n    code: 0,\n    message: &#39;删除成功&#39;,\n    result: &#39;&#39;,\n  &#125;)\n&#125;)\n\n四. 前端实现1 结构&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Todo List&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 一.完成HTML的结构 --&gt;\n    &lt;div class&#x3D;&quot;todo&quot;&gt;\n      &lt;div class&#x3D;&quot;header&quot;&gt;\n        添加待办:\n        &lt;input id&#x3D;&quot;add&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按回车添加待办&quot; &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;list&quot;&gt;\n        &lt;ul&gt;\n          &lt;!-- &lt;li&gt;\n            &lt;p&gt;待办1&lt;&#x2F;p&gt;\n            &lt;span&gt;上次更新:2022-02-26 11:15:23&lt;&#x2F;span&gt;\n            &lt;a href&#x3D;&quot;#&quot;&gt;删除&lt;&#x2F;a&gt;\n          &lt;&#x2F;li&gt;\n          &lt;li&gt;\n            &lt;p&gt;待办2&lt;&#x2F;p&gt;\n            &lt;span&gt;上次更新:2022-02-26 11:15:23&lt;&#x2F;span&gt;\n            &lt;a href&#x3D;&quot;#&quot;&gt;删除&lt;&#x2F;a&gt;\n          &lt;&#x2F;li&gt; --&gt;\n        &lt;&#x2F;ul&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2 样式在index.html中引用两个样式\n&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;reset.css&quot; &#x2F;&gt;\n&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;index.css&quot; &#x2F;&gt;\n1) reset样式* &#123;\n  margin: 0;\n  padding: 0;\n&#125;\n\nli &#123;\n  list-style: none;\n&#125;\n\na &#123;\n  text-decoration: none;\n&#125;\n2) 业务样式编写index.css\n.todo &#123;\n  width: 400px;\n  margin: 50px auto;\n&#125;\n\n.todo .header &#123;\n  height: 40px;\n  padding: 0 20px;\n  background-color: skyblue;\n  color: #fff;\n  line-height: 40px;\n&#125;\n\n.todo .header input &#123;\n  height: 30px;\n  padding-left: 10px;\n  color: #333;\n  border: none;\n  outline: none;\n&#125;\n\n.todo .list &#123;\n  min-height: 200px;\n  margin-top: 20px;\n  border: 1px solid #ccc;\n&#125;\n\n.todo .list li &#123;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin: 10px auto;\n  padding: 5px 20px;\n  background-color: #eee;\n&#125;\n\n.todo .list li span &#123;\n  margin-right: 5px;\n  font-size: 12px;\n  color: #999;\n&#125;\n\n.todo .list li p &#123;\n  flex: 1;\n&#125;\n3 交互在index.html中引用jQuery\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;3.6.0&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n在index.html中引用 业务代码index.js\n&lt;script src&#x3D;&quot;js&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;  注意在代码的最下面引入js文件!!!!!!!!!!!\n\n获取所有待办const BASE_URL &#x3D; &#39;http:&#x2F;&#x2F;localhost:3000&#39;\n\n&#x2F;&#x2F; 获取列表(所有待办)\nfunction getTodos() &#123;\n  &#x2F;&#x2F; 发送ajax请求, 调用 GET &#x2F;todos接口\n  $.ajax(&#123;\n    type: &#39;GET&#39;,\n    url: &#96;$&#123;BASE_URL&#125;&#x2F;todos&#96;,\n    success: function (res) &#123;\n      console.log(res)\n      &#x2F;&#x2F; 解构res对象\n      const &#123; code, message, result &#125; &#x3D; res\n      if (code &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 成功, 遍历result(数组)\n        result.forEach((item) &#x3D;&gt; &#123;\n          &#x2F;&#x2F; 在ul的后面添加li元素\n          $(&#39;.list ul&#39;).append(&#96;&lt;li&gt;\n          &lt;p&gt;$&#123;item.content&#125;&lt;&#x2F;p&gt;\n          &lt;span&gt;上次更新:$&#123;item.updated_time&#125;&lt;&#x2F;span&gt;\n          &lt;a href&#x3D;&quot;#&quot;&gt;删除&lt;&#x2F;a&gt;\n          &lt;&#x2F;li&gt;&#96;)\n        &#125;)\n      &#125; else &#123;\n        alert(message)\n      &#125;\n    &#125;,\n  &#125;)\n&#125;\n\ngetTodos()\n添加待办&#x2F;&#x2F; 添加待办\n&#x2F;&#x2F; 一. 监听add这个input框的回车事件\n&#x2F;&#x2F; 1.1 判断input框架的内容为空, 提示&quot;不能为空&quot;, 返回\n&#x2F;&#x2F; 1.2 判断input框架的内容不为空, 发送ajax请求, [POST &#x2F;todos]接口\n&#x2F;&#x2F; 1.3 拿到数据后, 判断是否失败, 如果成功, 重新加载数据\n$(&#39;#add&#39;).keyup((e) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; console.log(e)\n  &#x2F;&#x2F; 如果按下的键是回车键\n  if (e.keyCode &#x3D;&#x3D;&#x3D; 13) &#123;\n    &#x2F;&#x2F; 获取input框架的值\n    var inputValue &#x3D; $(&#39;#add&#39;).val()\n\n    &#x2F;&#x2F; 去掉首尾的空白字符\n    if (inputValue.trim() &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;\n      alert(&#39;待办事项不能为空&#39;)\n      return\n    &#125;\n\n    &#x2F;&#x2F; 发送ajax请求, 请求[POST &#x2F;todos]接口\n    $.ajax(&#123;\n      type: &#39;POST&#39;,\n      url: &#96;$&#123;BASE_URL&#125;&#x2F;todos&#96;,\n      data: &#123; content: inputValue &#125;,\n      success: function (res) &#123;\n        &#x2F;&#x2F; 清空输入框的数据\n        $(&#39;#add&#39;).val(&#39;&#39;)\n\n        const &#123; code, message &#125; &#x3D; res\n        if (code &#x3D;&#x3D;&#x3D; 0) &#123;\n          &#x2F;&#x2F; 重新获取列表\n          getTodos()\n        &#125; else &#123;\n          alert(message)\n        &#125;\n      &#125;,\n    &#125;)\n  &#125;\n&#125;)\n发现了一个问题, 当添加时会重复出现多条记录\n\n\n\n\n\n\n\n\n\n解决方法\n在getTodos时, 先清空子节点\n&#x2F;&#x2F; 获取列表(所有待办)\nfunction getTodos() &#123;\n  &#x2F;&#x2F; 发送ajax请求, 调用 GET &#x2F;todos接口\n  $.ajax(&#123;\n    type: &#39;GET&#39;,\n    url: &#96;$&#123;BASE_URL&#125;&#x2F;todos&#96;,\n    success: function (res) &#123;\n      console.log(res)\n      &#x2F;&#x2F; 解构res对象\n      const &#123; code, message, result &#125; &#x3D; res\n      if (code &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 清空ul中的数据\n        $(&#39;.list ul&#39;).empty()\n        &#x2F;&#x2F; 成功, 遍历result(数组)\n        result.forEach((item) &#x3D;&gt; &#123;\n          &#x2F;&#x2F; 在ul的后面添加li元素\n          $(&#39;.list ul&#39;).append(&#96;&lt;li&gt;\n                                  &lt;p&gt;$&#123;item.content&#125;&lt;&#x2F;p&gt;\n                                  &lt;span&gt;上次更新:$&#123;item.updated_time&#125;&lt;&#x2F;span&gt;\n                                  &lt;a href&#x3D;&quot;#&quot;&gt;删除&lt;&#x2F;a&gt;\n                                &lt;&#x2F;li&gt;&#96;)\n        &#125;)\n      &#125; else &#123;\n        alert(message)\n      &#125;\n    &#125;,\n  &#125;)\n&#125;\n修改待办&#x2F;&#x2F; 修改待办\n&#x2F;&#x2F; 当点击文字时, 变成一个可以输入的框. 拿到之前的数据\n$(&#39;.list&#39;).on(&#39;click&#39;, &#39;li&#39;, function () &#123;\n  &#x2F;&#x2F; on---监听动态创建的元素的事件\n  &#x2F;&#x2F; console.log($(this).find(&#39;p&#39;).text())\n  &#x2F;&#x2F; console.log($(this).find(&#39;span&#39;).text())\n  const content &#x3D; $(this).find(&#39;p&#39;).text()\n  const date &#x3D; $(this).find(&#39;span&#39;).text()\n\n  $(this).html(\n    &#96;&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;$&#123;content&#125;&quot;&#x2F;&gt;&lt;span&gt;$&#123;date&#125;&lt;&#x2F;span&gt;&lt;a href&#x3D;&quot;#&quot;&gt;删除&lt;&#x2F;a&gt;&#96;\n  )\n&#125;)\n\n&#x2F;&#x2F; 阻止input的点击事件向上冒泡\n$(&#39;.list&#39;).on(&#39;click&#39;, &#39;input&#39;, function (e) &#123;\n  e.stopPropagation()\n&#125;)\n\n&#x2F;&#x2F; 监听新创建的input框的回车事件\n$(&#39;.list&#39;).on(&#39;keyup&#39;, &#39;input&#39;, function (e) &#123;\n  if (e.keyCode &#x3D;&#x3D; 13) &#123;\n    &#x2F;&#x2F; 判断当前输入框的值为空\n    if ($(this).val().trim() &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;\n      alert(&#39;待办内容不能为空&#39;)\n      return\n    &#125;\n\n    const id &#x3D; $(this).parent().attr(&#39;data-index&#39;)\n    console.log(id)\n    &#x2F;&#x2F; 发送ajax请求\n    $.ajax(&#123;\n      type: &#39;PUT&#39;,\n      url: &#96;$&#123;BASE_URL&#125;&#x2F;todos&#x2F;$&#123;id&#125;&#96;,\n      data: &#123; content: $(this).val() &#125;,\n      success: function (res) &#123;\n        &#x2F;&#x2F; 重新获取数据\n        const &#123; code, message &#125; &#x3D; res\n        if (code &#x3D;&#x3D;&#x3D; 0) &#123;\n          getTodos()\n        &#125; else &#123;\n          alert(message)\n        &#125;\n      &#125;,\n    &#125;)\n  &#125;\n&#125;)\n$(&#39;.list&#39;).on(&#39;blur&#39;, &#39;input&#39;, function () &#123;\n  &#x2F;&#x2F; 判断当前输入框的值为空\n  if ($(this).val().trim() &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;\n    alert(&#39;待办内容不能为空&#39;)\n    return\n  &#125;\n\n  const id &#x3D; $(this).parent().attr(&#39;data-index&#39;)\n  console.log(id)\n  &#x2F;&#x2F; 发送ajax请求\n  $.ajax(&#123;\n    type: &#39;PUT&#39;,\n    url: &#96;$&#123;BASE_URL&#125;&#x2F;todos&#x2F;$&#123;id&#125;&#96;,\n    data: &#123; content: $(this).val() &#125;,\n    success: function (res) &#123;\n      &#x2F;&#x2F; 重新获取数据\n      const &#123; code, message &#125; &#x3D; res\n      if (code &#x3D;&#x3D;&#x3D; 0) &#123;\n        getTodos()\n      &#125; else &#123;\n        alert(message)\n      &#125;\n    &#125;,\n  &#125;)\n&#125;)\n删除待办&#x2F;&#x2F; 删除待办\n$(&#39;.list&#39;).on(&#39;click&#39;, &#39;a&#39;, function (e) &#123;\n  &#x2F;&#x2F; 阻止a元素向上冒泡\n  e.stopPropagation()\n\n  const id &#x3D; $(this).parent().attr(&#39;data-index&#39;)\n\n  $.ajax(&#123;\n    type: &#39;DELETE&#39;,\n    url: &#96;$&#123;BASE_URL&#125;&#x2F;todos&#x2F;$&#123;id&#125;&#96;,\n    success: function (res) &#123;\n      const &#123; code &#125; &#x3D; res\n      if (code &#x3D;&#x3D;&#x3D; 0) &#123;\n        getTodos()\n      &#125;\n    &#125;,\n  &#125;)\n&#125;)\n五. 联调六. 测试七. 部署八. 运维","slug":"综合案例-Todo小项目","date":"2022-12-01T14:18:16.930Z","categories_index":"项目","tags_index":"Todolist","author_index":"团子"},{"id":"b455dd2018d164911d1cb5d5e588f15b","title":"32_todolist项目练习及讲解","content":"1,后端基本功能实现环境的搭建\n\t1,生成api后端目录\n\t2,安装额外的nodemon,mysql,cors包\n\t3,集成nodemon,使用cors中间件\n\t4,创建todos.js路由模块\n\t5,导入数据库操作模块,编写具体的路由\n\n\n增删改查基本功能\n\t\n\n2,处理时间显示问题const con &#x3D; mysql.createConnection(&#123;\n    host:&#39;localhost&#39;,\n    port:3306,\n    user:&#39;root&#39;,\n    password:&#39;1234&#39;,\n    database:&#39;db2022_01&#39;,\n    timezone:&#39;SYSTEM&#39; &#x2F;* 使用系统时区 *&#x2F;\n  &#125;)\n\n3,提取mysql的配置目的\n\tmysql的配置经常会改变,方便后面操作\n\t还可以额外增加一个debug属性,将来根据这属性的值,来决定是否显示错误信息\n\t(在测试环境中,显示错误信息,在线上环境,不显示错误信息)\n做法\n\t1,在api下创建一个config文件夹,然后在创建一个index.js文件\n\t2,将mysql的配置信息剪切到index.js中,并导出\n\t3,在db文件夹下的index.js中导入mysql的配置信息并使用\n\n4,实现异常处理异常的两种处理方式\t\n\t1,throw(甩锅)\n\t\t抛出异常,一般是抛出一个异常对象(error)\n\t\t如果不进行处理的话,程序就会停止运行,后面的代码就无法执行\n\t\t\n\t2,try-catch(接盘)\n\t\t可以让程序在出了异常之后,后续代码能够正常执行,增强程序的健壮性\n\t\t\n\t\t语法\n\t\t\ttry&#123;\n\t\t\t\t可能会出现异常的代码\n\t\t\t&#125;catch(error)&#123;\n\t\t\t\t处理异常对象的代码\n\t\t\t&#125;\n\n做法\n\t&#x2F;&#x2F;导入调试的标记\n\tconst&#123;debug&#125; &#x3D; require(&#39;..&#x2F;config&#39;);\n\t\n\t\n\t  &#x2F;&#x2F;处理异常\n       try &#123;\n            const data &#x3D; await getAll(sql)\n            res.send(&#123;\n                    code:0,\n                    msg:&#39;获取所有代办成功&#39;,\n                    result:data\n            &#125;)\n       &#125; catch (error) &#123;\n            res.send(&#123;\n                code:100101,&#x2F;&#x2F;10代表第一个版本,01代表todolist项目,01代表第一个错误\n                msg:&#39;获取所有代办失败&#39;,\n                result: debug? error : &#39;&#39;\n            &#125;)\n       &#125;\n\n","slug":"day32_课堂笔记","date":"2022-12-01T14:15:54.316Z","categories_index":"项目","tags_index":"Todolist","author_index":"团子"},{"id":"106826aea6b9ab5ab35ab7da587e641c","title":"31_用户管理系统前端增删改完成","content":"昨日回顾1,将数据库操作的代码命名为index.js,放在db文件夹下.方便管理\n\n2,脚手架的使用及项目环境搭建(项目代码生成器)\n\t安装\n\t创建项目名,express --no-view backEnd 生成后端目录\n\t安装包(自带的包,mysql cors,nodemon)\n\t更改启动方式(node -&gt; nodemon)\n\t启动 进入后端目录,使用npm run start\n\t复制mysql操作的模块,并引入\n\t引入cors的模块,并使用\n\t\n3,编写后台代码\n\t找对路径,在user的路由模块中进行操作\n\t提供增删改查的路由,并调用相应的处理函数进行处理\n\t\n4,编写前台代码(查询)\n\t1,先写页面骨架\n\t2,再写样式\n\t3,发送ajax请求\n\t4,处理返回的数据,展示数据\n\t\n\n前台实现新增\n\t1,编写add.html页面骨架\n\t2,在style.css中,添加add.html的样式\n\t3,监听add按钮的点击,在点击事件中,获取用户输入的姓名和年龄进行判断\n\t4,如果为空,直接返回,否则,就发送post请求,提交到后台,修改数据库中的数据\n\t5,修改成功,弹出提示,并跳转到list.html页面\n\t\n修改\n\t1,编写edit.html页面的骨架\n\t2,在list.html页面为 修改的a标签 的href中拼接id属性\n\t3,在edit.html页面中获取跳转过来的路径携带过来的id的值\n\t4,发送ajax请求,根据id查找响应的用户,回显数据\n\t5,给按钮添加点击事件,获取用户输入的用户名和年龄进行判断\n\t6,如果为空,直接返回,否则,就发送put请求,提交到后台,修改数据库中的数据\n\t7,修改成功,弹出提示,并跳转到list.html页面\n\t\n删除\n\t1,在list.html页面为 删除的a标签的onclick属性中 设置方法,传入id\n    2,实现删除的方法,删除之前先弹出确认信息\n    3,如果确认删除,就发送ajax请求,删除数据库中的数据\n    4,删除成功,跳回当前页面\n\n","slug":"day31_课堂笔记","date":"2022-12-01T14:14:07.773Z","categories_index":"后端","tags_index":"express","author_index":"团子"},{"id":"5a9c51c782f6d4d77fd9a0571cb97c4f","title":"Express框架应用-实现用户模块","content":"一. 需求分析1 系统框架选择前后端分离的系统架构\n\n2 具体的业务需求\n有一个页面, 可以展示用户的列表\n有一个页面, 可以添加用户信息\n有一个页面, 可以修改用户信息\n点击删除按钮, 可以删除用户信息\n\n\n二. 技术方案1 数据库设计\n\n\n\n\n\n\n\n\n用户表  (users)\n\n\n\n字段名\n类型\n备注\n\n\n\nid\nint\n主键, 自增\n\n\nname\nvarchar(255)\n用户的姓名\n\n\nage\ntinyint unsigned\n用户的年龄\n\n\n使用Navicate建表\n\n2 接口设计1) baseURLhttp:&#x2F;&#x2F;localhost:3000\n\n2) 用户模块获取所有用户\n\n\n\n\n\n\n\n\n请求\n请求方式: GET\n请求URL: /users\nGET &#x2F;users\n\n\n\n\n\n\n\n\n\n\n响应\n[\n  &#123;\n    &quot;id&quot;: 1,\n    &quot;name&quot;: &quot;xiaoming&quot;,\n    &quot;age&quot;: 20\n\t&#125;,\n  &#123;\n    &quot;id&quot;: 2,\n    &quot;name&quot;: &quot;xiaomei&quot;,\n    &quot;age&quot;: 18\n\t&#125;,\n]\n\n根据id获取单个用户\n\n\n\n\n\n\n\n\n请求\n请求方式 GET\n请求地址 /users/:id\nGET &#x2F;users&#x2F;:id\nGET &#x2F;users&#x2F;1\n\n\n\n\n\n\n\n\n\n\n响应\n&#123;\n  &quot;id&quot;: 1,\n  &quot;name&quot;: &quot;xiaoming&quot;,\n  &quot;age&quot;: 20\n&#125;\n\n添加用户\n\n\n\n\n\n\n\n\n请求\n请求方式 POST\n接口地址 /users\nPOST &#x2F;users\n\n请求参数\n&#123;\n\t&quot;name&quot;: &quot;xiaoming&quot;,\n\t&quot;age&quot;: 20\n&#125;\n\n\n\n\n\n\n\n\n\n\n响应\n&#123;\n  &quot;id&quot;: 1,\n  &quot;name&quot;: &quot;xiaoming&quot;,\n  &quot;age&quot;: 20\n&#125;\n\n修改用户\n\n\n\n\n\n\n\n\n请求\n请求方式 PUT\n请求地址 /users/1\nPUT &#x2F;users&#x2F;:id\nPUT &#x2F;users&#x2F;1\n\n请求参数\n&#123;\n\t&quot;name&quot;: &quot;xiaoming-new&quot;,\n\t&quot;age&quot;: 200\n&#125;\n\n\n\n\n\n\n\n\n\n\n响应\n&#123;\n  &quot;id&quot;: 1,\n  &quot;name&quot;: &quot;xiaoming-new&quot;,\n  &quot;age&quot;: 200\n&#125;\n\n删除用户\n\n\n\n\n\n\n\n\n请求\n请求方式 DELETE\n请求地址 /users/:id\nDELETE &#x2F;users&#x2F;:id\nDELETE &#x2F;users&#x2F;1\n\n\n\n\n\n\n\n\n\n\n响应\n空\n\n三. 技术实现1 后端1) 项目搭建安装express脚手架执行命令, 全局安装脚本架(也称为项目生成器)\nnpm i express-generator -g\n\n安装完成后, 在全局会多一个命令\nexpress\n\n通过脚手加搭建项目在根目录下, 执行命令\nexpress --no-view backEnd\n\n\n在目录下创建一个backEnd的目录, 作为后端项目的目录\n--no-view: 创建一个数据服务, 不提供页面服务\n\n安装相关依赖进入backEnd目录, 执行命令, 根据package.jsoon中的依赖项, 安装项目所有的依赖\n\ncookie-parser: 解析cookie的中间件\ndebug: 调试代码的中间件\nexpress: express框架包\nmorgan: 记录日志的中间件\n\nnpm install\n\n启动项目使用nodemon启动项目,\n将nodemon作为开发时依赖安装\nnpm i nodemon -D\n\n会在package.json中, 生成devDependencies\n&quot;devDependencies&quot;: &#123;\n  &quot;nodemon&quot;: &quot;^2.0.15&quot;\n&#125;\n\n修改pagckage.json中的脚本\n&quot;scripts&quot;: &#123;\n  &quot;start&quot;: &quot;nodemon .&#x2F;bin&#x2F;www&quot;\n&#125;,\n\n执行\nnpm run start\n\n使用浏览器测试\n\n2) 实现获取所有用户编写router/users.js文件\nrouter.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 编写sql语句\n  &#x2F;&#x2F; 二. 执行sql语句, 获得结果\n  &#x2F;&#x2F; 三. 返回数据\n&#125;) \n\n安装mysql包npm i mysql\n\n复用数据库操作模块\n修改配置\n\n导入db模块\n\n\n\n\n\n\n\n\n\n\n示例\nconst &#123; getAll, getById, exec &#125; &#x3D; require(&#39;..&#x2F;db&#39;)\n&#x2F;&#x2F; 编写接口\n&#x2F;&#x2F; GET &#x2F;users\nrouter.get(&#39;&#x2F;&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 编写sql语句\n  let sql &#x3D; &#39;select * from users&#39;\n  &#x2F;&#x2F; 二. 执行sql语句, 获得结果\n  const users &#x3D; await getAll(sql)\n  &#x2F;&#x2F; 三. 返回数据\n  res.send(users)\n&#125;)\n\n测试创建test/users.http测试文件\n@baseURL &#x3D; http:&#x2F;&#x2F;localhost:3000\n\n###\nGET &#123;&#123;baseURL&#125;&#125;&#x2F;users\n\n\n3) 实现根据id获取单个用户&#x2F;&#x2F; 根据id获取单个用户\n&#x2F;&#x2F; GET &#x2F;users&#x2F;:id -&gt; &#123;&#125;\nrouter.get(&#39;&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析参数\n  let &#123; id &#125; &#x3D; req.params\n\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;select * from users where id&#x3D;$&#123;id&#125;&#96;\n  const user &#x3D; await getById(sql)\n\n  &#x2F;&#x2F; 三. 返回结果\n  res.send(user)\n&#125;)\n\n测试\n\n4) 实现添加用户&#x2F;&#x2F; 添加用户\n&#x2F;&#x2F; POST &#x2F;users &#123;&quot;name&quot;:&quot;test&quot;, &quot;age&quot;:20&#125;\nrouter.post(&#39;&#x2F;&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析参数\n  const &#123; name, age &#125; &#x3D; req.body\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;insert into users (name, age) values (&#39;$&#123;name&#125;&#39;, &#39;$&#123;age&#125;&#39;)&#96;\n  &#x2F;&#x2F; console.log(sql)\n  const resData &#x3D; await exec(sql)\n  &#x2F;&#x2F;console.log(resData)\n  &#x2F;&#x2F; 三. 返回结果\n  res.send(&#123;\n    id: resData.insertId,\n    name, &#x2F;&#x2F; name: name\n    age, &#x2F;&#x2F; age: age\n  &#125;)\n&#125;)\n\n测试\n\n5) 实现修改接口&#x2F;&#x2F; 修改用户\n&#x2F;&#x2F; PUT &#x2F;users&#x2F;:id &#123;&quot;name&quot;:&quot;test-new&quot;, &quot;age&quot;:30&#125;\nrouter.put(&#39;&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析参数\n  let &#123; id &#125; &#x3D; req.params\n  let &#123; name, age &#125; &#x3D; req.body\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;update users set name&#x3D;&#39;$&#123;name&#125;&#39;, age&#x3D;&#39;$&#123;age&#125;&#39; where id&#x3D;$&#123;id&#125;&#96;\n  const resData &#x3D; await exec(sql)\n  &#x2F;&#x2F; 三. 返回结果\n  console.log(resData)\n  res.send(&#123;\n    id,\n    name,\n    age,\n  &#125;)\n&#125;)\n\n测试\n\n6) 实现删除接口&#x2F;&#x2F; 删除用户\nrouter.delete(&#39;&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析参数\n  let &#123; id &#125; &#x3D; req.params\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;delete from users where id &#x3D; &#39;$&#123;id&#125;&#39;&#96;\n  await exec(sql)\n  &#x2F;&#x2F; 三. 返回结果\n  res.status(204).send(&#39;&#39;)\n&#125;)\n\n测试\n\n2 前端前后端交互流程图点击查看【processon】\n1) 创建list.html编写页面结构&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;用户列表&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;用户列表&lt;&#x2F;h1&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;a href&#x3D;&quot;.&#x2F;add.html&quot; class&#x3D;&quot;add-btn&quot;&gt;添加用户&lt;&#x2F;a&gt;\n      &lt;table class&#x3D;&quot;user-list&quot;&gt;\n        &lt;tr&gt;\n          &lt;th&gt;id&lt;&#x2F;th&gt;\n          &lt;th&gt;name&lt;&#x2F;th&gt;\n          &lt;th&gt;age&lt;&#x2F;th&gt;\n          &lt;th&gt;操作&lt;&#x2F;th&gt;\n        &lt;&#x2F;tr&gt;\n      &lt;&#x2F;table&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n编写样式base.css\n* &#123;\n  margin: 0;\n  padding: 0;\n&#125;\n\na &#123;\n  text-decoration: none;\n&#125;\ntable,\nth,\ntd &#123;\n  border: 1px solid #000;\n&#125;\n\nstyle.css\n.container &#123;\n  width: 80%;\n  padding: 20px 50px;\n&#125;\n.container .add-btn &#123;\n  &#x2F;* 第一段: position display *&#x2F;\n  display: inline-block;\n\n  &#x2F;* 第二段: 盒子模型 margin padding border width height *&#x2F;\n  padding: 12px 20px;\n  border: 1px solid #169bd5;\n\n  &#x2F;* 第三段: 背景相关 *&#x2F;\n  background-color: #ecf5ff;\n  &#x2F;* 第四段: 文本相关 *&#x2F;\n  color: #169bd5;\n  line-height: 1;\n  text-align: center;\n  cursor: pointer;\n\n  &#x2F;* 第五段: CSS3新增属性 *&#x2F;\n  border-radius: 5px;\n  box-sizing: border-box;\n  transition: all 0.2s;\n&#125;\n.container .add-btn:hover &#123;\n  background-color: #fff;\n  color: #169bd5;\n&#125;\n.container .user-list &#123;\n  margin-top: 20px;\n  width: 500px;\n  border: 1px solid #000;\n  border-spacing: 0px;\n  border-collapse: collapse;\n  text-align: center;\n&#125;\n\n编写js引入jquery\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;3.6.0&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n\n发送ajax请求\n&#x2F;&#x2F; 调用接口(获取所有用户)\n$.ajax(&#123;\n  url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;,\n  type: &#39;GET&#39;,\n  success: function (res) &#123;\n    console.log(res)\n  &#125;,\n&#125;)\n\n发现报错:\n\n\n\n\n\n\n\n\n\n\n原因\n发生了跨域请求\n\n\n\n\n\n\n\n\n\n跨域请求\n\n由于浏览器同源策略导致跨域问题\n当浏览器从一个域向另一个域发送请求时, 它认为这种请求不安全, 不允许发送\n\n域 = 协议  + 域名 + 端口\n\n\n\n\n\n\n\n\n\n最常用的解决方案\n在服务端开启CORS, 在服务端回复的响应头中, 加入特殊的头信息, 允许浏览器发送跨域请求\n在后端安装cors中间件\nhttps://www.npmjs.com/package/cors\nnpm i cors\n\n在app.js中导入cors中间件\nconst cors &#x3D; require(&#39;cors&#39;)\n\n全局注册cors()中间件\napp.use(cors())\n在ajax请求中,遍历拿到的数组,创建tr元素,追加到表格后面\n$.ajax(&#123;\n    url:&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;,\n    type:&#39;GET&#39;,\n    success:function(res)&#123;\n        &#x2F;&#x2F;遍历res数组,创建tr元素,追加到表格后面\n        res.forEach(item &#x3D;&gt; &#123;\n            const tr &#x3D; &#96;&lt;tr&gt;\n                            &lt;td&gt;$&#123;item.id&#125;&lt;&#x2F;td&gt;\n                            &lt;td&gt;$&#123;item.name&#125;&lt;&#x2F;td&gt;\n                            &lt;td&gt;$&#123;item.age&#125;&lt;&#x2F;td&gt;\n                            &lt;td&gt;\n                                &lt;a href&#x3D;&quot;#&quot;&gt;修改&lt;&#x2F;a&gt;\n                                &lt;a href&#x3D;&quot;#&quot;&gt;删除&lt;&#x2F;a&gt;\n                            &lt;&#x2F;td&gt;\n                        &lt;&#x2F;tr&gt;&#96;\n            $(&#39;.user-list&#39;).append(tr)\n        &#125;);\n    &#125;\n&#125;)\n\n\n\n2) 创建add.html编写页面结构&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;添加用户&lt;&#x2F;title&gt;\n    &lt;!-- 二. 编写样式 --&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;base.css&quot; &#x2F;&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;style.css&quot; &#x2F;&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.6.0&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 一. 编写HTML结构 --&gt;\n    &lt;h1&gt;添加用户&lt;&#x2F;h1&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n        &lt;div class&#x3D;&quot;form-item&quot;&gt;\n            &lt;label for&#x3D;&quot;username&quot;&gt;用户名: &lt;&#x2F;label&gt;\n            &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; name&#x3D;&quot;username&quot; placeholder&#x3D;&quot;请输入用户名&quot;&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;form-item&quot;&gt;\n            &lt;label for&#x3D;&quot;age&quot;&gt;年龄: &lt;&#x2F;label&gt;\n            &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;age&quot; name&#x3D;&quot;age&quot; placeholder&#x3D;&quot;请输入年龄&quot; &#x2F;&gt;\n        &lt;&#x2F;div&gt;\n        &lt;button id&#x3D;&quot;btn&quot; class&#x3D;&quot;add-btn&quot;&gt;提交&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n编写样式.container .form-item&#123;\n    margin: 20px auto;\n  &#125;\n\n.container .form-item input&#123;\n    height: 40px;\n    border: 1px solid lightgray;\n    padding: 0 15px;\n\n    outline: none;\n    border-radius: 4px;\n  &#125;\n\n.container .form-item input:focus&#123;\n      border-color: lightblue;\n&#125;\n编写js&#x2F;&#x2F;监听btn的点击事件\n$(&#39;#btn&#39;).click(function()&#123;\n\t&#x2F;&#x2F;获取用户名和密码进行判断\n\tconst name &#x3D; $(&#39;#username&#39;).val()\n\tconst age &#x3D; $(&#39;#age&#39;).val()\n\t&#x2F;&#x2F;判断\n\tif(name &#x3D;&#x3D; &#39;&#39; || age &#x3D;&#x3D; &#39;&#39;)&#123;\n\t\talert(&#39;用户名和密码不能为空&#39;)\n\t\treturn\n\t&#125;\n\t&#x2F;&#x2F;发送异步请求\n\t$.ajax(&#123;\n\t\ttype:&#39;POST&#39;,\n\t\turl:&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;,\n\t\tdata:&#123;name:name,age:age&#125;,\n\t\tsuccess:function(res)&#123;\n\t\t\talert(&#39;添加成功&#39;)\n\t\t\twindow.location.href&#x3D;&#39;.&#x2F;list.html&#39;\n\t\t&#125;\n\t&#125;)\n&#125;)\n3) 创建edit.html修改list入口$.ajax(&#123;\n  url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;,\n  type: &#39;GET&#39;,\n  success: function (res) &#123;\n    &#x2F;&#x2F; console.log(res)\n    &#x2F;&#x2F; 遍历res数组\n    &#x2F;&#x2F; 创建一个tr元素, 追加到表格的最后\n    res.forEach((item) &#x3D;&gt; &#123;\n      const tr &#x3D; &#96;&lt;tr&gt;\n                    &lt;td&gt;$&#123;item.id&#125;&lt;&#x2F;td&gt;\n                    &lt;td&gt;$&#123;item.name&#125;&lt;&#x2F;td&gt;\n                    &lt;td&gt;$&#123;item.age&#125;&lt;&#x2F;td&gt;\n                    &lt;td&gt;\n                      &lt;a href&#x3D;&quot;.&#x2F;edit.html?id&#x3D;$&#123;item.id&#125;&quot;&gt;修改&lt;&#x2F;a&gt;\n                      &lt;a href&#x3D;&quot;#&quot; onclick&#x3D;&quot;del($&#123;item.id&#125;)&quot;&gt;删除&lt;&#x2F;a&gt;\n                    &lt;&#x2F;td&gt;\n                  &lt;&#x2F;tr&gt;&#96;\n      $(&#39;.user-list&#39;).append(tr)\n    &#125;)\n  &#125;,\n&#125;)\n编写页面&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;修改用户&lt;&#x2F;title&gt;\n    &lt;!-- 二. 编写样式 --&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;base.css&quot; &#x2F;&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;style.css&quot; &#x2F;&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.6.0&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n        \n    &lt;!-- 一. 编写HTML结构 --&gt;\n    &lt;h1&gt;修改用户&lt;&#x2F;h1&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n        &lt;div class&#x3D;&quot;form-item&quot;&gt;\n            &lt;label for&#x3D;&quot;username&quot;&gt;用户名: &lt;&#x2F;label&gt;\n            &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; name&#x3D;&quot;username&quot; placeholder&#x3D;&quot;请输入用户名&quot;&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;form-item&quot;&gt;\n            &lt;label for&#x3D;&quot;age&quot;&gt;年龄: &lt;&#x2F;label&gt;\n            &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;age&quot; name&#x3D;&quot;age&quot; placeholder&#x3D;&quot;请输入年龄&quot; &#x2F;&gt;\n        &lt;&#x2F;div&gt;\n        &lt;button id&#x3D;&quot;btn&quot; class&#x3D;&quot;add-btn&quot;&gt;提交&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n     &lt;script&gt;\n        &#x2F;&#x2F; 三. 发送ajax请求, 根据id查找用户的信息\n        &#x2F;&#x2F; console.log(window.location)\n        &#x2F;&#x2F; console.log(window.location.search)\n        &#x2F;&#x2F; console.log(window.location.search.replace(&#39;?&#39;, &#39;&#39;))\n        &#x2F;&#x2F; console.log(window.location.search.replace(&#39;?&#39;, &#39;&#39;).split(&#39;&#x3D;&#39;))\n        &#x2F;&#x2F; console.log(window.location.search.replace(&#39;?&#39;, &#39;&#39;).split(&#39;&#x3D;&#39;)[1])\n\n        const id &#x3D; window.location.search.replace(&#39;?&#39;,&#39;&#39;).split(&#39;&#x3D;&#39;)[1]\n\n        &#x2F;&#x2F;发送ajax请求,根据id查询用户信息,并回显数据\n        $.ajax(&#123;\n            type:&#39;GET&#39;,\n            url:&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;&#39;+id,\n            success:function(res)&#123;\n                &#x2F;&#x2F;设置input的值（回显数据）\n                $(&#39;#username&#39;).val(res.name)\n                $(&#39;#age&#39;).val(res.age)\n            &#125;\n        &#125;)\n\n        &#x2F;&#x2F;添加点击事件,发送put请求修改用户信息\n        $(&#39;#btn&#39;).click(function()&#123;\n            &#x2F;&#x2F;获取input输入的值\n            const name &#x3D; $(&#39;#username&#39;).val()\n            const age &#x3D; $(&#39;#age&#39;).val()\n            &#x2F;&#x2F;判断\n            if(name &#x3D;&#x3D; &#39;&#39; || age &#x3D;&#x3D; &#39;&#39;)&#123;\n                alert(&#39;用户名和密码不能为空&#39;)\n                return\n            &#125;\n            &#x2F;&#x2F;发送put请求\n            $.ajax(&#123;\n                type:&#39;PUT&#39;,\n                url:&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;&#39;+id,\n                data:&#123;name,age&#125;,\n                success:function(res)&#123;\n                    alert(&#39;更新成功&#39;)\n                    window.location.href&#x3D;&#39;.&#x2F;list.html&#39;\n                &#125;\n            &#125;)\n        &#125;)\n\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4) 实现删除&#x2F;&#x2F; 处理删除\nfunction del(id)&#123;\n\tconst c &#x3D;  confirm(&#39;你确定要删除吗&#39;)\n\tif(c)&#123;\n\t\t$.ajax(&#123;\n\t\ttype:&#39;DELETE&#39;,\n\t\turl:&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;&#39;+id,\n\t\tsuccess:function(res)&#123;\n\t\t\tlocation.href&#x3D;&#39;.&#x2F;list.html&#39;\n\t\t&#125;&#125;) \n\t&#125;\n&#125;\n","slug":"Express框架应用-实现用户模块","date":"2022-12-01T14:09:41.043Z","categories_index":"后端","tags_index":"express","author_index":"团子"},{"id":"dec91e97c264ed31b95d6e5abfa5eeb8","title":"30_用户管理系统后台实现及前台查询所有","content":"昨日回顾改造了express后台的增删改查\n\t一,使用数组实现\n\t\t弊端\n\t\t\t数据不能持久存储,只是在内存中存储\n\t二,中间件优化\n\t\t1,优化处理请求体\n\t\t\tapp.use(express.json())\n\t\t\tapp.use(express.urlencoded())\n\t\t2,处理跨域请求\n\t\t\tapp.use(cors())\n\t三,数据库实现\n\t\t好处\n\t\t\t可以让数据持久化的存在文件中\n\t\t步骤\n\t\t\t1,导包,创建连接,连接数据库\n\t\t\t2,在路由(处理函数)中\n\t\t\t\t1,获取请求参数\n\t\t\t\t2,编写sql语句\n\t\t\t\t3,执行sql语句返回数据\n\t四,抽取数据库代码\n\t\t目的\n\t\t\t将业务逻辑代码和处理数据库的代码剥离出去\n\t\t\t方便后期维护,实现数据库代码的重用\n\t\t步骤\n\t\t\t把关于数据库的操作单独放在一个js文件中(对query这个方法进行了封装)\n\t\t\t\t1,导包,创建连接,连接数据库剪切到一个文件中\n\t\t\t\t2,提供查询所有getAll(),查询一个getByid(),增删改exec()\n\t\t\t\t3,这些方法都返回一个promise对象,异常通过reject返回,数据通过resolve返回\n\t\t\t\t4,导出方法\n\t五,用es7语法糖简化异步的调用\n\t\t目的\n\t\t\t简化代码,提高开发效率\n\t\t做法\n\t\t\t1,调用数据库方法的前面加上await关键字,就可以获取then方法执行的结果\n\t\t\t2,由于await只能放在异步函数中,在外面的处理函数前面加上async关键字\n\t六,修改数据库操作的文件的文件名和所在文件夹\n\t\t一般将文件名修改为index.js,将来不可以写文件名,默认会加载index.js\n\t\t一般将数据库操作的文件放在db文件夹下,将来方便程序员去维护\n\nexpress集成nodemon集成步骤\n\t1,在package.json中修改script脚本\n\t\t&#39;dev&#39;:&#39;要执行文件的路径&#39;\n\t2,使用npm run dev 执行代码\n\t\t\n\n\n\n用户管理系统搭建1,分析具体需求\n2,设计数据库,建表(用之前的学生表即可)\n3,设计接口\n\t前台:发送请求的url,需要的参数\n\t后台:返回数据的格式\n4,编写代码\n\t1,先写后端\n\t\texpress脚手架快速生成\n\t\t   1,全局安装脚手架 npm i express-generator -g\n\t\t   2,创建项目文件夹,在这个文件夹内使用express --no-view backEnd生成后端目录\n\t\t   3,进入后端backEnd目录内,使用npm install安装package.json配置的相关依赖(包)\n\t\t   4,继续使用命令npm i nodemon -D 安装nodemon包,\n\t\t   5,修改启动脚本(&quot;start&quot;: &quot;nodemon .&#x2F;bin&#x2F;www&quot;)\n\t\t   6,继续使用命令安装mysql和cors包,安装好之后就可以在package.json看到配置\n\t\t   7,在终端使用npm run start运行,在浏览器输入http:&#x2F;&#x2F;localhost:3000&#x2F;访问欢迎页\n\t\t   \n\t\t   8,导入数据库操作的模块 \n\t\t   \t \t将之前写好的db文件夹直接拷贝到backEnd文件夹下\n\t\t   \t \t在routes文件夹下的users.js文件中导入数据库操作模块\n\t\t   \t \t\tconst &#123;getAll,getById,exec&#125; &#x3D; require(&#39;..&#x2F;db&#39;);\n\t\t   \t \t\t\n\t\t   9,导入跨域请求的模块\n\t\t   \t\t在app.js中导入 const cors &#x3D; require(&#39;cors&#39;);\n\t\t   \t\t在app.js中注册 app.use(cors())  注册路由之前注册\n\n\n\n后端编写流程1,在用户路由模块users.js下编写代码\n2,编写获取所有用户,使用get请求,调用getAll()方法,返回所有用户的数组(data)\n3,编写获取一个用户,使用get请求,调用getById()方法,返回指定id的用户(data)\n4,编写新增一个用户,使用post请求,调用exec()方法,返回新增的用户(data.insertId)\n5,编写修改一个用户,使用put请求,调用exec()方法,返回新增的用户(无需data)\n5,编写删除一个用户,使用delete请求,调用exec()方法,设置状态码,返回空字符串(无需data)\n\n\n\n前端编写流程一,显示所有用户\n\t1,新建fontEnd文件夹\n\t2,新建3个html页面\n\t3,编写list.html页面的骨架\n\t4,编写基本样式base.css\n\t5,编写list页面样式style.css\n\t6,引入jquery,发送ajax请求(已经引入了cors处理跨域请求)\n\t7,遍历获取到的数据,动态拼接tr元素,追加到table下面\n\n","slug":"day30_课堂笔记","date":"2022-12-01T14:07:10.846Z","categories_index":"后端","tags_index":"express","author_index":"团子"},{"id":"841af1c8d1a60dd62055f0a0655c6017","title":"29_express集成数据库操作并封装","content":"昨日回顾中间件\n\t概念\n\t\t业务处理中间环节.(一个处理函数)\n\t规则\n\t\t(req,res,next) next可以将调用关系流转到下一个函数\n    分类\n    \t按照作用范围\n    \t\t局部生效的中间件(某些访问路径,某个路由调用)\n    \t\t全局生效的中间件(所有访问路径,通过use调用)\n    \t按照级别来分\n    \t\t内置中间件\n    \t\t\texpress.json()\n    \t\t\texpress.urlencoded()\n    \t\t\texpress.static()\n    \t\t第三方中间件\n    \t\t\tcors()\n    \t\t应用级别中间件\n    \t\t\t绑定app上,可以是全局,也可以是局部\n    \t\t路由级别中间件\n    \t\t\t绑定到路由对象 express.router() 上\n    模块化路由\n    \t由来\n    \t\t方便对路由的分类和管理\n    \t实现\n    \t\t根据不同的实体创建不同的js文件\n    \t\t在每个js文件中创建路由对象,加载具体的路由,再导出\n    \t\t在入口函数中使用app.use()注册路由模块\n\nnode连接数据库其实就是使用第三方包 mysql 操作数据库,需要下载mysql包\n\n1,导入mysql包\n2,创建连接(createConnection方法)\n\t传入 host port user password database\n3,连接数据库(connect方法)\n4,执行sql语句(query方法)\n5,关闭数据库连接(end())\n\n增删改查_数组实现(优化)&#x2F;&#x2F;使用内置中间件处理请求体\napp.use(express.json())\napp.use(express.urlencoded())\n&#x2F;&#x2F;使用第三方中间件处理跨域问题  --- 需要下载安装\napp.use(cors())  \n\n增删改查_数据库实现思路\n\t1,将数据库导包,创建连接,连接,这三个步骤拷贝进去\n\t2,在路由里面 编写sql语句,执行sql语句并返回数据\n\n增删改查_提取数据库操作目的\n\t将数据库操作的代码单独放到一个文件中,便于后期代码的维护\n做法\n\t1,将数据库导包,创建连接,连接的代码剪切过去,放在一个js文件中\n\t2,提供查询所有getAll,查询单个getById,增删改exec方法,方法里面用promise封装\n\t3,导出这3个方法\n\t4,在后台代码中,导入这个js文件,解构这3个方法并使用\n\n语法糖_async_awaitasync\n\t概念\n\t\t异步的意思\n\t作用\n\t\t可以将同步函数变成异步函数(调用函数返回就是promise对象),就可以使用then方法调用\n\t使用\n\t\t定义\n            async function m1()&#123;\n                return 222\n            &#125;\n         调用\n         \tconst p &#x3D; m1()\t\n       \t\tp.then(data &#x3D;&gt;&#123;\n                console.log(data);&#x2F;&#x2F;222\n            &#125;)\n            \nawait\n\t概念\n\t\t等待的意思\n\t作用\n\t\tawait可以等待 他后面的 promise对象执行之后,拿到返回的结果\n\t注意\n\t\tawait不能单独使用,必须跟async连用,存在于异步函数中\n\t\tawait后面必须要跟一个promise对象,如果不是promise对象,自动转成promise对象\n\t\tawait表达式,返回的是promise执行后的结果\n\t使用\n\t\t&#x2F;&#x2F;在外面套一个异步的函数的壳子fn\n        async function fn()&#123;\n\n            async function m1()&#123;\n                return 222\n            &#125;\n\n            const res &#x3D; await m1() \n            console.log(res);\n        &#125;\n\n        &#x2F;&#x2F;执行fn\n        fn()\t\n\n\n\n增删改查_es7语法改写app.get(&#39;&#x2F;users&#39;, async function(req,res)&#123;\n    &#x2F;&#x2F;获取请求参数(这里不需要)\n\n    &#x2F;&#x2F;编写sql语句\n    let sql &#x3D; &#39;select * from student&#39;\n\n    &#x2F;&#x2F;执行sql语句\n    const data &#x3D; await getAll(sql) \n\n    &#x2F;&#x2F;发给浏览器\n    res.send(data)\n    \n&#125;)\n\n","slug":"day29_课堂笔记","date":"2022-12-01T14:04:33.270Z","categories_index":"后端","tags_index":"express","author_index":"团子"},{"id":"8a9733c9b1d5d35d078b2db4ec97b51b","title":"restful","content":"一. 接口编程简介1 背景​    随着互联网的发展, 尤其是移动互联为代表的Web3.0时代. 客户端层出不穷, 以APP、微信、PC浏览器为代表, 服务端业务逻辑是基本一致的. \n​    那么有没有一种方式可以做到”一次编写,随时接入”呢?\n目前比较流行的方案就是”接口编程“\n \n2 什么是接口编程​    一般来说接口编程是基于HTTP协议, 通过URL请求对应的服务器资源(Resource).\n1) 什么是URL在HTTP协议中, URL的组成如下\nSchema:&#x2F;&#x2F;host[:port]&#x2F;path[?query-string]\n\n\nSchema: 使用的协议类型, 如http/https/ftp等\nhost:     主机域名或IP\nport:     端口号(可选)\npath:     路径\nquery-string: 查询参数(可选)\n\n例子:\nhttp://api.local.com/movies\nhttps://api.local.com:8080/articles?id=100\n2) 什么是资源\n狭义上讲, 所有在服务器保存的数据(如:音乐/视频/文章/个人信息…)都是服务器端资源.\n广义上讲, 任何服务器端的对象(如:应用程序/数据库记录/算法…)都可以看作资源.\n\n3 接口编程的作用\n\n\n\n\n\n\n\n\n主要是实现了前后端的分离\n后端(服务器)为前端(APP端/PC浏览器端/微信端)提供一个简单并且统一的方式(URL), 返回前端需要的数据(Resource).这样不管是APP还是Web浏览器, 只需要通过HTTP协议都可以实现同样的操作. \n二. RESTful设计六要素是不是所有前后端分离的设计都叫RESTful呢? 不是!!!\nful是一个后缀, 意思是”像什么一样的” windful\nRESTful是一种软件设计风格, 主要用于有客户端与服务端交互的软件.  主要包括6个方面\n\n资源路径(URL)\nHTTP动词(Method)\n过滤信息(query-string)\n状态码(Status-code)\n错误信息(Error)\n返回结果(Result)\n\n如下图所示:\n\n\n如果一个软件符合这些约定(风格), 我们就说这个软件是RESTful的\n1 资源路径标准的RESTful API中, 每个资源路径对应一个唯一的资源, 所以规定网址中不能有动词, 只能有名词, 并且一般来说为复数.\n比如:\nhttp://api.local.com/movies----表示电影资源 \nhttp://api.local.com/images----表示图片资源\nhttp://api.local.com/musics----表示音乐资源\nhttp://api.local.com/articles----表示文章资源\n2 Http动词对于资源, 一般有4个操作, CURD(增/删/改/查)\nGET:     从服务器获取资源(一项或多项)\nPOST:    在服务器新建一个资源\nPUT:    在服务器更新资源, 服务器返回完整的属性\nDELETE:    从服务器删除资源\nHEAD:    从服务器获取信息(响应头)\nPATCH:    在服务器更新资源, 服务器只返回更新的属性\n\n例子: \nPOST /articles     –    创建文章内容\nGET /articles/1    –    获取主键id为1的文章\n3 过滤信息(请求数据)当服务端需要返回的数据很多时, 服务器不可能全部返回\n此时, 我们可以在客户端携带过滤信息, 比如: 分页信息\n\n例子:\n?page=1                    –    第一页的信息\n?offset=10&amp;per_page=10    –    每页10条, 偏移10\n4 响应状态码服务端返回的信息, 用来告诉客户端操作结果\n\n\n\n状态码\n含义\n说明\n\n\n\n200\nOK\n操作成功, 并返回数据\n\n\n201\nCREATED\n新建成功\n\n\n204\nNO CONTENT\n删除成功\n\n\n400\nBAD REQUEST\n请求语法错误\n\n\n403\nForbidden\n请求没有权限的资源\n\n\n404\nNOT FOUND\n没有找到请求的资源\n\n\n5 错误处理如果状态码是4xx或者5xx, 需要告诉客户端对应的错误信息. 以Json格式返回\n{\n“error”: “错误信息”,\n}\n6 返回结果针对不同的操作, 服务需要返回的结果应该符合这样的规范\nGET /collections         –    返回资源列表(数组) \nGET /collections/:id        –    返回单个资源 eg. /collections/1\nPOST /collections        –    返回新生成的资源\nPUT /collections/:id        –    返回资源的完整属性\nPATCH /collections/:id    –    返回被修改的属性\nDELETE /collections/:id    –    返回204状态码+空文档 \n三. 工具1 服务端工具json-serverjson-server一个快速成形的RESTful接口服务工具, 使用json-server可以快速的搭建一个RESTful服务端\n第一步: 使用npm i json-server -g 全局安装\n第二步: 新建一个data.json做为数据源\ndata.json如下\n&#123;\n  &quot;users&quot;: [\n    &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;xiaoming&quot;, &quot;age&quot;: 20&#125;,\n    &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;xiaomei&quot;, &quot;age&quot;: 18&#125;,\n    &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;xiaopang&quot;, &quot;age&quot;: 1&#125;\n  ]\n&#125;\n\n第三步: 启动服务端\njson-server -w data.json\n\n会在localhost:3000端口启动一个RESTful服务\n2 客户端1) postman这里给大家安利一个工具postman. 这个是在接口编程中使用非常多的一个工具\nPostman是一个非常好用的免费API测试工具. 主要用于模拟发送Http请求.\n官网地址: https://www.getpostman.com/\n2) REST Client\nREST Client是一个非要好用的VSCode插件, 可以快速的测试RESTful接口\n第一步: 安装REST Client\n第二步: 编写test.http\nGET http:&#x2F;&#x2F;localhost:3000&#x2F;users HTTP&#x2F;1.1\n\n第三步: 点击Send Request\n\n\n\n\n\n\n\n\n\n演示\n\n四. 前后端分离与接口文档1 什么是前后端分离所谓前后端分离, 如下图所示:\n \n由上图可知, 一个项目有两个服务器\n前端服务器: 显示页面\n后端服务器: 提供数据\n通过API接口实现前后端的交互!\n2 前后端分离的好处\n提高开发效率: 前后端开发人员可是同时开发, 互不影响\n\n提高复用性: 后端通过统一的API提供数据, 这样可以同时为web前端/app前端/微信端提供数据\n\n\n3 接口文档咱们去公司之后, 经常会面临写接口文档的工作, 那么咱们看下接口文档怎么写\n见附件: [API接口文档.md](./API 接口文档.md)\n","slug":"restful","date":"2022-12-01T13:59:58.678Z","categories_index":"后端","tags_index":"restful","author_index":"团子"},{"id":"37a590a44a5ff61ad5ed7f48e2da3615","title":"Express","content":"一. Express简介Express 是一个极简而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。Express中文官网\n\n\n\n\n\n\n\n\n\n为什么说Express是一个极简的框架\nExpress的核心只有两个部分\n\n路由\n中间件\n\nExpress提供了基本的路由处理和中间件功能, 几乎所有功能的实现都由一个个独立的中间件完成\n1 路由路由可以认为是一种找到数据的路径, 或者说是URL+处理函数\n\n通过URL来区分不同的资源(页面或数据)\n通过处理函数来返回资源(页面或数据)\n\n前端通过URL请求数据. \n后端通过不同的路由, 调用对应的方法, 返回指定的数据\n\n2 中间件顾名思义, 中间件就是在什么的中间\n\n\n\n\n\n\n\n\n\n在请求和响应中间的处理程序\n有时候从请求到响应的业务比较复杂, 将这些复杂的业务拆开成一个个功能独立的函数, 就是中间件\n对于处理请求来说，在响应发出之前，可以在请求和响应之间做一些操作，并且可以将这个处理结果传递给下一个函数继续处理\nexpress 中间件函数，帮助拆解主程序的业务逻辑，\n并且每一个的中间件函数处理的结果都会传递给下一个中间件函数。\n就好比工厂里流水线工人清洗一个箱子:\n第一个人清洗侧面，第二个人清洗底面，第三个人清洗顶面，。。。\n这条流水线结束后，箱子也就清洗干净了\n各做各的，不相互影响，又彼此协作\n\n\n二. 安装及使用express也是一个node的包, 可以npm来安装\n1 安装npm i express \n\n2 使用步骤\n\n导入express包\n实例化对象\n编写路由(中间件)\n监听端口\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 1. 引入express包\nconst express &#x3D; require(&#39;express&#39;)\n&#x2F;&#x2F; 2. 实例化对象\nconst app &#x3D; express()\n&#x2F;&#x2F; 3. 编写路由\napp.get(&#39;&#x2F;&#39;, function(req, res) &#123;\n  res.send(&#39;hello world&#39;)\n&#125;)\n&#x2F;&#x2F; 4. 监听端口\napp.listen(3000)\n\n三. 路由路由模块由三部分组成\n\n请求方式\n\nURL\n\n处理函数\n\n\n路由模块主要方法是 app.METHOD\n\n1 请求方式请求方式就是HTTP协议的请求方式, 常见的有\n\nget: 对应app.get()\npost: 对应app.post()\nput: 对应app.put()\ndelete: 对应app.delete()\n\n2 URLURL的写法\n&#x2F;&#x2F; 第一种, 不带参数\napp.get(&#39;&#x2F;users&#39;, function(req, res) &#123;\n  res.send(&#39;hello world&#39;)\n&#125;)\n&#x2F;&#x2F; 第二种, 带参数\napp.get(&#39;&#x2F;users&#x2F;:id&#39;, function(req, res) &#123;\n  res.send(&#39;hello world&#39;)\n&#125;)\n&#x2F;&#x2F; 第三种, 正则表达式, 以html结尾\napp.get(&#x2F;.html$&#x2F;, function(req, res) &#123;\n  res.send(&#39;hello world&#39;)\n&#125;)\n\n3 处理函数\n\n\n\n\n\n\n\n\n语法\nfunction(req, res, next) &#123;\n  &#x2F;&#x2F; todo\n&#125;\n\n在处理函数中, 有两个形参\n\nreq(请求对象)\n res(响应对象)\n\n1) 请求对象请求对象包含了一次请求中的所有数据(http请求头, 请求参数…)\n\n\n\n\n\n\n\n\n\n示例\napp.get(&#39;&#x2F;&#39;, function (req, res) &#123;\n  console.log(req)\n&#125;)\n\n2) 获取请求参数\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; get请求\nreq.query.参数名\n\n\n\n\n\n\n\n\n\n\n示例: get请求\n&#x2F;&#x2F; 如果url是: &#x2F;users&#x2F;1, 通过params获取\napp.get(&#39;&#x2F;users&#x2F;:id&#39;, function(req, res) &#123;\n  res.send(req.params.id)\n&#125;)\n\n&#x2F;&#x2F; 如果url是: &#x2F;users?id&#x3D;1, 通过query获取\napp.get(&#39;&#x2F;users&#39;, function(req, res) &#123;\n  res.send(req.query.id)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n示例: post请求\n&#x2F;&#x2F; 1. 导入express包\nconst express &#x3D; require(&#39;express&#39;)\n&#x2F;&#x2F; 2. 实例化对象\nconst app &#x3D; express() &#x2F;&#x2F; app是一个对象\n\n&#x2F;&#x2F; 3. 编写路由(中间件)\napp.post(&#39;&#x2F;&#39;, function(req, res) &#123;\n  let postData &#x3D; &#39;&#39;\n  req.on(&#39;data&#39;, data &#x3D;&gt; postData +&#x3D; data)\n  req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n    res.send(JSON.parse(postData))\n  &#125;)\n&#125;)\n\n&#x2F;&#x2F; 4. 监听端口\napp.listen(3000, function () &#123;\n  console.log(&#39;server is running on http:&#x2F;&#x2F;localhost:3000&#39;)\n&#125;)\n\n根据id查找对应的数据并返回\n编写post.http\nPOST http:&#x2F;&#x2F;localhost:3000&#x2F;\nContent-Type: application&#x2F;json\n\n&#123;\n\t&quot;name&quot;: &quot;xiaoming&quot;\n&#125;\n\n3) 响应对象响应对象用于向客户端返回数据, 在处理函数中需要调用以返回数据\n\n常用的有两个\n\nres.send(): 返回各种类型\nres.json(): 返回json格式的数据\n\n四. 中间件1 中间件类型\n2 应用级中间件在Express中, 使用app.use或者app.METHOD注册的中间件叫做应用级中间件\n中间件就是一个函数\napp.use(&#39;path&#39;, function (req, res, next) &#123;\n  next()\n&#125;)\n\n\n\n\n\n\n\n\n\n\n注意\n在中间件中需要通过调用next()执行下一个中间件\n如果不执行next(), 也没有调用send(). 这次请求将会被挂起\n\n\n\n\n\n\n\n\n\n示例一\n&#x2F;&#x2F; 不写第一个参数, 给所有访问都注册了一个中间件\napp.use(function (req, res, next) &#123;\n  console.log(&#39;Time:&#39;, Date.now())\n  next()\n&#125;)\n\n\n\n\n\n\n\n\n\n\n示例二\napp.use(&#39;&#x2F;user&#x2F;:id&#39;, function (req, res, next) &#123;\n  console.log(&#39;Request Type:&#39;, req.method)\n  next()\n&#125;)\n\napp.get(&#39;&#x2F;user&#x2F;:id&#39;, function (req, res, next) &#123;\n  res.send(&#39;USER&#39;)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n示例三\n可以同时注册多个中间件函数\napp.use(&#39;&#x2F;user&#x2F;:id&#39;, function (req, res, next) &#123;\n  console.log(&#39;Request Type:&#39;, req.method)\n  next()\n&#125;, function (req, res, next) &#123;\n  console.log(&#39;Request Params:&#39;, req.params.id)\n  next()\n&#125;)\n\napp.get(&#39;&#x2F;user&#x2F;:id&#39;, function (req, res, next) &#123;\n  res.send(&#39;USER&#39;)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n示例四\napp.use除了注册函数做为中间件外, 还可注册一个express.Router()对象\nconst router &#x3D; express.Router()\napp.use(&#39;&#x2F;user&#x2F;:id&#39;, router)\n\n3 路由级中间件express.Router()对象也可以注册中间件.\n使用router.use或者router.METHOD注册的中间件叫做路由级中间件\nvar app &#x3D; express()\nvar router &#x3D; express.Router()\n\nrouter.use(function (req, res, next) &#123;\n  console.log(&#39;Time:&#39;, Date.now())\n  next()\n&#125;)\nrouter.get(&#39;&#x2F;users&#x2F;&#39;, function(req, res) &#123;\n  res.send(&#39;hello&#39;)\n&#125;)\n\n路由级中间件的应用\n当路由很多的时候, 如果全部写在app入口会使用文件过大, 不好维护. 可以把不同的路由拆分成多个模块\napp.js\nconst express &#x3D; require(&#39;express&#39;)\nconst userRouter &#x3D; require(&#39;.&#x2F;routes&#x2F;users.js&#39;)\n\nconst app &#x3D; express()\napp.use(function (req, res, next) &#123;\n  console.log(req.url)\n  next()\n&#125;)\n&#x2F;&#x2F; 加载路由\napp.use(&#39;&#x2F;users&#39;, userRouter)\n\napp.listen(3000)\n\nrouters/users.js\nconst express &#x3D; require(&#39;express&#39;)\n\nconst router &#x3D; express.Router()\n\nrouter.get(&#39;&#x2F;&#39;, function(req, res) &#123;\n  &#x2F;&#x2F; 返回所有用户信息\n  const data &#x3D; [\n    &#123;id:1, username: &#39;xiaoming&#39;, age: 20&#125;,\n    &#123;id:2, username: &#39;xiaomei&#39;, age: 18&#125;,\n    &#123;id:3, username: &#39;xiaopang&#39;, age: 1&#125;,\n  ]\n  res.json(data)\n&#125;)\n\nrouter.get(&#39;&#x2F;:id&#39;, function(req, res) &#123;\n  &#x2F;&#x2F; 返回所有用户信息\n  const user &#x3D; &#123;id:1, username: &#39;xiaoming&#39;, age: 20&#125;\n  res.json(user)\n&#125;)\n\nmodule.exports &#x3D; router\n\n\n\n五. 数据库操作1 安装mysql库npm i mysql\n\n2 入门案例操作数据库, 就是模拟客户端. 向MySQL的服务端发送SQL语句. 基本步骤如下:\n\n引入mysql包\n创建数据库连接\n连接数据库\n执行SQL查询\n关闭连接\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 1. 引入mysql包\nconst mysql &#x3D; require(&#39;mysql&#39;)\n\n&#x2F;&#x2F; 2. 创建数据库连接\nconst con &#x3D; mysql.createConnection(&#123;\n  host: &#39;localhost&#39;,\n  user: &#39;root&#39;,\n  password: &#39;123456&#39;,\n  database: &#39;db&#39;\n&#125;)\n\n&#x2F;&#x2F; 3. 连接数据库\ncon.connect()\n\n&#x2F;&#x2F; 4. 执行查询\ncon.query(&#39;select * from student&#39;, function (err, res) &#123;\n  if (err) throw err\n\n  console.log(res)\n&#125;)\n\n&#x2F;&#x2F; 5. 关闭连接\ncon.end()\n\n\n\n3 封装mysql","slug":"Express","date":"2022-12-01T13:58:51.651Z","categories_index":"后端","tags_index":"express","author_index":"团子"},{"id":"8a078447816c8261f3fa2174ce069557","title":"API接口文档","content":"API 接口文档API 接口说明\n  接口基准地址：http://localhost:3000\n  或者接口基准地址: http://www.brojie.cn:5051/api/v1或者http://api.brojie.cn:5051/v1\n  使用 HTTP Status Code 标识状态\n  数据返回格式统一使用 JSON\n\n支持的请求方法\n  GET（SELECT）：从服务器取出资源（一项或多项）。\n  POST（CREATE）：在服务器新建一个资源。\n  PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\n  DELETE（DELETE）：从服务器删除资源。\n\n通用返回状态说明\n\n\n状态码\n含义\n说明\n\n\n\n200\nOK\n请求成功\n\n\n201\nCREATED\n创建成功\n\n\n204\nDELETED\n删除成功\n\n\n400\nBAD REQUEST\n请求的地址不存在或者包含不支持的参数\n\n\n401\nUNAUTHORIZED\n未授权\n\n\n403\nFORBIDDEN\n被禁止访问\n\n\n404\nNOT FOUND\n请求的资源不存在\n\n\n422\nUnprocesable entity\n[POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误\n\n\n500\nINTERNAL SERVER ERROR\n内部错误\n\n\n\n\n\n\n\n\n用户管理用户数据列表\n请求路径：http://localhost:3000/users\n请求方法：get\n响应参数\n\n\n\n\n参数名\n参数说明\n备注\n\n\n\nid\nid\n不必须\n\n\nname\n用户名\n不必须\n\n\nage\n年龄\n不必须\n\n\n\n响应状态码\n\n\n参数名\n参数说明\n备注\n\n\n\nstatus\n响应码\n200: 成功\n\n\n\n\n\n响应数据\n\n[\n  &#123;\n    &quot;name&quot;: &quot;鸣人&quot;,\n    &quot;age&quot;: &quot;12&quot;,\n    &quot;id&quot;: 1\n  &#125;,\n  &#123;\n    &quot;id&quot;: 2,\n    &quot;name&quot;: &quot;佐助&quot;,\n    &quot;age&quot;: 11\n  &#125;,\n  &#123;\n    &quot;id&quot;: 3,\n    &quot;name&quot;: &quot;自来也&quot;,\n    &quot;age&quot;: 52\n  &#125;,\n  &#123;\n    &quot;id&quot;: 4,\n    &quot;name&quot;: &quot;卡卡西&quot;,\n    &quot;age&quot;: 28\n  &#125;\n]\n\n添加用户\n请求路径：http://localhost:3000/users\n请求方法：post\n请求参数\n\n\n\n\n参数名\n参数说明\n备注\n\n\n\nname\n用户名称\n不能为空\n\n\nage\n用户年龄\n不能为空\n\n\n\n响应参数\n\n\n\n\n参数名\n参数说明\n备注\n\n\n\nid\n用户 ID\n\n\n\nname\n用户名\n\n\n\nage\n年龄\n\n\n\n\n响应状态码\n\n\n\n参数名\n参数说明\n备注\n\n\n\nstatus\n响应码\n201: 成功\n\n\n\n响应数据\n\n\n&#123;\n  &quot;name&quot;: &quot;xiaoming&quot;,\n  &quot;age&quot;: &quot;20&quot;,\n  &quot;id&quot;: 5\n&#125;\n\n\n编辑用户\n请求路径：users/:id\n请求方法：put\n请求参数\n\n\n\n\n参数名\n参数说明\n备注\n\n\n\nid\n用户 id\n不能为空 参数是url参数:id\n\n\n\n响应参数\n\n\n\n\n参数名\n参数说明\n备注\n\n\n\nid\n用户 ID\n\n\n\nname\n用户名\n\n\n\nage\n年龄\n\n\n\n\n响应数据\n\n&#x2F;&#x2F; 200表示成功 404表示失败\n&#123;\n  &quot;name&quot;: &quot;xiaoming&quot;,\n  &quot;age&quot;: &quot;20&quot;,\n  &quot;id&quot;: 5\n&#125;\n\n删除用户\n请求路径：users/:id\n请求方法：delete\n请求参数\n\n\n\n\n参数名\n参数说明\n备注\n\n\n\nid\n用户 id\n不能为空参数是url参数:id\n\n\n\n响应参数\n\n响应数据\n\n\n&#x2F;&#x2F; 200 表示成功 404表示失败\n&#123;\n&#125;","slug":"API 接口文档","date":"2022-12-01T13:57:09.488Z","categories_index":"后端","tags_index":"api","author_index":"团子"},{"id":"d9294510272c3f8944ed00db23e606c1","title":"ajax","content":"一. 什么是AJAX1 概念\n\n\n\n\n\n\n\n\nAsynchronous  Javascript  And  Xml (异步javascript和xml)\nAJAX 不是新的编程语言，而是一种使用现有标准的新方法\nAJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容\n这里的xml是一种数据格式, 现在更多的使用json数据格式\n现在, 一般用作前后端分离的数据解决方案.\n2 同步和异步\n\n\n\n\n\n\n\n\n同步: 同一时间只能做一件事. 阻塞式\n服务端在处理时, 客户端只能等待\n\n\n\n\n\n\n\n\n\n\n异步: 同一时间可以处理多件事, 非阻塞\n\n3 使用场景\nbaidu地图\nbaidu联想搜索\n接口编程\n\n二. 原生Ajax的使用在浏览器中, 可以通过创建XMLHttpRequest对象来使用ajax.一般步骤如下:\n\n创建XMLHttpRequest对象\n设置请求方式\n发送请求\n获取响应数据, 处理返回结果\n\n1 发送get请求1) 入门案例\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n      &#x2F;&#x2F; 1.创建ajax对象\n      var xhr &#x3D; new XMLHttpRequest()\n      &#x2F;&#x2F; 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求\n      &#x2F;&#x2F; 1)请求方式 2)请求地址\n      xhr.open(&#39;get&#39;, &#39;.&#x2F;test.txt&#39;)\n      &#x2F;&#x2F; 3.发送请求\n      xhr.send()\n      &#x2F;&#x2F; 4.获取服务器端响应到客户端的数据\n      xhr.onload &#x3D; function () &#123;\n        console.log(xhr.responseText)\n      &#125;\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2) 处理json数据&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n      &#x2F;&#x2F; 1.创建ajax对象\n      var xhr &#x3D; new XMLHttpRequest()\n      &#x2F;&#x2F; 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求\n      &#x2F;&#x2F; 1)请求方式 2)请求地址\n      xhr.open(&#39;get&#39;, &#39;.&#x2F;test.json&#39;)\n      &#x2F;&#x2F; 3.发送请求\n      xhr.send()\n      &#x2F;&#x2F; 4.获取服务器端响应到客户端的数据\n      xhr.onload &#x3D; function () &#123;\n        &#x2F;&#x2F; 将返回的数据转换成json格式\n        var data &#x3D; JSON.parse(xhr.responseText)\n        console.log(data)\n      &#125;\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3) 处理带参数的get请求之前, 我们都是直接获取一个文件. \n现在我们请求一个URL地址. 做前后端分离\n\n\n\n\n\n\n\n\n\n什么是前后端分离\n前端通过请求一个URL地址向后端请求数据, 后端处理对应的URL请求返回指定格式的数据\n\n前端可以专心的做数据展示\n后端专心的做数据逻辑处理\n前后端通过URL交换数据, 这个URL就是数据接口API\n\n\n\n\n\n\n\n\n\n\n使用json-server\n这里, 我们先使用一个工具json-server来做为简易的服务端\n第一步: 使用npm i json-server -g全局安装\n第二步: 新建一个data.json做为数据源\ndata.json如下\n&#123;\n  &quot;users&quot;: [\n    &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;xiaoming&quot;, &quot;age&quot;: 20&#125;,\n    &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;xiaomei&quot;, &quot;age&quot;: 18&#125;,\n    &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;xiaopang&quot;, &quot;age&quot;: 1&#125;\n  ]\n&#125;\n\n第三步: 启动服务端\njson-server -w data.json\n\n会在localhost:3000端口启动一个Restful服务\n如果前端请求’localhost:3000/users?id=1’时\n相当于发送一个get请求, 并携带id=1的参数, 表示前端想获取id=1的用户信息\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n      &#x2F;&#x2F; 1.创建ajax对象\n      var xhr &#x3D; new XMLHttpRequest()\n      &#x2F;&#x2F; 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求\n      &#x2F;&#x2F; 1)请求方式 2)请求地址\n      &#x2F;&#x2F; get请求的参数写在URL中\n      xhr.open(&#39;get&#39;, &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users?id&#x3D;1&#39;)\n      &#x2F;&#x2F; 3.发送请求\n      xhr.send()\n      &#x2F;&#x2F; 4.获取服务器端响应到客户端的数据\n      xhr.onload &#x3D; function () &#123;\n        var data &#x3D; JSON.parse(xhr.responseText)\n        console.log(data)\n      &#125;\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2 发送post请求&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    用户名: &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; &#x2F;&gt; \n    年龄: &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;age&quot; &#x2F;&gt;\n    &lt;button id&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt;\n    \n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n      var btn &#x3D; document.getElementById(&#39;submit&#39;)\n      var username &#x3D; document.getElementById(&#39;name&#39;).value\n      var age &#x3D; document.getElementById(&#39;age&#39;).value\n\n      btn.addEventListener(&#39;click&#39;, function () &#123;\n        &#x2F;&#x2F; 1.创建ajax对象\n        var xhr &#x3D; new XMLHttpRequest()\n        &#x2F;&#x2F; 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求\n        &#x2F;&#x2F; 1)请求方式 2)请求地址\n        xhr.open(&#39;post&#39;, &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;)\n        &#x2F;&#x2F; 设置请求头\n        xhr.setRequestHeader(&#39;content-type&#39;, &#39;application&#x2F;json&#39;)\n        &#x2F;&#x2F; 3.发送请求\n        var params &#x3D; &#123; name: username, age: age &#125;\n        xhr.send(JSON.stringify(params))\n        &#x2F;&#x2F; 4.获取服务器端响应到客户端的数据\n        xhr.onload &#x3D; function () &#123;\n          var data &#x3D; JSON.parse(xhr.responseText)\n          console.log(data)\n        &#125;\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n如果使用form格式, 请求头需要设置为application/x-www-form-urlencoded\n\n\n\n\n\n\n\n\n\n示例\nvar params &#x3D; &#39;name&#x3D;&#39;+ username +&#39;&amp;age&#x3D;&#39; + age;\n&#x2F;&#x2F; 配置ajax对象\nxhr.open(&#39;post&#39;, &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;);\n&#x2F;&#x2F; 设置请求参数格式的类型（post请求必须要设置）\nxhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application&#x2F;x-www-form-urlencoded&#39;);\n&#x2F;&#x2F; 发送请求\nxhr.send(params);\n\n使用键值对的方式发送数据\n三. jQuery中的Ajax1 $.ajax()方法jQuery提供了方便的方式, 封装了ajax请求的方法\n\n\n\n\n\n\n\n\n\n语法\n$.ajax(&#123;\n  url: &#39;请求地址&#39;,\n  type: &#39;GET&#x2F;POST&#39;,&#x2F;&#x2F; 请求类型\n  data: &#123;&#125;, &#x2F;&#x2F; 请求参数\n  dataType: &#39;json&#39;, &#x2F;&#x2F; 返回的数据格式\n  success: function (res) &#123;&#125;, &#x2F;&#x2F; 成功的回调\n  error: function(err) &#123;&#125; &#x2F;&#x2F; 出错的回调\n&#125;)\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n      $.ajax(&#123;\n        url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;,\n        data: &#123; id: 1 &#125;,\n        dataType: &#39;json&#39;,\n        success: function (res) &#123;\n          console.log(res)\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\njQuery中的默认的content-type是x-www-form-urlencoded\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    用户名: &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; &#x2F;&gt; 年龄: &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;age&quot; &#x2F;&gt;\n    &lt;button id&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n      $(&#39;#submit&#39;).click(function () &#123;\n        var name &#x3D; $(&#39;#name&#39;).val()\n        var age &#x3D; $(&#39;#age&#39;).val()\n\n        $.ajax(&#123;\n          url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;,\n          type: &#39;post&#39;,\n          data: &#123; name: name, age: age &#125;,\n          dataType: &#39;json&#39;,\n          success: function (res) &#123;\n            console.log(res)\n          &#125;,\n        &#125;)\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n2 $.get()方法$.get()是发送get请求的简写方式\n\n\n\n\n\n\n\n\n\n语法\n$.get(&quot;url&quot;, &#123;params&#125;, callback)\n\n\n\n\n\n\n\n\n\n\n示例\n$.get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;, &#123;id: 1&#125;, function(res) &#123;\n  console.log(res)\n&#125;)\n\n3 $.post()方法$.post()是发送post请求的简写方式\n\n\n\n\n\n\n\n\n\n语法\n$.post(&quot;url&quot;, &#123;params&#125;, callback)\n\n\n\n\n\n\n\n\n\n\n示例\n$.post(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;, &#123;name: &#39;xxp&#39;, age: 1&#125;, function(res) &#123;\n  console.log(res)\n&#125;)\n\n四. 跨域请求1 什么是跨域请求当从一个域A向另一个域B发送请求时, 就叫做跨域请求\n这里的域指的是这样的一个概念：协议 + 域名 + 端口号均相同，那么就是同一个域.\n如: \n\nhttp://localhost:8080 请求https://localhost:8080是跨域请求, 协议不同\nhttp://localhost:8080 请求http://www.baidu.com是跨域请求, 域名不同\nhttp://localhost:8080 请求http://localhost:3000/users是跨域请求, 端口不同\n\n2 跨域请求的问题由于浏览器同源策略的限制, 浏览器是不允许发送跨域请求的.\n但是, 我们做前后端分离, 前端和后端通常是不在同一个域.如\n前端运行在http://localhost:5500 \n后端运行在http://localhost:3000 \n3 模拟跨域请求后端\n&#x2F;&#x2F; 引入http核心模块\nvar http &#x3D; require(&#39;http&#39;)\n\n&#x2F;&#x2F; 引入url核心模块\nvar url &#x3D; require(&#39;url&#39;)\n\n&#x2F;&#x2F; 创建web服务器\nvar server &#x3D; http.createServer()\n\n&#x2F;&#x2F; 处理请求\nserver.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 设置响应头\n  res.writeHead(&#39;200&#39;, &#123;\n    &#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf-8&#39;,\n  &#125;)\n\n  &#x2F;&#x2F; 分析路由\n  var data &#x3D; url.parse(req.url, true)\n  var pathname &#x3D; data.pathname\n  var query &#x3D; data.query\n\n  if (pathname &#x3D;&#x3D; &#39;&#x2F;&#39; || pathname &#x3D;&#x3D; &#39;&#x2F;index&#39;) &#123;\n    &#x2F;&#x2F; 处理get请求\n    if (req.method &#x3D;&#x3D; &#39;GET&#39;) &#123;\n      &#x2F;&#x2F; 打印在后端控制台\n      console.log(query)\n      &#x2F;&#x2F; 返回给浏览器\n      res.end(query.username)\n    &#125;\n  &#125; else if (pathname &#x3D;&#x3D; &#39;&#x2F;users&#39;) &#123;\n    res.end(JSON.stringify(&#123; name: &#39;xxp&#39;, age: 1 &#125;))\n  &#125; else &#123;\n    res.writeHead(&#39;404&#39;)\n    res.end(&#39;Not Found&#39;)\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; 监听3000端口\nserver.listen(3000)\n\nconsole.log(&#39;server is running on localhost:3000&#39;)\n\n\n前端\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n      $.ajax(&#123;\n        url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;,\n        data: &#123; id: 1 &#125;,\n        dataType: &#39;json&#39;,\n        success: function (res) &#123;\n          console.log(res)\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n\n演示\n\n4 如何解决跨域问题目前, 最主流的方式是CORS, 通过在服务端设置响应头, 允许跨域请求\n跨源资源共享 Cross-Origin Resource Sharing(CORS) 是一个新的 W3C 标准，它新增的一组HTTP首部字段，允许服务端其声明哪些源站有权限访问哪些资源。换言之，它允许浏览器向声明了 CORS 的跨域服务器，发出 XMLHttpReuest 请求，从而克服 Ajax 只能同源使用的限制\n配置上非常简单, 只需要在后端设置响应头即可\n&#x2F;&#x2F; 设置响应头\nres.writeHead(&#39;200&#39;, &#123;\n  &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,\n&#125;)\n\n上述代码表示允许所有域名的跨域请求. 更多设置, 参考: 知乎-跨域请求的四种方案\n\n\n\n\n\n\n\n\n\n扩展\n为什么使用json-server的时候没有出问题?\njson-server默认是允许跨域请求的\n\n","slug":"ajax","date":"2022-12-01T13:55:44.684Z","categories_index":"后端","tags_index":"ajax","author_index":"团子"},{"id":"6bf0818317072d9a48cc178884cabdd5","title":"27_接口编程_ajax_express入门","content":"昨日回顾一,基础的web服务器\n\t1,导模块\n\t2,创建服务器\n\t3,绑定请求事件\n\t4,设置端口监听\n\n二,解决中文乱码\n\t res.setHeader(&#39;content-type&#39;,&#39;text&#x2F;html;charset&#x3D;utf-8&#39;)\n\n三,根据不同url响应不同的数据\n\t获取请求路径\n\t\t const &#123;pathname&#125; &#x3D; url.parse(req.url,true)\n\t\t \n四,获取get请求的参数\n\tconst &#123;pathname,query&#125; &#x3D; url.parse(req.url,true)\n\t\n五,获取post请求的参数\n\t let postData &#x3D; &#39;&#39;\n     req.on(&#39;data&#39;,data &#x3D;&gt; &#123; postData +&#x3D; data&#125;)\n     req.on(&#39;end&#39;,()&#x3D;&gt;&#123;\n          console.log(postData);&#x2F;&#x2F;username&#x3D;zhangsan&amp;password&#x3D;123\n           &#x2F;&#x2F;使用querystring内置对象解析post请求的数据\n           const obj &#x3D; qs.parse(postData)\n           console.log(obj);&#x2F;&#x2F;&#123; username: &#39;zhangsan&#39;, password: &#39;123&#39; &#125;\n                \n           &#125;)\n           \n六,用promise封装 获取post请求参数的过程 \n     function getPostData(req)&#123;\n        return new Promise((resolve,reject)&#x3D;&gt;&#123;\n\n            let postData &#x3D; &#39;&#39;\n            req.on(&#39;data&#39;,data &#x3D;&gt; &#123; postData +&#x3D; data&#125;)\n            req.on(&#39;end&#39;,()&#x3D;&gt;&#123;\n                const obj &#x3D; qs.parse(postData)\n                resolve(obj)&#x2F;&#x2F;将obj放在结果属性中,将来调用then方法的时候,就能拿到结果\n            &#125;)\n        &#125;)\n    &#125;\n    \n七,访问静态资源\n\tres.end(fs.readFileSync(相对路径))\n\n\n\n接口编程概念接口概念\n\t其实就是一个规范,比如电脑usb接口,设计好usb的标准之后,做电脑和做外设的,就可以分别生产,生产好之后,直接就可以插上去使用\n\n接口文档概念\n\t就是接口的说明文档,它是我们调用接口(请求后台数据的)的依据\n\t接口文档中包含了对接口的url,参数,以及输出内容的说明\n\t我们参照接口文档,就能方便的知道接口的作用,以及接口是如何调用的\n\n接口编程概念\n\t就是前后端按照约定好的规则(接口文档)进行编程,编好之后进行联调就可以了\n\t具体体现,其实就是http协议中的请求和响应\n\t前端,主要是发送请求(明确 请求的url 和 请求方式 以及 请求参数)\n\t后端,主要是做出响应(明确 响应状态码 和 状态码描述 以及 返回具体的数据)\n\t\n接口编程好处\n\t实现前后端分离,便于协同开发\n\n\n\nrestful接口设计概念\n\t一种接口设计风格,主要用于有客户端和服务端交互的软件\n\t\n接口设计六要素\n\t前端\n\t\t资源路径:请求的url(http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;login)\n\t\tHTTP动词:请求方式(get)\n\t\t过滤信息:请求参数(username&#x3D;zhangsan&amp;password&#x3D;123)\n\t后台\n\t\t状态码(status-code):登录成功:200\n\t\t错误信息(error):服务器内部错误\n\t\t返回结果(date或者result):返回登录用户相关信息\n\t\t\n常用的HTTP动词\n\tGET:获取资源(一个或者多个)  --获取所有图书列表,获取单个图书信息\n\tPOST:新增资源             --添加一个图书\n\tPUT:修改资源              --修改某一个图书的信息\n\tDELETE:删除资源           --删除某一个图书\n\n\n\nrestful接口体验json-server概念\n\t一个快速成形的RESTful接口服务工具, 使用json-server可以快速的搭建一个RESTful服务端\n\t\n搭建服务端\n\t1,安装json-server软件(npm i json-server -g) \n\t2,创建一个data.json作为数据源\n\t3,启动服务端(json-server -w data.json)\n\t\n模拟前端(发送Restful风格的请求)\n\t查询\n\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;users 查询所有\n\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;users?id&#x3D;1 查询一个\n\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1  查询一个\n\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;users?id&#x3D;1&amp;id&#x3D;2  查询多个\n\n\t新增\n\t\tPOST http:&#x2F;&#x2F;localhost:3000&#x2F;users  需要加上请求体\n\n\t修改\n\t\tPUT http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1 需要加上请求体\n\n\t删除\n\t\tDELETE http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1 \n\nAJAX概念概念\n\t异步的js和xml技术(网络通讯中xml已经被json替换了)\n\t\n\t描述一个用户\n\t\txml方式\n\t\t\t&lt;user&gt;\n\t\t\t\t&lt;username&gt;张三&lt;&#x2F;username&gt;\n\t\t\t\t&lt;password&gt;123&lt;&#x2F;password&gt;\n\t\t\t&lt;&#x2F;user&gt;\n\t\tjson\n\t\t\t&#123;&quot;username&quot;:&quot;张三&quot;,&quot;password&quot;:&quot;123&quot;&#125;\n\n作用\n\t1,实现网页和服务器间的数据交换(请求后台数据)\n\t2,在不刷新整个页面的基础上,更新部分网页内容(局部刷新)\n\t3,一般作为前后端分离中请求后台数据的解决方案\n\t\n同步和异步\n\t同步:同一时间,只能做一件事情,阻塞式\n\t异步:同一时间,可以做多件事情,非阻塞式的(多线程的)\n\t\n应用场景\n\t百度注册(失去焦点的时候校验用户是否被注册)\n\t百度搜索框(根据用户的输入提示不同信息)\n\t百度地图(按需加载)\n\n原生的ajax使用XMLHttpRequest对象来发送请求,但是有兼容性问题\n\n&#x2F;&#x2F;1,创建ajax对象\nconst xhr &#x3D; new XMLHttpRequest()\n&#x2F;&#x2F;2,设置请求方式和url\nxhr.open(&#39;get&#39;,&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;2&#39;)\n&#x2F;&#x2F;3,发送请求\nxhr.send()\n&#x2F;&#x2F;4,设置回调函数\nxhr.onload &#x3D; function()&#123;\n\tconsole.log(xhr.responseText);\n&#125;\n\nconsole.log(&#39;执行结束.....&#39;);\n\n\n\njquery的ajax通用格式\n\t$.ajax(&#123;\n\t\turl:&#39;&#39;,&#x2F;&#x2F;请求的地址\n\t\ttype:&#39;&#39;,&#x2F;&#x2F;请求方式\n\t\tdata:&#123;&#125;,请求的参数\n\t\tdataType:&#39;&#39;,&#x2F;&#x2F;返回的数据格式(默认是json,可以不用写)\n\t\tsuccess:function(res)&#123;&#125;,&#x2F;&#x2F;成功的回调函数\n\t\terror:function(err)&#123;&#125;,&#x2F;&#x2F;失败的回调函数\n\t&#125;)\n\t\nget简化方式\n\t$.get(url, [data], [callback], [type])   后面3个参数是可选的\n        url:待载入页面的URL地址\n        data:待发送 Key&#x2F;value 参数。\n        callback:载入成功时回调函数。\n        type:返回内容格式，xml, html, script, json, text, _default\n        \n \npost简化方式\n\t$.post(url, [data], [callback], [type])   后面3个参数是可选的\n        url:待载入页面的URL地址\n        data:待发送 Key&#x2F;value 参数。\n        callback:载入成功时回调函数。\n        type:返回内容格式，xml, html, script, json, text, _default\t\n\n\n\nExpress简介概念\n\tExpress 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。\n\t\n本质\n\t对之前的内置模块http进行了封装,使用起来更加的方便\n\t\n核心\n\t可以设置中间件来响应 HTTP 请求。\n\t定义了路由表用于执行不同的 HTTP 请求动作\n\t\n核心概念\n\t路由\n\t\t根据不同的url路径,调用后台不同的处理函数\n\t中间件\n\t\t从请求开始到响应结束这个业务流程中的所有中间处理环节\n\n安装及使用安装\n\t新建一个英文的目录(目录名不要用express或express开头)\n\t进入这个目录,进行初始化(其实是生成了一个package.json配置文件)\n\t安装express,使用npm i express命令 \n使用\n\t1,导入express包\n\t2,实例化express对象\n\t3,处理请求\n\t4,设置端口监听\n\t\n区别(跟之前用http创建web服务的区别)\n\t1,不需要处理乱码问题\n\t2,不需要判断请求方式\n\t\n\tres.send() 和 res.end()区别\n\t\tend:其实原生的http模块中的方法,express也支持,只能传字符串,不能处理乱码问题\n\t\tsend:express中封装的方法,可以传任意类型,并且可以处理乱码问题\n\nexpress路由概念\n\t根据不同的url路径,调用后台不同的处理函数\n\t\n语法\n\tapp.请求方式(访问路径,处理函数)\n\t\t请求方式:get,post,put,delete,常用的是前两个\n\t\t访问路径:也可以正则(* 通配符)\n\t\t处理函数:匿名函数,匹配到不同路径,就会执行\n注意事项\n\t1,匹配顺序:从上到下\n\t2,只有请求方式和访问路径,同时匹配成功,express才会将这次请求转移到对应的处理函数处理\n\n","slug":"day27_课堂笔记","date":"2022-12-01T13:54:02.386Z","categories_index":"后端","tags_index":"","author_index":"团子"},{"id":"7602872111d99ce5490d2dd6567dd4a3","title":"28_express增删改查","content":"昨日回顾接口编程\n\t接口\n    \t规范,定义前后端交互的规范\n\t接口编程\n    \t前后端按照约定好的规则(接口文档中)进行编程.\nrestful\n\t概念\n    \t一种接口设计风格\n     六要素\n     \t前端\n        \t访问路径\n            请求方式\n            \tget 获取\n                post 新增\n                put 修改\n                delete 删除\n            请求参数\n        后端\n        \t状态码和描述\n            错误信息\n            返回数据\n            \n     具体的请求\n     \t查询\n\t\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;goods\n\t\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;goods&#x2F;1\n     \t新增\n        \tPOST http:&#x2F;&#x2F;localhost:3000&#x2F;good  \n\t\t\tname&#x3D;xiaomi&amp;price&#x3D;1999\n     \t修改\n        \tPUT http:&#x2F;&#x2F;localhost:3000&#x2F;good&#x2F;2  \n\t\t\tname&#x3D;xiaomi&amp;price&#x3D;1999\n     \t删除\n        \tDELETE http:&#x2F;&#x2F;localhost:3000&#x2F;goods&#x2F;2\n      \najax\n\t概念\n    \t异步的js和xml技术\n    作用\n    \t请求后台数据,异步刷新\t\n\t使用\n    \t原生的ajax\n        \t使用xmlhttpRequest对象\n        jquery的ajax\n        \t通用方式\n            \t$.ajax(&#123;\n                    url:请求路径\n                    type:请求方式\n                    data:请求参数\n                    dataType:返回的数据格式(默认是json)\n\t\t\t\t\tsuccess:function(res)&#123;&#125; &#x2F;&#x2F;成功\n\t\t\t\t\terror:function(err)&#123;&#125; &#x2F;&#x2F;失败\n                &#125;)\n            简化方式\n            \t$.get(访问路径,请求参数,回调函数)\n\t\t\t\t$.post(访问路径,请求参数,回调函数)\n\nexpress\n\t概念\n    \t基于nodejs的第三方框架,快速搭建一个完整功能的网站\n\t特性\n    \t路由\n        \t根据不同url路径和请求方式,调用后台不同的处理函数\n\t\t中间件\n        \t从请求到响应中间的所有处理环节\n    安装\n    \t初始化\n        \tnpm init -y\n\t\t安装\n        \tnpm i express\n        基本使用\n        \t导包\n            实例化对象\n            处理请求\n            设置端口监听\n        简单路由\n        \tapp.请求方式(访问路径,处理函数)\n\t\t\t匹配方式:从上到下\n            只有请求方式和访问路径都匹配才会执行后面的处理函数\n\n跨域请求问题概念\n\t从一个请求跳到另外一个请求,如果这两个请求的协议,域名和端口只要有一个不同,那么这次请求就是跨域请求(演示出错的问题:从5500端口跳到3000报错)\n\n火狐报错提示\n\t已拦截跨源请求：同源策略禁止读取位于 http:&#x2F;&#x2F;localhost:3000&#x2F;users 的远程资源。（原因：CORS 头缺少 &#39;Access-Control-Allow-Origin&#39;）\n\t\n解决方案\n\tres.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;) &#x2F;&#x2F;允许跨域请求\n\n\n\nExpress增删改查查询\n\tget方式  --&gt; app.get()\n\t\n\t查询所有 http:&#x2F;&#x2F;localhost:3000&#x2F;users   后台: &#x2F;users  直接返回数组\n\t查询一个 http:&#x2F;&#x2F;localhost:3000&#x2F;users?id&#x3D;1  后台: &#x2F;users  通过req.query获取参数\n\t查询一个 http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1  后台 &#x2F;users&#x2F;:id  通过req.params获取参数\n\t\n新增\n\tpost方式 --&gt; app.post()\n\t\n\t前台\n\t\thttp:&#x2F;&#x2F;localhost:3000&#x2F;users  application&#x2F;json &#123;&quot;name&quot;:&quot;赵六&quot;,&quot;age&quot;:26&#125;\n\t后台\n\t\t获取请求体数据\n\t\t设置新增用户的id\n\t\t把新增的用户添加到数组\n修改\n\tput方式 --&gt; app.put()\n\t\n\t前台\n\t\thttp:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1  application&#x2F;json &#123;&quot;name&quot;:&quot;赵六&quot;,&quot;age&quot;:26&#125;\n\t后台\n\t\t获取要修改元素的id\n\t\t获取请求体数据\n\t\t查找id相同的元素进行修改\n\t\t\n删除\n\tdelete方式 --&gt; app.delete()\n\t\n\t前台\n\t\thttp:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1\n\t后台\n\t\t获取要修改元素的id\n\t\t查找id相同的元素进行删除\n\n\n\n抽取及中间件简化抽取请求体&#x2F;&#x2F;封装一个中间件函数\n\n&#x2F;&#x2F;抽取获取请求体数据的方法\nfunction getPostData(req,res,next)&#123;\n    &#x2F;&#x2F;解决跨域请求\n    res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)\n\n    &#x2F;&#x2F;监听req的data和end事件\n    let postData &#x3D; &#39;&#39;\n    req.on(&#39;data&#39;,data &#x3D;&gt; postData +&#x3D; data) \n    req.on(&#39;end&#39;,()&#x3D;&gt;&#123; \n            &#x2F;&#x2F;使用JSON解析\n            const obj &#x3D; JSON.parse(postData)\n            \n            &#x2F;&#x2F;解决的第一问题:获取的请求体数据如果传递给下一个函数,使用req对象\n            &#x2F;&#x2F;(在req中自定义一个body属性,来存数据,将来在下一个函数中,就可以通过req.body拿到数据)\n            req.body &#x3D; obj\n\n            &#x2F;&#x2F;解决第二个问题:如果在当前函数中继续调用下一个函数(使用next参数)\n            next() &#x2F;&#x2F;作用:可以把函数的调用移交到下一个处理函数\n         &#125;)\n&#125;\n\n&#x2F;&#x2F;调用中间件函数\napp.post(&#39;&#x2F;users&#39;,getPostData,function(req,res)&#123;\n    \n    &#x2F;&#x2F;获取请求体数据\n    const user &#x3D; req.body\n\n    &#x2F;&#x2F;设置新增用户的id为数组长度+1\n    user.id &#x3D; db.length + 1\n\n    &#x2F;&#x2F;把新增的用户添加到数组\n    db.push(user)\n\n    &#x2F;&#x2F;发送数组给浏览器\n    res.send(db)\n    \n&#125;)\n\n中间件函数概念(middleWare)\n\t特指业务流程的中间处理环节,本质就是一个function处理函数\n\t\n调用流程\n\t当一个请求到达express服务器之后,可以连续调用多个中间件,从而对这次请求进行预处理\n\t\n分类\n\t按照作用范围来分\n\t\t局部生效的中间件\n\t\t全局生效的中间件\n\t按照级别来分\n\t\texpress内置中间件\n\t\texpress第三方中间件\n\t\t应用级中间件\n\t\t路由级中间件\n\t\t\n注意\n\t中间件函数的形参列表中,必须包含next参数\n\t跟之前的路由处理函数不同(路由处理函数只包含req和res参数)\n\tnext作用:实现多个中间件连续调用的关键,表示把流转关系移交到写一个中间件或者处理函数\n\n\n\n中间件的范围划分局部生效的中间件概念\n\t只在某些访问路径中使用的中间件,叫做局部生效的中间件\n举例\n\tgetPostData中间件,只在新增和修改的路由中生效,是局部生效的中间件\n注意\n\t1,一定要在路由之前注册中间件\n\t2,客户端发送过来的请求,可以连续调用多个中间件进行处理\n\t3,执行完中间件的业务代码之后,不要忘记调用next()\n\t4,为了防止代码逻辑混乱,调用next()之后,不要写额外代码\n\t5,连续调用多个中间件,多个中间件之间,共享req和res对象\n\n全局生效的中间件概念\n\t客户端发起的任何请求,到达服务器后,都会触发的中间件,叫做全局生效的中间件\n使用\n\t通常使用 app.use(中间件函数),来定义一个全局生效的中间件\n\n\n\n中间件的级别划分内置中间件概念\n\t由express官方提供的,主要有3个常见的内置中间件\n分类\n\texpress.json\n\t\t解析json格式的请求体数据\n\texpress.urlencoded\n\t\t解析url-encode格式的请求体数据\n\texpress.static\n\t\t快速托管静态资源,可以帮助加载html文件,图片,css样式\n\n第三方中间件概念\n\t由第三方个人或者团体开发的,使用之前需要下载\n分类\n\tcors() 处理跨域请求\n使用\n\tnpm i cors 下载跨域请求的包\n\tconst cors &#x3D; require(&#39;cors&#39;);  导入 cors 包\n\tapp.use(cors())  引入第三方中间件处理跨域请求\n原理\n\t在每一个响应中添加响应头:Access-Control-Allow-Credentials: true\n\n应用级中间件概念\n\t通过app.use(),或者app.get(),app.post()绑定到app实例上的中间件\n注意\n\t应用级中间件,可以是全局生效的,也可以是局部生效的,只不过都要绑定到app上\n\n模块化路由(额外)产生的原因\n\t1,当路由很多的时候,如果全部写在app入口文件,文件就会太大,不好维护\n\t2,项目中有不同类型的请求路径(用户相关,商品相关)都放在一个文件中,不好维护\n\t3,为了方便对路由进行模块化的管理,express不建议将路由直接挂载到app上,而是推荐\n\t\t将路由抽成单独的模块\n\t\t\n使用步骤\n\t1,创建路由模块对应的js文件,放在routes文件夹下\n\t2,调用express.router()创建路由器对象\n\t3,向路由对象上挂载具体的路由\n\t4,使用module.exports向外共享路由对象\n\t5,在入口文件中,使用app.use()注册路由模块\n\n路由级中间件概念\n\t绑定到路由对象(express.router()创建的)的中间件\n注意\n\t路由级中间件用处不是很多,了解一下就行\n\n","slug":"day28_课堂笔记","date":"2022-12-01T13:54:02.386Z","categories_index":"后端","tags_index":"express","author_index":"团子"},{"id":"7bc9d1c1cb8c4ecce97b26cdf0cc3331","title":"26_手写web服务_处理get_post请求参数","content":"昨日回顾内置模块\n\tfs 处理文件\n\t\treadFile()\n\t\twriteFile()\n\tpath 处理路径\n\t\tjoin()\n\thttp 服务器相关\n\t\tcreateServer()\n\t\t\n包(第三方模块)\n\t概念\n\t\t由第三方个人或者团队开发出来的免费模块\n\t作用\n\t\t封装了内置模块,提高效率\n\t使用\n\t\tnpm 包管理工具\n\t\t\tnpm i 包名\n\t\t\tnpm uninstall 包名\n\t\tnrm 镜像管理工具\n\t组成\n\t\tnode-modules \n\t\t\t自定义包名\n\t\t\t\tdist 发布目录\n\t\t\t\t\tindex.js 头文件,引入其他源文件\n\t\t\t\tsrc\n\t\t\t\t\t存放源码\n\t\t\t\tpackage.json 配置文件 (npm init -y)\n\t\t\t\t\tname 包名\n\t\t\t\t\tversion 版本号\n\t\t\t\t\tmain 入口文件\n\t\t手写包步骤\n\t\t\t1,创建包名文件夹\n\t\t\t2,初始化\n\t\t\t3,创建包的目录结构\n\t\t\t\tdist\n\t\t\t\tsrc\n\t\t\t4,创建index.js,修改package.json里面main属性\n\t\t\t5,编写源码\n\t\t\t6,编写index.js\n\t\t导入规则(require(&#39;calc&#39;))\n\t\t\t1,看是不是内置模块\n\t\t\t2,到node-modules找\n\t\t\t3,先找同名文件\n\t\t\t4,再找同名文件夹,如果有,就去package.json里面main属性找入口文件\n\t\t\t5,没有package.json,找index.js\n\t\t\t6,都没有就报错\n\t服务器概念\n\t\t通讯3要素\n\t\t\tip \n\t\t\t端口\n\t\t\t协议\n\t\turl\n\t\t\t统一资源定位符\n\t\t\t协议 域名(ip) 端口 资源路径\n\t\thttp协议\n\t\t\t概念\n\t\t\t\t超文本传输协议\n\t\t\t作用\n\t\t\t\t规定服务器和浏览器传输数据的规范\n\t\t\t请求消息(浏览器传给服务器)\n\t\t\t\t格式\n\t\t\t\t\t请求行\n\t\t\t\t\t\t请求方式 请求的uri 协议版本(可以省略)\n\t\t\t\t\t请求头\n\t\t\t\t\t\t键值对,告诉服务器我浏览器的一些信息\n\t\t\t\t\t\tuser-agent:浏览器的版本型号\n\t\t\t\t\t请求体\n\t\t\t\t\t\t只有在post请求中才有\n\t\t\t响应消息(服务器传给浏览器)\n\t\t\t\t格式\n\t\t\t\t\t响应行\n\t\t\t\t\t\t协议版本 状态码 状态码描述\n\t\t\t\t\t响应头\n\t\t\t\t\t\t键值对,告诉浏览器我服务器的一些信息\n\t\t\t\t\t\tcontent-type 设置发送的数据的格式和编码\n\t\t\t\t\t响应体\n\t\t\t\t\t\t显示在body的正文\n\t\t\t\t\t\t\n\t\t\t请求对象和响应对象\n\t\t\t\trequest对象(req对象)\n\t\t\t\t\t里面封装请求的消息,主要提供获取方法\n\t\t\t\t\t\t获取请求方式 req.method\n\t\t\t\t\t\t获取请求的url req.url\n\t\t\t\tresponse对象(res对象)\n                \t里面就封装了响应消息,主要提供设置方法\n                \t\t设置响应头 res.setHeader()\n                \t\t设置响应体 res.send()\n\t\t\t\n\n手写web服务1,基本的web服务&#x2F;&#x2F;1,导入模块\n&#x2F;&#x2F;2,创建web服务器\n&#x2F;&#x2F;3,绑定事件,处理请求\n&#x2F;&#x2F;4,设置端口,进行监听\n\n2,处理中文乱码产生的原因\n\t前后编码不一致\n\t\t服务器发送数据:使用ISO-8859-1(拉丁文),不支持中文的\n\t\t浏览器接收数据并解析:中文的window使用GBK(国标)\n解决\n\t使用响应对象,设置响应头,统一编码\n\t\tres.setHeader(&#39;content-type&#39;,&#39;text&#x2F;html;charset&#x3D;utf-8&#39;)\n\t\t告诉浏览器我发送数据的格式是utf-8,将来浏览器接收之后,就会以utf-8编码来解析\n\n3,处理路由路由:\n\t根据不同的请求url,响应不同的数据\n\thttp:&#x2F;&#x2F;localhost:3000&#x2F; 或者 http:&#x2F;&#x2F;localhost:3000&#x2F;index  响应首页\n\thttp:&#x2F;&#x2F;localhost:3000&#x2F;list  响应列表页\n\thttp:&#x2F;&#x2F;localhost:3000&#x2F;detail 响应详情页\n\thttp:&#x2F;&#x2F;localhost:3000&#x2F;aaa    页面找不到\n\n思路\n\t1,先通过请求对象req中的url属性,获取到请求的url\n\t2,再通过url的内置模块解析获取出来的url.得到url对象\n\t3,从url对象的 pathname属性中 拿到值\n\t\n\thttp:&#x2F;&#x2F;    localhost   :   3000    &#x2F;detail   ?    id&#x3D;1\n\t 协议\t\t\tip&#x2F;域名        端口     pathname      query\n\t \nurl.parse(urlStr,true) 参数问题\n\t第二个参数是true,得到的url对象如下\n        Url &#123;\n          protocol: null,\n          slashes: null,\n          auth: null,\n          host: null,\n          port: null,\n          hostname: null,\n          hash: null,\n          search: &#39;?id&#x3D;1&#39;,\n          query: [Object: null prototype] &#123; id: &#39;1&#39; &#125;, &#x2F;&#x2F;这里的query的值是对象\n          pathname: &#39;&#x2F;detail&#39;,\n          path: &#39;&#x2F;detail?id&#x3D;1&#39;,\n          href: &#39;&#x2F;detail?id&#x3D;1&#39;\n        &#125;\n        \n    第二个参数是false(默认),得到的url对象如下\n        Url &#123;\n          protocol: null,\n          slashes: null,\n          auth: null,\n          host: null,\n          port: null,\n          hostname: null,\n          hash: null,\n          search: &#39;?id&#x3D;1&#39;,\n          query: &#39;id&#x3D;1&#39;,   &#x2F;&#x2F;这里的query的值是字符串\n          pathname: &#39;&#x2F;detail&#39;,\n          path: &#39;&#x2F;detail?id&#x3D;1&#39;,\n          href: &#39;&#x2F;detail?id&#x3D;1&#39;\n        &#125;\n\n\n\n4,处理get请求数据需求:\n\t假设发送的get请求是 http:&#x2F;&#x2F;localhost:3000&#x2F;detail?id&#x3D;1\n\t 需要获取 url 后面拼接的参数 id &#x3D; 1.\n\t 将来我会通过id&#x3D;1去数据库查询具体的商品数据\n\t \n思路\n\t首先需要判断请求的路径是不是以&#x2F;detail开头的\n\t如果是的话,再判断请求的方式是不是get\n\t如果是的话,解析获取到的url,拿到里面query属性的值\n\t\n应用\n\t查询单个数据的操作(后面会讲)\n\n\n\n5,处理post请求数据需求\n\t模拟登录,一般是post请求(可以安装REST Client 模拟客户端发送post请求)\n\t请求url就是   http:&#x2F;&#x2F;localhost:3000&#x2F;\n\t请求体 就是   username&#x3D;zhangsan&amp;password&#x3D;123\n\t\n\t如何拿到 username和password的值\n\t\n思路\n\t监听request的 date数据变化事件  和 end 数据接收完成 事件\n\t在date事件中进行累加\n\t在end事件中打印最终的数据\n\t\n应用\n\t登录操作,新增操作\n\n\n\n6,封装post请求(Promise)原因\n\t获取post请求的数据,是一个固定写法,将来经常会用到\n\t并且获取请求数据是一个异步的操作,推荐使用promise封装\n\t\n步骤\n\t定义一个方法,方法返回一个promise对象\n\t因为创建promise对象,需要传一个函数\n\t将 要封装的代码 放在 这个函数的函数体里面\n\t将 代码的结果  放在 resolve()方法的参数里面 返回 ,将来调用then方法的时候就能拿到\n\t\n执行流程\n\t调用封装的getPostData(),得到promise对象,\n\t然后调用promise的then方法,通过then方法的第一个函数的参数date.\n\t就可以拿到之前promise对象中函数执行的结果\n\t最后进行打印\n\n\n\n7,处理静态资源需求\n\t当浏览器地址栏输入 http:&#x2F;&#x2F;localhost:3000&#x2F; 或者 http:&#x2F;&#x2F;localhost:3000&#x2F;index\n\t显示新闻首页\n\t\n思路\n\t1,解析请求路径,判断pathname是(&#x2F;或者&#x2F;index)\n\t2,读取public路径下的文件,并返回\n\n\n\nnodemon使用由来\n\t1,之前使用node执行程序,如果文件修改了,都需要重启,效率比较低\n\t2,使用nodemon,相当于node升级版本,可以监控文件的变化,自动进行重启.提高效率\n安装\n\tnpm i nodemon -g 全局安装nodemon\n使用\n\tnodemon 文件路径 启动服务\n\t\n终端启动爆红(没有管理员权限)解决\n\thttps:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43682519&#x2F;article&#x2F;details&#x2F;116788807\n\n\n\n端口占用解决打开cmd\n\t输入 netstat -anno 就可以查看到当前程序运行的端口\n\n\n","slug":"day26_课程笔记","date":"2022-12-01T13:46:15.874Z","categories_index":"后端","tags_index":"http","author_index":"团子"},{"id":"3c7a1f4a7818f7c459334d17943f7066","title":"25_包概念_http协议_请求响应","content":"昨日回顾nodejs\n\t概念\n\t\t提供了js代码的运行环境\n\t\t可以使用它来开发后台\n\t组成\n\t\tECMAScript语法\n\t\t内置模块\n\t\t第三方模块\n模块化编程\n\t概念\n\t\t按照固定的规则,把一个大的js文件拆分成若干个小文件(模块)\n\t好处\n\t\t提高代码的复用性,可维护性,按需加载,便于协同开发\n\t规则\n\t\t导入\n\t\t\trequire()\n\t\t导出\n\t\t\tmodule.exports\n\t\t\t\t和exports混用的时候问题:require()引入的永远是module.exports指向的对象\n分类\n\t内置模块\n\t\tfs,path,http\n\t自定义模块\n\t\t自己创建的js文件\n\t第三方模块\n\t\t第三方开发出来的,用之前需要下载\n作用域\n\t模块中的成员只能在当前模块内部访问,如果想要在外部使用,需要进行导出\n共享问题\n\t使用module.exports和exports都可以进行导出\n\trequire()引入的永远是module.exports指向的对象\n\t在一个模块中,不建议混用,习惯使用module.exports\n\n内置模块\n\tfs模块\n\t\t作用\n\t\t\t处理文件\n\t\t方法\n\t\t\treadFile(路径,编码,回调函数)\n\t\t\twriteFile(路径,数据,回调函数)\n\tpath模块\n\t\t作用\n\t\t\t处理路径的\n\t\t方法\n\t\t\tdirname()\n\t\t\tjoin()\n\t\t\textname()\n\t\t\tbasename()\n\thttp模块\n\t\t作用\n\t\t\t用来搭建web服务器\n\t\t方法\n\t\t\tcreateServer()\n\n\n\n包的操作包的概念来源\n\t跟内置模块和自定义模块不同,是由第三方个人或者团队开发出来的,免费给其他人使用\n\thttps:&#x2F;&#x2F;www.npmjs.com&#x2F;\n好处\n\t包其实是基于内置模块封装出来的,提供了一个更高级,更方便的API,提高了开发效率\n\t包和内置模块的关系,类似jquery和原生js之间的关系\n\nnpm包管理工具概念\n\t是由美国的一家公司提供的,用来管理包的,现在已经被集成到nodejs中\n安装\n\t无需安装.在安装node的时候,已经自动安装了\n查看版本\n\tnpm -v 查看版本号\n安装第三方软件\n\tnpm i 包名              安装包\n\tnpm uninstall 包名      卸载包\n\nnrm镜像管理工具概念\n\t解决国外网速慢的原因,可以使用国内的镜像\n使用\n\tnpm install nrm -g 安装镜像管理工具\n\tnrm ls 列出所有的镜像\n\tnrm use taobao 使用淘宝的镜像\n\npackage规范组成\n\tnode-modules \n\t\t用来存放所有已经安装到本地的包,require导入第三方包的时候,都是从这个目录汇总查找\n\tpackage.json\n\t\t当前包的配置文件,用于记录当前包的下载信息,例如包名,版本号,下载地址\n\t\tname:包名\n\t\tversion:版本\n\t\tmain:包的入口\n规范\n\t1,包必须以单独的目录存在\n\t2,包的顶级目录下必须包含package.json配置文件\n\t3,package.json中必须包含name(包名),version(版本号),main(包的入口)三个属性\n\t\n手写一个包(计算器calc 计算两个数的加减法)\n\t1,创建文件夹\n\t\t在node-modules下创建一个calc文件夹\n\t2,初始化这个文件夹\n\t\t使用cd命令进入calc文件夹\n\t\t使用npm init -y来初始化这个包,会在calc下创建一个package.json的配置文件\n\t3,创建包的目录结构\n\t\t1,创建src文件夹,用于存储源码\n\t\t2,创建dist文件夹,用于发布目录\n\t\t3.在dist文件夹下创建一个index.js文件,就是程序的入口文件\n\t\t4,修改package.json配置文件中的main属性值为&#39;dist&#x2F;index.js&#39;\n\t4,编写源码(src下面)\n\t\t1,在src下创建一个add.js,实现加法,并用module.exports导出\n\t\t2,在src下创建一个sub.js,实现减法,并用module.exports导出\n\t5,编写头文件(dist文件夹下的index.js里面)\n\t\t将源码里面的文件都导入进去,然后module.exports导出\n\t\t这么做的目的是,将来只需要引入头文件,就可以将整个源码中的文件引入\n\t6,使用自定义的calc包\n\t\t1,导入 const calc &#x3D; require(&#39;calc&#39;);\n\t\t2,使用 const m1 &#x3D; calc.add(1,2)\n\t\t\n\t\t\n\n模块加载机制加载步骤\n\t1,nodejs会假设它是一个内置模块  const calc &#x3D; require(&#39;calc&#39;);\n\t2,如果不是内置模块,就会去当前目录下的node_modules中查找\n\t3,首先看有么有该名字的js文件,如果有的话,就加载js文件\n\t4,如果没有该名字的js文件,就看是否有改名字的文件夹\n\t5,查看改文件夹中的package.json中的main选项,确定模块的入口文件\n\t6,如果进入文件夹之后,没有package.json文件,加载index.js\n\t7,如果连index.js文件都没有,就会报错\n\t\n加载注意\n\t1,模块在第一次加载后会被缓存,也就是多次调用require(),不会导致模块被加载多次\n\t2,不管是那种模块,都是优先从缓存中加载,从而提高加载速度\n\t3,内置模块是由nodejs官方提供,加载优先级最高\n\t\n一般规则\n\t--先内置模块\n\t--到node_modules中找\n\t--同名的js文件\n\t--同名的文件夹下的main指定的入口文件\n\t--同名的文件夹下的index.js\n\n\n\n服务器概念概念\n\t本质就是一台电脑,性能比个人电脑高很多\n\t\n\t负责存放和对外提供资源的电脑,叫做服务器\n\t负责获取和消费资源的电脑,叫做客户端\n\t\n网络通讯的三要素\n\tip:设备在网络中的唯一标识\n\t端口:程序在设备中的唯一标识\n\t协议:规定了浏览器和服务器之间数据的传输形式\n\t\t浏览器发什么样的数据给服务器,服务器才能解析\n\t\t服务器发什么样的数据给浏览器,浏览器才能解析\n\n\n\nURL地址概念\n\t统一资源定位符,可以定位互联网上的唯一一个资源\n\thttps:&#x2F;&#x2F;detail.tmall.com:80&#x2F;item.htm?id&#x3D;653413567689  淘宝某一个商品的url地址\n\t\n组成\n\t通讯协议: https:&#x2F;&#x2F;\n\tip或者域名: detail.tmall.com (这个域名将来会被DNS域名解析器解析为一个ip地址)\n\t端口: 80(一般网站默认使用80端口)\n\t资源的名称(存放位置): item.htm?id&#x3D;653413567689\n\t\n\t学生管理系统首页页面: http:&#x2F;&#x2F;localhost:3000&#x2F;index.js\n\nHTTP协议概念\n\t超文本传输协议\n作用\n\t规定了客户端和服务端进行网络内容传输所遵循的规范\n\t浏览器传给服务器什么样格式的数据,服务器才能解析\n\t服务器传给浏览器什么样格式的数据,浏览器才能解析\n特点\n\t基于请求和响应模型\n\t必须先有请求,再有响应\n\t请求和响应成对出现的\n\t\t请求成功,200\n\t\t请求失败,404,500\n\n请求消息概念\n\t客户端给服务器的消息,告诉服务器,我浏览器的一些信息\n组成\n\t请求行\n\t\t请求方式 请求的URI(统一资源标识符,前面没有协议) 协议版本\n\t\n\t请求头\n\t\tuser-agent:浏览器的版本型号\n\t\tcontent-type:发给服务器的数据格式\n\t\taccept:浏览器能够支持的返回内容的类型\n\t\taccept-language:浏览器期望获取自然语言的顺序\n\t请求体\n\t\t只有post请求方式才有\n\t\t\n常见的请求方式\n\tget请求\n\t\t数据拼接在地址栏后面,相对的不安全,只能拼接少量的数据\n\t\t一般用于从服务器获取数据(京东获取某个商品的详细信息,传一个商品的id)\n\tpost请求\n\t\t数据保存在请求体中,相对的安全,可以传递大量数据\n\t\t一般用于向服务器提交数据(表单,文件上传下载)\n\n响应消息概念\n\t服务器发给客户端的信息,告诉浏览器我发给你的消息的数据类型及特点\n组成\n\t响应行\n\t\t格式: 协议版本 状态码 状态码描述\n\t响应头\n\t\tcontent-type:告诉浏览器,我发送数据的类型和编码\n\t\tcontent-length:发给浏览器内容的字节长度\n\t响应体\n\t\t将来显示到页面正文的内容\n\t\t\n常用的响应状态码\n\t2XX 成功 200\n\t3XX 重定向 302\n\t4XX 客户端错误 404\n\t5XX 服务端错误 500 \n\t\nrestful风格,通过不同的请求方式调用不同的方法,来实现不同的功能(后面会讲)\n\tget:查询(查询一个,查询所有)\n\tpost:新增\n\tput:修改\n\tdelete:删除\n\n\n\n请求响应对象由来\n\t由于请求消息和响应消息,都是字符串,操作这些字符串很麻烦\n\tnode就将请求响应消息封装成了请求对象和响应对象\n分类\n\t请求对象(request对象)\n\t\t封装了请求消息,一般用于获取数据(获取请求方式request.getMethod,获取请求体)\n\t响应对象(response对象)\n\t\t封装了响应消息,一般用于设置数据(设置响应状态码)\n\n\n请求响应流程\n","slug":"day25_课堂笔记","date":"2022-12-01T13:40:54.834Z","categories_index":"后端","tags_index":"http","author_index":"团子"},{"id":"8ad32db149f95208d6fb34755e75039a","title":"Node快速入门","content":"一. Node概述1 Node是什么\n\n\n\n\n\n\n\n\nNode是一个基于Chrome V8引擎的JavaScript代码运行环境\n运行环境\n\n浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript代码的运行环境\nNode（软件）能够运行JavaScript代码，Node就是JavaScript代码的运行环境\n\n2 Node的安装Node官网：https://nodejs.org/en/\nNode中文官网: http://nodejs.cn/\n在官网安装下载\nwin+R打开cmd\n\n在cmd中输入node -v查看\n\n输入node, 进入到node的命令行, 执行js代码\n\n按两次ctrl+C退出node命令行\n3 Node的组成一开始, 几乎没有人把js当成一门真正的编程语言, 认为它只是运行在浏览器上小脚本而已. 事实上也如此, js的作者用10天写出的这个小玩意最开始仅仅只是为了做表单的验证, 节省一点带宽. 后来经过不断的发展, 慢慢完善, 但是依然存在一个缺陷: 没有模块的概念. 这对做大型项目是非常不利的\n网景 liveScript-&gt;JavaScript \nIE: JScript\njs的官方规范(ECMAScript)主要是规定: 词法, 语法, 表达式, 函数, 对象这些东西. \nW3C组织主要推进HTML5和web标准化, 这些过程基本上都是发生在前端. \n服务端的规范相当落后. 主要集中在这些方面:\n\n没有模块系统\n标准库较少(比如I/O操作, 文件系统)\n没有标准接口(比如几乎没有如何操作数据库的统一接口)\n缺乏包管理系统\n\n这个时候, CommonJS规范出现, 定义和完善了js的这些功能, Node可以被认为是对CommonJS规范的代码实现\n\n这张图, 很好的说明了Node与浏览器, W3C, CommonJS组织, ECMAScript之间的关系\n二. 模块化开发1 为什么需要模块化开发\n\n\n\n\n\n\n\n\n问题一: 文件依赖关系不明确\n一般认为，后加载的文件可能需要依赖于先加载的文件，比如\n01-依赖关系.html\n&lt;script src&#x3D;&quot;js&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;js&#x2F;scroll.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;js&#x2F;swiper.jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n\n现在我们在01-依赖关系.html使用了一个方法\n$(&#39;#fade&#39;).swiper(&#123;\n  type: &#39;fade&#39;,\n  src: scr,\n  arrow: true,\n&#125;)\n\n如果仅仅从代码上看. 很难分析出$()方法是在jquery.js还是在scroll.js中\n如果代码越来越复杂, 这种依赖关系更加难以维护, 在大型工程项目中尤为明显\n\n\n\n\n\n\n\n\n\n问题二: 命名冲突\njs还存在一个问题, 就是命名冲突, 后定义的变量会覆盖之前定义的变量\n02-命名冲突.html\n&lt;script src&#x3D;&quot;a.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;b.js&quot;&gt;&lt;&#x2F;script&gt;\n\n&lt;script&gt;\n  console.log(str) &#x2F;&#x2F; b文件中的str\n&lt;&#x2F;script&gt;\n\na.js\nvar str &#x3D; &#39;a文件中的str&#39;\n\nb.js\nvar str &#x3D; &#39;b文件中的str&#39;\n\n如果在a.js和b.js中同时定义了str变量, 由于b.js后加载, 会覆盖a.js中定义的str变量\n这在大项目中是非常危险的, 一旦你在自己的代码中改写了一个变量的值, 而这个变量恰好其他人也使用了, 会引用程序的崩溃, 并且无从查起\n\n\n\n\n\n\n\n\n\n扩展\n当然, 早期人们可以通过自执行匿名函数解决这个问题, 但是这种方案现在已经被CommonJS规范取代了.\n当然, 如果仔细深入的研究Node, 你会发现Node的实现也仅仅是在每个文件的最外层包裹一层自执行匿名函数\n在早些年, 没有模块化规范时, 可以定义一个自执行匿名函数(IIFE). \n由于函数会产生局部作用域, 在函数内定义的变量和函数不会污染全局\n如果其它文件需要使用, 就通过return将内部的成员暴露给外部\nconst moduleFoo &#x3D; (function () &#123;\n  const name &#x3D; &#39;xiaoming&#39;\n\n  function sayHi() &#123;\n    console.log(&#39;hello &#39; + name)\n  &#125;\n\n  return &#123;\n    name,\n    sayHi,\n  &#125;\n&#125;)()\n\n2 Node中的模块规范Node是对CommonJS规范的一种代码实现, 所以在Node中使用的就是CommonJS模块规范\n1) 模块\n\n\n\n\n\n\n\n\n每个文件被看成一个单独的模块,模块与模块之间是独立的\n如何理解呢?\n在一个文件(模块)中定义的变量, 在另一个文件(模块)中无法直接使用\n\n\n\n\n\n\n\n\n\n示例\n定义a.js\nvar str &#x3D; &#39;模块a中的str&#39;\n\n定义b.js\n&#x2F;&#x2F; 通过require, 表示引用a.js\nrequire(&#39;.&#x2F;a.js&#39;)\nconsole.log(str)\n\n\n\n\n\n\n\n\n\n\n演示\n\n2) 导出\n\n\n\n\n\n\n\n\n如果希望外部能使用当前模块中的变量/函数, 需要使用exports导出\n\nexports是一个对象\n将希望导出的变量/函数挂载到exports对象上, 表示导出\n所谓挂载就是给exports对象添加属性或者方法\n\n\n\n\n\n\n\n\n\n\n示例\n04-导出\na.js\nvar str &#x3D; &#39;a模块中的str变量&#39;\n\nfunction add(x, y) &#123;\n  return x + y\n&#125;\n\n&#x2F;&#x2F; 在exports对象上挂载str属性\nexports.str &#x3D; str\n&#x2F;&#x2F; 在exports对象上挂载add方法\nexports.add &#x3D; add\n\nb.js\n&#x2F;&#x2F; 导入a模块, a是一个对象, 相当于a模块中的exports对象\nvar a &#x3D; require(&#39;.&#x2F;a.js&#39;)\n\nconsole.log(a)\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n\n\n\n\n\n\n\n\n思考\n\n从上面的案例可知, 如果向外暴露(导出)属性或者方法, 可以使用exports. 但是如果想导出整个对象怎么办\n\n\n\n\n\n\n\n\n\n尝试\na_obj.js\nvar str &#x3D; &#39;a_obj模块中的str&#39;\n\nfunction add(x, y) &#123;\n  return x + y\n&#125;\n\nexports &#x3D; &#123;\n  str: str,\n  add: add,\n&#125;\n\nb_obj.js\nvar a_obj &#x3D; require(&#39;.&#x2F;a_obj.js&#39;)\n\nconsole.log(a_obj) &#x2F;&#x2F; &#123;&#125;\n\n\n\n\n\n\n\n\n\n\n演示\n\n通过尝试, 我们发现打印出来是一个空对象, 说明不能通过exports导出新对象\n\n实际上, Node在实现CommonJS模块规范时, \n每个模块都存在一个内置对象module表示当前模块\n\n\n\n\n\n\n\n\n\n在导出时, 实际导出的是module.exports. 而exports是它的引用\n上述代码相当于\nvar str &#x3D; &#39;a_obj模块中的str&#39;\n\nfunction add(x, y) &#123;\n  return x + y\n&#125;\n&#x2F;&#x2F; 给exports重新赋值一个对象, 并不影响module.exports\nexports &#x3D; &#123;\n  str: str,\n  add: add,\n&#125;\n\nmodule.exports &#x3D; &#123;&#125;\n\n\n\n\n\n\n\n\n\n\n图解\n\n\n\n\n\n\n\n\n\n\n结论\n\nexpots通过挂载属性向外暴露变量或者函数, 但是不能暴露对象\n一般情况下使用module.exports\n\n\n\n\n\n\n\n\n\n\n扩展: exports存在的意义\n那既然一般都是使用module.exports, 那exports存在的意义是什么呢?\n因为, 在CommonJS规范中规定模块的导出必须通过exports. Node在实现时也就保留了下来. 在实际使用时, 大部分都是直接用module.exports\n\n\n\n\n\n\n\n\n\n面试题\n该模块导出的是什么?\nvar str &#x3D; &#39;str&#39;\n\nfunction add(x, y) &#123;\n  return x + y\n&#125;\n\nexports.str &#x3D; str\nexports.add &#x3D; add\n\nexports &#x3D; &#123;\n  a: &#39;a&#39;,\n  b: &#39;b&#39;,\n&#125;\n\n答案: &#123; str: &#39;str&#39;, add: [Function: add] &#125;\n\n\n\n\n\n\n\n\n\n图解\n\n3) 导入在Node中导入模块, 需要经历3个步骤\n\n路径分析\n文件定位\n编译执行\n\nNode中的模块可以分为两类:\n\nNode提供的模块, 称为核心模块\n用户编写的模块, 称为文件模块(或者: 包package)\n\n\n\n\n\n\n\n\n\n\n核心模块\n对于核心模块的导入, 如fs, http, path等, 直接使用模块名\nconst fs &#x3D; require(&#39;fs&#39;)\nconst http &#x3D; require(&#39;http&#39;)\nconst path &#x3D; require(&#39;path&#39;)\n\n\n\n\n\n\n\n\n\n\n文件模块\n对于文件模块的导入, 情况比较复杂, 放在稍后一点讲解\n三. 核心模块Node的核心模块比较多, 这里我们重点介绍跟文件操作相关的path和fs\n更多的使用, 参考Node官网 API部分: http://nodejs.cn/api/ \n1 path模块path模块, 主要功能是对路径进行操作\n1) 使用步骤\n导入核心模块\n调用相关API\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 1.导入path模块\nconst path &#x3D; require(&#39;path&#39;)\n\n&#x2F;&#x2F; 2.调用API\n\n&#x2F;&#x2F; 当前文件的完整路径\nconsole.log(__filename) \n&#x2F;&#x2F; 当前文件所在目录\nconsole.log(path.dirname(__filename)) \n\n2) 常用API\n\n\n\n\n\n\n\n\npath.join()\npath.join() 方法会将所有给定的 path 片段连接到一起\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 1.导入path模块\nconst path &#x3D; require(&#39;path&#39;)\n\n&#x2F;&#x2F; 2.调用API\n\n&#x2F;&#x2F; 当前文件所有目录\nconsole.log(__dirname)\n\n&#x2F;&#x2F;当前目录下的fs子目录\nlet fs_path &#x3D; path.join(__dirname, &#39;fs&#39;)\nconsole.log(fs_path)\n\n2 fs模块fs模块(file system)文件操作系统, 主要功能是对目录/文件进行操作\n\n\n\n\n\n\n\n\n\n读文件\nfs.readFile(path, [options], callback)\n\npath: 需要读取文件的路径\noptions: 编码格式, 一般为’utf8’\ncallback: 回调函数\nerr: 错误对象\ndata: 数据\n\n\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 1.导入fs核心模块\nconst fs &#x3D; require(&#39;fs&#39;)\n\n&#x2F;&#x2F; 2.读取文件\nfs.readFile(&#39;1.txt&#39;, &#39;utf8&#39;, (err, data) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 如果文件读取出错 err 是一个对象 包含错误信息\n  &#x2F;&#x2F; 如果文件读取正确 err 是 null\n  if (err) throw err\n  \n  console.log(data)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n写文件\nfs.writeFile(file, data[, options], callback)\n\nfile: 需要写入的文件\ndata: 需要写入的数据\noptions: 编码格式等, 一般为’utf8’\ncallback: 回调函数\nerr: 出错对象\n\n\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 1.导入fs核心模块\nconst fs &#x3D; require(&#39;fs&#39;)\n\n&#x2F;&#x2F; 2.写文件\nfs.writeFile(&#39;index.html&#39;, &#39;&lt;h1&gt;Hello&lt;&#x2F;h1&gt;&#39;, &#39;utf8&#39;, err &#x3D;&gt; &#123;\n  if (err) throw err\n\n  console.log(&#39;写入成功&#39;)\n&#125;)\n\n四. 文件模块文件模块是由程序员基于Node环境编写并发布的代码, 通过由多个文件组成放在一个文件夹中, 所以也叫做包\n在编程界, 有一句经典的名言: ‘不要重复造轮子’, 文件模块就相当于已经造好的轮子, 我们需要一个功能时直接拿来使用就可以了. 因此, 文件模块最大的作用是: 代码复用\n1 npm包管理工具由于包太多了不好查找和维护, 自然会出现管理工具, npm(node package manager)就是其中非常出色的一个\n1) npm基本使用npm在安装node时, 会被自动安装, 首先通过命令查看npm是否已经安装\n在cmd命令行执行npm -v, 查看npm的版本信息\n\n\n\n\n\n\n\n\n\n\n安装包\nnpm install 包名称\n\n\n\n\n\n\n\n\n\n示例\n如果我们想安装jquery, 执行npm install jquery即可\n\n\n\n\n\n\n\n\n\n演示\n\n\n\n\n\n\n\n\n\n\n删除包\nnpm uninstall 包名称\n\n\n\n\n\n\n\n\n\n示例\n执行npm uninstall jquery\n\n\n\n\n\n\n\n\n\n演示\n\n2) 镜像与nrm由于npm是国外的网站, 包的下载速度比较慢, 有时不稳定会导致安装出错. 为了解决这个问题, 我们可以使用国内镜像, 镜像源就是一个和npm官网一样的网站(像镜子一样), 只不过在国内, 这样更加稳定, 并且速度也很快.\n\n\n\n\n\n\n\n\n\nnrm是一个镜像管理工具\n执行命令\nnpm install nrm -g\n\n\n-g: 表示全局安装\n\n全局安装会在C:\\Users\\mayn\\AppData\\Roaming\\npm路径下生成一个可执行命令, 这样就可以在命令行执行了\n\n在命令行执行\nnrm ls\n\n显示可用镜像\n\n使用nrm use切换镜像\nnrm use taobao\n\n更多命令, 使用nrm -h查看\n\n\n\n\n\n\n\n\n\n小结\n如果安装工具类的包, 一般加-g, 全局安装\n2 package规范每个发布在npm上的包都遵循统一的规范, 这个规范也就被称为’package规范’. 以jquery为例\n├─dist &#x2F;&#x2F; 项目发布目录\n├─external\n│  └─sizzle\n│      └─dist\n└─src &#x2F;&#x2F; 源代码\n└─package.json &#x2F;&#x2F; 包配置文件\n└─README.md &#x2F;&#x2F; 说明文件\n\n其中, 最重要的是package.json文件\n&#123;\n  &quot;name&quot;: &quot;&quot;, &#x2F;&#x2F; 包名称\n  &quot;version&quot;: &quot;1.0.0&quot;, &#x2F;&#x2F; 版本\n  &quot;description&quot;: &quot;&quot;, &#x2F;&#x2F; 描述\n  &quot;main&quot;: &quot;index.js&quot;, &#x2F;&#x2F; 入口文件\n  &quot;scripts&quot;: &#123; &#x2F;&#x2F; 脚本\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;&#125;, &#x2F;&#x2F; 项目依赖\n  &quot;devDependencies&quot;: &#123;&#125;, &#x2F;&#x2F; 开发时依赖\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;, &#x2F;&#x2F; 作者\n  &quot;license&quot;: &quot;ISC&quot;\n&#125;\n\n3 手写一个package通过自己手写一个简单的包, 我们来了解package规范\n1) 创建一个文件夹在node_modules下创建一个文件夹calc, 这个文件夹也就是一个package\n\n2) 初始化打开calc, 执行命令\nnpm init -y\n\n\n-y: 表示使用默认值初始化\n\n\n\n\n\n\n\n\n\n\n演示\n\n会在calc里生成package.json配置文件, 如下\n&#123;\n  &quot;name&quot;: &quot;calc&quot;, &#x2F;&#x2F; 包名称\n  &quot;version&quot;: &quot;1.0.0&quot;, &#x2F;&#x2F; 版本\n  &quot;description&quot;: &quot;&quot;, &#x2F;&#x2F; 描述\n  &quot;main&quot;: &quot;index.js&quot;, &#x2F;&#x2F; 入口文件\n  &quot;scripts&quot;: &#123; &#x2F;&#x2F; 脚本\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;, &#x2F;&#x2F; 作者\n  &quot;license&quot;: &quot;ISC&quot;\n&#125;\n\n其中, 最重要的是main, 用来指定: 其他人加载这个package时, 实际引入的文件是哪一个\n3) 创建目录结构创建如图所示的目录结构\n\n修改package.json的入口文件\n\n在dist目录下创建index.js, 作为入口文件\n4) 编写代码\n\n\n\n\n\n\n\n\nsrc/add.js\nfunction add (x, y) &#123;\n  return x + y\n&#125;\n\nmodule.exports &#x3D; add\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n\n\n\n\n\n\n\n\nsrc/sub.js\nmodule.exports &#x3D; function (x, y) &#123;\n  return x - y\n&#125;\n\n\n\n\n\n\n\n\n\n\ndist/index.js\nconst add &#x3D; require(&#39;..&#x2F;src&#x2F;add.js&#39;)\nconst sub &#x3D; require(&#39;..&#x2F;src&#x2F;sub.js&#39;)\n\nmodule.exports &#x3D; &#123;\n  add,\n  sub\n&#125;\n\n\n\n\n\n\n\n\n\n\n演示\n\n5) 使用package在node_modules同级目录创建test.js测试文件\nconst calc &#x3D; require(&#39;calc&#39;)\n\nconsole.log(calc.add(1, 2))\n\n\n\n\n\n\n\n\n\n\n演示\n\nrequire加载的流程:\n\n在node_modules下找calc目录\n解析package.json文件, 找到指定的入口文件:’dist/index.js’\n\n4 导入规则1) 以名称开头\n\n\n\n\n\n\n\n\n示例\nrequire(&#39;fs&#39;)\nrequire(&#39;calc&#39;)\n\n\nNode.js会假设它是核心模块\n如果不是核心模块Node.js会去当前目录下的node_modules中查找\n首先看是否有该名字的JS文件\n再看是否有该名字的文件夹\n查看该文件夹中的package.json中的main选项确定模块入口文件\n如果没有package.json文件, 加载index.js\n否则找不到报错\n\n2) 以路径开头\n\n\n\n\n\n\n\n\n示例\nrequire(&#39;.&#x2F;find&#39;)\nrequire(&#39;..&#x2F;add.js&#39;)\n\n\n如果模块后缀省略，先找同名JS文件再找同名JS文件夹\n如果找到了同名文件夹，找文件夹中的index.js\n如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件\n如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到\n\n五. 服务端编程Node最显著的特点就是将js扩展到了服务端, 使得可以使用js编写服务端程序. \n1 概念1) 服务器\n\n\n\n\n\n\n\n\n提供服务的机器, 也就是电脑, 跟普通的电脑相比, 服务器一般性能更好\n\n\n\n\n\n\n\n\n\n\n服务器集群\n\n\nhttp服务器: 提供http服务的电脑\n数据库服务器: 提供数据存储服务的电脑\n\n2) 服务所谓服务, 就是运行在电脑上的一个应用程序.\n在生活中, 我们都有去食堂吃饭的经历, 在食堂里有不同的窗口, 每个窗口卖的食品不一样, 就像提供的服务不一样\n\n在计算机网络中. 通过IP地址可以唯一的确定某一台电脑, 通过端口就可以唯一的确定这个电脑提供的服务\n\n\n\n\n\n\n\n\n\n结论\n服务 = IP + Port\n3) 服务端程序所谓服务端程序, 就是提供服务的程序, 通过运行在服务器上\n一般情况下, 服务端程序和客户端程序运行在不同的电脑上, 这两个程序要能通信(发送数据)就需要一个统一的标准, 这个标准就是协议, 在Web服务中使用的是Http协议\n2 Http协议Http是一种网络协议, 规定了web服务器与浏览器之前的交互语言, 是一种一问一答协议\n\n由浏览器发起请求(request)\n由web服务器针对请求生成响应(response)\n\n\n\n1) URLURL(Uniform Resource Locator), 统一资源定位符\n在计算机网络中, 可以通过统一资源定位符(URL)请求对应的服务器资源(Resource)\nSchema:&#x2F;&#x2F;host[:port]&#x2F;path[?query-string]\n\n\nSchema: 使用的协议类型, 如http/https/ftp等\nhost:     主机域名或IP\nport:     端口号(可选)\npath:     路径\nquery-string: 查询参数(可选)\n\n\n\n\n\n\n\n\n\n\n 示例\nhttp:&#x2F;&#x2F;api.local.com&#x2F;movies\nhttps:&#x2F;&#x2F;api.local.com:8080&#x2F;articles?id&#x3D;100\n\n\n\n\n\n\n\n\n\n\n资源\n\n狭义上讲, 所有在服务器保存的数据(如:音乐/视频/文章/个人信息…)都是服务器端资源.\n广义上讲, 任何服务器端的对象(如:应用程序/数据库记录/算法…)都可以看作资源.\n\n2) Http请求HTTP请求由三部分组成, 分别是:     \n\n请求行\n请求头\n请求体\n\n如下图所示\n \n请求行请求行的格式如下：\nMethod Request-URL HTTP-Version CRLF\n\n\nMethod：    HTTP请求的类型, 如:GET/POST/PUT/DELETE\nRequest-URL:     HTTP请求的唯一标识符, 如: /test.hmtl\nHTTP-Version:    HTTP协议版本, 如HTTP/1.1\nCRLF:         回车换行 CR(回车\\n)  LF(换行\\r)\n\n例子: GET /test.html HTTP/1.1 (CRLF) \n请求行以”空格”分割, 除结尾的外CR和LF外, 不允许出现单独的CR或LF字符\n请求头请求头包含许多有关的前端环境和请求正文的有用信息. \n请求体请求体主要包含前端发送给后端的数据\n对于GET请求, 一般不需要请求体, 因为GET参数直接体现在URL上\n对于POST请求, 需要请求体, 请求体里保存POST参数\n3) Http响应同样, HTTP响应也是由三部分组成, 分别是: \n\n响应行\n响应头\n响应体\n\n响应报文如下图所示:\n \n响应行响应行的格式如下：\nHTTP-Version Status-Code Reason-Phrase CRLF\n\n\nHTTP-Version：    HTTP协议版本, 如HTTP/1.1\nStatus-Code:         响应状态码, 如200/401/500\nReason-Phrase:    描述信息\nCRLF:             回车换行 CR(回车\\n)  LF(换行\\r)\n\n\n\n\n\n\n\n\n\n\n示例\nHTTP/1.1 200 OK\n状态码\n\n1xx：指示信息–表示请求已接收，继续处理。\n2xx：成功–表示请求已被成功接收、理解、接受。\n3xx：重定向–要完成请求必须进行更进一步的操作。\n4xx：客户端错误–请求有语法错误或请求无法实现。\n5xx：服务器端错误–服务器未能实现合法的请求。\n\n常见的状态码\n\n200 OK：客户端请求成功。\n400 Bad Request：客户端请求有语法错误，不能被服务器所理解。\n401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate一起使用。\n403 Forbidden：服务器收到请求，但是拒绝提供服务。\n404 Not Found：请求资源不存在，举个例子：输入了错误的URL。\n500 Internal Server Error：服务器发生不可预期的错误。\n\n响应头响应头是后端(服务器)返回给前端(客户端)的信息.\n响应体响应体是后端(服务器)返回给前端(客户端)的数据.\n比如: 一个html页面代码, 一张图片, 一个json数据…\n3 手写http服务程序Node提供了Http核心模块, 方便我们快速构建一个http服务程序\n1) 最简单的http服务程序\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 引入http核心模块\nconst http &#x3D; require(&#39;http&#39;)\n\n&#x2F;&#x2F; 创建web服务器\nconst server &#x3D; http.createServer()\n\n&#x2F;&#x2F; 处理请求\nserver.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n  res.end(&#39;&lt;h1&gt;hello&lt;&#x2F;h1&gt;&#39;)\n&#125;)\n\n&#x2F;&#x2F; 监听3000端口\nserver.listen(3000)\n\n\n\n\n\n\n\n\n\n\n演示\n\n2) 处理中文字符\n\n\n\n\n\n\n\n\n示例\n如果响应里包含中文会怎样?\n注意, 修改代码后要重启服务\nres.end(&#39;&lt;h1&gt;这是一个web服务器&lt;&#x2F;h1&gt;&#39;)\n\n\n\n\n\n\n\n\n\n\n演示\n\n我们发现会出现乱码. 我们需要在响应头里添加编码格式\nserver.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 设置响应头\n  res.writeHead(200, &#123;\n    &#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf-8&#39;,\n  &#125;)\n  res.end(&#39;&lt;h1&gt;这是一个web服务器&lt;&#x2F;h1&gt;&#39;)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n\n\n\n\n\n\n\n\nnodemon\n每次修改代码都需要手动重启服务. 这并不友好, 而且容易忘记. 这里, 大家可以安装nodemon工具\nnpm install nodemon -g\n\n然后, 使用nodemon来执行js文件, nodemon会监听文件的变化, 并且重新执行\n\n3) 处理路由\n\n\n\n\n\n\n\n\n分析URL\n不论是get请求还是post请求, 作为服务端而言, 首先要知道请求的URL\n在Node中, 可以通过url核心模块进行分析, 参考 官方文档\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 导入url模块\nconst url &#x3D; require(&#39;url&#39;)\n\n&#x2F;&#x2F; 通过url.parse方法, 返回url对象\nconst str &#x3D; &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;index&#39;\nconst obj &#x3D; url.parse(str, true)\nconsole.dir(obj)\n\n\n\n\n\n\n\n\n\n\n输出\nUrl &#123;\n  protocol: &#39;http:&#39;,\n  slashes: true,\n  auth: null,\n  host: &#39;localhost:3000&#39;,\n  port: &#39;3000&#39;,\n  hostname: &#39;localhost&#39;,\n  hash: null,\n  search: null,\n  query: [Object: null prototype] &#123;&#125;,\n  pathname: &#39;&#x2F;index&#39;,\n  path: &#39;&#x2F;index&#39;,\n  href: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;index&#39;\n&#125;\n\n这里我们最关心的是\n\npathname: 请求的路由\n\n通过路由, 服务端可以区分具体的资源, 比如\n\n/和index: 首页\nlist: 列表页\ndetail: 详情页\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 引入http核心模块\nconst http &#x3D; require(&#39;http&#39;)\n\n&#x2F;&#x2F; 引入url核心模块\nconst url &#x3D; require(&#39;url&#39;)\n\n&#x2F;&#x2F; 创建web服务器\nconst server &#x3D; http.createServer()\n\n&#x2F;&#x2F; 处理请求\nserver.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 设置响应头\n  res.writeHead(&#39;200&#39;, &#123;\n    &#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf-8&#39;,\n  &#125;)\n\n  &#x2F;&#x2F; 分析路由\n  const &#123; pathname &#125; &#x3D; url.parse(req.url, true)\n\n  if (pathname &#x3D;&#x3D; &#39;&#x2F;&#39; || pathname &#x3D;&#x3D; &#39;&#x2F;index&#39;) &#123;\n    res.end(&#39;首页&#39;)\n  &#125; else if (pathname &#x3D;&#x3D; &#39;&#x2F;list&#39;) &#123;\n    res.end(&#39;列表页&#39;)\n  &#125; else &#123;\n    res.writeHead(&#39;404&#39;)\n    res.end(&#39;Not Found&#39;)\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; 监听3000端口\nserver.listen(3000)\n\nconsole.log(&#39;server is running on localhost:3000&#39;)\n\n4) 处理GET请求对于同一个URL, 可以发起不同类型的请求, 处理请求, 主要是分析请求的参数\n由于GET参数直接在URL中, 在处理URL时, 通过query就可以得到\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 导入url模块\nconst url &#x3D; require(&#39;url&#39;)\n\n&#x2F;&#x2F; 通过url.parse方法, 返回url对象\nconst str &#x3D; &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;index?username&#x3D;xiaopang&#39;\nconst obj &#x3D; url.parse(str, true)\nconsole.dir(obj)\n\n\n\n\n\n\n\n\n\n\n输出\nUrl &#123;\n  protocol: &#39;http:&#39;,\n  slashes: true,\n  auth: null,\n  host: &#39;localhost:3000&#39;,\n  port: &#39;3000&#39;,\n  hostname: &#39;localhost&#39;,\n  hash: null,\n  search: &#39;?username&#x3D;xiaopang&#39;,\n  query: [Object: null prototype] &#123; username: &#39;xiaopang&#39; &#125;,\n  pathname: &#39;&#x2F;users&#x2F;index&#39;,\n  path: &#39;&#x2F;users&#x2F;index?username&#x3D;xiaopang&#39;,\n  href: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;index?username&#x3D;xiaopang&#39;\n&#125;\n\n\n\n\n\n\n\n\n\n\n处理get请求\n&#x2F;&#x2F; 引入http核心模块\nconst http &#x3D; require(&#39;http&#39;)\n\n&#x2F;&#x2F; 引入url核心模块\nconst url &#x3D; require(&#39;url&#39;)\n\n&#x2F;&#x2F; 创建web服务器\nconst server &#x3D; http.createServer()\n\n&#x2F;&#x2F; 处理请求\nserver.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 设置响应头\n  res.writeHead(&#39;200&#39;, &#123;\n    &#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf-8&#39;,\n  &#125;)\n\n  &#x2F;&#x2F; 分析路由\n  const &#123; query, pathname &#125; &#x3D; url.parse(req.url, true)\n\n  if (pathname &#x3D;&#x3D; &#39;&#x2F;&#39; || pathname &#x3D;&#x3D; &#39;&#x2F;index&#39;) &#123;\n    &#x2F;&#x2F; 处理get请求\n    if (req.method &#x3D;&#x3D; &#39;GET&#39;) &#123;\n      &#x2F;&#x2F; 打印在后端控制台\n      console.log(query)\n      &#x2F;&#x2F; 返回给浏览器\n      res.end(query.username)\n    &#125;\n  &#125; else if (pathname &#x3D;&#x3D; &#39;&#x2F;list&#39;) &#123;\n    res.end(&#39;列表页&#39;)\n  &#125; else &#123;\n    res.writeHead(&#39;404&#39;)\n    res.end(&#39;Not Found&#39;)\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; 监听3000端口\nserver.listen(3000)\n\nconsole.log(&#39;server is running on localhost:3000&#39;)\n\n5) 处理POST请求对于POST请求, 由于参数在数据报文中, 只有等数据传输完成才可以进行处理. \n主要使用request提供的data和end事件来处理\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 引入http核心模块\nconst http &#x3D; require(&#39;http&#39;)\n\n&#x2F;&#x2F; 引入url核心模块\nconst url &#x3D; require(&#39;url&#39;)\n\n&#x2F;&#x2F; 创建web服务器\nconst server &#x3D; http.createServer()\n\n&#x2F;&#x2F; 处理请求\nserver.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 设置响应头\n  res.writeHead(&#39;200&#39;, &#123;\n    &#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf-8&#39;,\n  &#125;)\n\n  &#x2F;&#x2F; 分析路由\n  const &#123; query, pathname &#125; &#x3D; url.parse(req.url, true)\n\n  if (pathname &#x3D;&#x3D; &#39;&#x2F;&#39; || pathname &#x3D;&#x3D; &#39;&#x2F;index&#39;) &#123;\n    &#x2F;&#x2F; 处理get请求\n    if (req.method &#x3D;&#x3D; &#39;GET&#39;) &#123;\n      &#x2F;&#x2F; 显示页面\n      console.log(query)\n    &#125; else if (req.method &#x3D;&#x3D; &#39;POST&#39;) &#123;\n      let post_data &#x3D; &#39;&#39;\n      &#x2F;&#x2F; post数据传递\n      req.on(&#39;data&#39;, (data) &#x3D;&gt; (post_data +&#x3D; data))\n      &#x2F;&#x2F; post数据传输完成\n      req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n        console.log(post_data)\n        res.end(post_data)\n      &#125;)\n    &#125;\n  &#125; else if (pathname &#x3D;&#x3D; &#39;&#x2F;list&#39;) &#123;\n    res.end(&#39;列表页&#39;)\n  &#125; else &#123;\n    res.writeHead(&#39;404&#39;)\n    res.end(&#39;Not Found&#39;)\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; 监听3000端口\nserver.listen(3000)\n\nconsole.log(&#39;server is running on localhost:3000&#39;)\n\n监听request的两个事件\n\ndata: 当服务端收到post数据时调用\nend: 当服务端收集完post数据时调用\n\n6) 处理静态资源\n\n\n\n\n\n\n\n\n静态资源\n像html, js, css, 图片这些数据都属于静态资源\n如果我们直接在end方法里通过字符串返回html, 显然不够友好.\n最好是能以文件的形式保存, 通过读取文件的方式返回\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 引入http核心模块\nconst http &#x3D; require(&#39;http&#39;)\n\n&#x2F;&#x2F; 引入url核心模块\nconst url &#x3D; require(&#39;url&#39;)\n\n&#x2F;&#x2F; 引入path核心模块\nconst path &#x3D; require(&#39;path&#39;)\n&#x2F;&#x2F; 引入fs核心模块\nconst fs &#x3D; require(&#39;fs&#39;)\n\n&#x2F;&#x2F; 创建web服务器\nconst server &#x3D; http.createServer()\n\n&#x2F;&#x2F; 读取静态资源\nfunction resolveStatic(file) &#123;\n  &#x2F;&#x2F; 将网络路由转换成服务器端真实路径\n  const realPath &#x3D; path.join(__dirname, &#39;public&#x2F;&#39; + file)\n\n  &#x2F;&#x2F; 同步读取文件\n  return fs.readFileSync(realPath)\n&#125;\n\n&#x2F;&#x2F; 处理请求\nserver.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 设置响应头\n  res.writeHead(&#39;200&#39;, &#123;\n    &#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf-8&#39;,\n  &#125;)\n\n  &#x2F;&#x2F; 分析路由\n  const &#123; pathname &#125; &#x3D; url.parse(req.url, true)\n\n  if (pathname &#x3D;&#x3D; &#39;&#x2F;&#39; || pathname &#x3D;&#x3D; &#39;&#x2F;index&#39;) &#123;\n    const html &#x3D; resolveStatic(&#39;index.html&#39;)\n    res.end(html)\n  &#125; else if (pathname &#x3D;&#x3D; &#39;&#x2F;list&#39;) &#123;\n    res.end(&#39;列表页&#39;)\n  &#125; else &#123;\n    res.writeHead(&#39;404&#39;)\n    res.end(&#39;Not Found&#39;)\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; 监听3000端口\nserver.listen(3000)\n\nconsole.log(&#39;server is running on localhost:3000&#39;)\n\n","slug":"Node快速入门","date":"2022-12-01T13:38:48.627Z","categories_index":"Node","tags_index":"node","author_index":"团子"},{"id":"d15fe50aabdeda8cc871dc1941f0910d","title":"24_node概念_模块化_内置模块","content":"昨日回顾单表约束\n\t主键约束\n\t非空约束\n\t唯一约束\n多表约束\n\t外键\n单表查询\n\t查询所有\n\t条件查询\n\t模糊查询\n\t聚合函数查询\n\t分组查询\n\t排序查询\n\t分页查询\n\t书写顺序\n\t\tselect -- from -- where -- group by -- having -- order by -- limit\n\t执行顺序\n\t\tfrom -- where -- group by -- having -- select -- order by -- limit\n多表关系\n\t一对一\n\t\t在任意一方添加外键指向另一方的主键,并且让外键唯一\n\t一对多\n\t\t在多的一方添加外键指向一的一方的主键\n\t多对多\n\t\t建立一个中间表,至少有两个字段,分别作为外键指向多的一方的主键\n多表查询\t\n\t交叉查询\n\t\t笛卡尔值,是其他查询的基础\n\t内连接查询\n\t\t两张表的交集\n\t外连接查询\n\t\t左外连接\n\t\t\t左边的全部+交集\n\t\t右外连接\n\t\t\t右边的全部+交集\n\t子查询\n\t\t结果是单行单列: &gt; &#x3D; &lt; 连接\n\t\t结果是多行单列: in any all exists\n\t\t结果是多行多列: 当作一个虚拟的表来参与查询\n\t自关联查询\n\t\t特殊表,将一张表当作两张表用,起不同的别名,加上关联条件\n\t\t\n\t内连接查询\n\t\t1,要查什么\n\t\t2,查这些需要动用哪几张表\n\t\t3,搞清表与表之间的关联关系\n\nNode概念概念简单的说 Node.js 就是运行在服务端的 JavaScript。\nNode.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。\nNode.js 是一个事件驱动 I&#x2F;O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。\n\n作用1,提供了js的运行环境(就是保证代码正常运行所必要的环境,他提供了很多内置模块保证js代码的执行)\n2,可以通过js来开发后台(很早的一种方式,成本比较低)\n\n组成ECMAScript\n\t和js中的基础语法是一样的\n内置模块\n\tfs 文件相关模块\n\tpath 路径相关模块\n\thttp 服务器相关\n第三方模块\n\texpress 路由,可以快速构建web应用\n\tmysql 可以通过js代码操作mysql数据库\n\n学习路径js\n\tECMAScript基础语法+浏览器的内置对象(DOM+BOM)+第三方库(jquery)\nnode\n\tECMAScript基础语法+内置模块(fs,path,http)+第三方模块(express,mysql等)\n\n\n\n模块化模块化概念概念\n\t遵循固定的规则,把一个大文件,拆成独立并且相互依赖的多个小文件(把代码进行模块化拆分)\n\t也是一个封装的思想,类似于函数(方法),都是对代码的封装\n\t但是函数和方法都只能在当前文件中使用,无法跨文件使用\n\t所以模块化就解决了这个文件,他其实是把代码放在一个单独的js文件中\n\t这样就可以跨文件使用,就是模块化的思想\n好处\n\t提高代码的复用性\n\t提高代码的可维护性\n\t可以实现按需加载\n\n模块化分类根据模块的来源不同\n\t内置模块\n\t\t由node官方提供的,例如 fs,path,http等\n\t自定义模块\n\t\t用户自己创建的每一个js文件,都是自定义模块\n\t第三方模块\n\t\t由第三方开发出来的,并且是官方提供的,使用之前需要下载\n\n模块化使用1,写一个js文件\n\t其实就是创建了一个自定义模块\n2,通过require(路径)方法加载自定义模块\n\t其实就是把刚才写好的模块复制进去\n\n模块作用域概念\n\t在自定义模块中,定义的变量,方法等成员,只能在当前模块使用\n全局变量污染问题\n\t\n\t1,传统方式引入模块\n\t\t模块1:let num &#x3D; 10\n\t\t模块2:let num &#x3D; 20\n\t\t\n\t\t在html中引入这两个模块\n\t\t\t&lt;script src&#x3D;&quot;.&#x2F;05_模块作用域_全局变量1_没有导出.js&quot;&gt;&lt;&#x2F;script&gt;\n\t\t\t&lt;script src&#x3D;&quot;.&#x2F;06_模块作用域_全局变量2_没有导出.js&quot;&gt;&lt;&#x2F;script&gt;\n\n\t\t运行的时候,就会报错,报变量重复定义,就出现全局变量的污染问题\n\t\t\n\t2,node引入模块化的规范(模块中的变量不能直接跨模块访问,必须要先导出,再导入)\n\t\t模块1:\n\t\t\tlet num &#x3D; 10\n\t\t\tmodule.exports.num &#x3D; num  &#x2F;&#x2F;导出\n\t\t模块2:\n\t\t\tlet num &#x3D; 20\n\t\t\tmodule.exports.num &#x3D; num\n\t\t\t\n\t\t引入模块1和模块2(必须要定义两个不同的变量来接收,这样num就存在于这两个变量中)\n\t\t\tconst n1 &#x3D; require(&#39;.&#x2F;08_模块作用域_全局变量1_有导出&#39;);\n\t\t\tconst n2 &#x3D; require(&#39;.&#x2F;09_模块作用域_全局变量2_有导出&#39;);\n\t\t\tconsole.log(n1.num);\n\t\t\tconsole.log(n2.num);\n\t\n\t结论\n\t\t因为不同的模块中,可能定义相同的变量名或者方法名,如果模块间能直接访问,就会出现冲突问题\n\t\t为了避免这种情况,node定义了一个规范,模块中的变量和方法只能在当前模块中访问,如果想跨\t\t 模块使用,必须先导出,再导入才能使用\n\n模块间共享module对象\n\t在每一个自定义模块中,都有一个module对象,他里面存储了和当前模块相关的信息\n\texports: &#123;&#125; &#x2F;&#x2F;这属性就是用来导出数据的,默认是&#123;&#125;\n\t\nmodule.exports对象\n\t这个对象的作用就是将模块中的成员共享出去,供外界使用\n\t将来外界既可以通过 require()方法导入自定义模块,进而拿到module.exports共享的数据\n\t\nexports对象\n\t由于module.exports单词写起来比较复杂,为了简化书写,node提供了exports对象\n\t默认情况下,module.exports对象和exports对象指向同一个对象\n\t\nmodule.exports和exports 使用误区\n\t使用require导入模块的时候,永远以module.exports指向的对象为准\n\t为了防止混乱,不要在同一个模块中同时使用exports和module.exports\n\t一般习惯使用module.exports对象\n\n\n\n内置模块fs模块概念\n\t官方提供的用于操作文件的模块.提供一系列操作文件的属性和方法,方便用户操作文件\n\t\n使用\n\t1,导入\n\t\tconst fs &#x3D; require(&#39;fs&#39;)\n\t2,调用方法\n\t\tfs.readFile() 读取指定文件的数据\n\t\tfs.writeFile() 向指定的文件写入数据\n\t\t\n语法\n\tfs.readFile(path[, options], callback)\n\t\tpath:文件路径,必要参数\n\t\toptions:编码等可选操作\n\t\tcallback:回调函数(读取文件完成之后,调用的函数)\n\t\t\n\tfs.writeFile(path, data[, options], callback)\n\t\tpath:文件路径,必要参数\n\t\tdata:要写入的数据,必要参数\n\t\toptions:编码等可选操作\n\t\tcallback:回调函数(读取文件完成之后,调用的函数)\n\npath模块概念\n\t用于处理路径的模块,提供了处理文件和目录路径的实用工具\n方法\n\tpath.dirname(p)返回路径中代表文件夹的部分\n\tpath.join([path1][, path2][, ...])用于连接路径。\n\tpath.extname(p) 返回路径中文件的后缀名\n\tpath.basename(p[, ext])返回路径中最后一部分,如果第二个参数传后缀名,获取出来的就没后缀\n","slug":"day24_课程笔记","date":"2022-12-01T13:34:25.200Z","categories_index":"Node","tags_index":"node","author_index":"团子"},{"id":"037fa750d83c04acd7b65b954d7307d0","title":"23_外键_多表关系_多表查询","content":"昨日回顾数据库概念\n\t存储数据的文件系统,通过标准的sql访问,方便对数据管理\n\t\n安装\n\tmysql\n\tNavicat\n\t\n应用\n\t一般一个项目创建一个数据库\n\t一个实体创建一张表\n\t一个对象的实例就是在表里面添加一条数据\nsql\n\t结构化的查询语句\n       DDL 定义语句\n       DML 操作语句\n       DQL 查询语句\n       DCL 控制语句\n\n数据类型\n\t整形\n\t\tint\n\t小数\n\t\tfloat\n\t\tdouble\n\t日期\n\t\tdate\n\t\ttime\n\t\tdateTime\n\t\ttimeStamp\n\t字符串\n\t\tchar\n\t\tvarchar\n字段属性\n\t不为空\n\t\tnot null\n\t默认值\n\t\tdefault\n\t主键\n\t\tprimary key\n\t自增\n\t\tauto_increment\n\t注释\n\t\tcomment\n\t唯一\n\t\tunique\n\n表记录的操作\n\t增\n\t\tinsert into 表名 values (值1,值2,...)\n\t删\n\t\tdelete from 表名 where 条件\n\t改\n\t\tupdate 表名 set 字段名 &#x3D; 字段值 where 条件\n\n单表约束主键约束\n\tprimary key (默认是非空并且唯一的)\n非空约束\n\tnot null\n唯一约束\n\tunique\n\n单表查询查询所有\n\tselect * from 表名\n\n条件查询\n\tselect * from 表名 where 条件\n\t\n模糊查询\n\tselect * from 表名 where 字段名 like (%代表0个或者多个字符,_代表一个字符)\n\t\n聚合函数查询\n\tmax()\n\tmin()\n\tsum()\n\tavg()\n\tcount(*)\n\t查询出来的数据都是一个单值,只有一个值\n\n排序查询 \n\torder by 字段名称 (asc升序 desc降序)\n\n分组查询\n\tgroup by 字段名称 \n\t\n\t注意:分组之后的查询字段,要么是分组字段,要么是聚合函数(是一个单值,对每一组做统计),其他字段,没有任何意义!!!\n\n分页查询\n\tLIMIT 起始索引,每页显示的条数;\n\t公式：起始索引 &#x3D; (当前页数-1) * 每页显示的条数\n\t\n书写的顺序(读起来更像一段话)\n\tselect -- from -- where -- GROUP BY -- having -- order by -- limit\n\t\n执行的顺序\n\tfrom -- where -- group by -- having -- select -- order by -- limit\n\t\n\tfrom:需要哪张表中查询数据\n\twhere:根据条件过滤表中的数据 \t\t\t\t---分组之前,过滤的是表中所有的数据\n\tgroup by:将where过滤后的数据进行分组\n\thaving:对上面已经分组的每一组数据进行过滤  \t---分组之后,过滤的是分组之后每一组数据\n\tselect:查看结果集的哪些列\n\torder by:把结果集按照指定的顺序排列\n\tlimit:需要取到结果集的前几行\n\n\n\n多表约束多表之间是通过外键进行关联的\n\t\n外键作用\n\t保证数据的完整性和有效性,有了外键约束,就不能随意的删除表中的数据\n\t\n添加外键代码\n\t在员工表上添加约束.让员工表中的dep_id作为外键指向部门表的主键\n\tALTER table employee add constraint fk_001 foreign key(dep_id) references department(id)\n\n\n\n多表关系一对一\n\t建表原则\n\t\t在任意一方,添加外键指向另一方的主键,并且让外键唯一\n\t应用\n\t\t数据库的优化 分表(把一张表分为2张表)\n一对多\n\t建表原则\n\t\t在多的一方添加外键,指向一的一方的主键\n\n多对多\n\t建表原则\n\t\t需要借助第三张中间表,中间表至少有两个字段,作为第三张表的外键,分别指向另外两张表的主键\n\n\n\n多表查询1,交叉查询\n\t所有表的组合情况\n\n2,内连接查询(所有表的交集(inner))\n\t隐式内连接\n\t\t表与表之间使用,连接,条件使用where连接\n\t显示内连接\n\t\t表与表之间使用inner连接,条件使用on连接\n\n3,外连接查询\n\t左外连接\n\t\t使用left join 连接,查的是左边表的全部和两张表的交集\n\t右外连接\n\t\t使用right join 连接,查的是右边表的全部和两张表的交集\n4,子查询\n\t结果是单行单列:使用运算符连接\n\t结果是多行单列:使用in any all exist 连接\n\t结果是多行多列:作为一张虚拟的表参与运算\n5,自关联查询\n\t是一张特殊的表,可以将它当做两张表,起不同的别名,用条件关联上\n\n\n\n","slug":"day23课程笔记","date":"2022-12-01T13:26:27.747Z","categories_index":"后端","tags_index":"sql","author_index":"团子"},{"id":"d0cd3b69cac8d24123497120cff3bdf6","title":"22_数据库安装_建表_增删改查","content":"昨日回顾闭包\n\t概念\n\t\t是一个函数,有权访问另外一个函数作用域里面的变量,这个变量所在的函数就是闭包\n\t作用\n\t\t延伸变量的作用范围\n\t应用\n\t\t立即执行函数\n\nlet和const\n\t特点\n\t\t1,都有块级作用域\n\t\t2,没有变量提升\n\t\t3,在同一个域中不能重复定义\n\t\t4,有暂时性死区\n\t使用场景\n\t\t1,const &gt; let &gt; var\n\t\t2,const一般用于引用数据类型, let一般用于基本数据类型\n\t\n类和继承\n\t定义\n\t\tclass 类名&#123;\n\t\t\tconstructor(参数列表)&#123;\n\t\t\t\tthis.属性名 &#x3D; 参数名\n\t\t\t&#125;\n\t\t\t方法名()&#123;&#125;\n\t\t&#125;\n\t继承\n\t\textends\n\t静态\n\t\tstatic修饰,可以直接使用类名调用\n\n解构\n\t将数据结构进行分解,赋给对应的变量\n\t\n\tconst[变量列表] &#x3D; [1,2,3]\n\tconst&#123;属性列表&#125; &#x3D; &#123;name:&#39;张三&#39;,age:23&#125;\n\n箭头函数\n\t简化对函数书写\n\t(参数列表) &#x3D;&gt; &#123;函数体&#125;\n\t参数只有一个 ()可以省\n\t函数体只有一条 &#123;&#125;可以省略\n\npromise\n\t属性\n\t\t状态属性\n\t\t\t默认是准备状态\n\t\t\t调用resolve(),变成成功状态\n\t\t\t调用reject(),变成失败状态\n\t\t结果属性\n\t\t\t默认是undefined,调用方法加上参数,结果就有值了\n\t方法\n\t\tthen\n\t\t\t两个参数\n\t\t\t\t第一个成功的时候,第二个就是失败的时候调用\n\t\t\t如果拿到数据\n\t\t\t\t在then的函数中,添加一个参数,就可以拿到数据\n\tthen返回值\n    \t是一个promise对象,继续调用then方法,实现链式编程\n    \t链式编程能够执行的前提条件是,第一个promise的状态要发生改变\n    \t\n\n数据库概念数据库\n\t存储数据的仓库,也是一个文件系统,可以方便我们对数据的操作\n数据库软件\n\t就是一个软件,类似于库管员,用来管理数据库(mysql)\n数据库的应用\n\t在开发中,一般一个应用会创建一个数据库\n\t在这个数据库里面可以创建很多张表,一般一个实体就会创建一张表\n\t一个表中可以插入很多条记录,一般一个对象的实例就会添加一个新的记录\n数据库的安装\n\t安装mysql软件\n\t安装Navicat连接工具\nsql\t\n\t概念\n\t\t结构化的查询语句\n\t作用\n\t\t对数据库进行增删改查\n\t分类\n\t\tDDL 数据库定义语句\n\t\tDML 数据库操作语句(增删改)\n\t\tDQL 数据库查询语句(查询)\n\t\tDCL 数据库控制语句(权限)\n\n\n\n数据类型整形\n\ttinyint\n\tsmallint\n\tint\n\tbigint\n\t\n小数\n\tfloat\n\tdouble\n\tdecimal\n\n字符串\n\tchar\n\tvarchar\n\ttext\n\tenum\n\n日期时间\n\tdate\n\ttime\n\tdatetime\n\ttimestamp\n\n\n\n字段属性1,能否为空\n\t默认是为null\n\t使用not null 设置不为空\n2,默认值\n\t使用default设置\n3,主键\n\t作用: 用来标识唯一的一行,默认是非空并且唯一的\n\t使用 primary key标识\n4,自增\n\t作用: 和主键一起使用,可以让序号自动增长\n\t使用 AUTO_INCREMENT 来设置\n\t序号设置自增之后,就不能重复使用\n5,注释\t\n\t作用:解释说明,给程序员看\n\t使用 comment来设置\n6,唯一\n\t作用:让列中的数据保存唯一\n\t使用 unique 设置\n\n\n\n综合建表案例博客表(表名 blog)\n\t字段\t\t\t字段类型\t\t\t字段属性\n\tid\t\t\t   int\t\t\t\t主键 自增\n\ttitle\t\t  varchar(255)        非空\n\tpublic_time\t   date\t\t\t\t  非空\n\tauthor       varchar(255)         非空\n\tlooks\t\t   int\t\t\t\t  非空  default 0\n\tcomment\t\t   int\t\t\t\t  非空  default 0\n\tcontent\t\t  text  \t\t\t  非空\n\t\n用户表\n\t-- 创建一个数据库\n    create DATABASE db02;\n\n    -- 使用这个数据库\n    use db02;\n\n    -- 创建一个用户表\n    CREATE table user(\n        id int primary key auto_increment,\n        username varchar(20) not null,\n        password varchar(20) not null\n    );\n\n\n\n数据增删改增\n\tINSERT into user values (null,&#39;张三&#39;,&#39;123&#39;);\n\t\n\t注意\n\t\t插入的数据要和表中的数据类型保持一致\n\t\t插入数据要在有效范围之内(规定20个字节,不能超过20个字节)\n\t\t如果插入的时候给null,就会自动填充默认值\n\t\t如果设置了自增,就会在原来的基础上 +1\n删\n\tDELETE from user where username &#x3D; &#39;张三&#39;\n\t\n改\n\tupdate user set password &#x3D; &#39;888&#39; where username &#x3D; &#39;张三&#39;;\n\t\n注意\n\t修改和删除一定要加上条件,否则会影响所有的数据\n\n\n\n数据基本查询-- 查询所有\n\tselect * from user;\n\n-- 条件查询\n\tselect * from user where username&#x3D;&#39;张三&#39; and password&#x3D;&#39;888&#39;;\n\t\n---------------------------------------------------\n\n查询所有\n\tselect * from 表名\n\t\n条件查询\n\tselect * from 表名 where 条件\n\t\n模糊查询(like)\n\t%代表 零个,一个或者多个字符\n\t_代表 匹配一个字符\n\tlike &#39;x%&#39;  以x开头\n\tlike &#39;%x&#39;  以x结尾\n\tlike &#39;%x%&#39;  包含x\n\tlike &#39;x_&#39;  以x开头,后面只有一个字符\n\tlike &#39;_x&#39;  以x结尾,前面只有一个字符\n\t\n聚合函数查询  结果是一个单值(只有一个值)\n\tmax() 最大值\n\tmin() 最小值\n\tsum() 求和\n\tavg()\t求平均值\n\tcount(*) 统计个数\n\t\n排序查询\n\torder by 字段名称\n\t\tasc默认升序 \n\t\tdesc降序\n\n","slug":"day22_课堂笔记","date":"2022-12-01T13:22:58.585Z","categories_index":"后端","tags_index":"sql","author_index":"团子"},{"id":"2ffd85dcab5fecc36d930380bb5ac946","title":"20_闭包_解构_类_promise","content":"昨日回顾作用域\n\t作用\n\t\t限定变量的作用范围\n\t分类\n\t\t全局作用域(script标签,浏览器关闭的时候销毁)\n\t\t局部作用域(函数里面,函数调用完成之后销毁)\n\t\t块级作用域(if,for循环的&#123;&#125;里面,ES6中语法)\n作用域链\n\t概念\n\t\t函数内部可以嵌套函数,每一次嵌套都会形成一个作用域\n\t\t把这些作用域串起来,就形成了作用域链\n\t作用\n\t\t根据&#39;内部函数可以访问外部函数的变量&#39;,使用链式查找来决定哪些数据能被内部函数访问\n\n原型和this指向\n\t解决的问题\t\n\t\t使用this来定义方法,每new一次,就会为对象的方法开辟空间,浪费内存\n\t解决的思路\n\t\t将公共的方法定义到原型对象中(构造函数名.prototype.方法名 &#x3D; 匿名函数)\n\t原型\n\t\t原型对象\n\t\t\t本质\n\t\t\t\t属于构造函数的一个属性,每一个构造函数里面都有\n\t\t\t作用\n\t\t\t\t可以把一些公共的属性或者方法,放在里面,将来创建对象的时候,可以节省内存\n\t\t对象的原型\n\t\t\t本质\n\t\t\t\t属于对象的一个属性,每一个创建出来的对象都有\n\t\t\t作用\n\t\t\t\t为对象查找方法,提供了一个方向\n\t\t\t\t先从构造函数里面找,没有的话,通过对象的原型找到原型对象,\n\t\t\t\t如果没有,就通过原型链找到上一层,一直找到object\n\t\t构造函数\n\t\t\t在原型对象 和 对象的原型,里面都有一个属性constructor,指向构造函数本身\n\t\t\t可以记录该对象引用于哪个构造函数\n\t原型链\n\t\t每一个实例对象,都有一个属性(__proto__),指向构造函数的原型对象,构造函数原型对象也是\n\t\t一个对象,也有__proto__,指向他的上一层,这样就形成了原型链\n\t\t\n\t\t原型链为对象查找和调用方法提供了一条路径\n\t\t\n函数进阶\n\t命名函数\t\t\t函数名调用\t\twindow\n\t匿名函数\t\t\t变量名调用\t\twindow\n\t构造函数\t\t\tnew调用\t\t  创建的实例对象\n\t字面量对象中的方法    字面量对象\t\t 字面量对象\n\t事件中的函数         事件触发调用\t  事件源对象\n\t定时器中的函数       定时调用\t\t   window\n\t立即执行函数\t\t   立即调用         window\n\t\n\t改变函数内this的指向\n\t\tcall\n\t高阶函数\n\t\t也是一个函数(将函数作为参数 或者是 返回值的函数)\n\n闭包概念\n\t是一个函数,有权访问另外一个函数作用域里面的变量,这个变量所在的函数就叫做闭包\n作用\n\t延伸变量的作用范围,之前定义在函数里面的num只能在函数内部调用,现在可以在外部调用\n应用\n\t立即执行函数(只要在立即执行函数里面的任意一个函数,都可以使用立即执行函数里面的变量)\n\n\n\nlet和const概念\n\tlet 声明的变量只在 let 命令所在的代码块内有效。\n\tconst 声明一个只读的常量，一旦声明，常量的值就不能改变。\n\t\n区别\n\t\t\t\t\t\tvar\t\t\t\tlet\t\t\t\tconst\n\t作用域\t\t\t\t函数级作用域\t\t块级作用域\t\t块级作用域\n\t变量提升\t\t\t 有\t\t\t\t 没有\t\t\t\t没有\n\t能否被修改\t\t\t可以\t\t\t\t可以\t\t\t  不可以\n\t\n使用场景\n\tlet一般用于定义变化的数据(基本数据类型)\n\tconst一般用于定义引用数据类型\n\t优先选用const 如果数据后面要修改,就选用let\n\n\n\n类和继承概念\n\t在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。\n\tclass 的本质是 function。\n\t它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。\n语法\n\t定义类\n\t\tclass 类名&#123;\n\t\t\tconstructor(参数1,参数2)&#123;\n\t\t\t\tthis.属性名1 &#x3D; 参数1\n\t\t\t\tthis.属性名2 &#x3D; 参数2\n\t\t\t&#125;\n\t\t\t方法名()&#123;\n\t\t\t\t方法体\n\t\t\t&#125;\n\t\t&#125;\n继承\n\tclass A extends B &#123;&#125;\n\t\n静态成员\n\t定义\n\t\t使用static修饰\n\t使用\n\t\t直接用类名调用,无需创建对象\n\n\n\n解构赋值概念\n\t一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值\n语法\n\t数组\n\t\tconst[变量列表] &#x3D; 要解构的数组\n\t对象\n\t\tconst&#123;变量列表&#125; &#x3D; 要解构的对象\n好处\n\t可以让调用者更方便的提取数组或者对象的值,或者调用里面的属性和方法\n\t\t\n\n\n\n箭头函数概念\n\t提供了一种更加简洁的函数书写方式\n语法\n\t最简单格式\n\t\t参数 &#x3D;&gt; 函数体 \n\t完整格式\n\t\t(参数1,参数2) &#x3D;&gt; &#123; 函数体 &#125;\n省略格式\n\t如果参数只有一个,()可以省略\n\t如果函数体只有一个语句.&#123;&#125;也可以省略\n\n\n\nPromise概念\n\t本质就是一个对象,对象有属性和方法,他有两个属性和一个方法\n\t一个是状态属性,一个结果属性.方法就是then方法\n创建\n\tconst p &#x3D; new Promise((resovle,reject) &#x3D;&gt; &#123;&#125;)\n属性\n\t状态属性 PromiseState \n        默认值是pending  准备状态,初始状态\n        调用resolve()方法,可以将状态改成完成状态\n        调用reject()方法,可以将状态改成拒绝状态\n       \n    结果属性 PromiseResult\n        默认值是undefined \n        调用方法的时候传一个参数,就可以将参数保存在结果属性中\n方法\n\t接收两个函数,如果p的状态是成功的,就会调用第一个函数,如果是失败的,就会调用第二个函数\n\tthen()方法只有在状态发生改变的时候才会调用\n\t给then方法中的函数加一个参数,就可以拿到结果属性中的值\n\t\nthen返回值\n\t又是一个新的promise对象,可以继续调用then方法,进而实现链式编程\n\t链式编程能够执行的前提条件:第一个promise对象,状态不是pending,必须要发生改变\n\n","slug":"day21_课堂笔记","date":"2022-12-01T13:11:29.368Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"469779a6e8484934bee8ecd3db81351f","title":"20_作用域_原型_函数进阶","content":"昨日回顾全局对象GO\n\t概念\n\t\tjs引擎整合所有的script标签产生的一个对象,window对象\n\t全局变量\n\t\t在script标签里面声明的变量\n\t全局函数\n\t\t在script标签里面声明的函数\n\t关系\n\t\t全局变量--&gt;GO对象一个属性\n\t\t全局函数--&gt;GO对象一个方法\n\n活动对象AO\n\t概念\n\t\t在函数被调用的那一刻产生的一个对象,用来保存当前函数的内部的执行环境\n\t局部变量\n\t\t在函数内部里面声明的变量\n\t局部函数\n\t\t在函数内部里面声明的函数\n\t关系\n\t\t局部变量--&gt;AO对象一个属性\n\t\t局部函数--&gt;AO对象一个方法\n\t\t\n全局预编译\n\t概念\n\t\tscript标签下,代码执行之前的一个预处理\n\t流程\n\t\t0,产生GO对象\n\t\t1,先找变量声明\n\t\t2,再找函数声明\n\t\t3,从上到下执行\n\t结论\n\t\t在全局环境中,如果存在同名的变量和函数,函数的优先级高\n\t\n函数预编译\n\t概念\n\t\t在函数里面,代码执行之前的一个预处理\n\t流程\n\t\t0,产生AO对象\n\t\t1,先找形参和变量的声明\n\t\t2,使用实参的值替换形参的值\n\t\t3,再找函数的声明\n\t\t4,从上到下依次执行函数体\n\t结论\n\t\t只要声明了局部函数,函数的优先级最高(同名的情况下)\n\t\t没有声明局部函数,实参的优先级高\n\t\t整体优先级: 局部函数 &gt; 实参 &gt; 形参和局部变量\n\n作用域作用\n\t限定变量在某个范围内起作用\n好处\n\t提高程序的可靠性,减少命名冲突(在ES6中,同一个域不能定义相同变量.否则报错)\n分类\n\t全局作用域\n\t\t由script标签产生的区域,从计算机角度可以理解为window对象管控的区域\n\t\t全局的变量和函数都是在全局作用域下,在浏览器关闭的时候销毁\n\t局部作用域\n\t\t由函数产生的区域,从计算机的角度可以理解为当前函数AO对象管控的区域\n\t\t局部的变量和函数都是在局部作用域下,在函数执行完成后销毁\n\t块级作用域\n\t\tES6中的语法,存在于if语句,for循环管控的&#123;&#125;所在的区域,对ES5没限制\n\n作用域链概念\n\t只要是代码,都是一个作用域中,写在函数内部的是局部作用域,没有写在函数内部的是在全局作用域中,\n\t如果这个函数,他的内部还有函数,那么在这个作用域中又可以诞生一个作用域.就形成了一个作用域链\n\t\n\t根据 &#39;内部函数可以访问外部函数的变量&#39; 这种机制,使用链式查找来决定哪些数据能被内部函数访问\n\t\n本质\n\t本质也是一个数据结构,函数内部可以嵌套函数,每一次嵌套都会形成一个作用域,把这些作用域串起来\n\t就形成了作用域链\n\n\n\n原型和this指向前置知识\n\t对象的三种创建方式\n\t\t1,构造函数\n\t\t2,字面量形式\n\t\t3,new Object形式\n\t成员分类\n\t\t实例成员\n\t\t\t构造函数内部,通过this添加,通过实例对象来调用\n\t\t静态成员\n\t\t\t在构造函数本身上添加,通过构造函数名来调用\n\t\t\t\n原型对象prototype\n\t概念\n\t\t原型是一个对象,每一个构造函数都有一个prototype属性,指向这个对象(本身)\n\t作用\n\t\t可以把那些不变的方法,直接定义到原型对象(prototype上),这样所有的对象的实例都可以共享这些方法,节省了内存\n\t\t\n对象的原型proto\n\t概念\n\t\t每一个对象都会有一个属性 __proto__,指向函数的原型对象(prototype)\n\t\t__proto__ 习惯称之为 对象的原型\n\t\t\nconstructor构造函数\n\t概念\n\t\t原型对象(Stat.prototype) 和 对象的原型(对象.__proto__),里面都一个属性constructor(constructor称为构造函数,指向构造函数本身)\n\t作用\n\t\t主要是记录该对象引用于哪一个构造函数,可以让原型对象重新指向原来的构造函数(了解)\n\t\n原型链\n\t概念\n\t\t每一个实例对象又有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有__proto__属性，这样一层一层往上找就形成了原型链。\n\t\t\n\t作用\n\t\t当实例对象调用方法的时候,首先在自身的this中定义的方法找\n\t\t如果没有的话,就通过__proto_找到,原型对象,看原型对象里面有没有定义\n\t\t如果没有的话,就通过原型对象的__proto__到上一层(父类中找这个方法)\n\t\t一直找到object,如果都没有的话,就报错\n\t\t\n\t\t__proto__ 对象原型的存在,就是为对象成员的查找机制提供了一个方向\n\n\n\n函数进阶定义总结\n\t命名函数\n\t匿名函数\n\tnew Function(参数1,参数2,函数体)\n调用总结\n\t命名函数   函数名调用\n\t匿名函数   变量名调用\n\t对象的方法  对象\n\t构造函数    对象\n\t绑定事件函数 事件对象调用\n\t定时器函数   自动调用\n\t立即执行函数  立即调用\nthis的指向总结\n\t命名函数   window\n\t匿名函数   window\n\t对象的方法  实例对象\n\t构造函数    实例对象\n\t绑定事件函数 事件对象\n\t定时器函数   window\n\t立即执行函数  window\ncall\n\t执行函数\n\t改变this的指向\n高阶函数\n\t函数作为参数或者返回值,这种函数,叫做高阶函数\n","slug":"day20_课堂笔记","date":"2022-12-01T13:09:33.617Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"c2ca0fd8b53bedb58b7bbb78ffccd016","title":"19_预编译","content":"昨日回顾DOM操作\n\t操作属性\n    \tprop()  固有属性\n    \t\t设置 prop(属性名,属性值)\n    \t\t获取 prop(属性名)\n    \tattr()  自定义属性\n    \t\t设置 attr(属性名,属性值)\n    \t\t获取 attr(属性名)\n\t操作样式\n\t\tcss方法\n\t\t\t获取 css(样式属性名)\n\t\t\t设置 css(样式属性名,属性值)\n\t\t类方法\n\t\t\taddClass()\n\t\t\tremoveClass() \n\t\t\ttoggleClass()\n\t操作文本\n\t\thtml() 标签体,有样式\n\t\t\t获取 jquery对象.html()\n\t\t\t设置 jquery对象.html(内容)\n\t\ttext() 标签体,有样式\n\t\t\t获取 jquery对象.text()\n\t\t\t设置 jquery对象.text(内容)\n\t\tval() 文本框\n\t\t\t获取 jquery对象.val()\n\t\t\t设置 jquery对象.val(内容)\n\t操作节点\n\t\t创建元素\n\t\t\t$(&#39;字符串类型的标签&#39;)\n\t\t添加元素\n\t\t\tappend() 末尾\n\t\t\tprepend() 前面\n\t\t删除元素\n\t\t\tremove() 删除\n\t效果\n\t\t显示和隐藏\n\t\t\tshow()\n\t\t\thide()\n\t\t\ttoggle()\n\t\t上拉和下拉滑动\n\t\t\tslideup()\n\t\t\tslidedown()\n\t\t\tslidetoggle()\n\t\t淡入淡出\n\t\t\tfadeIn()\n\t\t\tfadeOut()\n\t\t\tfadetoggle()\n\t\t\tfadeTo()\n\t遍历\n\t\tjquery对象.each(function(i,e)&#123;&#125;)\n\t\t$.each(jquery对象,function(i,e)&#123;&#125;)\n\t\t\n\t绑定和解绑\n\t\ton\n\t\t\t1,一次可以绑定多个不同类型的事件\n\t\t\t\tjquery对象.on(&#123;\n\t\t\t\t\t事件名称1:匿名函数1,\n\t\t\t\t\t事件名称2:匿名函数2\n\t\t\t\t&#125;)\n\t\t\t2,可以实现事件委托(将事件绑定到父元素上)\n\t\t\t3,可以实现动态绑定\n\t\t\t\tjquery对象.on(事件名称,子类元素的选择器,事件处理函数)\n\n全局对象GO全局对象(GO对象)\n    在浏览器环境中, js引擎会整合所有的&lt;script&gt;标签中的内容, 产生&#96;window对象&#96;\n全局变量\n    在script标签中声明的变量\n全局函数\n\t在script标签中声明的函数\n关系\n    全局变量其实是作为全局对象(GO对象)的一个属性来存在的\n    全局函数其实是作为全局对象(GO对象)的一个方法来存在的\n\n活动对象AO活动对象(AO对象)\n\t在函数被调用时产生的一个对象, 用来保存当前函数内部的执行环境\n局部变量\n\t在函数内部声明的变量\n局部函数\n\t在函数内部声明的函数\n关系\n\t局部变量其实是作为局部对象(AO对象)的一个属性来存在的\n\t局部函数其实是作为局部对象(AO对象)的一个方法来存在的\n\n全局预编译概念\n\t就是在全局环境下(script标签下),js引擎的预处理方式\n流程\n\t1,先查找变量的声明,作为GO对象的属性名,值为undefined\n\t2,再查找函数的声明,作为GO对象的属性名,值为function\n\t3,从上到下依次执行(声明的语句就会被略过)\n结论\n\t在全局环境中,如果存在同名的变量和函数,函数的优先级高\n\n函数预编译概念\n\t就是在局部环境下(函数里面),js引擎的预处理方法\n流程\n\t1,在函数被调用的那一刻,就会为当前函数产出AO对象\n\t2,查找形参和变量的声明作为AO对象的属性名,值为undefined\n\t3,使用实参的值,替换形参的值\n\t4,查找函数的声明,作为AO对象的属性名,值为function\n\t5,从上到下依次执行函数体\n\n\n\n作用域作用域链原型和this指向","slug":"day19_课堂笔记","date":"2022-12-01T13:03:31.746Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"f6ef7836a37fb0cf1951b89b46effc56","title":"18_juery操作和属性","content":"昨日回顾jquery\n\t概念\n\t\tjs的函数库\n\t作用\n\t\t选取元素\n\t\t操作dom\n\t\t添加一些特效\n\t\tajax\n\t使用\n\t\t先引入(本地或者网络)\n\t 语法\n\t \t$(匿名函数)  \n\t \t\t入口函数,将来页面加载完成之后,就可以调用匿名函数中的代码\n\t \t$(dom元素)\n\t \t\t可以将js对象转成jquery对象\n\t \t$(选择器)\n\t \t\t选择指定的元素,得到的是jquery对象\n\t 跟js对象互转\n\t \tjs对象 -&gt;  jquery对象  $(dom元素)\n\t    jquery对象 -&gt; js对象  jquery[0] 或者 jquery.get(0)\n\t事件操作\n    \tjquery对象.事件名称(匿名函数) \n    选择元素\n     \t通过传统的css选择器来选择元素\n     \t\t基本选择器\n     \t\t复合选择器\n     \t通过自带的筛选方法来选择元素\n     \t\tfirst()\n     \t\tlast()\n     \t\tparent()\n     \t\tchildren()\n     \t\tfind()\n     \t\tsiblings()\n\nDOM操作操作样式\n\tcss方法\n\t\tcss(属性名) 获取样式属性的值\n\t\tcss(属性名,属性值) 设置指定样式属性的值\n\t类方法\n\t\taddClass() 添加类\n\t\tremoveClass() 移除类\n\t\ttoggleClass() 切换类\n\n操作属性\n\tprop() 操作的是元素固有的属性\n\t\tprop(属性名,属性值)  设置\n\t\tprop(属性名)  获取\n\tattr() 操作的是元素自定义的属性\n\t\tattr(属性名,属性值)  设置\n\t\tattr(属性名)  获取\n操作文本\n\thtml() 有样式\n\t\thtml() 获取\n\t\thtml(内容) 设置\n\ttext() 纯文本\n\t\ttext() 获取\n\t\ttext(内容) 设置\n\tval()  操作文本框内容\n\t\tval() 获取\n\t\tval(内容) 设置\n\t\t\n操作节点\n\t创建节点\n\t\t$(&#39;字符串类型的元素&#39;)\n\t添加元素\n\t\tappend()添加到末尾\n\t\tprepend()添加到前面\n\t删除元素\n\t\tremove() 可以自己删除自己\n\njquery效果显示和隐藏\n\tshow([s,[e],[fn]])\n\thide([s,[e],[fn]])\n\ttoggle([s],[e],[fn]) \n\n上滑和下滑\n\tslideDown([s],[e],[fn]) \n\tslideUp([s,[e],[fn]]) \n\tslideToggle([s],[e],[fn]) \n\n淡入淡出\n\tfadeIn([s],[e],[fn]) \n    fadeOut([s],[e],[fn]) \n    fadeToggle([s,[e],[fn]]) \n    fadeTo([[s],o,[e],[fn]]) \n\n\njquery遍历使用场景\n\t针对同一类元素,做不同操作的时候,需要用到遍历\n语法\t\n\tjquery对象.each(匿名函数)\n\t$.each(jquery对象,匿名函数)\n\n事件绑定和解绑事件绑定\n\ton\n\t\t1,可以绑定多个不同类型事件\n\t\t2,可以实现事件委托(可以把子元素事件绑定到父元素上)\n\t\t3,可以实现动态绑定\n事件解绑\n\toff\n\n","slug":"day18_课堂笔记","date":"2022-12-01T12:41:34.942Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"a5b97ab8932b5f038d4330f012aa0a62","title":"jQuery","content":"一. jQuery介绍1 什么是jQuery\n\n\n\n\n\n\n\n\njQuery是一个JavaScript函数库\n在早期的时候, 浏览器有很多不同的版本, 如果要做各种浏览器兼容是很头疼的事. \njQuery的出现解决了这个问题, 处理了兼容问题, 并提供了一系列简洁的, 统一的操作DOM的方式\n\n\n\n\n\n\n\n\n\njQuery的口号是”write less, do more”\n2 jQuery包含哪些功能jQuery库包含以下功能：\n\nHTML 元素选取\nHTML 元素操作\nCSS 操作\nHTML 事件函数\nJavaScript 特效和动画\nHTML DOM 遍历和修改\nAJAX\n\n除此之外, 还提供了大量的插件. \n虽然现在3大框架的出现在一定程度上影响了jQuery的市场份额. 但是jQuery对于学习DOM编程还是非常有帮助的. 同时也不排除jQuery依然活跃于大型项目中\n二. jQuery快速上手1 jQuery的安装jQuery的安装只需要引入jQuery的js文件即可, 常用的获取jquery.js文件的方式:\n\n从 jquery.com 下载 jQuery 库\n从 CDN 中载入 jQuery, 如从 jsDelivr 中加载 jQuery\n\n这里, 更推荐大家使用CDN的方式引入\n\n\n\n\n\n\n\n\n\n推荐的CDN公共资源网站\njsDelivr\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.6.0&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\nbootCDN\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;3.6.0&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n\n更多公共资源CDN可以参考: 菜鸟驿站-jQuery安装\n\n\n\n\n\n\n\n\n\n扩展\n许多用户在访问其他站点时，已经从百度、又拍云、新浪、谷歌或微软加载过 jQuery。所以结果是，当他们访问您的站点时，会从缓存中加载  jQuery，这样可以减少加载时间。同时，大多数 CDN  都可以确保当用户向其请求文件时，会从离用户最近的服务器上返回响应，这样也可以提高加载速度\n2 jQuery语法jQuery最主要的作用就是操作DOM\n步骤:\n\n选择DOM元素\n执行操作(事件, 属性, 效果…)\n\n\n\n\n\n\n\n\n\n\n语法\n$(&#39;选择器&#39;).action\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;慢慢就看不见我了!!!&lt;&#x2F;div&gt;\n    &lt;script&gt;\n      &#x2F;&#x2F; 选择div元素, 在3s内隐藏\n      $(&#39;div&#39;).hide(3000)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3 入口函数当DOM元素加载完成后执行. 不用等所有内容(包括图片, css)加载完成\n\n\n\n\n\n\n\n\n\n示例\n$(function()&#123;\n    &#x2F;&#x2F; 执行代码\n&#125;)\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script&gt;\n      $(&#39;div&#39;).hide(3000)\n    &lt;&#x2F;script&gt;\n    &lt;div&gt;慢慢就看不见我了!!!&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n没有起效果.\n如果我们希望jQuery的代码生效, 可以考虑将代码放在入口函数中\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script&gt;\n      $(function () &#123;\n        $(&#39;div&#39;).hide(3000)\n      &#125;)\n    &lt;&#x2F;script&gt;\n    &lt;div&gt;慢慢就看不见我了!!!&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4 DOM对象与jQuery对象DOM对象是通过原生的DOM API得到的对象\njQuery对象是通过$()得到的对象\n两者可以使用方法不一样\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;box&lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      var div &#x3D; document.querySelector(&#39;div&#39;)\n      div.onclick &#x3D; function () &#123;\n        alert(123)\n      &#125;\n\n      var jqObj &#x3D; $(&#39;div&#39;)\n      &#x2F;&#x2F; jqObj 并没有onclick方法, 不会生效\n      jqObj.onclick &#x3D; function () &#123;\n        console.log(123)\n      &#125;\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nDOM对象和jQuery对象是可以相互转换的\n\n通过$()得到的对象是jq对象, 通过下标得到dom对象\n通过dom API得到dom对象, 通过$()转换为jq对象\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;box1&lt;&#x2F;div&gt;\n    &lt;div&gt;box2&lt;&#x2F;div&gt;\n    &lt;div&gt;box3&lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      &#x2F;&#x2F; 通过$()得到的对象是jq对象, 通过下标得到dom对象\n      var jqObj &#x3D; $(&#39;div&#39;)\n      console.dir(jqObj)\n      console.dir(jqObj[0])\n\n      &#x2F;&#x2F; 通过dom API得到dom对象, 通过$()转换为jq对象\n      var divs &#x3D; document.querySelectorAll(&#39;div&#39;)\n      console.log(divs)\n      console.log($(divs))\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n三. jQuery选择器类似于CSS选择器, jQuery提供丰富的选择器, 可以快速准确的选出DOM元素.\n这里, 我们也只是给出常用的选择器, 更多组合大家自行探索\n\n\n\n名称\n用法\n描述\n\n\n\nID选择器\n$(‘#id’)\n获取指定ID的元素\n\n\n类选择器\n$(‘.class’)\n获取一类class的元素\n\n\n标签选择器\n$(‘div’)\n获取所有div元素\n\n\n后代选择器\n$(‘ul li’)\n获取ul下所有的li元素\n\n\n:first\n$(‘li:first’)\n获取第一个li元素\n\n\neq(index)\n$(‘li:eq(2)’)\n获取索引号为2的元素, 从0开始\n\n\nfind(selector)\n$(‘ul’).find(‘li’)\n在ul下找所有的li元素\n\n\neq(index)\n$(‘li’).eq(2)\n相当于$(‘li:eq(2)’)\n\n\nsiblings(selector)\n$(this).siblings()\n选择自己的兄弟元素, 不包括自己\n\n\n属性选择器\n$(“a[target=’_blank’]”)\ntarget 属性值等于 “_blank” 的 a元素\n\n\n四. jQuery事件1 什么是事件当用户浏览网页时, 网页上一些可以交互的元素(按钮)对用户操作的反应就是事件.\n比如\n\n用户点击登录按钮\n看小说, 漫画时按键盘的左右键进行翻页\n\n这些都是事件\n2 常见的事件常见的事件可以分为\n\n鼠标事件\n键盘事件\n表单事件\n窗口事件\n\n\n3 jQuery如何处理事件\n\n\n\n\n\n\n\n\n语法\n$(&quot;选择器&quot;).事件名(function()&#123;\n    &#x2F;&#x2F; 事件处理函数\n&#125;);\n\n\n\n\n\n\n\n\n\n\n示例\n$(&quot;btn&quot;).click(function()&#123;\n    alert(&#39;我被点击了&#39;)\n&#125;);\n\n五. jQuery CSS操作通过jQuery可以快速的添加CSS样式\n1 CSS操作\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; 设置单个属性\n$(&quot;选择器&quot;).css(&#39;属性名&#39;, &#39;属性值&#39;)\n&#x2F;&#x2F; 设置多个属性\n$(&quot;选择器&quot;).css(&#123;\n  属性名1: 属性值1,\n  属性名2: 属性值2\n&#125;)\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;box&quot;&gt;box&lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      &#x2F;&#x2F; 对于-, 改成驼峰命名\n      &#x2F;&#x2F; 设置单个属性\n      $(&#39;#box&#39;).css(&#39;backgroundColor&#39;, &#39;skyblue&#39;)\n\n      &#x2F;&#x2F; 设置多个属性\n      $(&#39;#box&#39;).css(&#123;\n        width: &#39;400px&#39;,\n        height: &#39;400px&#39;,\n        color: &#39;#fff&#39;,\n        fontSize: &#39;32px&#39;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n2 类操作更多的时候, 我们使用类操作\n\n添加一个类样式: addClass\n删除一个类样式: removeClass\n切换类样式: toggleClass\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;style&gt;\n      div &#123;\n        width: 150px;\n        height: 150px;\n        background-color: skyblue;\n      &#125;\n\n      .current &#123;\n        background-color: greenyellow;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;box&lt;&#x2F;div&gt;\n    &lt;button id&#x3D;&quot;btnAdd&quot;&gt;点击添加颜色&lt;&#x2F;button&gt;\n    &lt;button id&#x3D;&quot;btnRemove&quot;&gt;点击删除颜色&lt;&#x2F;button&gt;\n    &lt;button id&#x3D;&quot;btnToggle&quot;&gt;点击切换颜色&lt;&#x2F;button&gt;\n\n    &lt;script&gt;\n      $(&#39;#btnAdd&#39;).click(function () &#123;\n        &#x2F;&#x2F; 添加颜色\n        $(&#39;div&#39;).addClass(&#39;current&#39;)\n      &#125;)\n\n      $(&#39;#btnRemove&#39;).click(function () &#123;\n        &#x2F;&#x2F; 删除颜色\n        $(&#39;div&#39;).removeClass(&#39;current&#39;)\n      &#125;)\n\n      $(&#39;#btnToggle&#39;).click(function () &#123;\n        &#x2F;&#x2F; 切换颜色\n        $(&#39;div&#39;).toggleClass(&#39;current&#39;)\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n\n综合练习: 仿京东Tab栏切换\n实现如下效果:\n\n思路:\n\n点击上部的li，当前li 添加current类，其余兄弟移除类。\n点击的同时，得到当前li 的索引号\n让下部里面相应索引号的item显示，其余的item隐藏\n\n\n\n\n\n\n\n\n\n\n答案\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;style&gt;\n      * &#123;\n        margin: 0;\n        padding: 0;\n      &#125;\n      li &#123;\n        list-style: none;\n      &#125;\n      .tab &#123;\n        width: 800px;\n        height: 300px;\n        margin: 100px auto;\n      &#125;\n      .tab-title &#123;\n        height: 36px;\n        background-color: #f1f1f1;\n        border: 1px solid #ccc;\n      &#125;\n      .tab-title ul li &#123;\n        float: left;\n        padding: 0 20px;\n        height: 36px;\n        line-height: 36px;\n        text-align: center;\n        cursor: pointer;\n      &#125;\n      .active &#123;\n        background-color: #c81623;\n        color: #fff;\n      &#125;\n      .item &#123;\n        display: none;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;tab&quot;&gt;\n      &lt;div class&#x3D;&quot;tab-title&quot;&gt;\n        &lt;ul&gt;\n          &lt;li class&#x3D;&quot;active&quot;&gt;商品介绍&lt;&#x2F;li&gt;\n          &lt;li&gt;规格与包装&lt;&#x2F;li&gt;\n          &lt;li&gt;售后保障&lt;&#x2F;li&gt;\n          &lt;li&gt;商品评价(50000)&lt;&#x2F;li&gt;\n          &lt;li&gt;手机社区&lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n      &lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;tab-item&quot;&gt;\n        &lt;div class&#x3D;&quot;item&quot; style&#x3D;&quot;display: block&quot;&gt;商品介绍&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;item&quot;&gt;规格与包装&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;item&quot;&gt;售后保障&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;item&quot;&gt;商品评价&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;item&quot;&gt;手机社区&lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      $(&#39;.tab-title li&#39;).click(function () &#123;\n        var i &#x3D; $(this).index()\n        $(this).addClass(&#39;active&#39;).siblings().removeClass(&#39;active&#39;)\n        $(&#39;.item&#39;).eq(i).show().siblings().hide()\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n这里使用到了链式操作\n$(this): 表示当前选中的li元素\n通过index(): 获取当前选中的li元素的下标\n\n总的思路是:\n给当前选中的添加样式\n给兄弟移除样式\n六. jQuery效果1 显示与隐藏三个方法\n\nshow()\nhide()\ntoggle()\n\n\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; 不带参数, 直接显示\n$(&#39;选择器&#39;).show()\n\n&#x2F;&#x2F; 带一个参数, 在time(毫秒)内显示\n$(&#39;选择器&#39;).show(time)\n\n&#x2F;&#x2F; 带二个参数, 在time(毫秒)内显示, 显示完后执行回调\n$(&#39;选择器&#39;).show(time, callback)\n\n\n\n\n\n\n\n\n\n\n示例\n$(&quot;button&quot;).click(function() &#123;\n  $(&quot;div&quot;).show(1000, function() &#123;\n    alert(1);\n  &#125;);\n&#125;)\n\n2 滑入滑出三个方法\n\nslideDown() \nslideUp() \nslideToggle()\n\n语法跟show()一样\n3 淡入淡出自学淡入淡出函数\n综合案例: 带下拉效果的导航条\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;!-- 2. 样式 --&gt;\n    &lt;style&gt;\n      &#x2F;* reset *&#x2F;\n      * &#123;\n        margin: 0;\n        padding: 0;\n      &#125;\n      li &#123;\n        list-style: none;\n      &#125;\n      a &#123;\n        text-decoration: none;\n      &#125;\n      &#x2F;* 布局 *&#x2F;\n      .nav &#123;\n        width: 400px;\n        margin: 50px auto;\n      &#125;\n      .nav .nav-item &#123;\n        float: left;\n        position: relative;\n      &#125;\n      .nav .nav-item .nav-title &#123;\n        display: block;\n        width: 80px;\n        height: 40px;\n        line-height: 40px;\n        text-align: center;\n        color: #333;\n        &#x2F;* background-color: #eee; *&#x2F;\n      &#125;\n      .nav .nav-item .nav-title:hover &#123;\n        background-color: #edeef0;\n        color: #ff8400;\n      &#125;\n      .nav .nav-menu &#123;\n        display: none;\n        position: absolute;\n        color: #333;\n        border-left: 1px solid #fecc5b;\n        border-right: 1px solid #fecc5b;\n      &#125;\n      .nav .nav-menu li &#123;\n        line-height: 40px;\n        padding: 0 20px;\n        white-space: nowrap;\n        border-bottom: 1px solid #fecc5b;\n      &#125;\n      .nav .nav-menu li:hover &#123;\n        background-color: #fff5da;\n        color: #e67902;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 1. 结构 --&gt;\n    &lt;nav class&#x3D;&quot;nav&quot;&gt;\n      &lt;ul&gt;\n        &lt;li class&#x3D;&quot;nav-item&quot;&gt;\n          &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;nav-title&quot;&gt;微博&lt;&#x2F;a&gt;\n          &lt;ul class&#x3D;&quot;nav-menu&quot;&gt;\n            &lt;li&gt;私信&lt;&#x2F;li&gt;\n            &lt;li&gt;评论&lt;&#x2F;li&gt;\n            &lt;li&gt;@我&lt;&#x2F;li&gt;\n          &lt;&#x2F;ul&gt;\n        &lt;&#x2F;li&gt;\n        &lt;li class&#x3D;&quot;nav-item&quot;&gt;\n          &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;nav-title&quot;&gt;博客&lt;&#x2F;a&gt;\n          &lt;ul class&#x3D;&quot;nav-menu&quot;&gt;\n            &lt;li&gt;博客评论&lt;&#x2F;li&gt;\n            &lt;li&gt;未读提醒&lt;&#x2F;li&gt;\n          &lt;&#x2F;ul&gt;\n        &lt;&#x2F;li&gt;\n        &lt;li class&#x3D;&quot;nav-item&quot;&gt;\n          &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;nav-title&quot;&gt;邮箱&lt;&#x2F;a&gt;\n          &lt;ul class&#x3D;&quot;nav-menu&quot;&gt;\n            &lt;li&gt;免费邮箱&lt;&#x2F;li&gt;\n            &lt;li&gt;VIP邮箱&lt;&#x2F;li&gt;\n            &lt;li&gt;企业邮箱&lt;&#x2F;li&gt;\n            &lt;li&gt;新浪企业邮箱客户端&lt;&#x2F;li&gt;\n          &lt;&#x2F;ul&gt;\n        &lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;nav&gt;\n    &lt;script&gt;\n      &#x2F;&#x2F; $(&#39;.nav-item&#39;).mouseenter(function () &#123;\n      &#x2F;&#x2F;   $(this).children(&#39;.nav-menu&#39;).slideDown(200)\n      &#x2F;&#x2F; &#125;)\n      &#x2F;&#x2F; $(&#39;.nav-item&#39;).mouseleave(function () &#123;\n      &#x2F;&#x2F;   $(this).children(&#39;.nav-menu&#39;).slideUp(200)\n      &#x2F;&#x2F; &#125;)\n      &#x2F;&#x2F; $(&#39;.nav-item&#39;).hover(\n      &#x2F;&#x2F;   function () &#123;\n      &#x2F;&#x2F;     $(this).children(&#39;.nav-menu&#39;).slideDown(200)\n      &#x2F;&#x2F;   &#125;,\n      &#x2F;&#x2F;   function () &#123;\n      &#x2F;&#x2F;     $(this).children(&#39;.nav-menu&#39;).slideUp(200)\n      &#x2F;&#x2F;   &#125;\n      &#x2F;&#x2F; )\n\n      $(&#39;.nav-item&#39;).hover(function () &#123;\n        $(this).children(&#39;.nav-menu&#39;).slideToggle(200)\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4 停止动画stop()\n如果不停止动画就会出现上面的情况. 我们可以使用stop停止动画\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;!-- 2. 样式 --&gt;\n    &lt;style&gt;\n      &#x2F;* reset *&#x2F;\n      * &#123;\n        margin: 0;\n        padding: 0;\n      &#125;\n      li &#123;\n        list-style: none;\n      &#125;\n      a &#123;\n        text-decoration: none;\n      &#125;\n      &#x2F;* 布局 *&#x2F;\n      .nav &#123;\n        width: 400px;\n        margin: 50px auto;\n      &#125;\n      .nav .nav-item &#123;\n        float: left;\n        position: relative;\n      &#125;\n      .nav .nav-item .nav-title &#123;\n        display: block;\n        width: 80px;\n        height: 40px;\n        line-height: 40px;\n        text-align: center;\n        color: #333;\n        &#x2F;* background-color: #eee; *&#x2F;\n      &#125;\n      .nav .nav-item .nav-title:hover &#123;\n        background-color: #edeef0;\n        color: #ff8400;\n      &#125;\n      .nav .nav-menu &#123;\n        display: none;\n        position: absolute;\n        color: #333;\n        border-left: 1px solid #fecc5b;\n        border-right: 1px solid #fecc5b;\n      &#125;\n      .nav .nav-menu li &#123;\n        line-height: 40px;\n        padding: 0 20px;\n        white-space: nowrap;\n        border-bottom: 1px solid #fecc5b;\n      &#125;\n      .nav .nav-menu li:hover &#123;\n        background-color: #fff5da;\n        color: #e67902;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 1. 结构 --&gt;\n    &lt;nav class&#x3D;&quot;nav&quot;&gt;\n      &lt;ul&gt;\n        &lt;li class&#x3D;&quot;nav-item&quot;&gt;\n          &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;nav-title&quot;&gt;微博&lt;&#x2F;a&gt;\n          &lt;ul class&#x3D;&quot;nav-menu&quot;&gt;\n            &lt;li&gt;私信&lt;&#x2F;li&gt;\n            &lt;li&gt;评论&lt;&#x2F;li&gt;\n            &lt;li&gt;@我&lt;&#x2F;li&gt;\n          &lt;&#x2F;ul&gt;\n        &lt;&#x2F;li&gt;\n        &lt;li class&#x3D;&quot;nav-item&quot;&gt;\n          &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;nav-title&quot;&gt;博客&lt;&#x2F;a&gt;\n          &lt;ul class&#x3D;&quot;nav-menu&quot;&gt;\n            &lt;li&gt;博客评论&lt;&#x2F;li&gt;\n            &lt;li&gt;未读提醒&lt;&#x2F;li&gt;\n          &lt;&#x2F;ul&gt;\n        &lt;&#x2F;li&gt;\n        &lt;li class&#x3D;&quot;nav-item&quot;&gt;\n          &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;nav-title&quot;&gt;邮箱&lt;&#x2F;a&gt;\n          &lt;ul class&#x3D;&quot;nav-menu&quot;&gt;\n            &lt;li&gt;免费邮箱&lt;&#x2F;li&gt;\n            &lt;li&gt;VIP邮箱&lt;&#x2F;li&gt;\n            &lt;li&gt;企业邮箱&lt;&#x2F;li&gt;\n            &lt;li&gt;新浪企业邮箱客户端&lt;&#x2F;li&gt;\n          &lt;&#x2F;ul&gt;\n        &lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;nav&gt;\n    &lt;script&gt;\n      $(&#39;.nav-item&#39;).hover(function () &#123;\n        $(this).children(&#39;.nav-menu&#39;).stop().slideToggle(200)\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n七. jQuery属性操作1 jQuery元素属性操作这里主要是两个方法\n\nprop()\nattr()\n\n虽然attrubite和property都有属性的意思, 但是\n\nprop() – 操作js对象的属性\nattr() – 操作html属性节点\n\nprop更适用于表单属性, 如：disabled / checked / selected 等\n\n\n\n\n\n\n\n\n\n示例\nprop示例\n$(&#39;button&#39;).on(&#39;click&#39;,function()&#123;\n  if ($(&#39;input&#39;).prop(&#39;checked&#39;)) &#123;\n    $(&#39;input&#39;).prop(&#39;checked&#39;,false);\n  &#125;else&#123;\n    $(&#39;input&#39;).prop(&#39;checked&#39;,true);\n  &#125;\n&#125;)\n\n attr示例\n&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; title&#x3D;&quot;baidu&quot;&gt;百度&lt;&#x2F;a&gt;\n&lt;button id&#x3D;&quot;btn&quot;&gt;点击&lt;&#x2F;button&gt;\n&lt;script&gt;\n  $(&#39;#btn&#39;).click(function () &#123;\n    console.log($(&#39;a&#39;).attr(&#39;title&#39;))\n    $(&#39;a&#39;).attr(&#39;title&#39;, &#39;百度&#39;)\n  &#125;)\n&lt;&#x2F;script&gt;\n\n2 jQuery文本操作主要涉及两个方法\n\nhtml()\ntext()\nval()\n\nhtml相当于原生的innerHTML\ntext相当于原生的innerText\nval相当于原生的value\n\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; 不带参数, 获取值\n$(&#39;选择器&#39;).html()\n\n&#x2F;&#x2F; 带参数, 设置值\n$(&#39;选择器&#39;).html(&#39;值&#39;)\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;div id&#x3D;&quot;test1&quot;&gt;1&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;test2&quot;&gt;2&lt;&#x2F;div&gt;\n&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;test3&quot; &#x2F;&gt;\n\n&lt;div&gt;\n  &lt;button id&#x3D;&quot;btn1&quot;&gt;1&lt;&#x2F;button&gt;\n  &lt;button id&#x3D;&quot;btn2&quot;&gt;2&lt;&#x2F;button&gt;\n  &lt;button id&#x3D;&quot;btn3&quot;&gt;3&lt;&#x2F;button&gt;\n&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n  $(&#39;#btn1&#39;).click(function () &#123;\n    &#x2F;&#x2F; html标签不会被解析, 原样输出\n    $(&#39;#test1&#39;).text(&#39;&lt;b&gt;Hello world!&lt;&#x2F;b&gt;&#39;)\n  &#125;)\n  $(&#39;#btn2&#39;).click(function () &#123;\n    &#x2F;&#x2F; html标签会被解析\n    $(&#39;#test2&#39;).html(&#39;&lt;b&gt;Hello world!&lt;&#x2F;b&gt;&#39;)\n  &#125;)\n  $(&#39;#btn3&#39;).click(function () &#123;\n    &#x2F;&#x2F; 修改test3中的值\n    $(&#39;#test3&#39;).val(&#39;用户名&#39;)\n  &#125;)\n&lt;&#x2F;script&gt;\n\n3 jQuery元素操作1) 添加元素有4个方法\n\nappend() - 在被选元素的内部插入子元素, 在最后\nprepend() - 在被选元素的内部插入子元素, 在最前\nafter() - 在被选元素的外部插入兄弟元素, 在后面\nbefore() - 在被选元素的外部插入兄弟元素, 在前面\n\n2) 删除元素如需删除元素和内容，一般可使用以下两个方法：\n\nremove() - 删除被选元素（及其子元素）\nempty() - 从被选元素中删除子元素\n\n\n\n\n\n\n\n\n\n\n案例: Todolist\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;style&gt;\n      * &#123;\n        margin: 0;\n        padding: 0;\n      &#125;\n      li &#123;\n        list-style: none;\n      &#125;\n      a &#123;\n        text-decoration: none;\n      &#125;\n      .todo &#123;\n        width: 400px;\n        margin: 50px auto;\n      &#125;\n      .todo .header &#123;\n        padding: 0 20px;\n        &#x2F;* height: 40px; *&#x2F;\n        line-height: 40px;\n        color: #fff;\n        background-color: skyblue;\n      &#125;\n      .todo .header input &#123;\n        height: 30px;\n        padding-left: 10px;\n        color: #333;\n        border: none;\n        outline: none;\n      &#125;\n      .todo .list &#123;\n        min-height: 100px;\n        margin-top: 20px;\n        border: 1px solid #ccc;\n      &#125;\n\n      .todo .list li &#123;\n        margin: 10px 0;\n        padding: 5px 20px;\n        background-color: #eee;\n      &#125;\n      .todo .list p &#123;\n        display: inline-block;\n        width: 200px;\n      &#125;\n      .todo .list a &#123;\n        float: right;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;todo&quot;&gt;\n      &lt;div class&#x3D;&quot;header&quot;&gt;\n        添加待办: &lt;input id&#x3D;&quot;add&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按回车添加待办&quot; &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;list&quot;&gt;\n        &lt;ul&gt;&lt;&#x2F;ul&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      &#x2F;&#x2F; 添加操作\n      $(&#39;#add&#39;).keyup(function (e) &#123;\n        if (e.keyCode &#x3D;&#x3D; &#39;13&#39;) &#123;\n          &#x2F;&#x2F; 得到add的值\n          var todo &#x3D; $(&#39;#add&#39;).val()\n\n          if (!todo) return\n\n          &#x2F;&#x2F; 创建元素\n          $(&#39;.list&#39;)\n            .find(&#39;ul&#39;)\n            .prepend(&#96;&lt;li&gt;&lt;p&gt;$&#123;todo&#125;&lt;&#x2F;p&gt;&lt;a href&#x3D;&quot;#&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#96;)\n\n          $(&#39;#add&#39;).val(&#39;&#39;)\n        &#125;\n      &#125;)\n\n      &#x2F;&#x2F; 修改操作\n      $(&#39;ul&#39;).on(&#39;click&#39;, &#39;p&#39;, function () &#123;\n        var p &#x3D; $(this)\n        var todo &#x3D; p.text()\n        var input &#x3D; $(&#96;&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;$&#123;todo&#125;&quot;&#x2F;&gt; &#96;)\n\n        p.html(input)\n\n        input.click(function () &#123;\n          input.focus()\n          return false\n        &#125;)\n\n        input.blur(function () &#123;\n          var newTxt &#x3D; $(this).val()\n          p.html(newTxt)\n        &#125;)\n        input.keyup(function (e) &#123;\n          if (e.keyCode &#x3D;&#x3D; &#39;13&#39;) &#123;\n            var newTxt &#x3D; $(this).val()\n            p.html(newTxt)\n          &#125;\n        &#125;)\n      &#125;)\n\n      &#x2F;&#x2F; 删除操作\n      $(&#39;ul&#39;).on(&#39;click&#39;, &#39;a&#39;, function () &#123;\n        $(this).parent().remove()\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n","slug":"jQuery","date":"2022-12-01T12:37:29.091Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"fbfddebc2434ce626b9f5720fcc8dd42","title":"17_juery基础语法_选择器","content":"JS回顾DOM\n\t概念\n\t\t文档对象模型,定义了查找,新增,修改,删除元素的标准\n\t获取\n\t\tquerySelector()\n\t\tquerySelectorAll()\n\t操作元素\n\t\t操作属性\n\t\t\t元素对象.属性名\n\t\t操作标签体\n\t\t\t元素对象.innerHTML\n\t\t操作样式\n\t\t\t元素对象.style.样式属性名(单独)\n\t\t\t元素对象.className\n\t操作节点\n\t\t创建元素节点\n\t\t\tcreateElement()\n\t\t添加节点\n\t\t\tappendChild()\n\t\t\tinsertBefore()\n\t\t删除节点\n\t\t\tremoveChild()\n\t事件\n\t\t三个要素\n\t\t\t事件源\n\t\t\t事件\n\t\t\t事件处理程序\n\t\t三个步骤\n\t\t\t写一个事件源\n\t\t\t写一个事件处理程序\n\t\t\t绑定事件源和事件处理程序\n\t\t事件注册\n\t\t\t传统方式  使用属性 \n\t\t\tH5方式   调用方法 \n\t\t常见事件\n\t\t\t点击 click\n\t\t\t焦点 blur\n\t\t\t鼠标移入移出  mouseover\n\t\t\t键盘事件 keydown  keyup keypress\n\t\t\t页面加载事件 load   自学\n\t\t\t内容改变事件 change\n\t\t\t表单提交事件 submit\n\t\t事件对象\n\t\t\t概念\n\t\t\t\t触发事件的时候,就会产生一个事件对象,这个事件对象包含了当前事件所有信息\n\t\t\t属性\n\t\t\t\ttarget\t返回触发此事件的元素（事件的目标节点）。\n\t\t\t\ttype\t返回当前 Event 对象表示的事件的名称。\n\t\t\t\tkeyCode\t返回键盘事件触发的键的值的字符代码\n\t\t\t方法\n\t\t\t\tpreventDefault()\t通知浏览器不要执行与事件关联的默认动作。\n\t\t\t\tstopPropagation()\t不再派发事件。\nBOM\n\t概念\n\t\t浏览器对象模型\n\t组成\n\t\twindow\n\t\t\t定时器相关\n\t\t\t\tsetTimeout clearTimeout()\n\t\t\t\tsetInterval clearInterval()\n\t\t\t弹框相关\n\t\t\t\talert()\n\t\t\t\tprompt()\n\t\t\t\tconfirm()\t显示带有一段消息以及确认按钮和取消按钮的对话框。\n\t\tlocation\n\t\t\t属性\n\t\t\t\thref 设置或者获取跳转的路径\n\t\t\t方法\n\t\t\t\treload 刷新\n\t\thistory\n\t\tscreen\n\t\tnavigator\n\n\n\nJquery概念概念\n\t一个js的函数库,对原生的js进行了封装,可以处理兼容性问题,方便对dom的操作\n作用\n\tHTML 元素选取\n    HTML 元素操作\n    CSS 操作\n    HTML 事件函数\n    JavaScript 特效和动画\n    HTML DOM 遍历和修改\n    AJAX\n\n\n\n入门案例引入方式\n\t1,本地引入(先下载,然后在页面中引入本地文件)\n\t2,网络引入(直接在页面中引入网络地址),推荐\n\t&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.6.0&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\t\n相关语法\n\t$(&#39;选择器&#39;) 选择元素,将来这元素就是jquery对象\n\thide()  显示隐藏的方法,jquery对象里面的方法\n\t$(匿名函数)  jquery的入口函数,可以实现在页面加载完成之后,执行匿名函数中的代码\n\n\n\n基础语法$的含义\n\tjQuery的别名,方法名的别名,是jquery语法的标志,可以简化我们的书写\n\t\njquery对象和dom对象(原生的js对象)区别\n\t来源方面\n\t\tdom对象主要是通过document获取的\n\t\tjquery对象是通过$(选择器)来获取的\n\t调用机制\n         dom对象本质是操作元素的属性\n         jquery对象本质是调用方法\n     \t 两者是不能混用的\n     \t \njquery对象和dom对象的转换\n\tdom对象 --&gt; jquery对象  $(dom对象)\n\tjquery对象 --&gt; dom对象  jquery对象[0] 或者 jquery对象.get(0)\n\t\njquery事件的入门\n\t格式\n       jq对象.方法名(匿名函数)\n\t   将来事件发生之后要进行操作写在匿名函数中就行了\n\n\n\n选择器1,使用和css通用的选择器来选择器元素\n\t基本选择器\n\t\tid选择器\n\t\t类选择器\n\t\t元素选择器\n\t复合选择器\n\t\t并集选择器\n\t\t交集选择器\n\t\t后代选择器\n\t\t子选择器\n\t筛选选择器\n\t\t:first\n\t\t:last\n\t\t:even\n\t\t:odd\n\t\t\n2,jquery自带的筛选方法\n\tfirst() 第一个\n\tlast()最后一个\n\tparent() 父元素\n\tchildren() 子元素\n\tfind() 查找后代元素\n\tsiblings()其他兄弟元素\n\n","slug":"day17_课堂笔记","date":"2022-12-01T12:11:52.967Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"ab2246c1172434c6023a55b8c939a44f","title":"16_事件对象_BOM","content":"昨日回顾DOM\n\t文档对象模型\n\t\t加载html文件的时候,浏览器将html文档封装成一个树形结构\n\t\tdocument-html-head,body 形成dom树\n\t作用\t\n\t\t定义了如何获取,操作元素属性(样式),添加和删除元素的规范\n\t思想\n\t\t把html页面中的各个组成部分,抽成对象,以面向对象的方式来操作\n获取元素\n\t获取单个\n\t\tdocument.getElementById()\n\t\tdocument.querySelector(选择器)\n\t获取多个\n\t\tdocument.getElementsByTagName()\n\t\tdocument.getElementsByClassName()\n\t\tdocument.querySelectorAll(选择器)\n操作元素\n\t1,操作属性\n\t\t设置\n\t\t\t元素对象.属性名 &#x3D; 属性值\n\t\t获取\n\t\t\t元素对象.属性名\n\t2,操作标签体\n\t\t设置\n\t\t\t元素对象.innerHTML &#x3D; 属性值\n\t\t获取\n\t\t\t元素对象.innerHTML\n\t3,操作样式\n\t\t单独设置\n\t\t\t元素对象.style.属性名 &#x3D; 属性值\n\t\t批量设置\n\t\t\t元素对象.className &#x3D; class值\n事件\n\t三个要素\n\t\t事件源\n\t\t事件\n\t\t事件处理程序\n\t三个步骤\n\t\t写一个事件源\n\t\t写一个监听器\n\t\t绑定事件源和监听器\n\t常见事件\n\t\t点击事件\n\t\t\tonclick\n\n\n\n节点操作概念\n\t在 HTML DOM (Document Object Model) 中 , 每一个元素都是 节点:\n\n    文档是一个文档节点。\n    所有的HTML元素都是元素节点。\n    所有 HTML 属性都是属性节点。\n    文本插入到 HTML 元素是文本节点\n    注释是注释节点。\n    \n操作\n\t创建元素节点\n\t\tdocument.createElement() 创建元素节点。\n\t添加节点\n\t\telement.appendChild()\t为元素添加一个新的子元素\n\t\telement.insertBefore()\t现有的子元素之前插入一个新的子元素\n\t删除节点\n\t\telement.removeChild()\t删除一个子元素\n\n\n\n其他事件点击事件\n\tonclick\n焦点事件\n\t获取焦点 onfocus\n\t失去焦点 onblur\n鼠标移入移出事件\n\tonmouseover\t鼠标移到某元素之上。\n\tonmouseout\t鼠标从某元素移开。\n\n\n\n事件对象概念\n\t事件发生之后,跟事件相关的一系列信息数据的集合都会被放到这个对象中,这个对象就是事件对象\n\t比如\n\t\t1,谁绑定了这个事件\n\t\t2,如果是鼠标触发事件,可以得到鼠标相关信息,比如鼠标的位置\n\t\t3,如果是键盘触发事件,可以得到键盘相关信息,比如按了那个键\n获取\n\t事件触发的时候就会产生事件对象,并且系统会以实参的形式传递给事件处理函数\n\t我们可以在事件处理函数中声明一个参数来接收事件对象\n\n作用\n\t1,可以获取当前事件的类型(e.type)\n\t2,在键盘事件中可以获取按了哪个键(e.keycode)\n\t3,可以阻止某些标签的默认行为(e.preventDefault())\n\t4,可以获取具体点击了哪一个子元素(e.target)\n\t5,可以阻止事件冒泡(e.stopPropagation())\n\t\n事件冒泡\n\t由于事件有传递性的,最开始是由最具体的元素接收,然后逐级向上传播到DOM的最顶层节点\n阻止事件冒泡\n\t有些情况下,我们只想让最具体的元素接收,而不想让事件向上传播,就可以使用e.stopPropagation()阻止事件冒泡\n\n\n\nBOM简介概念\n\t浏览器对象模型(Browser Object Model)\n作用\n\t使 JavaScript 有能力与浏览器&quot;对话&quot;。(操作浏览器)\n\t例如:弹框,新建一个窗口,跳转到其他窗口,实现定时操作\n组成\n\twindow\n\t\t窗口对象  表示浏览器窗口\n\tscreen \n\t\t屏幕对象  包含有关用户屏幕的信息\n\tlocation \n\t\t地址栏对象 用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。\n\thistory \n\t\t历史记录对象  包含浏览器的历史。\n\tnavigator \n\t\t浏览器对象   包含有关访问者浏览器的信息\n操作思想\n\t将浏览器的各个组成部分抽成对象,以面向对象的方式来操作(对象有属性和方法),提高开发效率\n\n\n\nwindow对象概念\n\t窗口对象\n\t包含页面中的很多东西(变量,函数,弹框,document等)\n方法\n\t定时一次\n\t\tsetTimeOut() 清除clearTimeout()\n\t循环定时\n\t\tsetinterval() 清除clearInterval()\n\n\n\nlocation对象概念\n\t地址栏对象,可以实现刷新和跳转\n属性\n\t href\n     \t设置\n     \t\tlocation.href &#x3D; 新的地址\n\t\t获取\n\t\t\tlocation.href   返回完整的url地址\n\n方法         \n\treload()  刷新\n\n","slug":"day16_课堂笔记","date":"2022-12-01T12:09:51.872Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"1a1853128f85ed795b64680874636106","title":"15_DOM概念_事件_操作元素","content":"昨日回顾面向对象\n\t类和对象\n\t内存执行情况\n内置类(自带的类)\n\tMath类\n\t\tPI\n\t\tmax()\n\t\tmin()\n\t\tabs()\n\t\tceil()\n\t\tfloor()\n\t\tround()\n\t\trandom()\n\t\tMath.floor(Math.random()*[max-min+1])+min\n\tDate类\n\t\tnew Date(参数列表)\n\t\tgetFullYear()\n\t\tgetMonth\n\t\t...\n\t\tgetTime()\n\tArray类\n\t\tpush() pop()\n\t\tsplice()\n\t\tsort()\n\t\treverse()\n\t\tindexOf()\n    Sting类\n    \tindexOf()\n    \tcharAt()\n    \tsubStr()\n    \treplace()\n\nDOM概念DOM:文档对象模型（Document Object Model）的简称\n\n文档对象模型\n\t当网页被加载时，浏览器会创建页面的文档对象模型\n\t这个模型是一个树形的结构,最上面是document文档对象,下面是根标签RootElement(HTML)\n\t然后依次往下展开,就形成了一个树形的结构\n\t\nDOM作用\n\t通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素\n\tJavaScript 能够改变页面中的所有 HTML 元素\n    JavaScript 能够改变页面中的所有 HTML 属性\n    JavaScript 能够改变页面中的所有 CSS 样式\n    JavaScript 能够对页面中的所有事件做出反应\n    \nDOM操作页面元素的思想\n\t就是将html页面中的所有组成部分(标签,属性,标签体,注释)都抽取成对象,用面向对象的方式来操作\t 因为对象中有属性和方法,比单纯操作字符串方便的多\n\t\nDocument 对象\n\t是js的一个内置对象,不需要new去创建,直接写,就能使用\n\t当浏览器载入 HTML 文档, 它就会成为 Document 对象。\n\tDocument 对象是 HTML 文档的根节点。\n\tDocument 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。\n\n\n\nDOM获取元素其实就是使用 document对象的方法来获取元素\n\n获取单个元素\n\tdocument.getElementById(id的值)  \n获取多个元素\n\tdocument.getElementsByTagName()\t返回带有指定标签名的对象集合。\n\tdocument.getElementsByClassName()\t返回文档中所有指定类名的元素集合\nH5新增\n\tdocument.querySelector() 返回文档中匹配指定的CSS选择器的第一元素\n    document.querySelectorAll() 返回文档中匹配的CSS选择器的所有元素节点列\n\n事件入门三个要素\n\t1,事件源(发生事件的那个东西)\n\t2,事件(触发的具体事情)\n\t3,事件处理程序(事件发生之后需要做的事情)\n\t\n\t例如:点击一个按钮,弹出一个消息框\n\t\t事件源:按钮\n\t\t事件:点击这件事情\n\t\t事件处理程序:点击之后弹出的消息(就是执行一个方法)\n\t\t\n三个步骤\n\t1,写一个事件源(写一个按钮)\n\t2,写一个监听器(事件处理程序,一个函数)\n\t3,绑定监听器和事件源(通过一个属性将二者绑定到一块)\n\n\n\nDOM操作属性设置\n\t元素对象.属性名 &#x3D; 属性值\n获取\n\t元素对象.属性名\n\n例如\n\t操作图片的src属性\n\t操作input的value属性\n\t操作input的checked属性\n\nDOM操作标签体innerHTML\n\t设置\n\t\t元素对象.innerHTML &#x3D; 值\n\t获取\n\t\t元素对象.innerHTML\n\t\t\ninnerText(操作的是纯文本)\n\t设置\n\t\t元素对象.innerText &#x3D; 值\n\t获取\n\t\t元素对象.innerText\n\nDOM操作样式一次设置一种样式\n\t元素对象.style.属性名称 &#x3D; 属性值\n\t\n批量设置样式\n\t元素对象.className &#x3D; class属性值\n\n","slug":"day15_课程笔记","date":"2022-12-01T12:08:50.709Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"fe2db7f298638367464a243c91a60f0e","title":"14_Math_Date_Array_String","content":"昨日回顾数组\n\t概念\n\t\t容器,存储数据\n\t定义和初始化\n\t\tvar arr1 &#x3D; new Array()\n\t\tvar arr2 &#x3D; new Array(1,2,3)\n\t\tvar arr3 &#x3D; [1,2,3]\n\t增\n\t\tarr[新的索引] &#x3D; 值\n\t删\n\t\tdelete arr[索引]\n\t改\n\t\tarr[索引] &#x3D; 值\n\t查\n\t\tarr[索引]\n\t\tarr.length\n\t其他操作\n\t\t遍历\n\t\t求和\n\t\t求最值\t\n函数\n\t概念\n\t\t封装了一段具有特定功能的代码块\n\t使用\n\t\t先定义 在调用\n\t格式\n\t\tfunction 函数名(参数列表)&#123;\n\t\t\t函数体\n\t\t\treturn 要返回的数据\n\t\t&#125;\n\t参数\n\t\t想当于一个媒介,调用就可以通过它将要操作的数据传递到函数内部进行操作\n\t返回值\n\t\t调用者可以通过它拿到函数执行的结果,进行下一步操作\n\t获取函数的参数的数组\n\t\targuments 内置对象\n\t分类\n\t\t命名函数\n\t\t匿名函数\n\n面向对象\n\t概念\n\t\t是一种思维方式,重在找对象,找不同的对象,找合适的对象,帮我们去做事情\n\t类\n\t\t对现实生活中具有相同属性和行为的事物的一个统称\n\t对象\n\t\t类中的一个具体存在\n\t类的三要素\t\n\t\t类名 属性  行为\n\n\n\nMath对象概念\n\t算术相关的对象\n属性\n\tMath.PI\n方法\n\tmax()\n\tmin()\n\tabs()\n\tceil()\n\tfloor()\n\tround()\n生成随机数\n\trandom() [0,1)\n\tMath.floor(Math.random()*(max-min+1))+min  生成[min,max]随机数\n\n\n\nDate对象概念\n\tDate 对象用于处理日期与时间。\n创建\t\n\tnew Date()\n\tnew Date(年,月,日)\n\tnew Date(&#39;日期类型的字符串&#39;)\n获取年月日\n\tgetFullYear()\n\tgetMonth()\n\tgetDate()\n\tgetDay()\n获取时分秒\n\tgetHours()\n\tgetMinutes()\n\tgetSeconds()\n获取毫秒值(从1970年开始)\n\tgetTime()\t返回 1970 年 1 月 1 日至今的毫秒数。\n\tvalueOf()\t返回 Date 对象的原始值。(原始值返回1970年1月1日午夜以来的毫秒数！)\n\n\n\nArray对象创建\n\tnew Array(长度)\n\tnew Array(元素1,元素2...)\n方法\n\tpush()\n\tpop()\n\tsplice()\n\tsort()\n\treverse()\n\tindexOf()\n\n\n\nString对象拼接\n\tconcat()\n查找索引\n\tindexOf\n查找字符\n\tcharAt()\n截取\n\tsubStr()\n\tsubString()\n替换\n\treplace()\n","slug":"day14_课堂笔记","date":"2022-12-01T12:07:16.863Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"b243feace6810f027b0a43495f082861","title":"13_数组_函数_面向对象","content":"昨日回顾选择语句\n\tif\n\t\tif\n\t\tif-else\n\t\tif-else-if\n\tswitch\n\t\t语法\n\t\t\tswitch(变量&#x2F;表达式)&#123;\n\t\t\t\tcase 值1:\n\t\t\t\t\t语句1\n\t\t\t\t\tbreak\n\t\t\t\tcase 值2:\n\t\t\t\t\t语句2\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\t语句\n\t\t\t\t\tbreak\n\t\t\t&#125;\n\t\t穿透\n\t\t\t原因:忘记写break\n\t\t\t好处:利用穿透简化代码\n\t应用场景\n\t\tif主要做范围的判断,switch主要用于等值判断\n循环语句\n\tfor循环\n\twhile循环\n\tdo-while循环\n\n\t区别\n\t\tfor,while先判断条件,在执行循环体\n\t\tdo-while先执行循环体,再判断条件\n\t应用场景\n\t\t循环次数确定使用for循环,次数不确定用while循环\n关键字\n\tbreak 终止循环\n\tcontinue 跳过本次循环,继续下一次循环\n\n\n\n数组概念\n\t存放数据的容器,方便管理数据(本质是引用数据类型)\n定义和初始化\n\tvar arr1 &#x3D; []&#x2F;&#x2F;空数组\n\tvar arr2 &#x3D; [1,2,3]&#x2F;&#x2F;创建的同时赋值\n增\n\tarr[新的索引] &#x3D; 值\n删\n\tdelete arr[要删除的索引]\n改\n\tarr[要修改的索引] &#x3D; 值\n查\n\t取值 arr[索引]\n\t长度 arr.length\n遍历\n\t普通for循环\n求和\t\n\t遍历累加\n求最值\n\t遍历进行比较\n二维数组\n\t概念\n\t\t本质还是一个数组,只不过是里面元素是一维数组\n\t取值\n\t\tarr[索引1] 取得是里面的一维数组\n\t\tarr[索引1][索引2]  取得是里面的一维数组的具体的元素\n\t遍历\n\t\t双重for循环\n\n\n\n函数概念\n\t封装了一段具有特定功能的代码块\n作用\n\t方便用户重复调用\n使用\n\t先定义,再调用\n参数\n\t就相当于一个媒介,调用者可以通过它将要操作的数据传递到函数内部进行操作,提高了程序的灵活性\n返回值\n\t将函数操作完的数据返回给调用者,将来调用者拿到数据之后就可以进行其他操作\n数组作为函数参数\n\t形式参数:任意的变量名 \n\t实际参数:传一个数组名,或者直接把数组传进去([1,2,3])\n在函数内部获取函数的参数\n\t通过一个变量argument获取,是一个伪数组\n分类\n\t命名函数\n\t匿名函数\n注意点\n\t1,如果函数没有显示的调用return,函数就没有返回值\n\t2,函数名代表整个函数\n\t3,实参的个数小于形参,多余的形参就不会被赋值,就是undefined\n\n\n\n面向对象面向过程和面向对象\n\t面向过程:完成一件事需要多少个步骤(重点关注的是步骤)\n\t面向对象:完成一件事需要多少个对象(重点关注的是对象,找合适的对象,帮我们去做)\n\n类和对象存在的意义\n\t就是使用代码来描述现实生活中的事物,进行编程(编程来源于生活)\n类的概念\n\t对现实生活中具有相同属性和行为的事物的一个统称(抽象的,相当于模板)\n对象的概念\n\t现实生活中的一个具体存在(具体的,通过模板创建出来的)\n类和对象的关系\n\t类相当于模板,对象就是通过这个模板创建出来的一个个真实存在的个体\n\t类中有什么,对象中就有什么,不会多也不会少\n类的定义\n\tfunction 类名(参数1,参数2)&#123;\n\t\t&#x2F;&#x2F;定义属性\n\t\tthis.属性1 &#x3D; 参数1\n\t\tthis.属性2 &#x3D; 参数2\n\t\t\n\t\t&#x2F;&#x2F;定义方法\n\t\tthis.方法名 &#x3D; function()&#123;\n\t\t\t方法体\n\t\t&#125;\n\t&#125;\n\t\n对象的创建\n\tvar 对象名 &#x3D; new 类名(实际参数1,实际参数2)\n\t\n调用属性和方法\n\t对象名.属性\n\t对象名.方法名(参数)\n\n","slug":"day13_课堂笔记","date":"2022-12-01T12:02:48.954Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"16735bd04b2de2188f178596bcaf05be","title":"12_选择循环语句","content":"昨日回顾概念\n\t运行在客户端的脚本语言\n作用\n\t校验表单\n\t网页行为\n\t服务端开发\n组成\n\tECMAScript基础语法\n\tDOM 文档对象模型\n\tBOM 浏览器对象模型\n引入方式\n\t内嵌式\n\t外链式\n变量\n\t概念\n\t\t其实就是内存中存取数据的那块空间\n\t作用\n\t\t存储变化的数据\n\t使用\n\t\t先定义在初始化\n\t\t定义同时初始化\n数据类型\n\t分类\n\t\t基本数据类型\n\t\t\t数值\n\t\t\t字符串\n\t\t\tboolean类型\n\t\t\t未定义\n\t\t\tnull\n\t\t引用数据类型\n\t\t\t数组 正则\n\t转换\n\t\t强制转换\n\t\t\tString()\n\t\t\tNumber()\n\t\t\tBoolean()  0 null undefined &#39;&#39; ---&gt; false\n\t\t自动转换\n\t\t\ttrue false null在运算的时候会自动转成数值\n\t\t\t字符串+ \n运算符\n\t算术运算符\n\t自增自减运算符\n\t\t++ 在前,先加1再运算\n\t\t++ 在后,先运算再加1\n\t比较运算符\n\t\t&gt; &lt; &#x3D;&#x3D; !&#x3D;\n\t逻辑运算符\n\t\t&amp;&amp; || !\n\t\t结果是boolean类型\n\t\t短路问题,提高效率\n\t三元运算符\n\t\t表达式1 ? 表达式2 : 表达式3\n\t赋值运算符\n\t\t基本 &#x3D; \n\t\t扩展 +&#x3D; -&#x3D; \n\n流程控制根据代码的结构情况分类\n\t顺序结构:从上到下依次执行\n\t选择结构:选择性的执行某些语句\n\t\tif语句\n\t\tif-else语句\n\t\tif-else-if语句\n\t\tswitch语句\n\t循环结构:根据条件重复的执行某些语句\n\t\tfor循环\n\t\twhile循环\n\t\tdo-while循环\n\t\n目标\n\t1,搞清楚每个结构的语法\n\t2,搞清他们的执行流程\n\t3,搞清他们的应用场景\n\n选择语句if语句\n\tif(条件表达式)&#123;\n\t\t语句体\n\t&#125;\n\t\nif-else语句\n\tif(条件表达式)&#123;\n\t\t语句体1\n\t&#125;else&#123;\n\t\t语句体2\n\t&#125;\n\t\nif-else-if语句\n\tif(条件表达式1)&#123;\n\t\t语句体1\n\t&#125;else if(条件表达式2)&#123;\n\t\t语句体2\n\t&#125;else if(条件表达式3)&#123;\n\t\t语句体3\n\t&#125;else if(条件表达式4)&#123;\n\t\t语句体4\n\t&#125;\n\t...\n\telse&#123;\n\t\t语句体2\n\t&#125;\n\t\nswitch语句\n\tswitch(表达式)&#123;\n        case 值1:\n            执行代码块 1\n            break;\n        case 值2:\n            执行代码块 2\n            break;\n        default:\n            与 case 1 和 case 2 不同时执行的代码\n    &#125;\n    \n 区别\n \tif语句和if-else语句,只能判断一个条件, if-else-if和switch可以判断多个条件\n \t所有switch语句都可以使用if-else-if改写,但是if-else-if语句不一定能够使用switch改写\n \tif语句只要用于范围的判断,switch主要用于等值判断(结果只有固定的几个取值,可以使用switch)\n\n\n\n循环语句for循环\n\tfor(初始化语句;条件判断语句;循环增量语句)&#123;\n\t\t循环体语句\n\t&#125;\n\nwhile循环\n\t基本格式\n\t\twhile(条件)&#123;\n           循环体语句\n        &#125;\n     完整格式\n     \t初始化语句\n        while(条件判断语句)&#123;\n        \t循环体语句\n        \t循环增量语句\n        &#125;\n\ndo-while循环\n \t基本格式\n\t\tdo&#123;\n           \t循环体语句\n        &#125;while(条件)\n        \n    完整格式\n        初始化语句\n        do&#123;\n        \t循环体语句\n        \t循环增量语句\n        &#125;while(条件判断语句)\n        \n区别\n\tfor循环和while循环\n\t\t先判断循环条件,在执行循环体\n\twhile循环\n\t\t先执行循环体,再判断循环条件(不管条件是否成立,都会先执行一次循环体)\n\t\t\n使用场景\n\t循环次数确定,建议使用for循环,结构简单紧凑\n\t循环次数不确定,但是循环条件确定,建议使用while循环\n\n\n\n循环关键字continue\n\t用于跳过循环中的一个迭代。(跳过当前循环,继续下一次循环)\n\nbreak\n\t用于跳出循环。\n\n","slug":"day12课程笔记","date":"2022-12-01T11:54:51.613Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"415519e90c14ac35f714ee5f282d32fe","title":"JavaScript基础","content":"一. JavaScript简介1 JS的发展历程回顾整个JavaScript的发展历程, 实际上就是Web发展的历程\n从最开始的拨号上网方式到现在的100M光纤, 4G/5G移动Web的发展\n在近20年, 上网的方式发生了翻天复地的变化, 可以说是科技大爆炸.\n人们在享受越来越便捷的上网的同时, 对Web产品的需求越来越高\n从单纯的对访问速度的需求, 越来越多的转移到视觉美感, 智能操作交互, 沉浸式虚拟现实, 这些需求又反过来推动了技术的不断创新与进步.\n1) JS的诞生在互联网初期(20世纪90年代) —-web1.0\n主要通过拨号上网的方式浏览网页, 提交信息. 上网的速度只有28.8 kbit/s\nJavaScript最初是网景公司的工程师Brandan Eich花了10天的时间设计出来的, 主要是为了在浏览器上先验证用户输入的信息是否符合格式. \n\n\n\n\n\n\n\n\n\n为什么要这样做呢?\n因为当时的网络是非常慢的, 如果用户填写了大量的信息, 提交到服务器, 在服务器端验证发现不合格, 用户要再次重新填写, 这个是很让人抓狂的. \n设想一下，用户填完一个表单，点击提交按钮，等待了 30 秒的处理后，看到的却是一条告诉你忘记填写一个必要的字段\n最开始的时候, Eich把自己设计的这种运行在浏览器上的脚本叫做liveScript, 在发布的时候为了蹭Java的热度, 就改名叫做JavaScript, 实际上跟Java没有半毛钱关系\n2) JS的成长在PC互联网(2010年之前)—-web2.0\n这个时候, 个人电脑PC开始普及, 网络速度突飞猛进, 上网的成本越来越低\n人们开始大量的使用PC访问web应用, 包括: \n\nblog(博客)–新浪\nRSS(订阅)\n社交网络(SNS)–FaceBook/人人网\nP2P(下载)–迅雷\n搜索引擎–Google/baidu\n即时通讯(IM)–QQ\n电子商务–Taobao\n\n在这个时代, JavaScript都只是一种不起眼的小脚本, 没有人把他当成真正的编程语言.\n JavaScript在这个时候依然只是用来处理PC网页的简单动画和验证, 也没有单独的前端岗位, 大部分前端的工作都是由php程序员或者UI人员完成的\n3) JS的新生\n\n\n\n\n\n\n\n\nweb3.0\n随着乔帮主推出的IPhone智能手机, 改变了人们的生活方式\n以智能手机为代表的移动互联网应运为生, 称为web3.0\n\n\n\n\n\n\n\n\n\nHTML5与CSS3\n到2015年左右, HTML5和CSS3的标准化, 大大推进了前端的发展\n前端做为一个独立的方向真正开始被重视\n\n\n\n\n\n\n\n\n\nECMA2015\n在2015年, JavaScript的规范组织ECMA(欧洲计算机制造商协会)推出了ECMA2015, 也被称为ES6\n这一版本的出现, 极大的改进了JavaScript语言, 使得JavaScript具备开发大型项目的能力\n\n\n\n\n\n\n\n\n\nV8引擎与Node.js\nChrome推出的V8引擎将JavaScript的速度提升了几个数量级\nNode.js的出现, 完善了JavaScript在服务端的能力, 使得JavaScript编写服务端程序作为可能\n\n\n\n\n\n\n\n\n\n未来的发展\n自2016年以来, 前端发展非常迅速,  开源社区越来越活跃, 出现了大量的工作岗位, 薪资也水涨船高\nJavaScript现在应用的范围越来越广\n\n微信小程序\nH5游戏\n桌面应用(Electron)\nwebApp\nAI+物联网( AIot)\n\n\n2  JS的组成一般认为JavaScript由三部分组成\n\nECMAScript: 基础语法\nDOM: 文档数据模型\nBOM: 浏览器对象模型\n\n\n1) ECMAScriptECMAScript 是由ECMA（ 原欧洲计算机制造商协会）进行标准化的一门编程语言, 主要规定了像变量, 数据类型, 流程控制, 函数等基础语法\n2) DOM和BOMW3C: 万维网联盟 (World Wide Web Consortium) 主要是完成HTML和CSS及浏览器标准化的研究, 是一个非盈利性的公益组织, 主要由大公司和开发人员组成\n其中, \n\nDOM是由W3C组织制定的标准, 通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色、事件等）\nBOM是由各个浏览器厂商根据DOM在各自浏览器上的实现, 不同的浏览器会略有差异, 通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等\n\n3 JS的写在哪里跟CSS一样, JS也有3种书写方式\n\n外部: 将JS文件单独保存, 再通过&lt;script src=&quot;xxx.js&quot;&gt;引入\n内嵌: 在HTML文件中, 将JS代码写在&lt;script&gt;标签中\n行内: 现在几乎不用\n\n\n\n\n\n\n\n\n\n\n示例\n外部\n&lt;script src&#x3D;&quot;my.js&quot;&gt;&lt;&#x2F;script&gt;\n\n内嵌\n&lt;script&gt;\n  alert(&#39;Hello  World~!&#39;)\n&lt;&#x2F;script&gt;\n\n在实际工作中, 通常将js代码写在文件中, 再使用外部方式引入.\n在学习阶段, 为了调试方便, 主要采用内嵌的方式\n4 体验JS为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：\n\n\n\n方法\n说明\n归属\n\n\n\nalert(msg)\n浏览器弹出警示框\n浏览器BOM\n\n\nconsole.log(msg)\n浏览器控制台打印输出信息\n浏览器BOM\n\n\nprompt(info)\n浏览器弹出输入框，用户可以输入\n浏览器BOM\n\n\n\n注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n\n  &lt;body&gt;\n    &lt;script&gt;\n      &#x2F;&#x2F; 这是一个输入框\n      var name &#x3D; prompt(&#39;请输入您的姓名&#39;)\n      &#x2F;&#x2F; alert 弹出警示框 输出的 展示给用户的\n      alert(name + &#39; 你好!&#39;)\n      &#x2F;&#x2F; console 控制台输出 给程序员测试用的\n      console.log(&#39;我是程序员能看到的:&#39; + name)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n\n调试技巧\n在Chrome浏览器中, 使用F12或者Ctrl+Shift+I打开调试窗口, 在console控制台中查看\n\n在控制台中, 也可以编写JS的代码\n\n二. 变量1 什么是变量变量是一个存放数据的容器(盒子), 由变量名和变量值组成\n就好比, 通过房间号(变量名)可以找到某个人(变量值)\n\n\n\n\n\n\n\n\n\n\n扩展\n变量是程序在内存中申请的一块用来存放数据的空间\n2 变量的使用1) 变量的声明\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; var 变量名\nvar uname\nvar age\n\n\nvar ( variable )是一个 JS关键字, 用来声明变量, 后面跟变量名\nuname/age就是变量名, 计算机通过这个名字就可以找到对应的内存空间, 进而访问到空间里的数据\n\n2) 变量的赋值\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; 变量名 &#x3D; 变量值\nage &#x3D; 10  &#x2F;&#x2F; 将数值10放到age对应的空间\n\n3) 声明的同时赋值\n\n\n\n\n\n\n\n\n示例\nvar age &#x3D; 18\n\n变量可以重新赋值, 新值会覆盖旧值\nage &#x3D; 81\n\n\n\n\n\n\n\n\n\n\n注意\n一般, 变量先声明再使用\n3 变量命名规则在JS中, 变量的命名是有一定的规则的\n\n标识符: 由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name\n变量名严格区分大小写, 如 app和App是两个不同的变量\n不能以数字开头\n不能是 关键字 或者 保留字\n\n推荐使用 驼峰法 (首字母小写，后面单词的首字母需要大写)\n如: myFirstName\n4 关键字与保留字\n更多相关的内容, 参考JavaScript 保留关键字\n三. 数据类型1 什么是数据类型\n\n\n\n\n\n\n\n\n现实\n描述不同的数据时, 人们往往会使用不同的类型, 比如:\n\n姓名: 字符\n年龄: 数字\n一个命题的结论: 真假\n\n\n\n\n\n\n\n\n\n\n程序\n在程序中, 不同类型的数据在存储和传输时占用空间的大小是不同的. 因此, 会存在数据类型的区别\n\n\n\n\n\n\n\n\n\n变量的数据类型\n变量的数据类型就是在变量中保存的数据的类型\n\n\n\n\n\n\n\n\n\n示例\nvar uname &#x3D; &#39;小小胖&#39; &#x2F;&#x2F; uname变量的数据类型就是字符型\nvar age &#x3D; 1 &#x2F;&#x2F; age变量的数据类型就是数字型\n\nJavaScript是弱类型语言, 并没有严格的规定变量的类型, 换句话说, 变量的类型是可以改变的, 但是强烈不建议这么做, \n不推荐\nvar age &#x3D; 1 &#x2F;&#x2F; 初始类型是数字型\nage &#x3D; &#39;你好&#39; &#x2F;&#x2F; age现在是字符型\n\n2 常用的数据类型1) 简单数据类型\nNumber: 数字型\nString: 字符型\nBoolean: 布尔型\nUndefined: 未定义\nNull: 空\n\n\n\n\n简单数据类型\n说明\n默认值\n\n\n\nNumber\n数字型, 包含整型和小数型, 如21, 0.2333\n0\n\n\nString\n字符型, 如’张三’, 字符串带引号\n‘’(空字符)\n\n\nBoolean\n布尔型, 如true, false; 等价于1和0\nfalse\n\n\nUndefined\n未定义, 变量声明, 未赋值就是undefined\nundefined\n\n\nNull\n空\nnull\n\n\n数字型\n\n\n\n\n\n\n\n\n\n示例\nvar num &#x3D; 10 &#x2F;&#x2F; num 数字型\nvar PI &#x3D; 3.14 &#x2F;&#x2F; PI 数字型\nvar num3 &#x3D; 0xFF &#x2F;&#x2F; 0x开头的是16进制数\n\nconsole.log(Number.MAX_VALUE) &#x2F;&#x2F; 数字型的最大值\nconsole.log(Number.MIN_VALUE) &#x2F;&#x2F; 数字型的最小值\nconsole.log(Number.MAX_VALUE * 2) &#x2F;&#x2F; Infinity 无穷大\nconsole.log(-Number.MAX_VALUE * 2) &#x2F;&#x2F; -Infinity 无穷大\n\nconsole.log(&#39;小小胖&#39; - 100) &#x2F;&#x2F; NaN 非数\n\n这里注意一种特殊的数: NaN(Not a Number)非数\n字符型\n使用引号来表示一个字符串\n\n单引号, 双引号都可以, 推荐使用单引号, HTML中一般使用双引号\n引号成对使用\n\n\n\n\n\n\n\n\n\n\n示例\nvar str &#x3D; &#39;我是一个&quot;高富帅&quot;的程序员&#39;;\nconsole.log(str);\n&#x2F;&#x2F; 字符串转义字符  都是用 \\ 开头 但是这些转义字符写道引号里面\nvar str1 &#x3D; &quot;我是一个&#39;高富帅&#39;的程序员&quot;;\nconsole.log(str1);\n\n转义字符\n\n\n\n转义符\n解释说明\n\n\n\n\\n\n换行符，n   是   newline   的意思\n\n\n\\\\\n斜杠   \\\n\n\n\\&#39;\n‘  单引号\n\n\n\\&quot;\n” 双引号\n\n\n\\t\ntab  缩进\n\n\n\\b\n空格 ，b   是   blank  的意思\n\n\n\n\n\n\n\n\n\n\n\n字符串拼接\n在JavaScript中, +是一个很特别的符号, 可以用于字符串的拼接\nvar str &#x3D; &#39;hello &#39; + &#39;world&#39;\nconsole.log(str) &#x2F;&#x2F; hello world\n\n\n\nvar hello &#x3D; &#39;hello &#39;\nvar world &#x3D; &#39;world&#39;\nvar str &#x3D; hello + world\nconsole.log(str)\n\n\n\nvar str &#x3D; &#39;10&#39; + &#39;20&#39;\nconsole.log(str) &#x2F;&#x2F; 1020\n\n\n\n\n\n\n\n\n\n\n小技巧\n在Chrome调试控制台中, \n\n蓝色: 数字\n黑色: 字符\n\n\n\n\n\n\n\n\n\n\n示例\n\n布尔型\n布尔类型有两个值：true 和 false. 其中\n\ntrue 表示真\nfalse 表示假\n\nconsole.log(true);  &#x2F;&#x2F; true\nconsole.log(false); &#x2F;&#x2F; false\n\nUndefined\n一个变量声明了, 但是没有被赋值, 这时变量里会使用默认值undefined\nNull\n空, 在讲对象的时候再讲\n2) 引用数据类型\nObject: 对象\n\n关于引用数据类型是相对比较难的问题, 在后面的章节, 我们会专门来讲解\n这里, 有一句名言, 大家可以先记下来, 后面慢慢体会\n\n\n\n\n\n\n\n\n\n在JavaScript中, 一切都是对象\n3 如何判断数据类型通过typeof 可用来获取检测变量的数据类型\n\n\n\n\n\n\n\n\n\n示例\nvar num &#x3D; 18;\nconsole.log(typeof num) &#x2F;&#x2F; 结果 number\n\n4 数据类型转换1) 显式转换最常见的是字符型转数值型\n\n\n\n\n\n\n\n\n\n需求\n\n先弹出第一个输入框，提示用户输入第一个值 保存起来\n再弹出第二个框，提示用户输入第二个值 保存起来\n把这两个值相加，并将结果赋给新的变量\n弹出警示框（alert) ， 把计算的结果输出 （输出结果）\n\n\n\n\n\n\n\n\n\n\n示例\nvar num1 &#x3D; prompt(&#39;请您输入第一个值：&#39;)\nvar num2 &#x3D; prompt(&#39;请您输入第二个值：&#39;)\nvar result &#x3D; num1 + num2\nalert(&#39;您的结果是:&#39; + result)\n\n我们发现prompt返回的类型是字符型, 两个字符型相加, 其实是拼接, 并不是我们想要的结果, 这时我们需要先将字符型转换成数字型, 再运算\nvar num1 &#x3D; prompt(&#39;请您输入第一个值：&#39;)\nvar num2 &#x3D; prompt(&#39;请您输入第二个值：&#39;)\nvar result &#x3D; parseInt(num1) + parseInt(num2)\nalert(&#39;您的结果是:&#39; + result)\n\n\n第3行, 用到了一个函数, parseInt作用是将字符转换成整数\n\n更多转换函数, 参考手册: JavaScript类型转换\n2) 隐式转换\n\n\n\n\n\n\n\n\n什么是隐式转换\n隐式转换就是JS引擎偷偷将类型转换了, 不让你知道\n由于JavaScript是一种非常灵活的语言, 导致数据类型存在大量隐式转换, 这里面有很多坑.\n我不打算在这里细讲, 这对初学者来说是个灾难. 但是一些技术的面试题里又特别喜欢扣这些细节\n因此, 我们先知道这里有坑, 再后续的面试准备课时, 我们会做一个专题专门来针对性的练习\n这些问题, 说实话, 在真实的工作中遇到的概率极低, 但是在面试中(尤其是笔试)中考查的很多. 不得不吐槽一下天朝的面试\n\n\n\n\n\n\n\n\n\n面试造航母, 上班拧螺丝\n通过几个例子, 大家先理解一些常用的\n\n\n\n\n\n\n\n\n\n示例\n+的隐式转换\n&#x2F;&#x2F; 只要+号的一边是字符, 最终的结果就是字符\nconsole.log(&#39;123&#39; + &#39;456&#39;) &#x2F;&#x2F; &#39;123456&#39;\nconsole.log(&#39;123&#39; + 456) &#x2F;&#x2F; &#39;123456&#39;\nconsole.log(&#39;123&#39; + true) &#x2F;&#x2F; &#39;123true&#39;\n\n&#x2F;&#x2F; 特殊\nundefined + 1 &#x2F;&#x2F; NaN\n\n==的隐式转换\n大体的原则是\n\n字符型 转换成 数字型\n布尔型 转换成 数字型\n\n\n\n\n\n\n\n\n\n\n示例\n&#39;1&#39; &#x3D;&#x3D; 1 &#x2F;&#x2F; true\ntrue &#x3D;&#x3D; 1 &#x2F;&#x2F; true\n&#39;1&#39; &#x3D;&#x3D; true &#x2F;&#x2F; true\n\n&#x2F;&#x2F; 特殊的\nNaN !&#x3D; NaN &#x2F;&#x2F; true\nundefined &#x3D;&#x3D; null &#x2F;&#x2F; true\n\n关于Boolean类型的转换\n空字符串(‘’), NaN, 0, null, undefined =&gt; false\n其余的全部 =&gt; true\n四. 运算符1 运算符的分类运算符（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号, 常用的有:\n\n 算数运算符\n 自增自减运算符\n 比较运算符\n 逻辑运算符\n 赋值运算符\n\n1) 表达式和返回值表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合\n简单理解：是由数字、运算符、变量等组成的式子\n表达式最终都会有一个结果，返回给开发者，称为返回值\n\n\n\n\n\n\n\n\n\n示例\n1 + 1 &#x2F;&#x2F; 是一个表达式, 返回值是2\n\nvar a &#x3D; 100\na + 100 &#x2F;&#x2F; 返回值是200\n\n1 &#x3D;&#x3D; &#39;1&#39; &#x2F;&#x2F; 返回值是true\n\n2 算数运算符算数运算符就是数学运算中的加减乘除\n\n\n\n运算符\n描述\n实例\n\n\n\n+\n加\n20 + 10 = 30\n\n\n-\n减\n20 - 10 = 10\n\n\n*\n乘\n20 * 10 = 200\n\n\n/\n除\n20 / 10 = 2\n\n\n%\n取模\n返回余数18 % 2 = 0 ; 15 % 2 = 1\n\n\n小数会存在精度丢失的问题\n0.1 + 0.2 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 0.30000000000000004\n\n\n因此, 不要直接拿小数进行比较!!!\n3 自增自减运算符自增自减都是对数字变量的操作\n\n\n\n\n\n\n\n\n\n示例\nvar num &#x3D; 1\nnum++\n++num\n\n下面这种是错误的\n1++\n\n1) 前置自增++num: 先+1, 再返回结果\nvar num &#x3D; 10\n++num &#x2F;&#x2F; 表达式返回11, 执行完后num的值是11\n\n2) 后置自增num++: 先返回结果, 再+1\nvar num &#x3D; 10\nnum++ &#x2F;&#x2F; 表达式返回10, 执行完后num的值是11\n\n\n\n\n\n\n\n\n\n\n练习\nvar a &#x3D; 10;\n++a; \nvar b &#x3D; ++a + 2;\nconsole.log(b);\n\nvar c &#x3D; 10;\nc++;\nvar d &#x3D; c++ + 2;\nconsole.log(d);\n\nvar e &#x3D; 10;\nvar f &#x3D; e++ + ++e;\nconsole.log(f);\n\n4 比较运算符比较运算符是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true / false）作为比较运算的结果\n\n\n\n运算符\n说明\n案例\n返回值\n\n\n\n&lt;\n小于\n1 &lt; 2\ntrue\n\n\n&gt;\n大于\n1 &gt; 2\nfalse\n\n\n&lt;=\n小于等于\n1 &lt;= 2\ntrue\n\n\n&gt;=\n大于等于\n1 &gt;= 2\nfalse\n\n\n==\n等于(会隐式转换)\n‘1’ == true\ntrue\n\n\n!=\n不等于\nNaN != NaN\ntrue\n\n\n===\n全等, 判断类型和值\n‘1’ === true\nfalse\n\n\n\n\n\n\n\n\n\n\n\n字符的比较\n字符的比较是按照ASCII码表依次比较的\n\n\n\n\n\n\n\n\n\n示例\n&#39;100&#39; &gt; &#39;99&#39; &#x2F;&#x2F; false\n100 &gt; 99 &#x2F;&#x2F; true\n\n\n\n5 逻辑运算符逻辑运算符是用来进行布尔值运算的运算符\n后面开发中经常用于多个条件判断\n\n\n\n运算符\n说明\n案例\n返回值\n\n\n\n&amp;&amp;\n逻辑与 and\n2&gt;1 &amp;&amp; 3 &gt;2\ntrue\n\n\n||\n逻辑或 or\n2&gt;1 || 3&gt;2\ntrue\n\n\n!\n逻辑非 not\n!true\nfalse\n\n\n1) 逻辑与全真为真, 一假为假\n\n\n\n案例\n返回值\n\n\n\ntrue &amp;&amp; true\ntrue\n\n\nfalse &amp;&amp; true\nfalse\n\n\ntrue &amp;&amp; false\nfalse\n\n\nfalse &amp;&amp; false\nfalse\n\n\n2) 逻辑或全假为假, 一真为真\n\n\n\n案例\n返回值\n\n\n\ntrue || true\ntrue\n\n\nfalse || true\ntrue\n\n\ntrue || false\ntrue\n\n\nfalse || false\nfalse\n\n\n3) 逻辑非真假互换\n\n\n\n案例\n返回值\n\n\n\n!true\nfalse\n\n\n!false\ntrue\n\n\n4) 短路运算当有多个表达式（值）做逻辑运算时\n第一个表达式值可以确定结果时,就不再继续运算后边的表达式的值\n\n逻辑与\n语法： 表达式1 &amp;&amp; 表达式2\n如果第一个表达式的值为真，则返回表达式2\n如果第一个表达式的值为假，则返回表达式1\n\nconsole.log( 123 &amp;&amp; 456 );        &#x2F;&#x2F; 456\nconsole.log( 0 &amp;&amp; 456 );          &#x2F;&#x2F; 0\nconsole.log( 123 &amp;&amp; 456 &amp;&amp; 789 ); &#x2F;&#x2F; 789\n逻辑或\n语法： 表达式1 || 表达式2\n如果第一个表达式的值为真，则返回表达式1\n如果第一个表达式的值为假，则返回表达式2\n\n &#x2F;&#x2F; 通常用来给默认值, 如\nfunction setName(name) &#123;\n  var uname &#x3D; name || &#39;&#39;\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\nvar num &#x3D; 0;\nconsole.log(123 || num++);\nconsole.log(num);\n\n\n\n\n\n\n\n\n\n\n练习\n判断是否为润年, 满足以下两个条件之一就是润年\n\n能被4整除且不能整除100\n能够被 400 整除\n\nvar year &#x3D; 2000\nvar res &#x3D; (year % 4 &#x3D;&#x3D; 0 &amp;&amp; year % 100 !&#x3D; 0) || (year % 400 &#x3D;&#x3D; 0)\n\n6 赋值运算符把数据赋值给变量的运算符\n\n\n\n运算符\n说明\n案例\n\n\n\n=\n赋值\nvar a = 100\n\n\n+=, -=\n加, 减一个数后再赋值\nvar age = 10; age += 5\n\n\n*=, /= ,%=\n乘, 除, 取模后再赋值\nvar a = 5; age *= 2\n\n\n7 运算符的优先级\n\n\n优先级\n运算符\n顺序\n\n\n\n1\n小括号\n()\n\n\n2\n一元运算符\n++ – !\n\n\n3\n算数运算符\n先 * / % 后 + -\n\n\n4\n关系运算符\n&gt; &gt;= &lt; &lt;=\n\n\n5\n逻辑运算符\n先 &amp;&amp; 后 ||\n\n\n6\n赋值运算符\n=\n\n\n五. 流程控制1 概念流程控制就是来控制代码按照一定结构顺序来执行\n主要有3种结构\n\n顺序\n条件\n循环\n\n程序的流程图, 可以通过使用processon在线编辑: ProcessOn\n\n2 顺序顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的\n3 条件根据不同的条件，执行不同的路径代码(执行代码多选一的过程) 从而得到不同的结果\n1) if语句\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; 条件成立执行代码，否则什么也不做\nif (条件表达式) &#123;\n    &#x2F;&#x2F; 条件成立执行的代码语句\n&#125;\n\n&#x2F;&#x2F; 条件成立  执行 if 里面代码，否则执行else 里面的代码\nif (条件表达式) &#123;\n    &#x2F;&#x2F; [如果] 条件成立执行的代码\n&#125; else &#123;\n    &#x2F;&#x2F; [否则] 执行的代码\n&#125;\n\n\n\n\n\n\n\n\n\n示例\nvar age &#x3D; prompt(&#39;请输入您的年龄:&#39;);\nif (age &gt;&#x3D; 18) &#123;\n  alert(&#39;已成年&#39;);\n&#125; else &#123;\n  alert(&#39;未成年&#39;);\n&#125;\n\n\n\n&#x2F;&#x2F; 适合于检查多重条件\nif (条件表达式1) &#123;\n    语句1\n&#125; else if (条件表达式2)  &#123;\n    语句2\n&#125; else if (条件表达式3)  &#123;\n   语句3\n ....\n&#125; else &#123;\n    &#x2F;&#x2F; 上述条件都不成立执行此处代码\n&#125;\n\n\n\n2) switch语句switch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码\n当要针对变量设置一系列的特定值的选项时，就可以使用 switch\nswitch( 表达式 )&#123; \n    case value1:\n        &#x2F;&#x2F; 表达式 等于 value1 时要执行的代码\n        break;\n    case value2:\n        &#x2F;&#x2F; 表达式 等于 value2 时要执行的代码\n        break;\n    default:\n        &#x2F;&#x2F; 表达式 不等于任何一个 value 时要执行的代码\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\n将数字1~7转换成星期一到星期天\nvar num &#x3D; prompt(&#39;请输入一个数字:&#39;)\nswitch (num) &#123;\n  case &#39;1&#39;:\n    alert(&#39;星期一&#39;)\n    break\n  case &#39;2&#39;:\n    alert(&#39;星期二&#39;)\n    break\n  case &#39;3&#39;:\n    alert(&#39;星期三&#39;)\n    break\n  case &#39;4&#39;:\n    alert(&#39;星期四&#39;)\n    break\n  case &#39;5&#39;:\n    alert(&#39;星期五&#39;)\n    break\n  case &#39;6&#39;:\n    alert(&#39;星期六&#39;)\n    break\n  case &#39;7&#39;:\n    alert(&#39;星期天&#39;)\n    break\n  default:\n    alert(&#39;输入有误, 请输入1~7的数字&#39;)\n&#125;\n\n4 循环重复多次执行有规律的代码, 可以使用循环来表示, 通过一个变量可以记录第几次循环, 已经循环的总次数\n1) for循环\n\n\n\n\n\n\n\n\n语法\nfor(初始化变量; 条件表达式; 操作表达式 )&#123;\n    &#x2F;&#x2F;循环体\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 基本写法\nfor(var i &#x3D; 1; i &lt;&#x3D; 10; i++)&#123;\n    console.log(&#39;媳妇我错了~&#39;)\n&#125;\n&#x2F;&#x2F; 用户输入次数\nvar num &#x3D; prompt(&#39;请输入次数:&#39;)\nfor (var i &#x3D; 1 ; i &lt;&#x3D; num; i++) &#123;\n    console.log(&#39;媳妇我错了~&#39;)\n&#125; \n\n\n\n\n\n\n\n\n\n\n示例\n累加求和\nvar sum &#x3D; 0\nfor(var i&#x3D;1; i&lt;&#x3D;10; i++) &#123;\n  sum +&#x3D; i\n&#125;\nconsole.log(sum)\n\n\n\n\n\n\n\n\n\n\n练习\n提示用户输入两个数, 计算累加求和\nvar num1 &#x3D; parseInt(prompt(&#39;请输入第一个数&#39;))\nvar num2 &#x3D; parseInt(prompt(&#39;请输入第二数&#39;))\n\nvar sum &#x3D; 0\nfor (var i &#x3D; num1; i &lt;&#x3D; num2; i++) &#123;\n  sum +&#x3D; i\n&#125;\nalert(&#39;从&#39; + num1 + &#39;到&#39; + num2 + &#39;的和是: &#39; + sum)\n\n在for循环中, 可以使用if和for循环\n\n\n\n\n\n\n\n\n\n示例\n分别求1~100的奇数和, 偶数和\nvar even &#x3D; 0;\nvar odd &#x3D; 0;\nfor (var i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;\n  if (i % 2 &#x3D;&#x3D; 0) &#123;\n    even &#x3D; even + i;\n  &#125; else &#123;\n    odd &#x3D; odd + i;\n  &#125;\n&#125;\nconsole.log(&#39;1~100 之间所有的偶数和是&#39; + even);\nconsole.log(&#39;1~100 之间所有的奇数和是&#39; + odd);\n\n\n\n\n\n\n\n\n\n\n示例\n 打印3行3列的星星\nvar star &#x3D; &#39;&#39;;\nfor (var j &#x3D; 1; j &lt;&#x3D; 3; j++) &#123;\n    for (var i &#x3D; 1; i &lt;&#x3D; 3; i++) &#123;\n      star +&#x3D; &#39;☆&#39;\n    &#125;\n    &#x2F;&#x2F; 每次满 3个星星 就 加一次换行\n    star +&#x3D; &#39;\\n&#39;\n&#125;\nconsole.log(star);\n\n\n\n\n\n\n\n\n\n\n练习\n打印n行m列的星星\n&#x2F;&#x2F; 打印n行m列的星星\nvar rows &#x3D; prompt(&#39;请您输入行数:&#39;);\nvar cols &#x3D; prompt(&#39;请您输入列数:&#39;);\nvar str &#x3D; &#39;&#39;;\nfor (var i &#x3D; 1; i &lt;&#x3D; rows; i++) &#123;\n  for (var j &#x3D; 1; j &lt;&#x3D; cols; j++) &#123;\n    str &#x3D; str + &#39;★&#39;;\n  &#125;\n  str +&#x3D; &#39;\\n&#39;;\n&#125;\nconsole.log(str);\n\n\n\n\n\n\n\n\n\n\n示例\n打印9*9乘法表\nvar str &#x3D; &#39;&#39;;\nfor (var i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123; &#x2F;&#x2F; 外层循环控制行数\n  for (var j &#x3D; 1; j &lt;&#x3D; i; j++) &#123; &#x2F;&#x2F; 里层循环控制每一行的个数  j &lt;&#x3D; i\n    str +&#x3D; j + &#39;×&#39; + i + &#39;&#x3D;&#39; + i * j + &#39;\\t&#39;;\n  &#125;\n  str +&#x3D; &#39;\\n&#39;;\n&#125;\nconsole.log(str);\n\n2) while循环\n\n\n\n\n\n\n\n\n语法\nwhile (条件表达式) &#123;\n  &#x2F;&#x2F; 当...条件满足时, 一直执行循环体\n  &#x2F;&#x2F; 循环体代码 \n&#125;\n\ndo…while\ndo &#123;\n    &#x2F;&#x2F; 循环体代码 - 条件表达式为 true 时重复执行循环体代码\n&#125; while(条件表达式);\n\n当条件满足时, 执行\n区别是do…while会先执行一次, 再判断\n3) 跳出循环continue: 跳出当前循环\nbreak: 跳出整个循环\n\n\n\n\n\n\n\n\n\n示例\nfor (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;\n  if (i &#x3D;&#x3D; 3) &#123;\n    console.log(&#39;这个包子有虫子，扔掉&#39;);\n    continue; &#x2F;&#x2F; 跳出本次循环，跳出的是第3次循环 \n  &#125;\n  console.log(&#39;我正在吃第&#39; + i + &#39;个包子呢&#39;);\n&#125;\n\nfor (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;\n  if (i &#x3D;&#x3D; 3) &#123;\n    console.log(&#39;发现半条虫子，再也吃不下了&#39;);\n    break; &#x2F;&#x2F; 直接退出整个for 循环，跳到整个for下面的语句\n  &#125;\n  console.log(&#39;我正在吃第&#39; + i + &#39;个包子呢&#39;);\n&#125;\n\n六. 数组1 基本概念1) 定义数组数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式\n\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F;1. 使用[]创建空数组\nvar  数组名 &#x3D; []；\n&#x2F;&#x2F;2. 在创建数组时, 给初始值\nvar  数组名 &#x3D; [&#39;小白&#39;,&#39;小黑&#39;,&#39;小胖&#39;];\n\n数组中可以存放任意类型的数据，例如字符串，数字，布尔值等\n\n\n\n\n\n\n\n\n\n示例\nvar arr &#x3D; [&#39;小小胖&#39;,12,true,28.9]\n\n2) 访问数组元素通过下标(索引)访问数组元素, 下标从0开始\nconsole.log(arr[0])\n\n3) 添加数组元素\n\n\n\n\n\n\n\n\n示例\nvar arr &#x3D; [&#39;小小胖&#39;, 12, true, 28.9]\narr[4] &#x3D; &#39;newValue&#39;\narr[6] &#x3D; &#39;第7个值&#39;\nconsole.log(arr) &#x2F;&#x2F; 数组的长度为7\nconsole.log(arr[5]) &#x2F;&#x2F; undefined\n\n4) 删除数组元素\n\n\n\n\n\n\n\n\n示例\ndelete arr[1] &#x2F;&#x2F; 删除数组元素, 不改变数组长度\nconsole.log(arr)\n\n2 遍历\n\n\n\n\n\n\n\n\n遍历: 依次访问数组的每一个元素\nvar arr &#x3D; [&#39;red&#39;,&#39;green&#39;, &#39;blue&#39;];\nfor(var i &#x3D; 0; i &lt; arr.length; i++)&#123;\n    console.log(arr[i]);\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\n求数组中的最大值\nvar arr &#x3D; [1, 2, 11, 3, 4]\n\nvar max &#x3D; arr[0]\nfor (var i &#x3D; 0; i &lt; arr.length; i++) &#123;\n  if (arr[i] &gt;&#x3D; max) &#123;\n    max &#x3D; arr[i]\n  &#125;\n&#125;\nconsole.log(max)\n\n3 多维数组如果一个数组a的一个元素也是一个数组, 数组a就叫多维数组\n\n\n\n\n\n\n\n\n\n示例\nvar arr &#x3D; [1, 2, [&#39;xiaopang&#39;, &#39;小小胖&#39;]]\n&#x2F;&#x2F; 如何获得小小胖的值\nconsole.log(arr[2][1])\n\n七. 函数1 基本概念可能会有非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用\n我们把实现特定功能的代码块叫做一个函数\n\n函数可以需要的任何时候调用\n函数不调用不执行\n\n1) 函数声明\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; 声明函数\nfunction 函数名() &#123;\n    &#x2F;&#x2F;函数体代码\n&#125;\n\n2) 调用函数\n\n\n\n\n\n\n\n\n语法\n函数名();\n\n\n\n\n\n\n\n\n\n\n示例\n将累加求和的功能\n封装成一个函数, 求1到100和\n&#x2F;&#x2F; 声明函数\nfunction getSum()&#123;\n  var sumNum &#x3D; 0;&#x2F;&#x2F; 准备一个变量，保存数字和\n  for (var i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;\n    sumNum +&#x3D; i;&#x2F;&#x2F; 把每个数值 都累加 到变量中\n  &#125;\n  alert(sumNum);\n&#125;\n&#x2F;&#x2F; 调用函数\ngetSum();\n\n2 参数参数可以使函数实现更加强大的功能\n1) 实参与形参\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; 带参数的函数声明\nfunction 函数名(形参1, 形参2 , 形参3...) &#123; &#x2F;&#x2F; 可以定义任意多的参数，用逗号分隔\n  &#x2F;&#x2F; 函数体\n&#125;\n&#x2F;&#x2F; 带参数的函数调用\n函数名(实参1, 实参2, 实参3...); \n\n\n形参: 函数声明时参数\n实参: 函数调用时参数\n\n2) 传参的过程传参的过程就是赋值的过程, 将实参的值赋值给形参\n\n\n\n\n\n\n\n\n\n示例\n进一步改造, 计算从n到m的和\n&#x2F;&#x2F; 声明函数\nfunction getSum(n, m)&#123;\n  var sumNum &#x3D; 0;&#x2F;&#x2F; 准备一个变量，保存数字和\n  for (var i &#x3D; n; i &lt;&#x3D; m; i++) &#123;\n    sumNum +&#x3D; i;&#x2F;&#x2F; 把每个数值 都累加 到变量中\n  &#125;\n  alert(sumNum);\n&#125;\n&#x2F;&#x2F; 调用函数\ngetSum(5, 10);\n\n3 返回值一般一个函数在调用后, 会产生一个固定的结果, 一般将结果返回出来, 具体要怎么使用这个结果, 不是由函数决定的. 这就是编程里的”单一职责”原则\n进一步改造\n&#x2F;&#x2F; 声明函数\nfunction getSum(n, m)&#123;\n  var sumNum &#x3D; 0;&#x2F;&#x2F; 准备一个变量，保存数字和\n  for (var i &#x3D; n; i &lt;&#x3D; m; i++) &#123;\n    sumNum +&#x3D; i;&#x2F;&#x2F; 把每个数值 都累加 到变量中\n  &#125;\n  return sumNum\n&#125;\n&#x2F;&#x2F; 调用函数\nvar res &#x3D; getSum(5, 10)\nalert(res)\nconsole.log(res)\n\n尝试封装一些函数\n\n求n到m的奇数和\n封装一个函数求n到m的平均值\n封装一个函数求数组中的最大值\n\n八. 对象1 类和对象1) 对象的概念\n\n\n\n\n\n\n\n\n对象: 一个具体的实体\n在现实世界中, 对象随处可见, 一个人,  一个学生, 一个杯子, 一辆汽车, 游戏里的一个英雄… 都是一个对象\n2) 对象的组成\n\n\n\n\n\n\n\n\n如何描述一个对象呢\n比如, \n\n每个人都有姓名, 年龄, 性别这些特征. \n游戏里的英雄都有生命值, 攻击力, 防御力这些特征.\n\n对象除了这些特征外, 还有一些行为/动作\n比如, \n\n人可以吃饭, 睡觉    \n游戏里的英雄可以移动, 可以放技能\n\n在程序里,\n\n把对象的特征叫做==属性==, 使用变量来描述\n把对象的行为叫做==方法==, 使用函数来描述\n\n因此, 我们得出一个重要结论:\n\n\n\n\n\n\n\n\n\n对象是由属性和方法组成的!!\n3) 类的概念\n\n\n\n\n\n\n\n\n类: 具有相同特征的事物的集合\n我们把具有相同特征和行为的实体抽象出来, 就形成了一个类. \n比如: 把人集合在一起, 就形成了人类, 把王者荣耀里的英雄集合起来, 就形成了英雄类\n\n每一个人类都有一些相同的特征, 比如: 姓名, 性别, 年龄, 身高, 体重…等\n每一个英雄也有一些相同的特征, 比如: 生命值, 攻击力, 防御力…等\n\n4) 程序中的类与对象\n\n\n\n\n\n\n\n\n那么如何使用程序来描述这些相同的特征呢?\n可以定义一个模板/规范/设计图纸, 然后通过这个模板/规范/设计图纸来==生产==一个个的实体. \n比如: 我们可以通过宝马车的设计图纸来生产一辆宝马车\n\n\n我们把定义的这个模板叫做==类==\n把生产出来的实体叫做==对象==\n把生产的过程叫做==实例化==\n\n5) 类和对象的关系类和对象的关系, 可以认为是==整体和个体, 抽象和具体的关系==\n通过上面的描述, 总结起来说, 就是\n\n类是对象的集合\n对象是类的实例化\n\n6) 小结\n对象是由属性和方法组成的\n属性就是变量, 方法就是函数\n类是对象的集合, 对象是类的实例化\n\n补充: 由于类是对象的集合, 通常我们也可以说类由属性和方法组成~\n2 初步认识JS中的类和对象1) 构造函数的定义在JS中, 没有类(class)的概念, 主要是通过构造函数来模拟的.[^1]\n\n\n\n\n\n\n\n\n\n语法\nfunction 构造函数名 () &#123;\n    &#x2F;&#x2F; 函数体\n&#125;\n\n\n使用function关键字表示定义一个构造函数\n构造函数名一般==首字母大写==\n\n\n\n\n\n\n\n\n\n\n示例: 2-1构造函数的定义.html\nfunction Person() &#123;\n    \n&#125;\n\n通过以上方式就可以定义一个Person构造函数, 相当于定义好了一个Person类\n2) 构造函数的作用通过构造函数实例化对象在JS中, 我们通过构造函数(类)来实例化对象\n\n\n\n\n\n\n\n\n\n语法\nnew 构造函数名()\n\n\n\n\n\n\n\n\n\n\n示例: 2-2通过构造函数实例化对象.html\n&#x2F;&#x2F; 一. 定义一个构造函数\nfunction Person() &#123;\n    \n&#125;\n&#x2F;&#x2F; 二. 实例化一个对象, 赋值给变量p\nvar p &#x3D; new Person();\nconsole.log(typeof p); &#x2F;&#x2F; object\n\n以上代码\n\n通过new关键字, 产生了一个对象, 并赋值给变量p\n通过typeof p测试变量p的类型为object, 说明p是一个对象\n\n在构造函数中定义属性\n\n\n\n\n\n\n\n\n构造函数规定了由该类实例化出来的对象应该包含哪些属性\n比如, 由学生类实例化出来的学生对象都应该有姓名, 年龄这些属性\nfunction Student () &#123;\n    this.uname &#x3D; null;\n    this.age &#x3D; null;\n&#125;\n\n在构造函数的内部, 我们通过this.属性名的方式来定义属性\n在这里, 大家先把这个看作固定写法, 后面我们再具体分析\n\n\n\n\n\n\n\n\n\n构造函数虽然可以规定实例对象应该包含哪些属性, 但是并不能确定实例对象的属性值\n比如 人类都应该有名字这个属性, 但是具体叫什么名字, 只有在一个人出生的时候才去确定\n因此, 在实例化对象的时候, 需要将具体的数据传递给构造函数\n\n\n\n\n\n\n\n\n\n示例: 2-3在构造函数中定义属性.html\n&#x2F;&#x2F; 一. 定义一个学生类\nfunction Student(n, a) &#123;\n    this.uname &#x3D; n;\n    this.age &#x3D; a;\n&#125;\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\n\n\n\n\n\n\n\n\n\n\n重要结论\n​    ==构造函数主要完成属性的初始化!!!==\n\n\n\n\n\n\n\n\n\n练习\n一. 通过构造函数Phone定义一个手机类, 包含型号(type), 价格(price), 颜色(color), 屏幕大小(size)\n二. 实例化两个对象\n\n一个iphone对象, 型号: iphoneX, 价格: 6999, 颜色: 土豪金, 屏幕大小: 5.8英寸\n一个huawei对象, 型号:p30 pro, 价格: 5988, 颜色: 极光蓝, 屏幕大小: 6.1英寸\n\n\n\n\n\n\n\n\n\n\n参考答案\n&#x2F;&#x2F; 一. 定义手机类\nfunction Phone(type, price, color, size) &#123;\n    &#x2F;&#x2F; 属性\n    this.type &#x3D; type;\n    this.price &#x3D; price;\n    this.color &#x3D; color;\n    this.size &#x3D; size;\n&#125;\n&#x2F;&#x2F; 二. 实例化对象\nvar iphone &#x3D; new Phone(&#39;iphoneX&#39;, 6999, &#39;土豪金&#39;, &#39;5.8英寸&#39;);\nvar huawei &#x3D; new Phone(&#39;p30 pro&#39;, 5988, &#39;极光蓝&#39;, &#39;6.1英寸&#39;);\n\n\n\n\n\n\n\n\n\n\n作业\n一.通过构造函数Hero定义一个英雄类, 包含血量(HP), 类型(type), 攻击力(attack)\n二.实例化两个对象\n\n一个lianpo对象, 血量:700, 类型: 力量型, 攻击力: 70\n一个houyi对象, 血量:300, 类型: 射手, 攻击力: 130\n\n3) 小结\n通过构造函数定义类(规定应该包含哪些属性名)\n通过new实例化对象(在实例化时, 确定属性值)\n构造函数主要完成==属性==的初始化\n\n3 对象的方法1) 方法的定义与使用我们已经知道\n\n类由属性和方法组成\n在JS中, 通过构造函数定义类\n在构造函数中可以通过this.属性名定义属性\n\n那么, 在构造函数中是否也可以通过this.方法名定义方法呢?\n在构造函数中定义方法\n\n\n\n\n\n\n\n\n示例: 3-1在构造函数中定义方法.html\n按照之前的方式, 尝试编写如下代码\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; function () &#123;\n    console.log(&#39;大家好&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n\nuname和age是属性\nsayHi是方法, 方法就是一个==函数==\n\n方法的使用(调用)\n\n\n\n\n\n\n\n\n语法\n对象.方法名()\n\n\n由于方法就是一个函数, 在后面加小括号表示方法的调用\n\n\n\n\n\n\n\n\n\n\n示例: 3-2调用对象的方法.html\n&#x2F;&#x2F; 三. 调用方法 -- 对象.方法名()\nstu.sayHi(); &#x2F;&#x2F; 大家好\n\n2) 存在的问题虽然可以在构造函数中定义方法, 但是一般不这么做, 为什么呢?\n看如下示例:\n\n\n\n\n\n\n\n\n\n示例: 3-3为什么不在构造函数中定义方法.html\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; function () &#123;\n    console.log(&#39;大家好&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; 三.判断stu.sayHi &#x3D;&#x3D;&#x3D; stu1.sayHi ?\nconsole.log(stu.sayHi &#x3D;&#x3D;&#x3D; stu1.sayHi); &#x2F;&#x2F;false\n\n\n上面这个比较表示stu对象和stu1对象的sayHi方法在内存中的首地址是不同的!!!\n\n我们发现\nfunction () &#123;\n  console.log(&#39;大家好&#39;);\n&#125;\n\n这段代码是相同的, 但是在每次实例化新对象时, 都会分配新的内存空间, 造成浪费.\n3) 小结\n一般不在构造函数中定义方法, 为什么?\n方法的调用语法: 对象.方法名()\n\n4 对象实例化原理分析1) 引用数据类型对象是一种特殊的数据, 看如下代码\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 定义一个学生类\nfunction Student(n, a) &#123;\n    this.uname &#x3D; n;\n    this.age &#x3D; a;\n&#125;\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\n\n\n这里并不是把所有的数据直接保存在变量中\n而是先在堆区开辟一个空间, 把这个空间的引用保存在变量中. \n在js中, ==函数==和==对象==都是引用数据类型\n\n\n这里有个词–”==引用==”\n\n\n\n\n\n\n\n\n\n什么是引用呢, 引用有什么用呢?\n一句话解释: ==引用就是来找数据的==\n类似于路径的概念, 就像我们可以通过路径E:\\docment\\image\\img.jpg找到电脑中的一个文件, \n又或者酒店的房间号, 通过房间号就可以找到房间\n通过引用就可以找到内存中的数据.\n引用本质上是内存首地址. 通过这个地址就可以找到对应的内存空间, 进而获取数据\n2) new实例化的过程\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 定义一个学生类\nfunction Student(n, a) &#123;\n    this.uname &#x3D; n;\n    this.age &#x3D; a;\n&#125;\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\n\n\n当代码执行到行7行时. \n\n在堆内存中开辟一段内存空间, 假设这段内存空间是从0x1111~0x2000\n因此通过0x1111就可以找到对应的这段内存空间, 进而获取其中的数据\n\n将0x1111保存在this中, 我们也可以说让this指向这个空间\n\n执行函数. 通过this=0x1111找到内存空间, 在这个空间中保存数据name:xiaoming,age:20\n\n最后, 将0x1111返回, 保存在stu中\n\n\n\n\n\n\n\n\n\n\n\n练习\n如果再实例化一个对象stu1, (假设内存地址是0x2222), 画出实例化的过程\n&#x2F;&#x2F; 一. 定义一个学生类\nfunction Student(n, a) &#123;\n    this.uname &#x3D; n;\n    this.age &#x3D; a;\n&#125;\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n\n\n\n\n\n\n\n\n\n参考答案\n\n这样, 我们就可以通过一个模板(Student构造函数)得到多个不同的对象(stu对象和stu1对象). 对象中保存的数据也不一样.\n3) 为什么不在构造函数中定义方法我们在上面的基础上进一步深入.\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; function () &#123;\n    console.log(&#39;大家好&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n上述代码的图解如下:\n\n这就解释了我们前面的问题. 虽然sayHi方法的代码是相同的, 但是每次实例化时会开辟一个新的内存空间, 造成浪费. \n4) 初步解决既然方法是相同的, 我们可不可以单独定义一个函数赋值给sayHi呢?\n\n\n\n\n\n\n\n\n\n示例: 4-1初步解决方法定义.html\n&#x2F;&#x2F; 初步解决方案\n\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; sayHi;\n&#125;\n\nfunction sayHi() &#123;\n  console.log(&#39;大家好&#39;);\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n上述代码图解如下:\n\n这样做确实可以解决, 但是这种做法很奇怪. 一般也不会使用, 为什么这么说呢. \n照理说, sayHi函数应该仅仅是属于Student类. 只有通过Student类实例化出来的对象可以调用. 而如果把sayHi放在全局下. 可以当成普通函数调用. 因此, 我们称这种做法破坏了类的封装性. \n\n\n\n\n\n\n\n\n\n什么是封装性?\n​    ==类的成员尽量封闭在类的内部, 隐藏细节与实现==\n看下面这个示例\n\n\n\n\n\n\n\n\n\n示例: 4-2初步解决方案带来的问题.html\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; sayHi;\n&#125;\n\nfunction sayHi() &#123;\n  console.log(&#39;大家好, 我叫&#39;+this.uname);\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; 使用对象调用可以得到希望的结果\nstu.sayHi(); &#x2F;&#x2F; 大家好, 我叫xiaoming\n\n&#x2F;&#x2F; 当普通函数直接调用, 会得到&#39;奇怪&#39;的结果\nsayHi(); &#x2F;&#x2F; 大家好, 我叫undefined\n\n为什么会出现这种’奇怪’的现象. 要搞明白这个问题, 就要了解js中的this指向[^2]\n5) 初步了解this指向为了搞清楚构造函数中的this, 我们还是先通过图解的方式来分析\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; sayHi;\n&#125;\n\nfunction sayHi() &#123;\n  console.log(&#39;大家好, 我叫&#39;+this.uname);\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; 使用对象调用可以得到希望的结果\nstu.sayHi(); &#x2F;&#x2F; 大家好, 我叫xiaoming\n\n\n\n\n\n\n\n\n\n\n图解\n\n通过上面的分析. 我们至少可以得出这样的结论\n\nthis也是一种引用数据类型\nthis的指向是在函数调用时确定的\n\n上述代码, 更为准确的写法是\n\n\n\n\n\n\n\n\n\n示例: \n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; sayHi;\n&#125;\n\nfunction sayHi() &#123;\n  console.log(&#39;大家好, 我叫&#39;+this.uname);\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; call表示调用函数, 并确定this指向stu对象\nstu.sayHi.call(stu); &#x2F;&#x2F; 大家好, 我叫xiaoming\n\n\n\n\n\n\n\n\n\n\n思考: 4-3思考题答案.html\n​    如果在调用sayHi的时候, 让this指向stu1, 大家思考一下会得到什么结果\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; sayHi;\n&#125;\n\nfunction sayHi() &#123;\n  console.log(&#39;大家好, 我叫&#39;+this.uname);\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; call表示调用函数, 并规定this指向stu1对象\nstu.sayHi.call(stu1); &#x2F;&#x2F; ???\n\n\n\n\n\n\n\n\n\n\n思考题答案\n​    大家好, 我叫xiaomei\n过程分析\n\n通过stu找到0x1111\n调用sayHi函数\n确定this指向stu1\n通过this找到this.uname, 也就是stu1.uname等于xiaomei\n\n最后, 我们分析把sayHi当普通函数调用的过程\n如果把sayHi当普通函数调用, 相当于在全局对象(在浏览器环境中是window)添加了属性和方法\n因此, 更准确的写法如下\n\n\n\n\n\n\n\n\n\n示例: 4-4当做普通函数调用.html\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; sayHi;\n&#125;\n\nfunction sayHi() &#123;\n  console.log(&#39;大家好, 我叫&#39;+this.uname);\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; call表示调用函数, 并确定this指向window对象\n&#x2F;&#x2F; 在window对象中并没有uname这个属性, 因此值为undefined\nwindow.sayHi()\nsayHi.call(window); &#x2F;&#x2F; 大家好, 我叫undefined\n\n\n\n\n\n\n\n\n\n\n思考\n​    如果我们人为在window中添加一个uname属性会怎样呢?\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; sayHi;\n&#125;\n\nfunction sayHi() &#123;\n  console.log(&#39;大家好, 我叫&#39;+this.uname);\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; 定义一个全局变量, 相当于在window对象中添加了一个uname属性\nvar uname &#x3D; &#39;全局uname&#39;;\nsayHi(); &#x2F;&#x2F; 大家好, 我叫全局uname\n\n5 原型前面, 我们了解到属性可以定义在构造函数中, 但是==方法的定义==没有很好的解决方案. \n为了解决这个问题, 提出了原型模式\n或者, 换句话说: ==原型的产生主要是为了解决方法共享的问题==\n1) 什么是原型模式系统在创建构造函数的同时, 会自动在内存中生成一个与之相应的对象, 这个对象就是原型对象\n比如: \n&#x2F;&#x2F; 定义一个构造函数\nfunction Person() &#123;&#125;\n\n系统在创建Person构造函数的同时, 自动在内存中生成一个与之对应的Person原型对象\n\n由上图可知, 构造函数与原型对象是两个独立的内存空间\n2) 构造函数与原型对象的关系他们是相对独立的. 但是又存在联系\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 构造函数\nfunction Person(n) &#123;\n  this.uname &#x3D; n;\n&#125;\n&#x2F;&#x2F; 二. 打印构造函数的结构\nconsole.dir(Person);\n\n在Person构造函数的内部存在一个属性 prototype指向Person的原型对象\n在Person原型对象的内部也存在一个属性constructor指向Person的构造函数\n\n证明Person构造函数中存在prototype属性\n\n由上图可知, Person构造函数中, 确实存在prototype属性, 该属性指向一个对象\n3) 实例对象与原型对象的关系在由Person类实例化出来的对象person1和person2中也有一个属性__proto__(隐式原型)指向原型对象\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 构造函数\nfunction Person(n) &#123;\n  this.uname &#x3D; n;\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar person1 &#x3D; new Person(&#39;xiaoming&#39;);\nvar person2 &#x3D; new Person(&#39;xiaomei&#39;);\n\n&#x2F;&#x2F; 三. 打印person1和person2的内部结构\nconsole.dir(person1);\nconsole.dir(person2);\n\n\n\n\n\n\n\n\n\n\n证明\n由Person实例化出来的实例对象person1中存在__proto__属性指向Person的原型对象\n\n4) 三者的关系构造函数的prototype属性和实例对象的__proto__属性指向同一个对象\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 定义构造函数\nfunction Person(n) &#123;\n  this.uname &#x3D; n;\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar p &#x3D; new Person(&#39;xiaoming&#39;);\n\n&#x2F;&#x2F; 三. 测试\nconsole.log(Person.prototype &#x3D;&#x3D;&#x3D; p.__proto__); &#x2F;&#x2F; true\n\n\n\n\n\n\n\n\n\n\n图解\n\n5) 使用原型定义方法我们先大致了解下如何通过原型模式定义方法, 再具体分析\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 在构造函数中定义属性\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n&#125;\n\n&#x2F;&#x2F; 二. 在原型中定义方法\nStudent.prototype.sayHi &#x3D; function () &#123;\n  console.log(&#39;大家好, 我叫&#39;+this.uname);\n&#125;\n\n&#x2F;&#x2F; 三. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; 比较不同的对象的方法是否相同\nconsole.log(stu.sayHi &#x3D;&#x3D;&#x3D; stu1.sayHi); &#x2F;&#x2F; true\n&#x2F;&#x2F; 我们发现stu中并没有sayHi这个方法, 但是为什么可以使用呢?\n\n6) 小结\n在构造函数中定义属性\n在原型对象中定义方法\n\n九. 常用的内置对象1 常用的内置对象\nMath对象\nDate对象\n字符串对象\n数组对象\n\n\n\n\n\n\n\n\n\n\n学习方法\n查文档! 查文档! 查文档!\n学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN/W3C来查询。        Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。        MDN:https://developer.mozilla.org/zh-CN/\n2 Math对象的常用方法\n\n\n方法名\n功能\n\n\n\nMath.floor()\n向下取整\n\n\nMath.max()/Math.min()\n求最大和最小值\n\n\nMath.random()\n获取范围在[0,1)内的随机值\n\n\n3 Date对象的常用方法\n\n\n方法名\n功能\n\n\n\ngetFullYear()\n获取年份\n\n\ngetMonth()\n获取月份(0~11)\n\n\ngetDate()\n获取日期(1~31)\n\n\ngetDay()\n获取星期(0~6)\n\n\ngetHours()\n获取小时\n\n\ngetMinutes()\n获取分钟\n\n\ngetSeconds()\n获取秒\n\n\n4 数组对象的常用方法\n\n\n方法名\n功能\n返回值\n\n\n\npush()\n在末尾添加元素\n新数组的长度\n\n\npop()\n删除最后一个元素\n删除的元素的值\n\n\nslice()\n截取子数组\n新数组\n\n\nsplice()\n通常用于删除某个指定元素\n新数组\n\n\n5 JSON对象的常用方法\n\n\n方法名\n功能\n返回值\n\n\n\nJSON.parse(str)\n将JSON字符串转换成JS对象\nJS对象\n\n\nJSON.stringify(obj, null, 2)\n将 JS 对象转换为 JSON 字符串\nJSON字符串\n\n\n","slug":"JavaScript基础","date":"2022-12-01T11:51:08.408Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"8bc067569f8f6351f0ef53903883b0a2","title":"11_js变量_数据类型_运算符","content":"概念及入门概念\n\t一种运行在客户端的脚本语言(script脚本意思)\n作用\n\t表单的动态校验\n\t网页的特效(轮播图)\n\t服务端的开发(nodejs)\n\t桌面程序\n\t控制硬件-物联网\n组成\n\tECMAScript 基础语法\n\tDOM 文档数据模型\n\tBOM 浏览器数据模型\n书写方式\n\t1,内嵌式\n\t\t在html页面中创建一个script标签,将js代码放进去\n\t2,外链式\n\t\t新建一个js文件,把js代码放进去\n\t\t以后需要用的时候,使用script标签引入就行,提高了代码的复用性\n注释\n\t单行注释\n\t\t&#x2F;&#x2F;\n\t多行注释\n\t\t&#x2F;* *&#x2F;\n输入输出\n\t输入\n\t\tprompt(内容)\n\t输出\n\t\talert()\n\t\tconsole.log()\n\t\tdocument.write()\n\n\n\n变量概念\n\t本质就是内存中存取数据的那一块空间(容器)\n作用\n\t存储变化的数据\n使用\n\t1,先声明在赋值\n\t2,声明的同时再赋值\n特点\n\t里面的数据可以修改\n注意点\n\t1,不能以数字开头(必须以字母开头,以 $ 和 _ 符号开头不推荐)\n\t2,严格区分大小写\n\t3,不能是关键字或者保留字\n\t4,尽量的见名知意\n\n\n\n数据类型作用\n\t给数据进行分类,方便管理\n分类\n\t基本数据类型\n\t\tnumber 数值\n\t\tString 字符串\n\t\tboolean 布尔型\n\t\tundefined 未定义\n\t\tnull 空\n\t引用数据类型\n\t\t类\n\t\t数组\n\t\t日期,正则\n转换\n\t强制转换\n\t\tString() 转换为字符串\n        Number() 转换为数字\n        Boolean() 转换为布尔值。\n        \t可以将0 null undefined &#39;&#39;(空字符串)会被转成false,其他转成true\n        \t\n    自动转换\n    \t任意类型的数据加上字符串都会被转成字符串\n        true,false,null和数值进行运算的时候,都会被转成数值\n        \n    + 运算的规律\n        如果+两端有一段是字符串,就会执行字符串的拼接\n        如果+两端都不是字符串,就会默认使用Number()进行强转,然后进行加法运算\n\n运算符算术运算符\n\t+ - * &#x2F;  %\n\t% 取的两个数相除的余数\n\t\n自增自减运算符\n\t++在前,先变量+1,然后在返回计算后的结果\n\t++在后,先把变量的值返回,然后变量再加1\n\t\n\t不管++在前还是在后,最终变量的值都会加1\n\t\n比较运算符\n\t&gt; &lt; &gt;&#x3D; &lt;&#x3D; !&#x3D; &#x3D;&#x3D;\n\t结果是boolean类型\n\n逻辑运算\n\t&amp;&amp; || !\n\t结果是Boolean类型\n\n赋值运算符\n\t基本 &#x3D;\n\t复合 +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;\n\t\t\t\n三元运算符\n\t表达式1 ? 表达式2 : 表达式3\n\n\n\n","slug":"day11_课堂笔记","date":"2022-12-01T11:48:38.759Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"e994d58426d1973329baeeb9f5fd4931","title":"08_旋转_动画_flex布局","content":"昨日回顾定位\n\t概念\n\t\t布局方式,盒子层叠,固定显示\n\t使用\n\t\t定位方式\n\t\t设置偏移值\n\t分类\n\t\t相对定位\n\t\t\t相对于自身\n\t\t\t原点:原来的左上角的位置\n\t\t\t不脱标\n\t\t绝对定位\n\t\t\t相对于最近有定位祖先元素\n\t\t\t原点:定位祖先元素左上角(都没有,就是body左上角)\n\t\t\t脱标\n\t\t固定定位\n\t\t\t相对于body的左上角\n\t\t\t原点:body的左上角\n\t\t\t脱标\n\t应用\n\t\t子绝父相\nvertical-align\n\t概念\n\t\t设置行内元素,行内块元素垂直对齐方式\n\t取值\n\t\tbaseline\n\t\ttop\n\t\tbottom\n\t\tmiddle\n\t应用\n\t\timg撑开div之后,底部有间隙\n\t\timg垂直居中问题(只设置line-height&#x3D;父元素高度不行的)\noverflow\n\t概念\n\t\t控制内容区域超出之后的显示效果\n\t取值\n\t\thidden\n\t\tauto\n元素隐藏\n\tdisplay none 不占位置\n\tvisibility hidden 占位置\n字体图标\n\t本质是字体,用于页面中一些小的标签\n\t使用\n\t\t拖入字体包\n\t\t引入字体样式\n\t\t调用类名去显示\n\nCSS新特性过渡\n\t语法\n\t\ttransition: 属性名或者all 过渡时间\n\t注意\n\t\t过渡属性一般写在过渡元素上面\n\t\t\n位移\n\t语法\n\t\ttransform:translateX()  x轴\n\t\ttransform:translateY()  y轴 --- 可能会覆盖上面的\n\t\ttransform:translate(x轴,y轴) --  避免被覆盖\n\t注意\t\n    \t使用百分比,是相对于他自身\n旋转\n\t语法\n\t\ttransform:rotate(angle)\t定义 2D 旋转，在参数中规定角度。\n\t取值\n\t\t正数 顺时针\n\t\t负数 逆时针\n\t\t\n渐变\n\t语法\n\t\tbackground-image:linear-gradient(颜色1,颜色2...) \n\t\t\n\tlinear-gradient() 函数\n\t\t用于创建一个表示两种或多种颜色线性渐变的图片。\n\t\t创建一个线性渐变，需要指定两种颜色，还可以实现不同方向（指定为一个角度）的渐变效果，如\t\t   果不指定方向，默认从上到下渐变。\n\t\t\n动画\n\t语法\n\t\t1,先定义动画\n\t\t\t@keyframes 动画名称&#123;\n\t\t\t\t0%&#123;&#125;&#x2F;&#x2F;开始的状态\n\t\t\t\t100%&#123;&#125;&#x2F;&#x2F;结束的状态\n\t\t\t&#125;\n\t\t2,使用动画\n\t\t\t在需要添加动画的元素上,加一个animation,设置动画的名称 和动画的时长\n\t\t\t\n\t注意\n\t\t动画名称 和 动画持续的时长 必须要赋值\n\n\n\nflex布局概念\n\t一种弹性布局方式,他布局页面更加的简单,灵活,避免浮动脱标的影响\n\t\n组成\n\t弹性容器(父元素)\n\t弹性盒子(子元素)\n\t主轴(默认是水平方向,子元素就会默认水平排布)\n\t侧轴&#x2F;交叉轴(默认是垂直方向)\n\t\n使用\n\t1,需要在父元素上添加display:flex属性\n\t2,根据需要添加对应轴的属性来实现布局\n\t\n主轴对齐方式\n\tjustify-content\n\t\tcenter 居中\n\t\tspace-between 两边没有间隙,中间间隙等分\n\t\tspace-around 中间间隙是两边间隙的2倍\n\t\tspace-evenly 所有间隙等分\n\t\t\n侧轴对齐方式\n\talign-items\t\n\t\tcenter 居中\n\t\tstretch 拉伸 默认\n伸缩比\n\t实现子元素宽度不一样\n\tflex:数值 取父元素剩余宽度的份数\n\t\n子级元素的换行显示\n\tflex-wrap:wrap换行\n\t\n换行之后,行的显示方式\n\talign-content\n\t\tcenter 居中\n\t\tspace-between 上下两边没有间隙,中间间隙等分\n\t\tspace-around 中间间隙是上下两边间隙的2倍\n\n修改轴向\n\tflex-direction:column\n\t\n\t修改之后 实现水平对齐 align-items:center\n\t\t    实现垂直对齐 justify-content:center\n\n","slug":"day08_课堂笔记","date":"2022-12-01T11:35:05.354Z","categories_index":"前端三剑客","tags_index":"css","author_index":"团子"},{"id":"55ae4994231e43a4884c40522a431107","title":"07_定位_字体图标_新特性","content":"昨日回顾伪元素\n\t概念\n\t\tcss模拟生成的一些非主体部分\n\t语法\n\t\t::before\n\t\t::after\n\t注意\n\t\tcontent\n\t\t默认行内元素\n伪类选择器\n\t概念\n\t\t根据元素在html中的结构查询\n\t语法\n\t\t:first-child\n\t\t:last-child\n\t\t:nth-child(n)\n\t\t\t2n+1\n\t\t\t2n\n\t\t\t-n+5\n\t\t\tn+5\n浮动\t\n\t概念\n\t\t布局方式\n\t属性\t\n\t\tfloat:浮动\n\t\tclear清除\n\t特点\n\t\t脱标,覆盖标准流\n\t\t会受到上面元素边界的影响\n\t\t行内可以设置宽高,块级可以在一行显示\n\t清除浮动\n\t\t原因\n\t\t\t影响后面元素的布局\n\t\t做法\n\t\t\t设置父元素高度\n\t\t\t额外标签\n\t\t\t单伪元素\n\t\t\t双伪元素\n\n定位概念概念\n\t也是一种布局方式,可以让元素自由摆放在页面中的任意位置\n应用场景\n\t1,盒子之间的层叠问题,因为定位之后的元素层级是最高的,可以叠加在其他盒子上面\n\t2,可以将盒子始终固定在屏幕的某一位置\n使用\n\t1,设置定位的方式:position属性\n\t2,设置偏移值:水平和垂直就近各取一个\n\n相对定位概念\n\t自恋型定位,相对于他之前的位置进行移动\n语法\n\tposition:relative\n特点\n\t 1.没有脱标,占据空间的\n     2,参照坐标原点:以前在标准流左上角为原点\n应用场景\n\t1,子绝父相(常见的布局技巧)\n\t2,用于小范围的移动\n\n绝对定位概念\n\t拼爹型定位,相对于最近的有定位的祖先元素进行移动\n语法\n\tposition:absolute\t\n特点\n\t1,脱标,不占位置\n    2,参照的坐标原点:最近有定位的父元素\n                  如果父元素没有定位,一层层往上找,如果都没有,就参照body(浏览器正文左上角)\n应用场景\n\t1,子绝父相(常见的布局技巧)\n\n子绝父相概念\n\t一种常用跟定位相关的布局技巧,子元素是绝对定位,父元素是相对定位\n作用\n\t让子元素相对于父元素进行自由移动\n好处\n\t父元素是相对定位,没有脱标,对网页的布局影响是最小的\n应用场景\n\t一,元素水平居中\n\t\t1,子绝父相\n\t\t2,left: 50%;&#x2F;* 50%是相对于父元素 *&#x2F;\n\t\t3,transform: translateX(-50%);\n\t二,元素水平垂直居中\n\t\t1,子绝父相\n\t\t2,top: 50%;\n\t\t3,transform: translate(-50%,-50%);\n\n固定定位概念\n\t死心眼定位,相对于浏览器进行定位\n语法\n\tposition:fixed\n特点\n\t脱标,不占位置\n    参照的原点:浏览器正文的左上角\n场景\n\t让盒子固定在屏幕的某个位置\n\n层级关系1,不同布局之间的层级关系\n\t标准流 &lt; 浮动 &lt; 定位\n2,不同定位之间的层级关系\n\t相对,绝对,固定 默认的层级是相同的\n\t写在最下面的元素层级越高,会覆盖上面的元素\n\t可以使用z-index属性更改元素的层级,值越大,层级越高,这样就不需要更改html的结构\n\n\n\nvertical-align概念定义行内元素&#x2F;行内块元素 的基线相对于 该元素所在行的基线 的垂直对齐方式,默认是基线对齐\n\n作用可以解决 行内元素&#x2F;行内块元素 垂直对齐的问题\n\n取值baseline\t默认。元素放置在父元素的基线上。\nmiddle\t把此元素放置在父元素的中部。\nbottom\t使元素及其后代元素的底部与整行的底部对齐。\ntop\t把元素的顶端与行中最高元素的顶端对齐\n\n\n\n其他效果溢出效果属性\n\toverflow\n作用\n\t控制内容部分的显示效果\n取值\n\tvisible\t默认值。内容不会被修剪，会呈现在元素框之外。\n    hidden\t内容会被修剪，并且其余内容是不可见的。\n    scroll\t内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。\n    auto\t如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。\n\n隐藏效果display: none  在网页中不占位置\nvisibility:hidden  在网页中占据位置\n\n\n\n字体图标概念\n\t用于展示图标,本质是一个字体\n好处\n\t灵活地修改样式,降低服务器的请求次数\n\n使用\n\t1,将字体包拖到项目中\n\t2,引入字体图标的样式\n\t3,调用图标对应的类名去展示\n\n\n\nCSS新特性过渡作用\n\t让元素的样式慢慢发生改变\n使用\n\ttransition: all 1s;\n注意\n\t这个属性需要给过渡元素本身添加\n\n位移作用\n\t让元素沿着x轴或者y轴移动\n语法\n\ttransform:translate(水平移动举例,垂直移动距离)\n\ttransform:translateX()\n\ttransform:translateY()\n取值\n\t像素值,或者百分比(相对于自身的)\n\n","slug":"day07_课堂笔记","date":"2022-12-01T11:31:32.927Z","categories_index":"前端三剑客","tags_index":"css","author_index":"团子"},{"id":"43ea23256ce2c18e132735ea490d5a7f","title":"06_伪元素_伪类_浮动","content":"昨日回顾盒子模型\n\t像素级调整\n\t\n\t分类\t\n\t\t行盒:行级元素\n\t\t\t设置宽度没有效果,由内容决定\n\t\t块盒:块级元素\n\t\t\t设置宽度有效果,没有设置宽度,跟父元素一致,没有设置高度,由内容决定\n\t\t\t\n\t组成\n\t\t边框\n\t\t内边距\n\t\t外边距\n\t边框\n\t\t复合属性:border\n\t\t\t\tborder-width\n\t\t\t\t\t复合属性:1-4个取值 上右下左顺时针,某一边没有赋值,看对面\n\t\t\t\tborder-style\n\t\t\t\tborder-color\n\t\t单一方向border+方位词\n\t\tboder-radius 从左上角开始 顺时针赋值\n\t内边距\n\t\t设置边框和内容之间的间距\n\t\t取值也是1-4值,上右下左顺时针\n\t\t单一方向padding+方位词\n\t\t设置边框和内边距都会撑大盒子\n\t\t\t1.手动内减\n\t\t\t2,自动内减 box-sizing:border-box\n\t\t\t\n\t外边距\n\t\t设置盒子与盒子之间的距离\n\t\t取值也是1-4值,上右下左顺时针\n\t\t单一方向margin+方位词\n\t\t外边框合并:\n\t\t\t垂直布局的块级元素,只设置一个就可以\n\t\t外边距塌陷\n\t\t\t父子元素,子元素的margin-top作用在父元素上了\n\t\t\t给父元素设置margin-top,或者添加标签体\n\n\n\n伪元素概念\n\t伪元素在html骨架中并没有通过代码去实现,而是在css中实现的\n作用\n\t一般在页面中的非主体内容可以使用伪元素\n区别\n\t普通元素:通过html设置的标签生成的\n\t伪元素:由css模拟出来的标签效果\n\t本质区别:是否创建了新的元素\n语法\n\t::before 在父元素位置的最前面添加一个伪元素\n\t::after 在父元素位置的最后面添加一个伪元素\n注意点\n\t1,必须设置content属性才能生效\n\t2,伪元素默认是行内元素\n\n\n\n伪类作用\n\t无需添加额外属性,就可以根据元素在html中的结构关系来查找元素\n区别\n\t普通选择器:在html结构有标识的,id选择器,类选择器,在html标签中都有额外属性\n\t伪类选择器:在html结构中没有标识,根据逻辑上的关系来选择元素\n语法\n\t选择一个\n\t\t:first-child 选择第一个子元素\n\t\t:last-child 选择最后一个子元素\n\t\t:nth-child(n) 选择第n个(从1开始)\n\t\t:nth-last-child(n) 选择第n个(倒着数)\n\t选择多个\n\t\tn:关键字 取值为0,1,2,4...\n\t\t通过n组成一些常见的公式实现选择多个\n\t\t\t奇数:2n+1 2n-1  odd\n\t\t\t偶数:2n  even\n\t\t\t前5个: -n+5 (n必须要写在前面)\n\t\t\t从第5个往后:n+5(包含第5个)\n好处\n\t减少对html中类选择器的依赖,可以简化代码\n场景\n\t常用查找父级元素中的子元素\n\n\n\n标准流概念\n\t又称为文档流,浏览器默认采用的一套排版规则,规定了元素该如何排布\n规则\n\t块级元素\n\t\t从上到下,垂直布局,独占一行\n\t行级元素\n\t\t从左到右,水平布局,不能独占一行,只有上行空间不够才换行\n\n\n\n浮动作用\n\t早期 图文混排\n\t现在 页面布局(让块元素水平排布)\n语法\n\tleft\t元素向左浮动。\n\tright\t元素向右浮动。\n\tnone\t默认值。元素不浮动，并会显示在其在文本中出现的位置。\n特点\n\t1,浮动元素会脱离标准流(脱标),在标准流中不占位置,相当于从地面飘到了天空\n\t2,浮动元素比标准流级别高,可以覆盖标准流中的元素\n\t3,下一个浮动的元素,会在上一个浮动的元素后面进行左右浮动(就形成水平排布)\n\t4,浮动元素会受到上面元素边界的影响\n\t5,浮动元素有特殊的显示效果\n\t\t块级元素,浮动之后,就不会独占一行,一行可以显示多个\n\t\t行级元素,浮动之后,可以设置宽高(将来在布局的时候,不需要加上display:block)\n\n\n\n清除浮动概念\n\t因为子元素浮动了,就不能撑开标准流中的父元素的高度,后面元素的布局就会受影响,需要清除浮动对后面元素的影响\n\t\n原因\n\t子元素浮动后脱标,不占据标准流的位置\n\t\n目的\n\t就是为了让父元素有高度,从而不影响页面中其他元素的布局\n\t\n解决方式一:\n\t直接给父元素添加高度\n\t\t特点:\n\t\t\t简单粗暴,方便\n\t\t缺点\n\t\t\t有些布局中,不能固定父元素的高度,比如新闻列表\n解决方式二:\n\t额外标签法\n\t\t做法\n\t\t\t1,在父元素内容的最后面添加一个块元素\n\t\t\t2,给添加的块元素设置属性 clear:both\n\t\t缺点\n\t\t\t会在页面中添加额外的标签,会让页面结构变得复杂\n解决方式三:\n\t单伪元素清除法\n\t\t做法\n\t\t\t用伪元素替代了额外标签\n\t\t优点\n\t\t\t可以在项目中使用,直接给标签加上clearfix类就可以了\n解决方式四:\n\t双伪元素清除法\n\t\t做法\n\t\t\t添加前后两个伪元素,前面的伪元素用于解决margin塌陷问题,后面的伪元素用于清除浮动\n\t\t优点\n\t\t\t比单伪元素新增解决margin塌陷的问题\n","slug":"day06_课堂笔记","date":"2022-12-01T11:28:27.571Z","categories_index":"前端三剑客","tags_index":"css","author_index":"团子"},{"id":"e0eab4cf5da0462fb961c80cc5b3ffef","title":"05_核子模型详解","content":"昨日回顾常见属性\n\t尺寸属性\n\t\twidth\n\t\theight\n\t背景属性\n\t\tbackground-color\n\t\tbackground-image\n\t字体属性\n\t\tfont-size\n\t文本属性\n\t\tcolor\n\t边框属性\n\t\tborder\n\t盒子模型\n\t\tmargin\n\t\t\n字体属性\n\t分开\n\t\tfont-style\n\t\tfont-weight\n\t\tfont-size\n\t\tfont-family\n\t连写\n\t\tfont:style weight size&#x2F;line-height family\n\t\t\n文本属性\n\tcolor 文本颜色 \n\ttext-align\n\ttext-indent\n\ttext-decoration\n\tline-height  设置行间距和垂直居中\n\t\n背景属性\n\t分开写\n\t\tbackground-color\n\t\tbackground-image\n\t\tbackground-repeat\n\t\tbackground-position  ---精灵图\n\t连写\n\t\tbackground:color image repeat position\n\t\t\n三大特性\n\t层叠性\n\t继承性 文本 字体  对齐方式\n\t优先级 继承 &lt; 元素 &lt; 类 &lt; id &lt; 行内 &lt; !impotant\n\t\n\n盒子模型行盒和块盒分类行级元素对应的就是行盒\n\t不能独占一行,设置宽高没有效果,宽高是由内容来决定的\n\n块级元素对应的就是块盒\n\t独占一行,设置宽高有效果\n\t如果不设置宽度,跟父元素宽度保持一致\n\t如果不设置高度,默认是由内容撑开\n\t\n互转\n\t行级-&gt;块级 display:block\n\t块级-&gt;行级 display:inline\n\t行内块 display:inline-block(可以设置宽高,可以在一行显示)\n\n盒子模型组成边框 border\n内边距 padding\n外边距 margin\n\n边框详解分开写\n\tborder-width\n\tborder-style\n\tborder-color\n连写\t\n\tborder: border-width border-style border-color\n单独设置某一方向上的边框\n\tborder-bottom: 10px solid red;\n圆角\n\tborder-radius\n\n盒子大小初始计算盒子宽度 &#x3D; 左边框 + 内容的宽度 + 右边框\n\n设置边框,会撑大盒子\n\n解决:计算多余的大小,手动在内容区域中减去(手动内减)\n\n内边距详解作用\n\t设置边框和内容区域的距离\n赋值\n\t从上边距开始,顺时针,如果某一边没有赋值,看对面\n单一方向赋值\n\tpadding-方位词\n\n盒子大小最终计算盒子宽度 &#x3D; 左边框 + 左内边距 + 内容的宽度  + 右内边距 + 右边框\n\n设置内边距,会撑大盒子\n\n解决:计算多余的大小,手动在内容区域中减去(手动内减)\n\n盒子尺寸自动内减做法\n\tbox-sizing: border-box;\n\t\n原理\n\t浏览器自动计算需要减去的尺寸,在内容区域减去(自动内减)\n\n外边距详解作用\n\t设置 盒子 与 盒子 之间的距离\n赋值\n\t从上边距开始,顺时针,如果某一边没有赋值,看对面\n单一方向赋值\n\tmargin-方位词\n\n清除默认内外边距应用场景\n\t浏览器会为部分标签设置默认的margin和padding,其实我们不需要,一般在项目开始之前需要先清除这些标签的默认样式\n\n例如\n\tbody标签的默认margin\n\tp标签的默认上下margin\n\tul标签的默认上下margin和padding-left\n\t\n淘宝的处理方式\n\tblockquote, body, button, dd, dl, dt, fieldset, form, h1, h2, h3, h4, h5, h6, hr, input, legend, li, ol, p, pre, td, textarea, th, ul &#123;\n    margin: 0;\n    padding: 0;\n&#125;\n\n京东的处理方式\n* &#123;\n    margin: 0;\n    padding: 0;\n&#125;\n\n外边距正常情况场景\n\t水平布局的盒子,左右的margin正常的,互不影响\n结果\n\t最终两者的间距为左右margin之和\n\n外边距合并情况场景\n\t垂直布局的盒子,上下的margin会合并\n结果\n\t最终两者的距离为margin中的最大值\n解决方法\n\t避免就好\n\t只给其中一个盒子设置margin即可\n\n外边距塌陷情况场景\n\t互相嵌套的块级元素,子元素的margin-top会作用在父元素上\n结果\n\t导致父子元素一起向下移动\n解决\n\t1,给父元素设置border-top或者padding-top(分割父子元素的margin-top)\n\t2,设置父元素的overflow: hidden\n\t3,转成行内块元素\n\t4,设置浮动\n\n","slug":"day05_课堂笔记","date":"2022-12-01T11:27:32.923Z","categories_index":"前端三剑客","tags_index":"css","author_index":"团子"},{"id":"6ebca54f38fa8fefa2acc1b9ec6647ba","title":"04_字体文本背景属性","content":"昨日回顾表单\n\tform\n\t\taction\n\t\tmethod\n\t\n\tinput\n\t\ttype\n\t\t\ttext\n\t\t\tpassword\n\t\t\tradio\n\t\t\tcheckbox\n\t\t\tfile\n\t\t\treset\n\t\t\tsubmit\n\t\t\tbutton\n\t\tchecked\n\t\t\tchecked\n\tselect\n\t\toption 子标签\n\t\t\tselected\n\t\t\t\tselected  选中\n\ttextarea\n\t\tcols 列数\n\t\trows 行数\n\t\n\t共同属性\n\t\tname\n\t\t\t将数据提交到后台\n\t\t\t单选复选框分组\n\t\tvalue\n        \t设置单选复选框提交到后台的值\n\t\t\t设置按钮上的值\n\t\t\t设置下拉选择框提交到后台的值\n\t\t\t\n\t新增\n\t\tlabel 提升用户体验 让光标聚焦到关联的控件上\n\t\tbutton  定义按钮,加上type属性\n\t\t\n表格\n\ttable\n\t\twidth\n\t\theight\n\t\tborder\n\ttr\n\t\talign\n\tth,td\n\t\trowspan\n\t\tcolspan\ncss\n\t概念\n\t\t层叠样式表 样式+布局\n\t引入方式\n\t\t行内样式\n\t\t内部样式\n\t\t外部样式\n\t选择器\n\t\t基本\n\t\t\tid选择器\n\t\t\t类选择器\n\t\t\t元素选择器\n\t\t扩展\n\t\t\t并集选择器 ,\n\t\t\t交集选择器 \n\t\t\t后代选择器\n\t\t\t子选择器\n\t\t\t兄弟选择器 +\n\t\t\t属性选择器 []\n\t\t\t伪类选择器 hover\n\t\n\n\n\n常见属性入门尺寸属性\n\twidth 宽度\n\theight 高度\n背景属性\n\tbackground-color 背景颜色\n\tbackground-image 背景图片\n字体属性\n\tfont-size 字体大小\n文本属性\n\tcolor 文本颜色\n边框属性\n\tborder 边框\n盒子模型\n\tmargin 外边距\n\n\n\n字体相关属性分开写\n\tfont-style 字体样式\n\tfont-weight 字体粗细\n\tfont-size 字体大小\n\tfont-family 字体系列\n连写\n\tfont:style weight size family\n\n文本相关属性基本属性\n\tcolor 颜色\n\ttext-align 对齐方式\n\ttext-decoration 装饰线\n\ttext-indent 首行缩进\n\tline-height 行高\n\t\nline-height\n\t1,设置文本上下间距\n\t2,可以让单行文本垂直居中(line-height &#x3D; 文本所在父元素的高度)\n\n\t注意点\n\t\t设置line-height:1,取消上下默认间距,实现精准布局\n\t\t跟font连写的时候,可能会被覆盖,一般将line-height放在字体连写的后面\n\n\n\n背景相关属性基本属性\n\t背景颜色\n\t\tbackground-color\n\t背景图片\n\t\tbackground-image\n\t背景平铺\n\t\tbackground-repeat\n\t背景位置\n\t\tbackground-position\n\t背景尺寸\n\t\tbackground-size\n\t\t\n背景连写\n\tbackground: color image repeat position\n\t\n颜色取值\n\t1,关键字\n\t2,rgb\n\t3,rgba\n\t4,#16进制值\n\t\n精灵图\n\t场景\n\t\t将项目中多张小图,合并成一张大图,这张大图就叫做精灵图\n\t好处\n\t\t减少服务器发送图片的次数,提高页面的加载速度\n\t步骤\n        1,创建一个盒子\n        2,设置盒子的大小为要展示的图片的大小\n        3,设置精灵图为盒子的背景图片\n        4,将小图片左上角的坐标取负值,设置给图片的background-position属性\n\nCSS三大特性层叠性\n\t后写的样式会覆盖先写的样式(相同的样式会覆盖,不同的样式会叠加)\n\n继承性\n\t子元素会继承父元素的相关属性,可以在一定程度上减少代码\n\t\n\t应用场景\n\t\t1,直接给ul设置list-style:none,就可以去掉无序列表中的小圆点\n\t\t2,直接给body设置font-size,可以统一浏览器默认文字的大小\n优先级\n\t不同的选择器具有不同优先级,优先级高的选择器会覆盖优先级低的选择器样式\n\t\n\t规律\n\t\t继承 &lt; 元素选择器 &lt; 类选择器 &lt; id选择器 &lt; 行内样式 &lt; !important\n\t注意点\n\t\t1,!important写在属性值的后面,分号的前面\n\t\t2,!important不能提升继承的优先级,只要继承,优先级是最低的\n\t\t3,实际开发中不建议使用!important\n\n","slug":"day04_课堂笔记","date":"2022-12-01T11:14:19.660Z","categories_index":"前端三剑客","tags_index":"css","author_index":"团子"},{"id":"bdae8df5a111dedc49e69aa7490b0c37","title":"Css基础知识","content":"一. CSS简介1 CSS的基本概念1) 什么是CSSCSS(Cascading Style Sheets)  ，通常称为CSS样式表或层叠样式表\n2) CSS的作用CSS的作用就是用来规定每个HTML元素表现的样子, 比如\n\n字体的大小\n颜色\n摆放位置…\n\n\n\n\n\n\n\n\n\n\nCSS也被称为网页的化妆师\n\n再比如, 如果说HTML是毛坯房的话, 加上CSS就是精装修房\n\n\n随着web的发展, 出现一种非常重要的思想\n\n\n\n\n\n\n\n\n\n结构(html)与样式(css)相分离\n这样设计的好处, 实现代码的复用, 利用工程化开发.\n比如, 老板觉得网站的风格不看好, 可以换一个”皮肤”, 其实只需要修改css样式就可以了, 网站的结构和数据可以不变\n3) CSS的书写位置\n外联\n内嵌\n行内\n\n在工作中最常见的方式是, 将CSS文件单独做为一个文件存储, 再通过&lt;link&gt;标签引入\n在目前的学习阶段, 为了调试方便, 我们将CSS写在html文件的&lt;style&gt;标签中\n行内几乎不用, 可以自行了解\n\n\n\n样式表\n优点\n缺点\n使用情况\n控制范围\n\n\n\n行内样式表\n书写方便，权重高\n没有实现样式和结构相分离\n较少\n控制一个标签（少）\n\n\n内部样式表\n部分结构和样式相分离\n没有彻底分离\n较多\n控制一个页面（中）\n\n\n外部样式表\n完全实现结构和样式相分离\n需要引入\n最多，强烈推荐\n控制整个站点（多）\n\n\n4) CSS的基础语法\n\n\n\n\n\n\n\n\n语法\n&lt;head&gt;\n&lt;style&gt;\n    选择器（选择的标签） &#123; \n      属性1: 属性值1;\n      属性2: 属性值2; \n      属性3: 属性值3;\n    &#125;\n&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n\n主要由 选择器+声明块 组成\n\n\n\n\n\n\n\n\n\n示例\n将h1的字体改成红色\n&lt;style&gt;\n\t h1 &#123;\n\t \tcolor: red;\n\t &#125;\n&lt;&#x2F;style&gt;\n\n二. 选择器1 什么是选择器\n\n\n\n\n\n\n\n\n选择器的主要作用就是从一堆元素中选出特定的符合要求的元素\n\n比如, 上图中有一堆小黄人, 现在需要统一改变单眼小黄人的颜色为红色, 该如何操作呢?\n\n第一步: 选出所有的单眼小黄人\n第二步: 修改颜色为红色\n\nCSS的思想也是类似的\n\n第一步: 通过选择器, 找出符合要求的HTML元素\n第二步: 修改找出来的元素的属性\n\n常见的选择器包括\n\n元素选择器\n类选择器\nid选择器\n\n2 基本选择器1) 元素选择器\n\n\n\n\n\n\n\n\n作用\n根据标签名, 将同一种标签元素选择出来\n\n\n\n\n\n\n\n\n\n语法\n标签名 &#123;\n 属性: 值\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\n修改所有p标签的颜色为红色\np*3&gt;lorem10\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      p &#123;\n        color: red;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    将所有p标签的颜色改为红色\n    &lt;p&gt;\n      Lorem ipsum dolor, sit amet consectetur adipisicing elit. Minima,\n      consequuntur.\n    &lt;&#x2F;p&gt;\n    &lt;p&gt;\n      Facere, earum eum voluptates explicabo aut tempora eveniet voluptate. Eos!\n    &lt;&#x2F;p&gt;\n    &lt;p&gt;\n      Fugit cupiditate ea doloremque quidem obcaecati. Rerum quam explicabo\n      quod.\n    &lt;&#x2F;p&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n2) 类选择器\n\n\n\n\n\n\n\n\n作用\n选择某一类元素, 该元素通过class属性指定\n\n\n\n\n\n\n\n\n\n语法\n.类名 &#123;\n\t属性: 值\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\ndiv*5&gt;lorem3\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;类选择器&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .red &#123;\n        color: red;\n      &#125;\n      .blue &#123;\n        color: blue;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;Lorem, ipsum dolor.&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;red&quot;&gt;Facere, possimus laboriosam.&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;blue&quot;&gt;Ducimus, ea perferendis!&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;red&quot;&gt;Accusamus, accusantium dolores.&lt;&#x2F;div&gt;\n    &lt;div&gt;Eius, eaque magni.&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n多类名使用空格隔开\n\n3) id选择器\n\n\n\n\n\n\n\n\n作用\n选择某一个元素, 该元素通过id属性指定\n\n\n\n\n\n\n\n\n\n语法\n#id名 &#123;\n\t属性: 值\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;p id&#x3D;&quot;username&quot;&gt;&lt;&#x2F;p&gt;\n\n练习实现’Google’图标\n提示\n\n使用span让多个元素在同一行排列\n使用class类选择器\n使用color定义颜色\n使用font-size:100px指定大小\n\n\n\n\n\n\n\n\n\n\n\n答案\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      span &#123;\n        font-size: 100px;\n      &#125;\n\n      .red &#123;\n        color: red;\n      &#125;\n      .blue &#123;\n        color: blue;\n      &#125;\n      .yellow &#123;\n        color: yellow;\n      &#125;\n      .green &#123;\n        color: green;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;\n      &lt;span class&#x3D;&quot;blue&quot;&gt;G&lt;&#x2F;span&gt;\n      &lt;span class&#x3D;&quot;red&quot;&gt;o&lt;&#x2F;span&gt;\n      &lt;span class&#x3D;&quot;yellow&quot;&gt;o&lt;&#x2F;span&gt;\n      &lt;span class&#x3D;&quot;blue&quot;&gt;g&lt;&#x2F;span&gt;\n      &lt;span class&#x3D;&quot;green&quot;&gt;l&lt;&#x2F;span&gt;\n      &lt;span class&#x3D;&quot;red&quot;&gt;e&lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n方法更多选择器的用法, 查手册CSS手册\n\n3 复合选择器1) 后代选择器\n\n\n\n\n\n\n\n\n作用\n选择某一个元素的子孙后代, 使用 空格\n\n\n\n\n\n\n\n\n\n语法\n父选择器 子选择器 &#123;\n\t属性: 值\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      nav li &#123;\n        color: red;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 主导航 --&gt;\n    &lt;nav&gt;\n      &lt;ul&gt;\n        &lt;li&gt;Lorem.&lt;&#x2F;li&gt;\n        &lt;li&gt;Nobis!&lt;&#x2F;li&gt;\n        &lt;li&gt;Exercitationem?&lt;&#x2F;li&gt;\n        &lt;li&gt;Voluptas.&lt;&#x2F;li&gt;\n        &lt;li&gt;Nulla!&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;nav&gt;\n\n    &lt;!-- 新闻列表 --&gt;\n    &lt;ul&gt;\n      &lt;li&gt;Lorem.&lt;&#x2F;li&gt;\n      &lt;li&gt;Magni!&lt;&#x2F;li&gt;\n      &lt;li&gt;Sed?&lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2) 并集选择器\n\n\n\n\n\n\n\n\n作用\n同时选择多个选择器, 使用 逗号\n\n\n\n\n\n\n\n\n\n语法\n选择器1, 选择器2 &#123;\n\t属性: 值\n&#125;\n\n3) 交集选择器\n\n\n\n\n\n\n\n\n作用\n同时满足条件, 使用 点号\n\n\n\n\n\n\n\n\n\n语法\n选择器1.选择器2 &#123;\n\t属性: 值\n&#125;\n\n现在有这样一个需求\nh1和p都是应用的同一个类表示强调, 但是我们希望h1的强调是红色, p的强调是蓝色\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      h1.import &#123;\n        color: red;\n      &#125;\n      p.import &#123;\n        color: blue;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1 class&#x3D;&quot;import&quot;&gt;Lorem.&lt;&#x2F;h1&gt;\n    &lt;p class&#x3D;&quot;import&quot;&gt;\n      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Impedit\n      molestias, odio doloremque ab neque numquam animi, ipsum qui natus aut\n      dignissimos quo nobis sequi architecto nemo tempore cum ipsa possimus!\n    &lt;&#x2F;p&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n4) a元素的伪类选择器\n\n\n\n\n\n\n\n\n作用\n选择同一元素的不同状态\n\n\n\n\n\n\n\n\n\n语法\n\na:link      /* 未访问的链接 */\na:visited   /* 已访问的链接 */\na:hover     /* 鼠标移动到链接上 */\na:active    /* 选定的链接 */\n\n书写顺序: lvha, 爱恨法则, love &amp; hate\n\n\n\n\n\n\n\n\n\n示例\na &#123;   \n  font-weight: 700;\n  font-size: 16px;\n  color: gray;\n&#125;\na:hover &#123;   &#x2F;* :hover 是链接伪类选择器 鼠标经过 *&#x2F;\n\tcolor: red; &#x2F;*  鼠标经过的时候，由原来的 灰色 变成了红色 *&#x2F;\n&#125;\n\n5) 自学\n属性选择器\n子代选择器\n兄弟选择器\n\n练习&lt;!-- 主导航栏 --&gt;\n&lt;nav class&#x3D;&quot;top-nav&quot;&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;公司首页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;公司简介&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;公司产品&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;联系我们&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n&lt;&#x2F;nav&gt;\n&lt;!-- 侧导航栏 --&gt;\n&lt;aside class&#x3D;&quot;side-nav&quot;&gt;\n  &lt;div class&#x3D;&quot;left&quot;&gt;左侧侧导航栏&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;right&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;登录&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;aside&gt;\n\n在不修改以上结构代码的前提下，完成以下任务：\n\n链接 登录 的颜色 为 红色\n鼠标经过 登录 时颜色 为 蓝色\n主导航栏里面的所有的链接改为橙色   \n\n三. 文本相关属性1 font相关1) 大小font-size\n\n\n\n\n\n\n\n\n作用\n设置字体大小\n\n\n\n\n\n\n\n\n\n示例\nh1 &#123;  \n\tfont-size:20px; \n&#125;\n\n2) 字体font-family\n\n\n\n\n\n\n\n\n作用\n设置字体\n\n\n\n\n\n\n\n\n\n示例\nbody &#123;\n  font-family: Arial,Microsoft Yahei,sans-serif\n&#125;\n\n\nsan-serif : 非衬线字体(文字的笔画粗细是一样的, 如黑体)\nserif: 衬线字体(文字的笔画有尖角, 如宋体)\n\n会依次查找电脑上的字体, 如果都没有, 就使用一种非衬线字体\n3) 粗细font-weight\n\n\n\n\n\n\n\n\n作用\n设置文本的粗细\n\n\n\n\n\n\n\n\n\n示例\ndiv &#123;\n  font-weight: bold\n&#125;\n\n\n\n\n属性值\n描述\n\n\n\nnormal\n默认值（不加粗的）\n\n\nbold\n定义粗体（加粗的）\n\n\n100~900\n400 等同于 normal，而 700 等同于 bold  我们重点记住这句话\n\n\n4) 风格font-style\n\n\n\n\n\n\n\n\n作用\n设置文本的倾斜\ndiv &#123;\n  font-style: italic\n&#125;\n\n5) 常用连写font是可以连写的, 通常连写也是很常见的\n选择器 &#123; font: font-style  font-weight  font-size&#x2F;line-height  font-family;&#125;\n\n\n\n\n\n\n\n\n\n\n示例\nbody &#123;\n  font: 16px &quot;Microsoft Yahei&quot;\n&#125;\n\n2 外观1) color\n\n\n\n\n\n\n\n\n作用\ncolor属性用于定义文本的颜色\n\n\n\n表示表示\n属性值\n\n\n\n预定义的颜色值\nred，green，blue\n\n\n十六进制(使用的最多)\n#rrggbb, #FF0000，#FF6600，#29D794\n\n\nRGB代码\nrgb(255,0,0)或rgb(100%,0%,0%)\n\n\n\nR: red红色, #00~#FF(0~255), 前两位\nG: green绿色, #00~#FF(0~255), 中间两位\nB: blue蓝色,#00~#FF(0~255), 后两位\n2) 文本对齐text-align\n\n\n\n\n\n\n\n\n\n作用\n设置文本内容的水平对齐方式\n\n\n\n属性\n解释\n\n\n\nleft\n左对齐（默认值）\n\n\nright\n右对齐\n\n\ncenter\n居中对齐\n\n\n3) 行高line-height\n\n\n\n\n\n\n\n\n\n作用\n属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高\n4) 装饰线text-decoration   通常我们用于给链接修改装饰效果\n\n\n\n值\n描述\n\n\n\nnone\n默认。定义标准的文本。 取消下划线（最常用）\n\n\nunderline\n定义文本下的一条线。下划线 也是我们链接自带的（常用）\n\n\noverline\n定义文本上的一条线。（不用）\n\n\nline-through\n定义穿过文本下的一条线。（不常用）\n\n\n5) 单位\n\n\n值\n\n\n\n\npx\n像素值\n\n\nem\n1em 等于当前的字体尺寸. 例如，如果某元素以 12px 显示，那么 2em 是24px\n\n\n%\n百分比\n\n\n数值\n倍数\n\n\n小综合练习实现如下效果:\n\n提示:\n\n标题文本都居中, 可以考虑提取一个公共样式\n腾讯新闻有下划线, 但是并不是一个链接\n收藏本文是链接, 但是没有下划线\n在段落里有一个首行缩进的效果, 是两个汉字, 如何实现\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;综合案例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        font: 16px &#39;Microsoft Yahei&#39;;\n      &#125;\n      article .title &#123;\n        font-size: 28px;\n        font-weight: 400;\n      &#125;\n      article .tac &#123;\n        text-align: center;\n      &#125;\n      article .date &#123;\n        color: #ccc;\n      &#125;\n      article .author &#123;\n        color: #990000;\n        text-decoration: underline;\n      &#125;\n      article .sub-title a &#123;\n        color: #00f;\n        text-decoration: none;\n      &#125;\n      article .sub-title input &#123;\n        color: red;\n      &#125;\n      article .sub-title button &#123;\n        color: green;\n        font-weight: 700;\n      &#125;\n      article p &#123;\n        line-height: 26px;\n        text-indent: 2em;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;article&gt;\n      &lt;h1 class&#x3D;&quot;title tac&quot;&gt;加强反垄断监管是为了更好发展&lt;&#x2F;h1&gt;\n      &lt;div class&#x3D;&quot;sub-title tac&quot;&gt;\n        &lt;span class&#x3D;&quot;date&quot;&gt;2020年12月20日&lt;&#x2F;span&gt;\n        &lt;span class&#x3D;&quot;author&quot;&gt;腾讯新闻 （20人参与）&lt;&#x2F;span&gt;\n        &lt;a href&#x3D;&quot;&quot;&gt;收藏本文&lt;&#x2F;a&gt;\n        &lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;请输入查询条件&quot; &#x2F;&gt;\n        &lt;button&gt;搜索&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n      &lt;hr &#x2F;&gt;\n      &lt;p&gt;\n        近日，市场监管总局根据举报，在前期核查研究的基础上，对阿里巴巴集团控股有限公司实施“二选一”等涉嫌垄断行为立案调查。这是我国在互联网领域加强反垄断监管的一项重要举措，有利于规范行业秩序、促进平台经济长远健康发展。\n      &lt;&#x2F;p&gt;\n      &lt;p&gt;\n        近年来，我国线上经济蓬勃发展，新业态、新模式层出不穷，对推动经济高质量发展、满足人民日益增长的美好生活需要发挥了重要作用。但与此同时，线上经济凭借数据、技术、资本优势也呈现市场集中度越来越高的趋势，市场资源加速向头部平台集中，关于平台垄断问题的反映和举报日益增加，显示线上经济发展中存在一些风险和隐患。近期召开的中央政治局会议和中央经济工作会议均明确要求强化反垄断和防止资本无序扩张，得到社会热烈反响和广泛支持。可见，反垄断已成为关系全局的紧迫议题。\n      &lt;&#x2F;p&gt;\n    &lt;&#x2F;article&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n四. 背景相关属性\n\n\n\n\n\n\n\n\n什么是叫背景\n背景的概念最早提出是在摄影和图像处理领域, \n主要目的是为了突出主体, 通常会用一个背景来衬托. 比如证件照\n\n网页一开始主要也是来处理文字和图片, 就借鉴了背景这个概念\n背景可以纯色的, 也可以是一张图片\n1 背景颜色(color)\n\n\n\n\n\n\n\n\n语法\nbackground-color:颜色值;   默认的值是 transparent  透明的\n\n如果要设置背景, 元素必须有宽高!\n2 背景图片(image)\n\n\n\n\n\n\n\n\n语法 \nbackground-image : none | url (url) \n\n\n\n\n参数\n作用\n\n\n\nnone\n无背景图（默认值）\n\n\nurl\n使用相对地址指定背景图像\n\n\nbackground-image : url(images&#x2F;demo.png);\n\n1) 背景图片与插入图片的区别\nimg元素: 属于HTML的范畴, 当图片是HTML结构的一个组成部分时, 使用img\n背景图片: 属于CSS的范畴, 当图片只是为了美化, 使用背景图片\n\n\n\n\n\n\n\n\n\n\n示例\n比如一篇文章, 除了文字描述外, 为了更好的表达要说明的内容, 配了一张图, 这张图就是网页的组成部分,是一个HTML的元素, 就使用img\n\n这里是一个按钮(属于HTML功能), 但是为了让这个按钮更漂亮, 使用背景图片\n\n2) 路径在CSS中的路径是相对于CSS文件的. \n3 背景平铺（repeat）默认情况下背景图片是铺满整个容器的, 就好比贴地板, 这样做的好处是可以减小整个图片的体积, 加快网站的访问速度\n\n\n\n\n\n\n\n\n\n语法\nbackground-repeat : repeat | no-repeat | repeat-x | repeat-y \n\n\n\n\n参数\n作用\n\n\n\nrepeat\n背景图像在纵向和横向上平铺（默认的）\n\n\nno-repeat\n背景图像不平铺\n\n\nrepeat-x\n背景图像在横向上平铺\n\n\nrepeat-y\n背景图像在纵向平铺\n\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        background-image: url(&#39;.&#x2F;images&#x2F;bg.jpg&#39;);\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4 背景位置(position)\n\n\n\n\n\n\n\n\n语法 \nbackground-position : length || length\n\nbackground-position : position || position \n\n\n\n\n参数\n值\n\n\n\nlength\n百分数 | 由浮点数字和单位标识符组成的长度值\n\n\nposition\ntop | center | bottom | left | center | right   方位名词\n\n\n\n注意：\n必须先指定background-image属性\nposition 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。\n如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left  top和top  left效果一致\n如果只指定了一个方位名词，另一个值默认居中对齐。\n如果position 后面是精确坐标， 那么第一个，肯定是 x  第二的一定是y\n如果只指定一个数值,那该数值一定是x坐标，另一个默认垂直居中\n如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标\n\n\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      div &#123;\n        width: 600px;\n        height: 600px;\n        background-color: #aaa;\n        background-image: url(.&#x2F;images&#x2F;money.jpg);\n        background-repeat: no-repeat;\n        background-position: center center;\n        &#x2F;* background-position: 100px 100px; *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n5 背景简写\n\n\n\n\n\n\n\n\n建议\nbackground: 背景颜色 背景图片地址 背景平铺 背景位置\n\n\n\n\n\n\n\n\n\n示例\nbackground: transparent url(image.jpg) repeat-y center top ;\n\n6 背景图的应用精灵图, 很多时候, 我们可以把多个小图标整合到一起, 再通过position调节找出我们想要的背景图. \n\n\n\n\n\n\n\n\n\n优势\n可以减少请求次数\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      div &#123;\n        height: 40px;\n        width: 40px;\n        background-image: url(&#39;.&#x2F;images&#x2F;icon.png&#39;);\n        background-position: -130px -35px;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n五. CSS的特性1 层叠性所谓层叠性是指多种CSS样式的叠加在一起, 同时作用在一个元素时, 最终浏览器以谁为主的问题\n\n\n\n\n\n\n\n\n\n原则\n后写的样式会覆盖先写的样式\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n\t&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n\t&lt;title&gt;Document&lt;&#x2F;title&gt;\n\t&lt;style&gt;\n\t\tdiv &#123;\n\t\t\tcolor: red;\n\t\t\tfont-size: 30px;\n\t\t&#125;\n\n\t\tdiv &#123;\n\t\t\tcolor: blue;\n\t\t&#125;\n\t&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\t&lt;div&gt;\n\t\t 长江后浪推前浪，前浪死在沙滩上。\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n2 继承性子元素会继承父元素==文本==相关的属性\n\nfont-\ntext-\nline-\ncolor\n\n\n\n\n\n\n\n\n\n\n示例\n一般, 我们会统一给body设置font-size\nbody &#123;\n  font: 16px &quot;Mircosoft Yahei&quot;\n&#125;\n\n给父元素设置color\n3 优先级1) 权重公式定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时，\n\n选择器相同，则执行层叠性\n选择器不同，就会出现优先级的问题\n\n关于优先级，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）权重公式\n\n\n\n标签选择器\n计算权重公式\n\n\n\n继承或者 *\n0,0,0,0\n\n\n每个元素（标签选择器）\n0,0,0,1\n\n\n每个类，伪类\n0,0,1,0\n\n\n每个ID\n0,1,0,0\n\n\n每个行内样式 style=””\n1,0,0,0\n\n\n每个!important  重要的\n∞ 无穷大\n\n\n总的原则是, 影响范围越小, 选出的元素越特殊, 权重越高\n2) 权重叠加我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。\n就是一个简单的加法计算\n\ndiv ul  li   ——&gt;      0,0,0,3\n.nav ul li   ——&gt;      0,0,1,2\na:hover      —–—&gt;   0,0,1,1\n.nav a       ——&gt;      0,0,1,1\n\n\n\n\n\n\n\n\n\n\n注意\n不存在进位\n比如, 10个元素选择器叠加在一起, 权重依然没有一个类选择器高\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      a &#123;\n        color: red;\n      &#125;\n      ul a &#123;\n        color: blue;\n      &#125;\n      .mylink &#123;\n        color: green;\n      &#125;\n      #myli a &#123;\n        color: grey;\n      &#125;\n      #mydiv .mylink &#123;\n        color: skyblue;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;mydiv&quot;&gt;\n      &lt;ul id&#x3D;&quot;myul&quot;&gt;\n        &lt;li id&#x3D;&quot;myli&quot;&gt;&lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;mylink&quot;&gt;举例&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n六. 盒子模型1 盒子分类每个元素都有默认的显示方式, 包括\n\n块盒: 独占一行, 可以设置宽高\n行盒: 不独占一行, 高度由字体大小撑开\n\n显示方式都是由display属性控制的\ndisplay常见的值:\n\nblock: 块盒\ninline: 行盒\ninline-block: 行内块\n\n重要结论块盒(div)可以设置宽高\n行盒(span)设置宽高不生效, 由内容决定\n行内块(img)可以设置宽高, 又跟其它元素在同一行显示\n2 盒子模型1) 网页的布局网页布局中，我们是如何把里面的文字，图片，按照美工给我们的效果图排列的整齐有序呢？\n\n\n网页布局\n\n 首先利用CSS设置好盒子的大小，然后摆放盒子的位置\n 最后把网页元素比如文字图片等等，放入盒子里面\n\n\n\n因此, 我们需要先了解如何摆放盒子\n2) 盒子模型现实中的盒子有\n\n边框(厚度): border\n填充泡沫: padding\n内容: content\n\n盒子与盒子之间的距离就是外边距\n\n代码中的盒子模型, 打开浏览器, 通过调试窗口, 可以看到\n\n\n\n\n\n\n\n\n\n\n示例\ndiv &#123;\n\twidth: 100px;\n\theight: 100px;\n\tborder: 1px solid;\n\tmargin: 10px;\n\tpadding: 10px;\n&#125;\n\n3) 边框border\n\n\n\n\n\n\n\n\n语法\nborder : border-width || border-style || border-color \n\n\n\n\n属性\n作用\n\n\n\nborder-width\n定义边框粗细，单位是px\n\n\nborder-style\n边框的样式\n\n\nborder-color\n边框颜色\n\n\n边框的样式包括:\n\nnone：没有边框即忽略所有边框的宽度（默认值）\nsolid：边框为单实线(最为常用的)\ndashed：边框为虚线 \ndotted：边框为点线\n\n\n\n\n\n\n\n\n\n\n示例\ndiv &#123;\n   border: 1px solid red;\n&#125;\n\n\n\n\n\n\n\n\n\n\n圆角边框\n在新的设计语言里, 圆角边框也是非常常见的表现形式, 在CSS3中新增了border-radius\n比如:\n\n\n\n\n\n\n\n\n\n\n示例\np &#123;\n  width: 80px;\n  height: 30px;\n  background-color: red;\n  font-size: 16px;\n  color: #fff;\n  text-align: center;\n  line-height: 30px;\n  border-radius: 15px;\n&#125;\n\n通过调整border-radius的值改变弧度, 当值为height的一半时, 就是表现为一个半圆形\n也可以通过border-radius: 50%画一个圆\ndiv &#123;\n  width: 200px;\n  height: 200px;\n  background-color: skyblue;\n  border-radius: 50%;\n&#125;\n\n4) 内边距padding内边距也叫内填充, 是内容和边框border之间的距离\n\n\n\n属性\n作用\n\n\n\npadding-left\n左内边距\n\n\npadding-right\n右内边距\n\n\npadding-top\n上内边距\n\n\npadding-bottom\n下内边距\n\n\n\n\n\n\n\n\n\n\n\n简写\n按顺时针的方向: 上右下左\n\n\n\n\n\n\n\n\n\n示例\ndiv &#123;\n  &#x2F;* 上:10px 右:20px 下:10px 左:20px *&#x2F;\n  padding: 10px 20px 10px 20px;\n&#125;\n\n一般, 写两个值的情况比较常见\n分别表示: 上下和左右\n\n\n\n\n\n\n\n\n\n示例\ndiv &#123;\n  &#x2F;* 上:10px 右:20px 下:10px 左:20px *&#x2F;\n  padding: 10px 20px;\n&#125;\n\n\n\n\n\n\n\n\n\n\n实战案例\n新浪导航栏的核心就是因为里面的字数不一样多，所以我们不方便给具体的宽度\n这个时候, 我们就可以通过设置padding的方式撑开盒子\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n\t&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n\t&lt;title&gt;新浪导航栏案例&lt;&#x2F;title&gt;\n\t&lt;style&gt;\n\t&#x2F;*清除元素默认的内外边距*&#x2F;\n\t\t* &#123;\n\t\t\tmargin: 0;\n\t\t\tpadding: 0;\n\t\t&#125;\n\t\t.nav &#123;\n\t\t\theight: 41px;\n\t\t\tbackground-color: #FCFCFC;\n\t\t\t&#x2F;*上边框*&#x2F;\n\t\t\tborder-top: 3px solid #FF8500;\n\t\t\t&#x2F;*下边框*&#x2F;\n\t\t\tborder-bottom: 1px solid #EDEEF0;\n\t\t&#125;\n\t\t.nav a &#123;\n\t\t\t&#x2F;*转换为行内块*&#x2F;\n\t\t\tdisplay: inline-block;\n\t\t\theight: 41px;\n\t\t\tline-height: 41px;\n\t\t\tcolor: #4C4C4C;\n\t\t\t&#x2F;*代表 上下是 0  左右是 20 内边距*&#x2F;\n\t\t\tpadding: 0 20px;\n\t\t\ttext-decoration: none;\n\t\t\tfont-size: 12px;\n\t\t&#125;\n\t\t.nav a:hover &#123;\n\t\t\tbackground-color: #eee;\n\t\t&#125;\n\t&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\t&lt;div class&#x3D;&quot;nav&quot;&gt;\n\t\t&lt;a href&#x3D;&quot;#&quot;&gt;设为首页&lt;&#x2F;a&gt;\n\t\t&lt;a href&#x3D;&quot;#&quot;&gt;手机新浪网&lt;&#x2F;a&gt;\n\t\t&lt;a href&#x3D;&quot;#&quot;&gt;移动客户端&lt;&#x2F;a&gt;\n\t\t&lt;a href&#x3D;&quot;#&quot;&gt;博客&lt;&#x2F;a&gt;\n\t\t&lt;a href&#x3D;&quot;#&quot;&gt;微博&lt;&#x2F;a&gt;\n\t\t&lt;a href&#x3D;&quot;#&quot;&gt;关注我&lt;&#x2F;a&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n影响\n设置padding会使盒子的宽度变大, 而影响布局\n比如, 使最后一个盒子被挤到下一行, 这里需要学了浮动后再给大家演示\n\n\n\n\n\n\n\n\n\n演示\n盒子的宽度改变\n\n\n\n\n\n\n\n\n\n设置box-sizing\n默认情况下, 盒子是content-box, 宽高都是基于内容计算的, 但是这样计算不方便\n为了解决这个问题, CSS3引入了box-sizing, 宽高的计算可以根据border-box计算\n5) 外边距margin外边距通常用来设置两个盒子之间的距离, 可以用来确定盒子之间的相对位置关系\n\n\n\n属性\n作用\n\n\n\nmargin-left\n左外边距\n\n\nmargin-right\n右外边距\n\n\nmargin-top\n上外边距\n\n\nmargin-bottom\n下外边距\n\n\n\n\n\n\n\n\n\n\n\n块盒水平居中\n\n盒子必须指定了宽度（width）\n左右的外边距都设置为auto\n\n\n\n\n\n\n\n\n\n\n示例\n.container &#123;\n  width: 1100px;\n  margin: 0 auto;\n&#125;\n\n\n\n\n\n\n\n\n\n\n清除默认内外边距\n由于浏览器会有一个默认的样式, 为了使我们的网页在所有的浏览器中看起来是一样的效果, 通常我们会先清除一些默认样式, 这个过程叫reset\n最简单的reset\n\n\n\n\n\n\n\n\n\n示例\n* &#123;\n  margin: 0;\n  padding: 0;\n&#125;\n\n使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。\n相邻块元素垂直外边距的合并\n当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom\n下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和\n取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。\n\n \n\n解决方案：尽量给只给一个盒子添加margin值。\n嵌套块元素垂直外边距的合并（塌陷）\n对于两个嵌套关系的块元素，如果父元素没有上内边距及边框\n父元素的上外边距会与子元素的上外边距发生合并\n合并后的外边距为两者中的较大者\n\n \n\n解决方案：\n\n可以为父元素定义上边框\n可以为父元素定义上内边距\n\n七. 浮动1 为什么需要浮动首先, 思考一下下面的问题:\n\n如何让多个块盒(div)水平排列成一行？\n如何实现块盒的左右对齐?\n\n2 什么是浮动\n\n\n\n\n\n\n\n\n概念\n设置了浮动属性的元素会\n\n脱离标准普通流\n移动到指定位置\n\n浮动最早的出现, 是为了实现图文混排的, 但是随后, 大家发现可以通过浮动来实现布局\n3 语法选择器 &#123; \n\tfloat: left&#x2F;right; \n&#125;\n\n\n\n\n属性值\n描述\n\n\n\nnone\n元素不浮动（默认值）\n\n\nleft\n元素向左浮动\n\n\nright\n元素向右浮动\n\n\n让一个元素向左或向右浮动\n4 特性1) 脱标设置了浮动的元素会脱离标准流, 不再占用原来的位置, 后面的盒子会向上跑\n.box1 &#123;\n  float: left;\n  width: 200px;\n  height: 200px;\n  background-color: rgba(255, 0, 0, 0.5);\n&#125;\n.box2 &#123;\n  width: 150px;\n  height: 300px;\n  background-color: skyblue;\n&#125;\n\n\n2) 改变displayfloat属性会改变元素display属性。\n任何元素都可以浮动。浮动元素会生成一个块盒，而不论它本身是何种元素。 \n生成的块盒和我们前面的行内块极其相似\n\n同在一行显示\n可以设置宽高\n\n5 应用我们知道，浮动是脱标的，会影响下面的标准流青霉素\n因此, 我们需要给浮动的元素添加一个标准流的父元素，这样可以最大化的减小了对其他标准流的影响\n1) 实现头部布局\n左边是一个logo\n右边是导航\n\n\n2) 实现内容布局\n3) 演示padding改变的影响6 清除浮动1) 为什么要清除浮动因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为0，就影响了下面的标准流盒子\n2) 如何清除浮动目前使用最多的方式, 使用:after伪元素\n\n\n\n\n\n\n\n\n\n示例\n.clearfix:after &#123;  \n  content: &quot;&quot;; \n  display: block; \n  clear: both;\n&#125;   \n\n八. 定位1 为什么需要定位如果想实现下面的效果, 只靠浮动是没有办法实现的\n\n\n像上面这种, 让一个盒子固定在某个位置的情况, 需要使用定位来实现\n2 什么是定位定位也是用来布局的，它有两部分组成：\n\n\n\n\n\n\n\n\n\n定位 = 定位模式 + 边偏移\n定位模式包括:\n\n绝对定位: posistion: absolute\n相对定位: position: relative\n固定定位: position: fixed\n\n边偏移包括\n\n\n\n边偏移属性\n示例\n描述\n\n\n\ntop\ntop: 80px\n顶端偏移量，定义元素相对于其父元素上边线的距离。\n\n\nbottom\nbottom: 80px\n底部偏移量，定义元素相对于其父元素下边线的距离。\n\n\nleft\nleft: 80px\n左侧偏移量，定义元素相对于其父元素左边线的距离。\n\n\nright\nright: 80px\n右侧偏移量，定义元素相对于其父元素右边线的距离\n\n\n定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。\n3 定位模式详解1) 相对定位相对定位参考自己在标准流中的位置偏移 \n效果图\n\n特点\n\n相对于自己原来在标准流中位置来移动的\n原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n\t&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n\t&lt;title&gt;Document&lt;&#x2F;title&gt;\n\t&lt;style&gt;\n\t\tdiv &#123;\n\t\t\twidth: 200px;\n\t\t\theight: 200px;\n\t\t\tbackground-color: pink;\n\t\t&#125;\n\t\t.two &#123;\n\t\t\tbackground-color: purple;\n\t\t\tposition: relative;\n\t\t\ttop: 100px;\n\t\t\tleft: 100px;\n\t\t&#125;\n\t&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\t&lt;div&gt;1&lt;&#x2F;div&gt;\n\t&lt;div class&#x3D;&quot;two&quot;&gt;2&lt;&#x2F;div&gt;\n\t&lt;div&gt;3&lt;&#x2F;div&gt;\n\t\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2) 绝对定位绝对定位参考最近的带有定位的父级元素偏移\n\n如果父级没有定位, 就参考浏览器的左上角偏移\n\n\n\n如果父元素有定位, 参考父元素的左上角偏移\n\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n\t&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n\t&lt;title&gt;绝对定位以带有定位的父级元素来移动位置&lt;&#x2F;title&gt;\n\t&lt;style&gt;\n\t\t.yeye &#123;\n\t\t\twidth: 500px;\n\t\t\theight: 500px;\n\t\t\tbackground-color: skyblue;\n\t\t\tposition: absolute;\n\t\t&#125;\n\t\t.father &#123;\n\t\t\twidth: 350px;\n\t\t\theight: 350px;\n\t\t\tbackground-color: pink;\n\t\t\tmargin: 100px;\n\t\t\t&#x2F;*position: relative;*&#x2F;\n\t\t&#125;\n\t\t.son &#123;\n\t\t\twidth: 200px;\n\t\t\theight: 200px;\n\t\t\tbackground-color: purple;\n\t\t\t&#x2F;*margin-left: 100px;*&#x2F;\n\t\t\tposition: absolute;\n\t\t\ttop: 50px;\n\t\t\tleft: 50px;\n\t\t&#125;\n\t&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\t&lt;div class&#x3D;&quot;yeye&quot;&gt;\n\t\t&lt;div class&#x3D;&quot;father&quot;&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;son&quot;&gt;&lt;&#x2F;div&gt;\n\t\t&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n规律\n如果给一个元素设置绝对定位, 一定要记得给其父元素设置相对定位, 否则会出现意料之外的情况\n简记: 子绝父相 —— 子级是绝对定位，父级要用相对定位\n3) 固定定位固定定位参考浏览器可视窗口偏移\n\n\n\n\n\n\n\n\n\n示例\n微信公众号底部布局\n4 应用1) 小图标2) 侧栏广告3) 盒子居中\n\n\n\n\n\n\n\n\n绝对定位的盒子居中\n\n\n\n\n\n\n\n\n\n相对定位的盒子居中\n5 z-index在使用定位布局时，可能会出现盒子重叠的情况\n加了定位的盒子，默认后来者居上， 后面的盒子会压住前面的盒子\n应用 z-index 层叠等级属性可以调整盒子的堆叠顺序\n\n","slug":"CSS","date":"2022-12-01T11:11:22.073Z","categories_index":"前端三剑客","tags_index":"css","author_index":"团子"},{"id":"94ff201ca1ae476922b8d2b0356a8a36","title":"03_css选择器","content":"昨日回顾标签的分类\n\t行级标签 不能独占一行 span \n\t块级标签 独占一行  div \n常见的标签\n\t文档结构标签 html head title body\n\t文本相关标签 h1-h6 p font\n\t格式相关标签 hr br b i u \n\t列表相关标签 ul ol li\n\t图片媒体相关 img audio video\n\t超链接标签   a href target\n\t语义化标签 header footer main aside section article\n\t表单相关的标签\n\t\tform标签 定义表单提交的地址和范围\n\t\t\taction 提交地址\n\t\t\tmethod 提交方式\n\t\t\t\tget \n\t\t\t\tpost\n\t\tinput标签 用于输入或者选择信息\n\t\t\ttype \n\t\t\t\ttext 文本框\n\t\t\t\tpassword 密码框\n\t\t\t\tradio 单选\n\t\t\t\tcheckbox 多选\n\t\t\t\tfile 文件框\n\t\t\t\tsubmit 提交\n\t\t\t\treset 重置\n\t\t\t\tbutton 普通按钮\n\t\t\tname\n\t\t\t\t将数据提交到后台\n\t\t\t\t给单选和复选框进行分组\n\t\t\tvalue\n\t\t\t\t可以区分单选和复选框选中的数据\n\n\n\n表单标签form 表单标签 定义表单要提交的范围和提交的地址\n\t重要属性\n\t\taction:提交的地址,默认提交的是当前页面\n\t\tmethod:规定用于发送表单数据的 HTTP 方法\n\t\t\tget:把数据拼接在地址栏的后面,相对的不安全,只能提交少量数据(默认就是get)\n\t\t\tpost:把数据拼接在请求体中,相对的安全,可以提交大量数据,主要用于文件上传下载\n\ninput 输入项标签 根据type属性值的不同,呈现不同的样式,让用户输入或者选择\n\t重要属性\n\t\ttype\n\t\t\ttext    文本框(默认)\n\t\t\tpassword 密码框(里面的内容不以明文显示)\n\t\t\tradio   单选框\n\t\t\tcheckbox    复选框\n\t\t\tfile    文件框(用于上传文件)\n\t\t\tsubmit  提交按钮(提交页面数据)\n\t\t\treset   重置按钮(恢复页面刚打开时的效果)\n\t\t\tbutton  普通按钮(结合js一起使用)\n\n\t\tchecked \n\t\t\tchecked  单选和复选框的默认选中状态\n\nselect 下拉选择框  对于取值只有固定的几个,可以考虑使用下拉选择框\n\toption 选择项标签\n\t\t重要属性\n\t\t\tselected\n\t\t\t\tselected  下拉选择框的默认选中\n\ntextarea 文本域 类似于大的文本框\n\t重要的属性\n\t\tcols 列数(宽度)\n\t\trows 行数(高度)\n\n通用属性\n\tname\n\t\t表单项元素要提交到后台,必须要有name属性\n\t\t对于单选和复选框,可以使用name进行分组\n\t\t可以设置submit,reset,button按钮上的默认文字\n\n\tvalue\n\t\t对于单选和复选框,需要指定value属性的值,用于区分用户选择了哪一个选项\n\t\t可以设置下拉选择框里面选择项option标签的值,设置之后提交到后台使用就是value里的值,否则用的是标签体\n\n表格标签表格标签\n\ttable\t\n\t\tborder 边框\n\t\twidth 宽度\n\t\theight 高度\n\t\tcellpadding 单元格边沿和内容之间的空白\n\t\tcellspacing 单元格之间的空白\n\t\talign 定义表格与周围元素的对齐方式\n\ttr\n\t\talign 定义内容的对齐方式\n\tth\t\n\t\t表头,在单元格的基础上加粗和居中\n\ttd\n\t\trowspan 跨行\n\t\tcolspan 跨列\n\n\n\nCSS概念及入门概念层叠样式表,用于设置样式,布局控制   主流的布局方式:div+css\n\n区别1,css更加专业,可以实现html属性实现不了的效果\n2,可以实现标签和样式的分离,提高样式的重用性,提高开发效率\n\nCSS引入方式行内样式概念\n\t使用style属性,在html标签上添加样式,也叫内联样式\n\t&lt;font style&#x3D;&quot;font-size: 1000px; color:green&quot;&gt;新茶上市,欢迎品尝&lt;&#x2F;font&gt;\n特点\n\t简单,耦合性强,不利于代码和样式的分离,没有复用性\n\n内部样式概念\n\t使用style标签,结合css选择器,来给元素添加样式\n\t&lt;style&gt;\n        font&#123; &#x2F;* 选择器:用来选择元素的 *&#x2F;\n            font-size: 48px;\n            color: green;\n        &#125;\n    &lt;&#x2F;style&gt;\n    \n特点\n\t实现了代码和样式的分离,可以在当前页面进行复用\n\n外部样式概念\n\t将css样式封装到一个css文件,然后通过link标签引入\n\t\n做法\n\t1,将样式抽取到一个css文件中\n        font&#123; &#x2F;* 选择器:用来选择元素的 *&#x2F;\n            font-size: 48px;\n            color: green;\n        &#125;\n    2,在页面中引入\n    \t&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;font.css&quot;&gt;\n    \t\n特点\n\t实现了代码和样式的分离,可以在多个页面中进行复用,可以统一网站的风格,或者实现换肤功能\n\n三种引入优先级行内样式的优先级是最高的,因为他只为这一行服务\n内部样式和外部样式的优先级是一样的,谁最后解析,显示谁\n\nCSS基本选择器id选择器概念\n\t通过id的属性值来选择元素,一般选择的是唯一的一个元素\n语法\n\t#id值\n注意\n\tid值不要以数字开头,同一个页面中id值也不要相同\n\n类选择器概念\n\t通过class属性的值来选择元素,一般选择的是一批元素(开发中最常用的)\n语法\n\t.class属性值\n\n元素选择器概念\n\t通过标签名来选择元素,一般选择的是一批元素\n语法\n\t元素名称(标签名)\n\n基本选择器优先级行内样式 &gt; id选择器 &gt; 类选择器 &gt; 元素选择器\n\n结论: 越是具体的优先级越高,越是通用模糊的优先级越低\n\nCSS扩展选择器并集选择器作用\n\t同时选择多个选择器\n语法\n\t选择器a,选择器b\n\n交集选择器作用\n\t同时选择多个条件的选择器\n语法\n\t选择器a选择器b\n\n后代选择器作用\n\t选择某一个元素的子孙后代\n语法\n\t选择器a 选择器b\n\n子选择器作用\n\t选择某一个元素的子代选择器\n格式\n\t选择器a &gt; 选择器b\n\n兄弟选择器作用\n\t选择某一个元素相邻的下一个元素\n格式\n\t选择器a + 选择器b\n\n属性选择器作用\n\t通过属性来选择元素,经常用在表单元素中\n格式\n\t[属性名] 或者 [属性名&#x3D;属性值]\n\n伪类选择器作用\n\t用来添加一些选择器的特殊效果。\n格式\n\ta:link &#123;color:#FF0000;&#125; &#x2F;* 未访问的链接 *&#x2F;\n\ta:visited &#123;color:#00FF00;&#125; &#x2F;* 已访问的链接 *&#x2F;\n\ta:hover &#123;color:#FF00FF;&#125; &#x2F;* 鼠标划过链接 *&#x2F;\n\ta:active &#123;color:#0000FF;&#125; &#x2F;* 已选中的链接 *&#x2F;\n\n","slug":"day03_上课笔记","date":"2022-12-01T11:09:11.926Z","categories_index":"前端三剑客","tags_index":"css","author_index":"团子"},{"id":"627ae9b93973501953e5d4b34d6ad23f","title":"02_html常用标签","content":"昨日回顾概念\n\t超文本标记语言,主要用于描述一个页面\n操作思想\n\t容器的思想(标签就相当于容器)\n特点\n\t语法宽松\n\t不区分大小写\n\t标签是预定义好\n组成\n\t标签\n\t标签体\n\t属性\n\t注释\n\t特殊字符\n\n标签分类按是否独占一行来划分\n行级元素如果上一行有空间,就在上一行显示,如果没有空间,才会另起一行(font,b)\nspan是纯粹的行级元素,默认是不可以换行,主要用于存放少量数据\n\n块级元素不管上一行有没有空间,直接另起一行显示(p,h1)\ndiv是纯粹的块级元素,默认是自动换行,主要用于布局(结合css)\n\n常用标签文档结构标签&lt;html&gt;\n\t&lt;head&gt;文档的头部&lt;&#x2F;head&gt;\n\t&lt;body&gt;文档的正文&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n文本相关标签字体标签 font\n标题标签 h1 - h6\n段落标签 p\n\n格式相关标签水平线 hr\n换行 br\n粗体 b strong\n斜体 i em\n下划线 u\n删除线 del\n高亮 mark\n\n列表相关标签无序列表 ul\n\t属性 type\n\t\n有序列表 ol\n\t属性 type\n\t\tstart\n列表项 li\n\n图片媒体标签图片标签\n\t标签名 img\n\t\t重要属性 \n\t\t\tsrc 图片路径,推荐使用相对路径\n\t\t\t\t如果图片和当前文件在同一个目录下,直接使用 图片名(.&#x2F;图片名)显示\n\t\t\t\t如果图片在当前文件的下一层目录,使用 目录名&#x2F;图片名(.&#x2F;目录名&#x2F;图片名)显示\n\t\t\t\t如果图片在当前文件的上一层目录,使用 ..&#x2F;图片名(..&#x2F;代表回退到上一层)显示\n\t\t其他属性\n\t\t\twidth:宽度\n\t\t\theight:高度\n\t\t\talt:图片无法显示的时候替代图片\n\t\t\ttitle:鼠标经过图片的时候提示文字\n音频标签\n\t标签名 audio\n\t重要的属性\n\t\tsrc 音频的路径\n\t\tcontrols 显示播放的控制面板\n\t\t\n视频标签\n\t标签名 video\n\t重要的属性\n\t\tsrc 视频的路径\n\t\tcontrols 显示播放的控制面板\n\n\n\n链接相关标签标签名 a\n\t重要的属性\n\t\thref 定义要跳转的资源的链接\n\t\t\t站外资源\n\t\t\t站内资源\n\t\t\t锚链接\n\t\ttarget 定义页面的打开方式\n\t\t\t_bank 在新的窗口打开\n\t\t\t_self 在当前窗口打开\n\n\n\n布局相关标签概念\n\t也叫语义化标签,没有任何样式,主要用于划分不同的区域,便于布局管理\n\n使用\n\t&lt;header&gt;\t定义了文档的头部区域\n\t&lt;main&gt;\t\t定义了文档的主体部分\n\t&lt;footer&gt;\t定义 section 或 document 的页脚。\n\t&lt;aside&gt;\t定义页面的侧边栏内容。\n\t&lt;section&gt;\t定义文档中的节（section、区段）[区域]。\n\t&lt;article&gt;\t定义页面独立的内容区域。\n\n注意\n\t这些都是块级元素,用于划分区域,主要跟css结合来布局页面\n\n表单相关标签概念\n\t主要是用于收集用户信息的\n分类\n\tform 表单标签 定义表单要提交的范围和提交的地址\n       重要属性\n          action:提交的地址,默认提交的是当前页面\n          method:规定用于发送表单数据的 HTTP 方法\n                get:把数据拼接在地址栏的后面,相对的不安全,只能提交少量数据(默认就是get)\n                post:把数据拼接在请求体中,相对的安全,可以提交大量数据,主要用于文件上传下载\n\n   input 输入项标签 根据type属性值的不同,呈现不同的样式,让用户输入或者选择\n           重要属性\n             type\n                text    文本框(默认)\n                password 密码框(里面的内容不以明文显示)\n                radio   单选框\n                checkbox    复选框\n                file    文件框(用于上传文件)\n                submit  提交按钮(提交页面数据)\n                reset   重置按钮(恢复页面刚打开时的效果)\n                button  普通按钮(结合js一起使用)\n\n             checked \n                  checked  单选和复选框的默认选中状态\n\n            通用属性\n                name\n                    表单项元素要提交到后台,必须要有name属性\n                    对于单选和复选框,可以使用name进行分组\n\n                value\n                    对于单选和复选框,需要指定value属性的值,用于区分用户选择了哪一个选项\n\n","slug":"day02_上课笔记","date":"2022-12-01T11:07:16.448Z","categories_index":"前端三剑客","tags_index":"html","author_index":"团子"},{"id":"e6b640e4d28251deb6bc8140b6579928","title":"Html基础","content":"一.HTML起步前言-认识网页1) 什么是网页网页就是一个.html的文件, 里面按照一定的规范书写了一些代码\n2) 网页是如何显示出来很多没有接触过 web 的学员可能会有这样一个疑问\n为什么 html 文件里写的是代码, 看到的网页却有具体的样子呢\n网页文件一般使用浏览器打开, 浏览器在加载网页文件后会根据代码 渲染 成我们看到的样子\n渲染: 也叫解析, 翻译, 加工 \n3) 网页的组成网页一般由三个方面构成\n\n结构(Structure): 网页中包含哪些内容\n样式(Style): 这些内容如何呈现出来\n行为(Behavior): 网页上的内容如何跟用户交互\n\n\n\n\n标准\n说明\n备注\n\n\n\n结构\n结构用于对网页元素进行整理和分类，主要指HTML\n\n\n\n样式\n表现用于设置网页元素的版式、颜色、大小等外观样式，主要指 CSS\n\n\n\n行为\n行为是指网页模型的定义及交互的编写，主要指 Javascript\n\n\n\n1 HTML 是什么\n\n\n\n\n\n\n\n\nHTML(Hyper Text Markup Language): 超文本标记语言\n\n超文本:\n超越文本: 不仅仅只有文本, 还有多媒体文件, 如: image 图片, audio 音频, video 视频\n超链接: 可以从一个页面跳到另一个页面\n\n\n标记语言: 带有固定的格式, 只是用来标记某种含义, 不是编程语言\n\n\n\n\n\n\n\n\n\n\n\n举例\n&lt;from&gt;我&lt;&#x2F;from&gt;\n&lt;to&gt;公司&lt;&#x2F;to&gt;\n&lt;title&gt;辞职申请&lt;&#x2F;title&gt;\n&lt;content&gt;世界那么大, 我想去看看&lt;&#x2F;content&gt;\n&lt;time&gt;2015.4.13&lt;&#x2F;time&gt;\n\n2 HTML 的组成HTML 由一系列的 元素 elements 组成, 在元素中包含 属性（Attribute）\n1) 元素\n\n\n\n\n\n\n\n\n示例\n&lt;p&gt;我的猫咪脾气爆:)&lt;&#x2F;p&gt;\n\n\n2) 属性元素中可以包含属性\n\n\n\n\n\n\n\n\n\n示例\n&lt;p class&#x3D;&quot;editor-note&quot;&gt;我的猫咪脾气爆:)&lt;&#x2F;p&gt;\n\n\n在有些教程里不分元素和标签, 都是混用的. 但是根据 HTML5 的规范, 元素(element)更加准确\n参考 MDN 文档: HTML 是何方神圣\n3 HTML 文档的基本结构HTML 有自己固定的基本格式\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;我的第一个页面&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    主体内容\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n\n\nHTML 标签名、属性名和大部分属性值统一用小写, 一般使用双引号\n推荐：\n&lt;head&gt;\n  &lt;title&gt;我的第一个页面&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt;\n&lt;&#x2F;body&gt;\n\n不推荐：\n&lt;Head&gt;\n  &lt;TITLE&gt;我的第一个页面&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n\n\n\n\n\n\n\n\n\n\n@扩展阅读\n更多关于文档的详细内容, 参考MDN文档: HTML 文档详解\n4 元素的分类HTML 的元素分为两类\n\n双标签元素\n单标签元素\n\n1) 双标签元素在 HTML 中, 绝大部分元素(99%)都是双标签元素, 即有开始, 有结束, 在标签内部可以包含内容\n&lt;标签名&gt; 内容 &lt;&#x2F;标签名&gt;\n比如: &lt;body&gt;我是文字&lt;&#x2F;body&gt;\n\n2) 单标签元素极少部分(常见就几个)元素不包含任何内容, 叫做空元素, 也叫单标签元素\n&lt;标签名 &#x2F;&gt; 比如: &lt;img &#x2F;&gt;\n\n5 元素的关系针对双标签元素, 主要存在两种关系\n\n嵌套关系(父子关系)\n并列关系(兄弟关系)\n\n\n嵌套关系\n\n&lt;head&gt;\n  &lt;title&gt;&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n\n\n2.并列关系\n&lt;head&gt;&lt;&#x2F;head&gt;\n&lt;body&gt;&lt;&#x2F;body&gt;\n\n\n二.HTML 入门1 HTML 的由来\n\n\n\n\n\n\n\n\n为什么发明 HTML? 或者说发明 HTML 是为了解决什么问题\n在早些年的时候. 人们获取信息的主要途径是看 报纸\n后来, 随着互联网的普及, 人们主要通过 电脑浏览网页 来获取信息(新闻)\n因此, 发明 HTML 最初的目的其实是为了解决人们如何通过电脑来看新闻的问题\n当然, 现在及未来, 移动互联网的兴起, 大家更多的会使用移动设备(手机, 平板)来看新闻\n\n\n\n\n\n\n\n\n\n移动互联网会取代互联网吗? 或者说手机会取代电脑吗\n移动互联网技术本质上还是是基于互联网的. 是对互联网的延伸和补充, 让大家能更方便的, 随时随地的使用互联网, 享受互联网的便捷\n\n通过上面的分析, 我们大概就能猜到 HTML 在设计的时候或多或少会参考报纸的一些理念.\n\n大致分析一下, 报纸上有哪些元素\n\n总标题\n文章\n段落\n图片\n页头页脚\n\n其实 HTML 也是这么设计的\n\nHTML 由元素组成, 认识 HTML 其实就是学习 HTML 中的元素. 本章主要介绍常见的 HTML 元素, 大致分为\n\n文本相关元素\n超文本相关元素\n布局相关元素\n表单元素(进阶部分介绍)\n表格元素(进阶部分介绍)\n\n\n\n\n\n\n\n\n\n\n说明\n当然, 如果你想了解更多, 更完整的 HTML 元素相关的内容的话\n还是请自行查阅 MDN: HTML 元素参考\n2 文本相关元素首先, 我们来了解跟文本相关的 HTML 元素\n1) 标题元素 h这里有六个标题元素 —— h1~h6\n每个元素代表文档中不同级别的内容;\n\nh1 表示主标题（the main heading）\nh2 表示二级子标题（subheadings）\nh3 表示三级子标题（sub-subheadings）\n\n其基本语法格式如下：\n&lt;h1&gt;标题文本&lt;&#x2F;h1&gt;\n&lt;h2&gt;标题文本&lt;&#x2F;h2&gt;\n&lt;h3&gt;标题文本&lt;&#x2F;h3&gt;\n&lt;h4&gt;标题文本&lt;&#x2F;h4&gt;\n&lt;h5&gt;标题文本&lt;&#x2F;h5&gt;\n&lt;h6&gt;标题文本&lt;&#x2F;h6&gt;\n\n\n\n\n\n\n\n\n\n\n\n强调\nHTML 只规定结构和内容. 不规定样式.\n总原则: 结构和样式分离, 结构由 HTML 控制, 样式由 CSS 控制!!!\n\n\n\n\n\n\n\n\n\n为什么看到的 h1 比 h2 大呢\n浏览器会给每个元素一些默认的样式. 而这些样式都是可以被修改的.\n事实上, 我们完全可以控制h2的样式, 让它看起来像h1. 但是从语义上来说, 是不同的\n\n\n\n\n\n\n\n\n\n@扩展-语义\n语义(semantic)是一个非常重要的概念, 通常表示一个元素有特殊的含义. 比如\nh1是一个语义元素, 一般表示一个网页中最重要的内容. 最好只出现一次, 这样有利于搜索引擎的处理\n参考 MDN: 为什么我们需要语义\n\n\n\n\n\n\n\n\n\n最佳实践\n\n您应该最好只对每个页面使用一次&lt;h1&gt;— 这是顶级标题，所有其他标题位于层次结构中的下方。\n请确保在层次结构中以正确的顺序使用标题。不要使用&lt;h3&gt;来表示副标题，后面跟&lt;h2&gt;来表示副副标题 - 这是没有意义的，会导致奇怪的结果。\n在可用的六个标题级别中，您应该旨在每页使用不超过三个，除非您认为有必要使用更多。具有许多级别的文档（即，较深的标题层次结构）变得难以操作并且难以导航。在这种情况下，如果可能，建议将内容分散在多个页面上。\n\n以上内容摘自 MDN: 编辑结构层次\n2) 段落元素 p单词缩写： paragraph 段落 [ˈpærəgræf] 无须记这个单词\n作用语义：\n可以把 HTML 文档分割为若干段落\n\n\n\n\n\n\n\n\n\n语法\n&lt;p&gt;内容&lt;&#x2F;p&gt;\n\n3) 综合小案例有这样一段文本, 请按照语义添加合适的元素, 使用网页的结构更清晰\n三国演义\n\n罗贯中\n\n第一回 宴桃园豪杰三结义 斩黄巾英雄首立功\n\n话说天下大势，分久必合，合久必分。周末七国分争，并入于秦。及秦灭之后，楚、汉分争，又并入于汉……\n\n第二回 张翼德怒鞭督邮 何国舅谋诛宦竖\n\n且说董卓字仲颖，陇西临洮人也，官拜河东太守，自来骄傲。当日怠慢了玄德，张飞性发，便欲杀之……\n\n却说张飞\n\n却说张飞饮了数杯闷酒，乘马从馆驿前过，见五六十个老人，皆在门前痛哭。飞问其故，众老人答曰：“督邮逼勒县吏，欲害刘公；我等皆来苦告，不得放入，反遭把门人赶打！”……\n\n4) 强调元素在人类语言中，为了突出一句话的意思，我们通常强调某些词，并且我们通常想要标记某些词作为重点或者在某种程度上的不同。 HTML 提供了许多语义化的元素，并且允许我们通过这些元素的意义标记正文内容，在这个章节中，我们将看到最常见的一小部分元素\n\n强调: 使用&lt;em&gt;\n非常重要: 使用&lt;strong&gt;\n\n表示强调 em当我们想要在口语中添加强调，我们重读某些词，以便隐含的说出我们想要说的意思。类似的，在写作中，我们通过将文字写成 斜体 来强调它\n\n\n\n\n\n\n\n\n\n举例\n\n表示非常重要 strong为了强调重要的词，在口语方面我们往往用重音强调，在文字方面则是用 粗体字 来达到强调的效果\n\n\n\n\n\n\n\n\n\n举例\n\n\n\n\n\n\n\n\n\n\n@扩展-表示强调的元素\n参考 MDN: 重点强调\n3 超文本相关元素超文本主要包括两层含义:\n\n超越普通文本, 如多媒体: 图片(img 元素), 音频(audio 元素), 视频(video 元素)\n超链接, a 元素\n\n1) 超链接元素 a正是因为超链接元素的存在, 将世界上所有的网页联系在一起, 使互联网成为一个互相联系的网络\n\n\n\n\n\n\n\n\n\n作用\n超链接可以使我们的文档跳转到任何其他的文档（或其他资源 resource）\n\n\n\n\n\n\n\n\n\n语法\n&lt;a href&#x3D;&quot;统一资源定位符(URL)&quot;&gt;显示信息&lt;&#x2F;a&gt;\n\n什么是 URLURL(Uniform Resource Locator): 统一资源定位符\n\n\n\n\n\n\n\n\n\nURL 就是我们在浏览器地址栏输入的内容\n基本结构\nprotocol :&#x2F;&#x2F; hostname[:port] &#x2F; path\n\n\n\n\n\n\n\n\n\n\n举例\n\nhttp://127.0.0.1:5500/01_体验html.html\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;超链接元素&lt;&#x2F;h1&gt;\n    &lt;h2&gt;超链接元素a: 可以使我们从一个网页跳转到另一个网页&lt;&#x2F;h2&gt;\n    &lt;hr &#x2F;&gt;\n    我是一个超链接, 点我可以跳转到百度:&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt;\n    &lt;hr &#x2F;&gt;\n   \t&lt;a href&#x3D;&quot;.&#x2F;01-第一个页面.html&quot;&gt;点我可以跳转到本站点的其它页面&lt;&#x2F;a&gt;\n    &lt;hr &#x2F;&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2) 图片元素 img图片元素允许我们将图片放到网页中, 这样我们的网页就变得漂亮起来\n\n\n\n\n\n\n\n\n\n语法\n&lt;img src&#x3D;&quot;文件路径&#x2F;文件名.后缀名&quot; &#x2F;&gt;\n\n文件路径\n\n\n\n\n\n\n\n\n什么是文件路径\n用来 表示 文件 或者 文件夹 在计算机存储的位置\n文件路径就是找到一个文件的途径. 有两个概念\n路径分类\n\n绝对路径(完整路径)\n\n\n\n\n\n\n\n\n\n举例\n/宇宙/银河系/太阳系/地球/中国/武汉/栋哥\n\n网络绝对路径: 从http://域名对应的地址开始查找, 直到找到目标文件为止\n本地绝对路径: 从计算机的根盘符下开始查找, 直到找到目标文件为止\n\n\n相对路径: 从当前文件开始查找, 直到找到目标文件为止\n\n\n\n\n\n\n\n\n\n举例\n指路, 从当前地方出发, 向前100米, 再左转\n./: 要找的文件在同级目录下\n../: 要找的文件在上一级目录 ../资源/01.jpg\n目录名/: 要找的文件在子目录中\n\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;图片元素img&lt;&#x2F;h1&gt;\n    &lt;h2&gt;可以在网页中嵌入图片&lt;&#x2F;h2&gt;\n    &lt;hr &#x2F;&gt;\n    &lt;ul&gt;\n      &lt;li&gt;\n        使用绝对路径: &lt;img src&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:5500&#x2F;blog.png&quot; width&#x3D;&quot;200px&quot; &#x2F;&gt;\n      &lt;&#x2F;li&gt;\n      &lt;li&gt;使用相对路径: &lt;img src&#x3D;&quot;.&#x2F;blog.png&quot; width&#x3D;&quot;200px&quot; &#x2F;&gt;&lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n最佳实践\n在 img 标签中, 最好使用相对路径\n3) 视频元素 videovideo 元素是 HTML5 新增的元素. 用于在 HTML 文档中嵌入媒体播放器\nvideo 标签就是用来播放视频的\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;视频元素video&lt;&#x2F;h1&gt;\n    &lt;h2&gt;可以在网页上播放视频&lt;&#x2F;h2&gt;\n    &lt;video src&#x3D;&quot;.&#x2F;test_video.mp4&quot; width&#x3D;&quot;480px&quot; autoplay controls muted&gt;&lt;&#x2F;video&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4 布局相关元素一个“典型的网站”可能会这样布局\n\n\n页头(header): 通常横跨于整个页面顶部有一个大标题 和/或 一个标志\n导航(nav): 指向网站各个主要区段的超链接\n主体(main): 中心的大部分区域是当前网页大多数的独有内容\n侧边栏(aside): 一些外围信息、链接、引用、广告等\n页脚(footer): 页脚放置公共信息（比如版权声明或联系方式）\n\n1) header\n可以是body的子元素, 表示网站的全局页头(常用)\n也可以是section或article的子元素, 表示这个区域的页头\n\n2) nav通常是body的子元素, 表示网站的顶部导航\n3) main网页的主体部分, 每个页面只能用一个main. 且直接做为body的子元素, 最后不要把他嵌套到别的元素中\n4) section 和 articlesection 表示一组类似功能的区块. article 表示一篇文章\n形式一: section 包含 article\n\n&lt;section&gt;\n  &lt;article&gt;\n    &lt;h2&gt;\n      标题一\n    &lt;&#x2F;h2&gt;\n    &lt;p&gt;内容....&lt;&#x2F;p&gt;\n  &lt;&#x2F;article&gt;\n  &lt;article&gt;\n    &lt;h2&gt;\n      标题二\n    &lt;&#x2F;h2&gt;\n    &lt;p&gt;内容....&lt;&#x2F;p&gt;\n  &lt;&#x2F;article&gt;\n  ...\n&lt;&#x2F;section&gt;\n\n形式二: article 包含 section\n\n5) footer通常做为页面的页脚\n6) 综合案例\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;二次元俱乐部&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 头部header-导航nav --&gt;\n    &lt;header&gt;\n      &lt;h1&gt;二次元俱乐部&lt;&#x2F;h1&gt;\n      &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;01.jpg&quot; alt&#x3D;&quot;logo&quot; &#x2F;&gt;\n      &lt;nav&gt;\n        &lt;a href&#x3D;&quot;#&quot;&gt;首页&lt;&#x2F;a&gt;\n        &lt;a href&#x3D;&quot;#&quot;&gt;产品&lt;&#x2F;a&gt;\n        &lt;a href&#x3D;&quot;#&quot;&gt;分类&lt;&#x2F;a&gt;\n        &lt;a href&#x3D;&quot;#&quot;&gt;联系我们&lt;&#x2F;a&gt;\n      &lt;&#x2F;nav&gt;\n    &lt;&#x2F;header&gt;\n    &lt;!-- 左侧main --&gt;\n    &lt;main&gt;\n      &lt;section&gt;\n        &lt;article&gt;文章一&lt;&#x2F;article&gt;\n        &lt;article&gt;文章二&lt;&#x2F;article&gt;\n        &lt;article&gt;文章三&lt;&#x2F;article&gt;\n      &lt;&#x2F;section&gt;\n\n      &lt;section&gt;\n        &lt;article&gt;文章一&lt;&#x2F;article&gt;\n        &lt;article&gt;文章二&lt;&#x2F;article&gt;\n        &lt;article&gt;文章三&lt;&#x2F;article&gt;\n      &lt;&#x2F;section&gt;\n    &lt;&#x2F;main&gt;\n    &lt;!-- 右侧aside --&gt;\n    &lt;aside&gt;\n      &lt;section&gt;热门&lt;&#x2F;section&gt;\n      &lt;section&gt;广告&lt;&#x2F;section&gt;\n    &lt;&#x2F;aside&gt;\n    &lt;!-- 底部footer --&gt;\n    &lt;footer&gt;版本所有©2000-2077&lt;&#x2F;footer&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n7) 无语义元素这里重点介绍两个元素\n\ndiv 元素\nspan 元素\n\n标准的制定者不可能把生活中的所有内容都语义化.\n所以 80%的情况下, 不好确定某个部分的具体语义时, 一般使用无语义元素.\n\n\n\n\n\n\n\n\n\n提示\n无语义元素反而是使用的更多的元素, 在 HTML5 标准之前, 布局基本都是使用 div\n5 块元素与行元素本节是非常重要的一节!\n前面关于元素的分类是按照功能性进行划分的\n从显示上进行划分, 元素又可以被分为\n\n块元素(block element): 独占一行显示的元素\n行元素(inline element): 多个元素在同一行上显示的元素\n\n1) 默认的块元素\n标题元素: h1~h6\n段落元素: p\n列表元素: ul ol dl li\n布局元素: header nav main section article\n无语义元素: div\n\n一般块元素里可以放其它元素, 或者文本内容\n2) 默认的行元素\n超文本元素: a\n图片元素: img\n无语义元素: span\n\n\n\n\n\n\n\n\n\n\n特别说明\n\n元素是块元素还是行元素, 不是由 html 决定的. html 只定义结构, 显示是由 CSS 控制的\n决定元素是块元素还是行元素, 是通过 CSS 的 display 属性控制的.\n\n6 列表元素列表元素按使用频率可以细分为\n\n无序列表(ul: unordered list)\n有序列表(ol: ordered list)\n描述列表(dl: description list)\n\n1) 无序列表 ul表示列表项之间是没有先后顺序的\n\n\n\n\n\n\n\n\n\n示例\nemmet: ul&gt;li*3&gt;lorem1\n\n&lt;ul&gt;\n  &lt;li&gt;Lorem.&lt;&#x2F;li&gt;\n  &lt;li&gt;Quisquam.&lt;&#x2F;li&gt;\n  &lt;li&gt;Sapiente.&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n2) 有序列表 ol表示列表项之间是存在先后顺序的\n\n\n\n\n\n\n\n\n\n示例\nemmet: ol&gt;li&#123;第$项&#125;*3\n\n&lt;ol&gt;\n  &lt;li&gt;第1项&lt;&#x2F;li&gt;\n  &lt;li&gt;第2项&lt;&#x2F;li&gt;\n  &lt;li&gt;第3项&lt;&#x2F;li&gt;\n&lt;&#x2F;ol&gt;\n\n3) 描述列表 dl表示一个自定义的列表\nemmet: dl&gt;(dt&#123;标题$&#125;+dd&#123;内容$&#125;)*3\n\n&lt;dl&gt;\n  &lt;dt&gt;标题1&lt;&#x2F;dt&gt;\n  &lt;dd&gt;内容1&lt;&#x2F;dd&gt;\n  &lt;dt&gt;标题2&lt;&#x2F;dt&gt;\n  &lt;dd&gt;内容2&lt;&#x2F;dd&gt;\n  &lt;dt&gt;标题3&lt;&#x2F;dt&gt;\n  &lt;dd&gt;内容3&lt;&#x2F;dd&gt;\n&lt;&#x2F;dl&gt;\n\n7 表单1) 基本介绍\n\n\n\n\n\n\n\n\n生活中的表单\n在生活中, 比如我们去银行申请信用卡, 我们需要填写一张申请表\n\n在我们申请email的时候, 我们需要填写用户名, 密码这些信息\n\n像这些申请单在程序里就是以表单的形式的存在的\n\n\n\n\n\n\n\n\n\n表单的作用\n目的是为了收集用户的信息, 传递给服务器, 在服务器中存储\n2) 语法&lt;form action&#x3D;&quot;url地址&quot; method&#x3D;&quot;提交方式&quot; name&#x3D;&quot;表单名称&quot;&gt;\n  各种表单控件\n&lt;&#x2F;form&gt;\n\n常用属性：\n\n\n\n属性\n属性值\n作用\n\n\n\naction\nurl地址\n用于指定接收并处理表单数据的服务器程序的url地址。\n\n\nmethod\nget/post\n用于设置表单数据的提交方式，其取值为get或post。\n\n\nname\n名称\n用于指定表单的名称，以区分同一个页面中的多个表单。\n\n\n3) input元素\n\n\n\n\n\n\n\n\n语法\n&lt;input type&#x3D;&quot;属性值&quot; value&#x3D;&quot;你好&quot;&gt;\n\n\ninput 输入的意思 \ninput是单标签元素\ntype属性设置不同的属性值用来指定不同的控件类型\n除了type属性还有别的属性\n\n\n4) label元素\n\n\n\n\n\n\n\n\n语法\n&lt;label for&#x3D;&quot;sex&quot;&gt;男&lt;&#x2F;label&gt;\n&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; id&#x3D;&quot;sex&quot;&gt;\n\n5) textarea元素\n\n\n\n\n\n\n\n\n语法\n&lt;textarea &gt;\n  文本内容\n&lt;&#x2F;textarea&gt;\n\n6) select元素\n\n\n\n\n\n\n\n\n语法\n&lt;select&gt;\n  &lt;option&gt;选项1&lt;&#x2F;option&gt;\n  &lt;option&gt;选项2&lt;&#x2F;option&gt;\n  &lt;option&gt;选项3&lt;&#x2F;option&gt;\n  ...\n&lt;&#x2F;select&gt;\n\n8 表格1) 基本介绍为了更方便人们的阅读, 对于一些数据以表格的形式展现效果会更好, 比如\n\n还有: 成绩表, 工资表, 人员名单表,  商品清单表等等…\n在程序中, 我们使用table来表示\n2) 语法\n\n\n\n\n\n\n\n\n语法\n&lt;table&gt;\n  &lt;tr&gt;\n    &lt;th&gt;表头&lt;&#x2F;th&gt;\n  &lt;&#x2F;tr&gt;\n  &lt;tr&gt;\n    &lt;td&gt;单元格内的文字&lt;&#x2F;td&gt;\n    ...\n  &lt;&#x2F;tr&gt;\n  ...\n&lt;&#x2F;table&gt;\n\n\ntable用于定义一个表格标签。\ntr(table row) 用于定义表格中的行，必须嵌套在 table中\nth(table head)用于定义表格中的表头, 必须嵌套在tr中\ntd(table data) 用于定义表格中的单元格，必须嵌套在tr中\n\n3) table的常用属性\n\n\n\n\n\n\n\n\n\n示例\n&lt;table width&#x3D;&quot;600px&quot; border&#x3D;&quot;1&quot; cellspacing&#x3D;&quot;0&quot;&gt;\n  &lt;caption&gt;\n    xx中学高一课程表\n  &lt;&#x2F;caption&gt;\n  &lt;tr&gt;\n    &lt;th&gt;周一&lt;&#x2F;th&gt;\n    &lt;th&gt;周二&lt;&#x2F;th&gt;\n    &lt;th&gt;周三&lt;&#x2F;th&gt;\n    &lt;th&gt;周四&lt;&#x2F;th&gt;\n    &lt;th&gt;周五&lt;&#x2F;th&gt;\n  &lt;&#x2F;tr&gt;\n\n  &lt;tr&gt;\n    &lt;td&gt;语文&lt;&#x2F;td&gt;\n    &lt;td&gt;地理&lt;&#x2F;td&gt;\n    &lt;td&gt;语文&lt;&#x2F;td&gt;\n    &lt;td&gt;地理&lt;&#x2F;td&gt;\n    &lt;td&gt;数学&lt;&#x2F;td&gt;\n  &lt;&#x2F;tr&gt;\n  &lt;tr&gt;\n    &lt;td&gt;英语&lt;&#x2F;td&gt;\n    &lt;td&gt;美术&lt;&#x2F;td&gt;\n    &lt;td&gt;语文&lt;&#x2F;td&gt;\n    &lt;td&gt;政治&lt;&#x2F;td&gt;\n    &lt;td&gt;微机&lt;&#x2F;td&gt;\n  &lt;&#x2F;tr&gt;\n  &lt;tr&gt;\n    &lt;td&gt;数学&lt;&#x2F;td&gt;\n    &lt;td&gt;生物&lt;&#x2F;td&gt;\n    &lt;td&gt;语文&lt;&#x2F;td&gt;\n    &lt;td&gt;生物&lt;&#x2F;td&gt;\n    &lt;td&gt;微机&lt;&#x2F;td&gt;\n  &lt;&#x2F;tr&gt;\n  &lt;tr&gt;\n    &lt;td&gt;数学&lt;&#x2F;td&gt;\n    &lt;td&gt;英语&lt;&#x2F;td&gt;\n    &lt;td&gt;英语&lt;&#x2F;td&gt;\n    &lt;td&gt;体育&lt;&#x2F;td&gt;\n    &lt;td&gt;班会&lt;&#x2F;td&gt;\n  &lt;&#x2F;tr&gt;\n&lt;&#x2F;table&gt;\n\n4) 标题\n\n\n\n\n\n\n\n\n语法\n&lt;table&gt;\n   &lt;caption&gt;我是表格标题&lt;&#x2F;caption&gt;\n&lt;&#x2F;table&gt;\n\n5) 高级用法\n\n\n\n\n\n\n\n\n表格的合并\n\n跨行合并：rowspan=”合并单元格的个数”      \n跨列合并：colspan=”合并单元格的个数”\n\n","slug":"HTML","date":"2022-12-01T11:05:03.560Z","categories_index":"前端三剑客","tags_index":"html","author_index":"团子"},{"id":"8416d0c3a62e12a2fab3a68a80de7a85","title":"01_html概念入门","content":"HTML概念超文本标记语言,主要用于描述一个页面\n\n操作思想网页中有很多数据,不同的数据可能需要不同的展示效果,这个时候,就可以使用标签把要操作的数据包裹起来.通过修改标签的属性值,来实现标签内数据样式的改变\n\n一个标签就相当于一个容器,想要修改容器内的数据样式,只需要修改容器的属性值,就可以实现\n\n特点语法非常的宽松\n标签不区分大小写(建议小写)\n标签都是预定义好的,每个标签都有特殊的含义 \n\t xml语法(标签可以自定义)\n\t&lt;user&gt;\n\t\t&lt;username&gt;张三&lt;&#x2F;username&gt;\n\t\t&lt;password&gt;张三&lt;&#x2F;password&gt;\n\t&lt;&#x2F;user&gt;\n\n语法标签\n\t由尖括号括起来的关键字组成\n标签体\n\t开始标签和结束标签中间的所有内容,都叫做标签体,可以是一段普通的文本,也可以是其他标签\n属性\n\t为元素提供更多信息,可以改变元素的样式,以名称和值的形式出现\n注释\n\t解释说明, 设置行注释块级键(ctrl+&#x2F;)\n特殊字符\n\t空格\t&amp;nbsp; \t小于号\t&lt;  大于号\t&gt;\n\n\n\n常用标签文档标签(页面结构标签)\n\t&lt;html&gt;\n\t\t&lt;head&gt;\t\t\t\t\t-- html的头部\n\t\t\t&lt;title&gt;&lt;&#x2F;title&gt;     -- html的标题\n\t\t&lt;&#x2F;head&gt;\n\t\t&lt;body&gt;\t\t\t\t\t-- html的正文\n\t\t&lt;&#x2F;body&gt;\n\t&lt;&#x2F;html&gt;\n\n","slug":"day01_上课笔记","date":"2022-12-01T11:03:41.173Z","categories_index":"前端三剑客","tags_index":"html","author_index":"团子"},{"id":"b785373ff41b86c86fee988839b61307","title":"你好，欢迎到访团子的博客","content":"欢迎首位用户，安红红同学！\n","slug":"你好，欢迎到访团子的博客","date":"2022-12-01T01:38:04.832Z","categories_index":"测试","tags_index":"hello","author_index":"团子"},{"id":"73a4f8512e04fe7927935c7418b949d7","title":"在前端页面调用api时的问题","content":"1.请求路径利用.env.development文件去实现url的统一化。代码\n.env.developmentVITE_APP_BASE_API =’http://localhost:3000&#39;\n2.在request文件夹内，新建index.js文件，实现拦截器，用于封装所有请求的通用功能（get,post,patch,put..）import axios from ‘axios’\naxios.defaults.baseURL = import.meta.env.VITE_APP_BASE_APIaxios.defaults.timeout = 3000/**\n\nhttp request 拦截器\n/axios.interceptors.request.use(  (config) =&gt; {config.data = JSON.stringify(config.data)\nconfig.headers = &#123;\n  &#39;Content-Type&#39;: &#39;application/json&#39;,\n&#125;\nreturn config\n\n  },  (error) =&gt; {return Promise.reject(error)\n\n  })/**\nhttp response 拦截器\n/axios.interceptors.response.use((response) =&gt; {  if (response.data.errCode === 2) {console.log(&#39;过期&#39;)\n\n  }  return response},(error) =&gt; {  console.log(‘请求出错：’, error)})\n\n/**\n封装get方法\n@param url  请求url\n@param params  请求参数\n@returns {Promise}\n/export function get(url, params = {}) {return new Promise((resolve, reject) =&gt; {  axios.get(url, &#123;\n  params: params,\n&#125;)\n.then((response) =&gt; &#123;\n  landing(url, params, response.data)\n  resolve(response.data)\n&#125;)\n.catch((error) =&gt; &#123;\n  reject(error)\n&#125;)\n\n})}\n\n/**\n封装post请求\n@param url\n@param data\n@returns {Promise}\n/\n\nexport function post(url, data) {  return new Promise((resolve, reject) =&gt; {axios.post(url, data).then(\n  (response) =&gt; &#123;\n    //关闭进度条\n    resolve(response.data)\n  &#125;,\n  (err) =&gt; &#123;\n    reject(err)\n  &#125;\n)\n\n  })}/**\n封装patch请求\n@param url\n@param data\n@returns {Promise}\n/export function patch(url, data = {}) {return new Promise((resolve, reject) =&gt; {  axios.patch(url, data).then((response) =&gt; &#123;\n  resolve(response.data)\n&#125;,\n(err) =&gt; &#123;\n  msag(err)\n  reject(err)\n&#125;\n\n  )})}\n\n/**\n封装put请求\n@param url\n@param data\n@returns {Promise}\n/\n\nexport function put(url, data = {}) {  return new Promise((resolve, reject) =&gt; {axios.put(url, data).then(\n  (response) =&gt; &#123;\n    resolve(response.data)\n  &#125;,\n  (err) =&gt; &#123;\n    msag(err)\n    reject(err)\n  &#125;\n)\n\n  })}//统一接口处理，返回数据export default function (fecth, url, param) {  let _data = ‘’  return new Promise((resolve, reject) =&gt; {switch (fecth) &#123;\n  case &#39;get&#39;:\n    // console.log(&#39;begin a get request,and url:&#39;, url)\n    get(url, param)\n      .then(function (response) &#123;\n        resolve(response)\n      &#125;)\n      .catch(function (error) &#123;\n        // console.log(&#39;get request GET failed.&#39;, error)\n        reject(error)\n      &#125;)\n    break\n  case &#39;post&#39;:\n    post(url, param)\n      .then(function (response) &#123;\n        resolve(response)\n      &#125;)\n      .catch(function (error) &#123;\n        // console.log(&#39;get request POST failed.&#39;, error)\n        reject(error)\n      &#125;)\n    break\n  default:\n    break\n&#125;\n\n  })}/**\n查看返回的数据\n@param url\n@param params\n@param data\n/function landing(url, params, data) {  if (data.code === -1) {  }}\n\n3.对应事件写对应请求import http from ‘./index’export default {  // 请求示例  /* getBanner() {    return new Promise((resolve, reject) =&gt; {      http(‘get’, ‘/banner’).then(        (res) =&gt; {          resolve(res)        },        (error) =&gt; {          reject(error)        }      )    })  }, */\n  // 获取所有公告  getNotice() {    return new Promise((resolve, reject) =&gt; {      http(‘get’, ‘/gg_notice’).then(        (res) =&gt; {          resolve(res)        },        (error) =&gt; {          reject(error)        }      )    })  },  // 添加公告 data: {content,title,username}  addNotice(data) {    return new Promise((resolve, reject) =&gt; {      http(‘post’, ‘/gg_notice’, data).then(        (res) =&gt; {          resolve(res)        },        (error) =&gt; {          reject(error)        }      )    })  },}\n","slug":"在前端页面调用api时的问题","date":"2022-11-30T19:16:44.834Z","categories_index":"学习笔记","tags_index":"axios","author_index":"团子"},{"id":"84c5d95635333c1f19b7db5d1c2143cd","title":"箭头的缺点","content":"1、函数内部没有arguments2、不兼容call,apply,bind3、不能作为对象的方法4、代码难以阅读1、arguments函数内部没有arguments/* 1、函数内部没有arguments /function go(){    console.log(arguments)}const fn  = ()=&gt;{    console.log(arguments);}go();fn();2、不兼容call,apply,bindvar name = “window”;function go() {    console.log(this.name)}const fn = () =&gt; {    console.log(this.name)}go.call({ name: “vue” });fn.call({ name: “react” })//❌箭头函数不兼容call,bind,apply3、不能作为对象的方法/ 不能作为对象的方法 /var obj = {    name: “react”,    sayName: () =&gt; {        console.log(this.name)    }}obj.sayName(); //❌4、代码可读性差/ 代码可读性差 */var a =20;const fn = ()=&gt;a&gt;10? ‘正确’:’错误’;\n","slug":"箭头的缺点","date":"2022-11-30T19:16:44.832Z","categories_index":"学习笔记","tags_index":"javascript","author_index":"团子"},{"id":"1f8d1e15bde0d92144a385b911e17e2d","title":"节流和防抖的总结","content":"一、总结1、节流：本质上是对执行频率的限制，有节奏的在执行。(走A)2、防抖：本质上是对执行次数的限制，多次密集触发的情况下，只会执行一次。(回城)3、节流更关注”过程”，防抖关注”结果”。二、重点● 过程(限制频率) vs 结果。● 实际工作 https://www.lodashjs.com/\n","slug":"节流和防抖的总结","date":"2022-11-30T19:16:44.828Z","categories_index":"学习笔记","tags_index":"javascript","author_index":"团子"}]