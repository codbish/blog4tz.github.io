[{"id":"b785373ff41b86c86fee988839b61307","title":"你好，欢迎到访团子的博客","content":"一名在路上的WebGiser，记录学习之路\n","slug":"你好，欢迎到访团子的博客 copy 2","date":"2022-12-02T10:53:16.489Z","categories_index":"welcome","tags_index":"hello","author_index":"团子"},{"id":"c167393a4acf0fefa10f0093679620ef","title":"任务","content":"12月3号 组件通信复习，看视频+看文档+总结","slug":"任务","date":"2022-12-02T10:42:29.611Z","categories_index":"梳理","tags_index":"Vue2基础","author_index":"团子"},{"id":"757df1fd86f1866fcfb8bc703ef31782","title":"javaScript高级","content":"1 - 预编译概念1) 什么是预编译首先, 我们要知道Javascript是解释性语言\n\n解释性: 逐行解析, 逐行执行\n\n那么, 什么是预编译呢?\n在Javascript真正被解析之前, js解析引擎会首先把整个文件进行预处理, 以消除一些歧义. 这个预处理的过程就被称为预编译\n\n\n\n\n\n\n\n\n\n示例\nconsole.log(a)\nvar a &#x3D; 123\nconsole.log(a)\nfunction a() &#123;\n  console.log(a)\n&#125;\na()\n\n这是一段奇怪的代码, 大家可以先思考一下, 三个console.log分别会打印出什么\n如果要完全理解, 我们就需要深入的分析js引擎到底是如何工作的!!!\n2) 全局对象GO\n\n\n\n\n\n\n\n\n全局对象\n全局对象(Global Object): \n\n在浏览器环境中, js引擎会整合所有的&lt;script&gt;标签中的内容, 产生window对象, 这个window对象就是全局对象\n在node环境中, 会产生global对象\n\n全局变量在&lt;script&gt;标签中声明的变量为全局变量, 全局变量会作为window对象的属性存在!!\n\n\n\n\n\n\n\n\n\n示例\nvar a &#x3D; 100\nconsole.log(a)\nconsole.log(window.a)\n\n这里打印a实际上相当于打印window对象的a属性\n\n\n\n\n\n\n\n\n\n扩展\n啥叫整合?\n\n\n\n\n\n\n\n\n\n示例\n&lt;script&gt;\n  var a &#x3D; 100\n  console.log(a)\n  console.log(window.a)\n&lt;&#x2F;script&gt;\n&lt;script&gt;\n  &#x2F;&#x2F; 在这里能访问到a吗???\n  console.log(a)\n&lt;&#x2F;script&gt;\n\n\n可以, 因为js引擎会把所有的&lt;script&gt;标签整合到一起, 生成一个window对象\n\n全局函数在&lt;script&gt;标签中声明的函数为全局函数, 全局函数会作为window对象的方法存在!!\n\n\n\n\n\n\n\n\n\n示例\nfunction a() &#123;\n  console.log(&#39;111&#39;)\n&#125;\nconsole.log(window.a)\n\n\n\n那么问题来了, 当同时定义变量a和函数a时, 会发生什么呢?\n就像我们看到的奇怪代码里一样, 而预编译就是为了处理类似的这些冲突\n3) 活动对象AO\n\n\n\n\n\n\n\n\n活动对象\n活动对象(Activation Object): 也叫激活对象\n\n在函数被调用时产生, 用来保存当前函数内部的执行环境(Execution Context), 也叫执行期上下文\n在函数调用结束时销毁\n\n局部变量在函数内部声明的变量叫局部变量, 局部变量做为AO对象的属性存在\n\n\n\n\n\n\n\n\n\n示例\nfunction a() &#123;\n  var i &#x3D; 0\n  console.log(i)\n&#125;\na()\n\n\n\n\n\n\n\n\n\n\n\n如何理解局部\n在函数a的外部, 不能访问变量i, 变量i只在函数a的范围内才能使用. 其实, 这也就是作用域的由来, skr~\n\n如果不执行函数, 不会产生AO对象, 就不会存在i属性\n如果执行函数, 就会产生AO对象, 并将变量i作为AO对象的属性\n函数执行完后, AO对象被销毁, 也就意味着不能使用i属性\n\n局部函数在函数内部声明的函数叫局部函数, 局部函数做为AO对象的方法存在\n\n\n\n\n\n\n\n\n\n示例\nfunction a() &#123;\n  function b() &#123;\n    console.log(222)\n  &#125;\n  b()\n&#125;\na()\n\n\n2 - 全局预编译1) 流程\n查找变量声明, 作为GO对象的属性名, 值为undefined\n查找函数声明, 作为GO对象的属性名, 值为function\n\n\n\n\n\n\n\n\n\n\n变量声明\n通过var关键字声明变量\nvar a &#x2F;&#x2F; 变量声明\nvar a &#x3D; 111 &#x2F;&#x2F; 变量声明+变量赋值\n\n\n\n\n\n\n\n\n\n\n函数声明\n通过function关键字声明函数\nfunction a () &#123;&#125; &#x2F;&#x2F; 函数声明\nvar a &#x3D; function () &#123;&#125; &#x2F;&#x2F; 函数表达式, 不是函数声明\n\n\n\n\n\n\n\n\n\n\n示例\nconsole.log(a)\nvar a &#x3D; 100\nconsole.log(a)\nfunction a() &#123;\n  console.log(111)\n&#125;\nconsole.log(a)\n\n\n\n2) 结论如果存在同名的变量和函数, 函数的优先级高\n3 - 函数预编译1) 流程\n在函数被调用时, 为当前函数产生AO对象\n查找形参和变量声明作为AO对象的属性名, 值为undefined\n使用实参的值改变形参的值\n查找函数声明, 作为AO对象的属性名, 值为function\n\n2) 示例\n\n\n\n\n\n\n\n\n示例一\nfunction a(test) &#123;\n  var i &#x3D; 0\n  function b() &#123;\n    console.log(222)\n  &#125;\n  b()\n&#125;\na(1)\n\n\n\n在函数a的AO对象中, 存在三个属性\n\ntest: 形参, 值为1\ni: 局部变量, 值为0\nb: 局部函数\n\n\n\n\n\n\n\n\n\n\n示例二\nfunction a(test) &#123;\n  console.log(b)\n  var b &#x3D; 0\n  console.log(b)\n  function b() &#123;\n    console.log(222)\n  &#125;\n&#125;\na(1)\n\n\n\n当局部变量与局部函数同名时, 函数的优先级高\n\n\n\n\n\n\n\n\n\n示例三\nfunction a(b, c) &#123;\n  console.log(b)\n  var b &#x3D; 0\n  console.log(b)\n  function b() &#123;\n    console.log(222)\n  &#125;\n  console.log(c)\n&#125;\na(1)\n\n\n\n\n\n\n\n\n\n\n\n\n示例四\nfunction a(i) &#123;\n  var i\n  console.log(i)\n&#125;\na(1)\n\n3) 结论只要声明了局部函数, 函数的优先级最高\n没有声明局部函数, 实参的优先级高\n整体来说: 局部函数 &gt; 实参 &gt; 形参和局部变量\n4 - 作用域与作用域链4.1 作用域概念及分类概述通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。\n\nJavaScript（es6前）中的作用域有两种：\n\n\n全局作用域\n局部作用域（函数作用域）    \n\n分类全局作用域作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件。\n\n局部作用域作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。\n\n块级作用域\n块作用域由 { } 包括。\n\n在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码：    \njava有块级作用域：\nif(true)&#123;\n  int num &#x3D; 123;\n  system.out.print(num);  &#x2F;&#x2F; 123\n&#125;\nsystem.out.print(num);    &#x2F;&#x2F; 报错\n\n以上java代码会报错，是因为代码中 { } 即一块作用域，其中声明的变量 num，在 “{ }” 之外不能使用；\n而与之类似的JavaScript代码，则不会报错：\n\n\n  Js中没有块级作用域（在ES6之前）\n  if(true)&#123;\n  var num &#x3D; 123;\n  console.log(123); &#x2F;&#x2F;123\n&#125;\nconsole.log(123);   &#x2F;&#x2F;123\n\n4.2 作用域链概念及机制只要是代码都一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据在**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链\n\n案例分析1function f1() &#123;\n    var num &#x3D; 123;\n    function f2() &#123;\n        console.log( num );\n    &#125;\n    f2();\n&#125;\nvar num &#x3D; 456;\nf1();\n\n案例分析2作用域链：采取就近原则的方式来查找变量最终的值。\nvar a &#x3D; 1;\nfunction fn1() &#123;\n    var a &#x3D; 2;\n    var b &#x3D; &#39;22&#39;;\n    fn2();\n    function fn2() &#123;\n        var a &#x3D; 3;\n        fn3();\n        function fn3() &#123;\n            var a &#x3D; 4;\n            console.log(a); &#x2F;&#x2F;a的值 ?\n            console.log(b); &#x2F;&#x2F;b的值 ?\n        &#125;\n    &#125;\n&#125;\nfn1();\n\n4.3 作用域本质分析1) 域\n\n\n\n\n\n\n\n\n域: 范围, 区域\n在js中, 作用域分为全局作用域和局部作用域\n\n全局作用域: 由&lt;script&gt;标签产生的区域, 从计算机的角度可以理解为window对象\n局部作用域: 由函数产生的区域, 从计算机的角度可以理解为该函数的AO对象\n\n2) 作用域链在js中, 函数存在一个隐式属性[[scopes]], 这个属性用来保存当前函数在执行时的环境(上下文), 由于在数据结构上是链式的, 也被称为作用域链. 我们可以把它理解成一个数组\n\n\n\n\n\n\n\n\n\n函数类型存在[[scopes]]属性\nfunction a() &#123;&#125;\n\nconsole.dir(a) &#x2F;&#x2F; 打印内部结构\n\n输出\n[[scopes]]属性在函数声明时产生, 在函数被调用时更新\n[[scopes]]属性记录当前函数的执行环境\n在函数被调用时, 将该函数的AO对象压入到[[scopes]]中\n\n\n\n\n\n\n\n\n\n示例\nfunction a() &#123;\n  console.dir(a)\n  function b() &#123;\n    console.dir(b)\n    function c() &#123;\n      console.dir(c)\n    &#125;\n    c()\n  &#125;\n  b()\n&#125;\na()\n\n\n\n\n\n\n\n\n\n\n演示\n[[scopes]]属性是一个数组的形式\n0: 是函数b的AO对象\n1: 是GO对象\n3 作用作用域链有什么作用呢?\n在访问变量或者函数时, 会在作用域链上依次查找, 最直观的表现是: \n\n内部函数可以使用外部函数声明的变量\n\n\n\n\n\n\n\n\n\n\n示例\nfunction a() &#123;\n  var aa &#x3D; 111\n  function b() &#123;\n    console.log(aa)\n  &#125;\n  b()\n&#125;\na()\n\n\n在函数a中声明定义了变量aa\n在函数b中没有声明, 却可以使用\n\n\n\n\n\n\n\n\n\n\n思考\n如果在函数b中, 也定义同名变量aa会怎样\n\n\n\n\n\n\n\n\n\n示例\nfunction a() &#123;\n  var aa &#x3D; 111\n  function b() &#123;\n    var aa &#x3D; 222\n    console.log(aa)\n  &#125;\n  b()\n&#125;\na()\n\n第一个问题: 函数a和函数b里的变量aa是不是同一个变量?\n第二个问题: 函数b里打印的aa是用的谁?\n\n\n\n\n\n\n\n\n\n结论\n内部函数可以使用外部函数的变量\n外部函数不能使用内部函数的变量\n5 - 原型和this指向5.1对象的三种创建方式–复习\n字面量方式\nvar obj &#x3D; &#123;&#125;;\nnew关键字\nvar obj &#x3D; new Object();\n构造函数方式\nfunction Person(name,age)&#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n&#125;\nvar obj &#x3D; new Person(&#39;zs&#39;,12);\n\n5.2静态成员和实例成员5.2.1实例成员实例成员就是构造函数内部通过this添加的成员 如下列代码中uname age sing 就是实例成员,实例成员只能通过实例化的对象来访问\n function Star(uname, age) &#123;\n     this.uname &#x3D; uname;\n     this.age &#x3D; age;\n     this.sing &#x3D; function() &#123;\n     console.log(&#39;我会唱歌&#39;);\n    &#125;\n&#125;\nvar ldh &#x3D; new Star(&#39;刘德华&#39;, 18);\nconsole.log(ldh.uname);&#x2F;&#x2F;实例成员只能通过实例化的对象来访问\n\n5.2.2静态成员静态成员 在构造函数本身上添加的成员  如下列代码中 sex 就是静态成员,静态成员只能通过构造函数来访问\n function Star(uname, age) &#123;\n     this.uname &#x3D; uname;\n     this.age &#x3D; age;\n     this.sing &#x3D; function() &#123;\n     console.log(&#39;我会唱歌&#39;);\n    &#125;\n&#125;\nStar.sex &#x3D; &#39;男&#39;;\nvar ldh &#x3D; new Star(&#39;刘德华&#39;, 18);\nconsole.log(Star.sex);&#x2F;&#x2F;静态成员只能通过构造函数来访问\n\n5.3构造函数的问题构造函数方法很好用，但是存在浪费内存的问题。\n\n5.4构造函数原型prototype构造函数通过原型分配的函数是所有对象所共享的。\nJavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。\n我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。\nfunction Star(uname, age) &#123;\n    this.uname &#x3D; uname;\n    this.age &#x3D; age;\n&#125;\nStar.prototype.sing &#x3D; function() &#123;\n\tconsole.log(&#39;我会唱歌&#39;);\n&#125;\nvar ldh &#x3D; new Star(&#39;刘德华&#39;, 18);\nvar zxy &#x3D; new Star(&#39;张学友&#39;, 19);\nldh.sing();&#x2F;&#x2F;我会唱歌\nzxy.sing();&#x2F;&#x2F;我会唱歌\n\n\n\n5.5对象原型对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。\n__proto__对象原型和原型对象 prototype 是等价的\n__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype\n\n\n\n\n\n5.6constructor构造函数对象原型（ __proto__）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。\nconstructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。\n\t\t\t一般情况下，对象的方法都在构造函数的原型对象中设置。\n\n5.7原型链​    每一个实例对象又有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有__proto__属性，这样一层一层往上找就形成了原型链。\n5.8构造函数实例和原型对象三角关系1.构造函数的prototype属性指向了构造函数原型对象\n2.实例对象是由构造函数创建的,实例对象的__proto__属性指向了构造函数的原型对象\n3.构造函数的原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数\n\n\n\n\n\n5.9原型链和成员的查找机制任何对象都有原型对象,也就是prototype属性,任何原型对象也是一个对象,该对象就有__proto__属性,这样一层一层往上找,就形成了一条链,我们称此为原型链;\n当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。\n如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。\n如果还没有就查找原型对象的原型（Object的原型对象）。\n依此类推一直找到 Object 为止（null）。\n__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。\n\n5.10原型对象中this指向构造函数中的this和原型对象的this,都指向我们new出来的实例对象\nfunction Star(uname, age) &#123;\n    this.uname &#x3D; uname;\n    this.age &#x3D; age;\n&#125;\nvar that;\nStar.prototype.sing &#x3D; function() &#123;\n    console.log(&#39;我会唱歌&#39;);\n    that &#x3D; this;\n&#125;\nvar ldh &#x3D; new Star(&#39;刘德华&#39;, 18);\n&#x2F;&#x2F; 1. 在构造函数中,里面this指向的是对象实例 ldh\nconsole.log(that &#x3D;&#x3D;&#x3D; ldh);&#x2F;&#x2F;true\n&#x2F;&#x2F; 2.原型对象函数里面的this 指向的是 实例对象 ldh\n\n\n5.11通过原型为数组扩展内置方法Array.prototype.sum &#x3D; function() &#123;\n  var sum &#x3D; 0;\n  for (var i &#x3D; 0; i &lt; this.length; i++) &#123;\n  sum +&#x3D; this[i];\n  &#125;\n  return sum;\n&#125;;\n&#x2F;&#x2F;此时数组对象中已经存在sum()方法了  可以始终 数组.sum()进行数据的求\n\n6 - 函数进阶6.1函数的定义方式\n方式1 函数声明方式 function 关键字 (命名函数)\nfunction fn()&#123;&#125;\n方式2 函数表达式(匿名函数)\nvar fn &#x3D; function()&#123;&#125;\n方式3 new Function() \nvar f &#x3D; new Function(&#39;a&#39;, &#39;b&#39;, &#39;console.log(a + b)&#39;);\nf(1, 2);\n\nvar fn &#x3D; new Function(&#39;参数1&#39;,&#39;参数2&#39;..., &#39;函数体&#39;)\n注意\n&#x2F;*Function 里面参数都必须是字符串格式\n第三种方式执行效率低，也不方便书写，因此较少使用\n所有函数都是 Function 的实例(对象)  \n函数也属于对象\n*&#x2F;\n\n6.2函数的调用&#x2F;* 1. 普通函数 *&#x2F;\nfunction fn() &#123;\n\tconsole.log(&#39;人生的巅峰&#39;);\n&#125;\n fn(); \n&#x2F;* 2. 对象的方法 *&#x2F;\nvar o &#x3D; &#123;\n  sayHi: function() &#123;\n  \tconsole.log(&#39;人生的巅峰&#39;);\n  &#125;\n&#125;\no.sayHi();\n&#x2F;* 3. 构造函数*&#x2F;\nfunction Star() &#123;&#125;;\nnew Star();\n&#x2F;* 4. 绑定事件函数*&#x2F;\n btn.onclick &#x3D; function() &#123;&#125;;   &#x2F;&#x2F; 点击了按钮就可以调用这个函数\n&#x2F;* 5. 定时器函数*&#x2F;\nsetInterval(function() &#123;&#125;, 1000);  这个函数是定时器自动1秒钟调用一次\n&#x2F;* 6. 立即执行函数(自调用函数)*&#x2F;\n(function() &#123;\n\tconsole.log(&#39;人生的巅峰&#39;);\n&#125;)();\n\n6.3函数内部的this指向这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同\n一般指向我们的调用者.\n6.4改变函数内部 this 指向call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向\nvar o &#x3D; &#123;\n\tname: &#39;andy&#39;\n&#125;\n function fn(a, b) &#123;\n      console.log(this);\n      console.log(a+b)\n&#125;;\nfn(1,2)&#x2F;&#x2F; 此时的this指向的是window 运行结果为3\nfn.call(o,1,2)&#x2F;&#x2F;此时的this指向的是对象o,参数使用逗号隔开,运行结果为3\n\n以上代码运行结果为:\n6.5.高阶函数高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。\n此时fn 就是一个高阶函数\n函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。\n同理函数也可以作为返回值传递回来\n7 - 闭包7.1变量的作用域复习变量根据作用域的不同分为两种：全局变量和局部变量。\n\n函数内部可以使用全局变量。\n函数外部不可以使用局部变量。\n当函数执行完毕，本作用域内的局部变量会销毁。\n\n7.2什么是闭包闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。 \n7.3闭包的作用作用：延伸变量的作用范围。\n function fn() &#123;\n   var num &#x3D; 10;\n   function fun() &#123;\n       console.log(num);\n \t&#125;\n    return fun;\n &#125;\nvar f &#x3D; fn();\nf();\n\n7.4闭包的案例闭包应用-3秒钟之后,打印所有li元素的内容\n for (var i &#x3D; 0; i &lt; lis.length; i++) &#123;\n   (function(i) &#123;\n     setTimeout(function() &#123;\n     console.log(lis[i].innerHTML);\n     &#125;, 3000)\n   &#125;)(i);\n&#125;\n\n8 - let和const8.1 letES6中新增了用于声明变量的关键字\nlet声明的变量只在所处于的块级有效 if (true) &#123; \n     let a &#x3D; 10;\n &#125;\nconsole.log(a) &#x2F;&#x2F; a is not defined\n\n注意：使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。\n不存在变量提升console.log(a); &#x2F;&#x2F; a is not defined \nlet a &#x3D; 20;\n\n暂时性死区利用let声明的变量会绑定在这个块级作用域，不会受外界的影响\nvar tmp &#x3D; 123;\nif (true) &#123; \n    tmp &#x3D; &#39;abc&#39;;\n    let tmp; \n&#125; \n\n经典面试题var arr &#x3D; [];\nfor (var i &#x3D; 0; i &lt; 2; i++) &#123;\n    arr[i] &#x3D; function () &#123;\n        console.log(i); \n    &#125;\n&#125;\narr[0]();\narr[1]();\n\n\n\n\n经典面试题图解：此题的关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值。\nlet arr &#x3D; [];\nfor (let i &#x3D; 0; i &lt; 2; i++) &#123;\n    arr[i] &#x3D; function () &#123;\n        console.log(i); \n    &#125;\n&#125;\narr[0]();\narr[1]();\n\n\n\n\n经典面试题图解：此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值.\n小结\nlet关键字就是用来声明变量的\n使用let关键字声明的变量具有块级作用域\n在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的\n防止循环变量变成全局变量\n使用let关键字声明的变量没有变量提升\n使用let关键字声明的变量具有暂时性死区特性\n\n8.2 const声明常量，常量就是值（内存地址）不能变化的量\n具有块级作用域 if (true) &#123; \n     const a &#x3D; 10;\n &#125;\nconsole.log(a) &#x2F;&#x2F; a is not defined\n\n声明常量时必须赋值const PI; &#x2F;&#x2F; Missing initializer in const declaration\n\n常量赋值后，值不能修改const PI &#x3D; 3.14;\nPI &#x3D; 100; &#x2F;&#x2F; Assignment to constant variable.\n\nconst ary &#x3D; [100, 200];\nary[0] &#x3D; &#39;a&#39;;\nary[1] &#x3D; &#39;b&#39;;\nconsole.log(ary); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;]; \nary &#x3D; [&#39;a&#39;, &#39;b&#39;]; &#x2F;&#x2F; Assignment to constant variable.\n\n小结\nconst声明的变量是一个常量\n既然是常量不能重新进行赋值，如果是基本数据类型，不能更改值，如果是复杂数据类型，不能更改地址值\n声明 const时候必须要给定值\n\n8.3 let、const、var 的区别\n使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象\n使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升\n使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值\n\n1 Script对象与Block对象let和const声明的变量不会挂载到GO(window)对象上, 而是做为Script对象的属性存在\n\n\n\n\n\n\n\n\n\n块作用域\n由&#123;&#125;形成块作用域, 会形成一个Block对象\n在&#123;&#125;里通过let和const声明的变量做为Block对象的属性\n\n\n\n\n\n\n\n\n\n示例\nlet i &#x3D; 1\n&#123;\n  let i &#x3D; 2\n  console.log(i)\n&#125;\nconsole.log(i)\n\n\n\n\n\n\n\n\n\n\n演示\n2 不能重复声明在同一个Script和同一个Block下, 不能重复声明, 会报语法错误\n\n\n\n\n\n\n\n\n\n示例\nlet i &#x3D; 1\n&#123;\n  let i &#x3D; 2\n  const i &#x3D; 3 &#x2F;&#x2F; 会报语法错误\n  console.log(i)\n&#125;\nconsole.log(i)\n\n3 声明前不能使用(TDZ)在变量声明前是不能使用的\n\n\n\n\n\n\n\n\n\n示例\nconsole.log(i) &#x2F;&#x2F; 在script作用域下, 声明前不能使用\nlet i &#x3D; 1\n&#123;\n  let i &#x3D; 2\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\nlet i &#x3D; 1\n&#123;\n  console.log(i) &#x2F;&#x2F; 在block作用域下, 声明前不能使用\n  let i &#x3D; 2\n&#125;\n\n我们通过也把这个区域叫做暂时性死区TDZ\n4 在for循环中使用let\n\n\n\n\n\n\n\n\n示例\nconst arr &#x3D; []\nfor (let i &#x3D; 0; i &lt; 3; i++) &#123;\n  arr[i] &#x3D; function () &#123;\n    console.log(i)\n  &#125;\n&#125;\narr[0]()\n\n\n\n\n\n\n\n\n\n\n演示\n看这里的作用域链\n所以, 当调用arr[0]时, 在自己的作用域链上查找, 先找到Block作用域中i的值0\n9 - 解构赋值ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构\n9.1 数组解构 let [a, b, c] &#x3D; [1, 2, 3];\n console.log(a)&#x2F;&#x2F;1\n console.log(b)&#x2F;&#x2F;2\n console.log(c)&#x2F;&#x2F;3\n&#x2F;&#x2F;如果解构不成功，变量的值为undefined\n\n9.2 对象解构let person &#x3D; &#123; name: &#39;zhangsan&#39;, age: 20 &#125;; \nlet &#123; name, age &#125; &#x3D; person;\nconsole.log(name); &#x2F;&#x2F; &#39;zhangsan&#39; \nconsole.log(age); &#x2F;&#x2F; 20\n\nlet &#123;name: myName, age: myAge&#125; &#x3D; person; &#x2F;&#x2F; myName myAge 属于别名\nconsole.log(myName); &#x2F;&#x2F; &#39;zhangsan&#39; \nconsole.log(myAge); &#x2F;&#x2F; 20\n\n\n9.3 小结\n解构赋值就是把数据结构分解，然后给变量进行赋值\n如果结构不成功，变量跟数值个数不匹配的时候，变量的值为undefined\n数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用逗号隔开\n利用解构赋值能够让我们方便的去取对象中的属性跟方法\n\n10 - 箭头函数10.1语法ES6中新增的定义函数的方式。\n() &#x3D;&gt; &#123;&#125; &#x2F;&#x2F;()：代表是函数； &#x3D;&gt;：必须要的符号，指向哪一个代码块；&#123;&#125;：函数体\nconst fn &#x3D; () &#x3D;&gt; &#123;&#125;&#x2F;&#x2F;代表把一个函数赋值给fn\n\n函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号\nfunction sum(num1, num2) &#123; \n    return num1 + num2; \n&#125;\n&#x2F;&#x2F;es6写法\nconst sum &#x3D; (num1, num2) &#x3D;&gt; num1 + num2; \n\n\n如果形参只有一个，可以省略小括号\n function fn (v) &#123;\n     return v;\n &#125; \n&#x2F;&#x2F;es6写法\n const fn &#x3D; v &#x3D;&gt; v;\n\n\n箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this\nconst obj &#x3D; &#123; name: &#39;张三&#39;&#125; \n function fn () &#123; \n     console.log(this);&#x2F;&#x2F;this 指向 是obj对象\n     return () &#x3D;&gt; &#123; \n         console.log(this);&#x2F;&#x2F;this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象\n     &#125; \n &#125; \n const resFn &#x3D; fn.call(obj); \n resFn();\n\n\n10.2 小结\n箭头函数中不绑定this，箭头函数中的this指向是它所定义的位置，可以简单理解成，定义箭头函数中的作用域的this指向谁，它就指向谁\n箭头函数的优点在于解决了this执行环境所造成的一些问题。比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题\n\n10.3 面试题var age &#x3D; 100;\n\nvar obj &#x3D; &#123;\n\tage: 20,\n\tsay: () &#x3D;&gt; &#123;\n\t\talert(this.age)\n\t&#125;\n&#125;\n\nobj.say();&#x2F;&#x2F;箭头函数this指向的是被声明的作用域里面，而对象没有作用域的，所以箭头函数虽然在对象中被定义，但是this指向的是全局作用域\n\n11 promise11.1 为什么需要promise像写同步代码一样写异步代码\n11.2 Promise的基本使用Promise是一个构造函数, 通过new关键字实例化对象\n\n\n\n\n\n\n\n\n\n语法\nnew Promise((resolve, reject)&#x3D;&gt;&#123;&#125;)\n\n\nPromise接受一个函数作为参数\n在参数函数中接受两个参数\nresolve: 成功函数\nreject: 失败函数\n\n\n\n\n\n\n\n\n\n\n\n\npromise实例\npromise实例有两个属性\n\nstate: 状态\nresult: 结果\n\n1) promise的状态第一种状态: pending(准备, 待解决, 进行中)\n第二种状态: fulfilled(已完成, 成功)\n第三种状态: rejected(已拒绝, 失败)\n2) promise状态的改变通过调用resolve()和reject()改变当前promise对象的状态\n\n\n\n\n\n\n\n\n\n示例\nconst p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; resolve(): 调用函数, 使当前promise对象的状态改成fulfilled\n  resolve()\n&#125;)\nconsole.dir(p) &#x2F;&#x2F; fulfilled\n\n\n\n\n\n\n\n\n\n\n示例\nconst p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; resolve(): 调用函数, 使当前promise对象的状态改成fulfilled\n  &#x2F;&#x2F; reject(): 调用函数, 使当前promise对象的状态改成rejected\n\n  &#x2F;&#x2F; resolve()\n  reject()\n&#125;)\nconsole.dir(p)\n\n\nresolve(): 调用函数, 使当前promise对象的状态改成fulfilled\nreject(): 调用函数, 使当前promise对象的状态改成rejected\n\n\n\n\n\n\n\n\n\n\npromise状态的改变是一次性的, 单向不可逆\n3) promise的结果\n\n\n\n\n\n\n\n\n示例\nconst p &#x3D; new Promise((resolve, reject)&#x3D;&gt; &#123;\n  &#x2F;&#x2F; 通过调用resolve, 传递参数, 改变 当前promise对象的 结果\n  resolve(&#39;成功的结果&#39;)\n  &#x2F;&#x2F;reject(&#39;失败的结果&#39;)\n&#125;)\nconsole.dir(p)\n\n11.3 Promise的方法then方法\n\n\n\n\n\n\n\n\n示例\nconst p &#x3D; new Promise((resolve, reject)&#x3D;&gt; &#123;\n  &#x2F;&#x2F; 通过调用resolve, 传递参数, 改变 当前promise对象的 结果\n  resolve(&#39;成功的结果&#39;)\n  &#x2F;&#x2F;reject(&#39;失败的结果&#39;)\n&#125;)\n\n&#x2F;&#x2F; then方法函数\n&#x2F;&#x2F; 参数\n&#x2F;&#x2F; 1. 是一个函数\n&#x2F;&#x2F; 2. 还是一个函数\n&#x2F;&#x2F; 返回值: 是一个promise对象\np.then(()&#x3D;&gt;&#123;\n  &#x2F;&#x2F; 当promise的状态是fulfilled时, 执行\n  console.log(&#39;成功时调用&#39;)\n&#125;, () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 当promise的状态是rejected时, 执行\n  console.log(&#39;失败时调用&#39;)\n&#125;)\nconsole.dir(p)\n\n\n\n\n\n\n\n\n\n\n示例\nconst p &#x3D; new Promise((resolve, reject)&#x3D;&gt; &#123;\n  &#x2F;&#x2F; 通过调用resolve, 传递参数, 改变 当前promise对象的 结果\n  &#x2F;&#x2F;resolve(&#39;123&#39;)\n  reject(&#39;失败的结果&#39;)\n&#125;)\n\n&#x2F;&#x2F; then方法函数\n&#x2F;&#x2F; 参数\n&#x2F;&#x2F; 1. 是一个函数\n&#x2F;&#x2F; 2. 还是一个函数\n&#x2F;&#x2F; 返回值: 是一个promise对象\np.then((value)&#x3D;&gt;&#123;\n  &#x2F;&#x2F; 当promise的状态是fulfilled时, 执行\n  console.log(&#39;成功时调用&#39;, value)\n&#125;, (err) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 当promise的状态是rejected时, 执行\n  console.log(&#39;失败时调用&#39;, err)\n&#125;)\nconsole.dir(p)\n\n\n在then方法的参数函数中, 通过形参使用promise对象的结果\n\n\n\n\n\n\n\n\n\n\nthen方法返回一个新的promise实例, 状态是pending\nconst p &#x3D; new Promise((resolve, reject)&#x3D;&gt; &#123;\n  &#x2F;&#x2F; 通过调用resolve, 传递参数, 改变 当前promise对象的 结果\n  resolve(&#39;123&#39;)\n  &#x2F;&#x2F;reject(&#39;失败的结果&#39;)\n&#125;)\n\n&#x2F;&#x2F; then方法函数\n&#x2F;&#x2F; 参数\n&#x2F;&#x2F; 1. 是一个函数\n&#x2F;&#x2F; 2. 还是一个函数\n&#x2F;&#x2F; 返回值: 是一个promise对象\nconst t &#x3D; p.then((value)&#x3D;&gt;&#123;\n  &#x2F;&#x2F; 当promise的状态是fulfilled时, 执行\n  console.log(&#39;成功时调用&#39;, value)\n&#125;, (reason) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 当promise的状态是rejected时, 执行\n  console.log(&#39;失败时调用&#39;, reason)\n&#125;)\nconsole.dir(t)\n\n\n\n\n\n\n\n\n\n\npromise的状态不改变, 不会执行then里的方法\n&#x2F;&#x2F; 如果promise的状态不改变, then里的方法不会执行\nnew Promise((resolve, reject) &#x3D;&gt; &#123;\n\n&#125;).then((value) &#x3D;&gt; &#123;\n  console.log(&#39;成功&#39;)\n&#125;, (reason) &#x3D;&gt; &#123;\n  console.log(&#39;失败&#39;)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n在then方法中, 通过return将返回的promise实例改为fulfilled状态\n&#x2F;&#x2F; 如果promise的状态不改变, then里的方法不会执行\nconst p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  resolve()\n&#125;)\n\nconst t &#x3D; p.then((value) &#x3D;&gt; &#123;\n  console.log(&#39;成功&#39;)\n  &#x2F;&#x2F; 使用return可以将t实例的状态改成fulfilled\n  return 123\n&#125;, (reason) &#x3D;&gt; &#123;\n  console.log(&#39;失败&#39;)\n&#125;)\n\nt.then((value) &#x3D;&gt; &#123;\n  console.log(&#39;成功2&#39;, value)\n&#125;, (reason) &#x3D;&gt; &#123;\n  console.log(&#39;失败&#39;)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n如果在then方法中, 出现代码错误, 会将返回的promise实例改为rejected状态\n&#x2F;&#x2F; 如果promise的状态不改变, then里的方法不会执行\nconst p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  resolve()\n&#125;)\n\nconst t &#x3D; p.then((value) &#x3D;&gt; &#123;\n  console.log(&#39;成功&#39;)\n  &#x2F;&#x2F; 使用return可以将t实例的状态改成fulfilled\n  &#x2F;&#x2F;return 123\n\n  &#x2F;&#x2F; 如果这里的代码出错, 会将t实例的状态改成rejected\n  console.log(a)\n\n&#125;, (reason) &#x3D;&gt; &#123;\n  console.log(&#39;失败&#39;)\n&#125;)\n\nt.then((value) &#x3D;&gt; &#123;\n  console.log(&#39;成功2&#39;, value)\n&#125;, (reason) &#x3D;&gt; &#123;\n  console.log(&#39;失败&#39;, reason)\n&#125;)\n\n","slug":"JavaScript高级","date":"2022-12-01T13:05:46.773Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"160798b2cf8572c8eb52185a8e5b18aa","title":"5、从输入地址从服务器响应发生了什么?","content":"\n","slug":"前端面试题-5、从输入地址从服务器响应发生了什么_new","date":"2022-12-05T09:10:01.818Z","categories_index":"GIS面试题","tags_index":"前端基础","author_index":"团子"},{"id":"5c4a517f312f359d9c867ffb751b4424","title":"4、Vue和React的区别","content":"\n相同点\n都使用了Virtual DOM（虚拟DOM）Virtual DOM + Diff算法。\n\n\n\n\n\n\n\n\n\n当ui更新时，根据render函数重新生成VNode(虚拟dom的节点)，再与原来的虚拟DOM进行对比，通过diff算法来更新真实的DOM\n\n都是用了组件化思想，流程基本一致。\n\n都是 响应式的。\n\n都提倡单向数据流\n不同点\n1.核心思想不同:::tips\n\n\n\nVue推崇渐进式开发体验，数据可变，双向数据绑定\nReact推崇函数式编程，单向数据流:::2.框架本质不同**Vue**本质是**MVVM**框架，由**MVC**发展而来；**React**是前端组件化框架，由后端组件化发展而来。\n\n\n\n\n\n\n\n\n**React**不是一个完整的MVC框架，最多可以认为是MVC中的（view）层，甚至React并不非常认可MVC开发模式；React构建页面UI的库。可以简单地理解为，React将界面分成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套、就成了我们的页面\n\n\n\n3.监听数据变化实现的原理的不同\n**vue2**通过**Object.defineProperty**来对**data**各个属性的**getter/setter**以及一些函数来监听数据的变化。\n**Vue3**通过**Proxy**设定数据对象的代理对象来劫持数据的变化。\n**vue**被劫持的数据会被收集到**watcher**里，当数据更新时，且在**watcher**里时，就会更新相关组件，否则不会更新。采用了数据劫持+观察者模式相结合的方式实现了双向绑定。\n而**react**则是通过比较引用(对象地址)的方式，来进行数据劫持。\n\n\n4.组件通信的区别相同点，推崇的都是单向数据流(vue1除外)\n\nVue2，3父子组件通信是通过自定义属性和事件来实现的。跨多级组件通信通过 **provide**,**inject**来实现\nreact则是通过自定义属性和传递方法(回调函数)实现的。跨多级组件通过**context** 实现。\n\n\n5.渲染方式的不同表层上：\n\nreact通过jsx语法进行渲染\nvue通过模板语法(插值语法，指令语法)\n\n实现的方式上：\n\nreact的渲染原理都是通过原生的js实现的，如条件渲染，通过三元表达式，列表渲染通过循环来实现\n\nvue的渲染是通过一系列指令来实现的，如v-for，v-if，v-bind，v-on等\n6.渲染的过程不同\nvue通过跟踪每一个组件的依赖关系，当组件的状态发生改变的时候，只会重新渲染改变的组件存在依赖关系的组件(父组件)，不会重新渲染整个组件树。\n\nreact 在父组件状态改变时，会更新所有的子组件。\n7.HOC与mixins，组合不同的功能的方式不同先说结论，具体看下面的内容。\n\n\n\n共同点\n都是用于组件逻辑复用实现的一种方式\n都不会对原来的组件或状态有影响\n\n\n不同点\n**HOC**，是一种对组件逻辑的加工，可以依据原来的逻辑生成新的逻辑功能\n**mixins**是对不同功能的组合HOC\n\n\n\n\nHOC高阶组件(实际上就是高阶函数–&gt;参数为函数，返回值为函数，还是一个纯函数)，并不是组件，是一个加工组件的函数，该函数会返回一个函数式组件，是复用组件逻辑的一种技巧。\n\n\n\n\n\n\n\n\n纯函数详解：\n\n\n纯函数\n\n\n\n\n\n\n\n\n\n高阶函数示例\nimport React from &#39;react&#39;;\n\nconst hoc &#x3D; (CountShow) &#x3D;&gt; &#123;\n  return (&#123; count &#125;) &#x3D;&gt; &#123;\n    return &lt;CountShow count&#x3D;&#123;count * 2&#125; &#x2F;&gt;;\n  &#125;;\n&#125;;\nexport default hoc;\n\nimport React from &#39;react&#39;;\n\nconst CountShow &#x3D; (&#123; count &#125;) &#x3D;&gt; &#123;\n  return &lt;div&gt;show:&#123;count&#125;&lt;&#x2F;div&gt;;\n&#125;;\n\nexport default CountShow;\nimport React from &#39;react&#39;;\nimport &#123; useState &#125; from &#39;react&#39;;\nimport CountShow from &#39;.&#x2F;components&#x2F;CountShow&#39;;\nimport hoc from &#39;.&#x2F;components&#x2F;Hoc&#39;;\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n  const increment &#x3D; () &#x3D;&gt; &#123;\n    setCount(count + 1);\n  &#125;;\n  const DoubleCount &#x3D; hoc(CountShow);\n  return (\n    &lt;div&gt;\n      &lt;DoubleCount count&#x3D;&#123;count&#125; &#x2F;&gt;\n      &lt;CountShow count&#x3D;&#123;count&#125; &#x2F;&gt;\n      &lt;button onClick&#x3D;&#123;increment&#125;&gt;&#123;count&#125;&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\nexport default App;\n\n\n\n\n\n\n\n\n\n高阶组件的好处，是可以复用组件的逻辑，提高代码的复用性以及组件的灵活性。以及是纯函数的关系，不会带来一些副作用如增加父子组件的级数。\n高阶组件的两种实现方式：\n\n属性代理  –上面的示例就是属性代理\n反向继承  （与class组件有关，就不多说了，感兴趣的可以查阅资料）mixins\n\n\n\n\n\n\n\n\n**mixins** 是一个js对象，可以包含vue组件的任意功能选项，当组件引用**mixins**对象时，所有**mixins**对象的选项都将被混入该组件的本身的选项中，以便提高逻辑的复用。\n\n\n\n8.Vuex和Redux\n**store**的注入和使用上存在区别\n**vuex3**是直接将**store**注入到组件实例中，vuex4是通过hook useStore来访问**store**，通过**mutation**处理同步操作，**action**处理异步操作。\n**redux** 通过action来处理同步操作，处理异步操作还需要使用中间件（**redux-thunk**）。\n\n\n**state**数据区别\n**vuex**使用的是可变数据，可以直接修改\n**redux**数据是只读的，每次都是用新的**state**来替换旧的**state**\n\n\n\n","slug":"前端面试题-4、Vue和React的区别_new","date":"2022-12-05T08:58:31.395Z","categories_index":"GIS面试题","tags_index":"前端基础","author_index":"团子"},{"id":"fbd1c03b6dde10013525e18ed49a95c5","title":"3、localStorage和sessionStorage及cookie之间的区别","content":"实现多页应用之间各页面之间的通讯，主要有浏览器数据存储和服务器两种方式。浏览器数据存储的方式主要使用本地存储方式解决。即调用localStorage,Cookie等本地存储方式。服务器方式主要使用websocket浏览器存储Cookie,SessionStorage,LocalStorage这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。**注意: **session和sessionStorage不是一个概念。在服务端有一种存储方式叫做:session会话存储，常常被简称session。Web StoragesessionStorage和LocalStorage都是浏览器本地存储，统称为Web Storage,存储内容大小一般5~10MB。浏览器通过Window.sessionStorage和Window.localStorage属性实现本地存储机制。\n相关API\n1、 localStorage.setItem(&#39;key&#39;,&#39;value&#39;)\n2、 localStorage.getItem(&#39;key&#39;)\n3、 localStorage.removeItem(&#39;key&#39;)\n4、 localStorage.clear();\n\n资料\n1.CookieCookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录网址时，可以将登陆信息保存在cookie中那么久避免了重复登陆的情况。\n2.localStoragelocalStorage 是 HTML5 标准中新加入的技术,特点:除非被清除,否则永久保存。一般大小在5MB;\n3.sessionStoragesessionStorage 是HTML5新增的一个会话存储对象，用于临时保存同一窗口(或标签页)的数据，刷新页面数据依旧存在，在关闭窗口或标签页之后将会删除这些数据\n\n\n\n特性\nCookie\nlocalStorage\nsessionStorage\n\n\n\n数据的生命期\n一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效\n除非被清除，否则永久保存\n仅在当前会话下有效，关闭页面或浏览器后被清除\n\n\n存放数据大小\n4K左右\n一般为5MB\n\n\n\n与服务器端通信\n每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题\n仅在客户端（即浏览器）中保存，不参与和服务器的通信\n\n\n\n易用性\n需要程序员自己封装，源生的Cookie接口不友好\n源生接口可以接受，亦可再次封装来对Object和Array有更好的支持\n\n\n\n&lt;body&gt;\n    &lt;button id&#x3D;&quot;btn&quot;&gt;存储&lt;&#x2F;button&gt;\n    &lt;script&gt;\n        var btn &#x3D; document.getElementById(&quot;btn&quot;);\n        btn.onclick &#x3D; function()&#123;\n            sessionStorage.setItem(&quot;name&quot;,&quot;lisi&quot;)\n            localStorage.setItem(&quot;age&quot;,18)\n        &#125;\n    &lt;&#x2F;script&gt;\n \n&lt;&#x2F;body&gt;\n\n\n\n\n\n\n\n\n\n执行以上代码，执行点击事件之后，关闭页面，可以看到sessionStorage中存储的数据不见了。\n","slug":"前端面试题-3、localStorage和sessionStorage及cookie之间的区别","date":"2022-12-05T08:22:09.684Z","categories_index":"GIS面试题","tags_index":"前端基础","author_index":"团子"},{"id":"ede97da6effb4c891550eb512876fb58","title":"2、如何允许跨域","content":"access-control-allow-origin:&quot;*&quot;\n\n前端跨域\n1、jsonp跨域Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。\n&#x2F;* jquery-ajax  jsonp*&#x2F;\n$.ajax(&#123;\n  url:&quot;http:&#x2F;&#x2F;192.168.4.18:7000&#x2F;ad&quot;,\n  method:&quot;get&quot;,\n  dataType:&quot;jsonp&quot;,\n  success:res&#x3D;&gt;&#123;\n    console.log(res)\n  &#125;\n&#125;)\n\n2、script标签(了解)var script &#x3D; document.createElement(&quot;script&quot;);\nscript.src &#x3D; &quot;http:&#x2F;&#x2F;192.168.4.18:7000&#x2F;ad?&amp;callback&#x3D;handleResponse&quot;;\ndocument.body.prepend(script);\nfunction handleResponse(res) &#123;\n  &#x2F;&#x2F; 对response数据进行操作代码\n  console.log(res)\n&#125;\n\n服务端跨域Access-Control-Allow-Origin&#39;:&#39;*&#39;\n\nkoa.js\nkoa2-cors&#x2F;&#x2F;中间 \nconst cors &#x3D; require(&quot;koa2-cors&quot;);\napp.use(cors(&#123;\n    origin:&quot;*&quot;\n&#125;));\n&#x2F;&#x2F;所有其他的域,都可以访问本域\nconst koa &#x3D; require(&quot;koa&quot;);\nconst app &#x3D;  new koa();\napp.use(async ctx&#x3D;&gt;&#123;\n    ctx.set(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;)\n    ctx.body &#x3D; &#123;\n        name:&quot;cheng&quot;\n    &#125;\n&#125;)\napp.listen(5000)\n\n","slug":"前端面试题-2、如何允许跨域","date":"2022-12-05T08:08:58.151Z","categories_index":"GIS面试题","tags_index":"前端基础","author_index":"团子"},{"id":"27c31af80a226dc9c96b00e0485fbbea","title":"1、移动开发","content":"\n一、是什么样的移动开发1、网页版的移动开发2、混合APP。\n\n二、具体实现页面版的开发:\n单位:rem vm  ui框架：vant-ui  \nuni-app\n混合App\nReact-native taro\nflutter\nIonic\n","slug":"前端面试题-1、移动开发","date":"2022-12-05T08:04:05.348Z","categories_index":"GIS面试题","tags_index":"前端基础","author_index":"团子"},{"id":"f12b38e6bdb288a0ca6492d10e709155","title":"9、Cesium中支持哪些矢量数据格式","content":"geojson\ntopjson\nkml\nczml\n\n","slug":"cesium面试题-9、Cesium中支持哪些矢量数据格式","date":"2022-12-05T07:51:39.049Z","categories_index":"GIS面试题","tags_index":"Cesium基础","author_index":"团子"},{"id":"8ecb1743c77469f806908557f1034b09","title":"8、笛卡尔直角坐标-空间直角坐标系-地理坐标系之间的区别","content":"https://www.cnblogs.com/Joetao/articles/1895574.html大地坐标系，笛卡尔平面坐标系，笛卡尔空间直角坐标系之间的区别。\n1、笛卡尔空间直角坐标系\nnew Cesium.Cartesian3.fromDegrees(x,y,z) \n\n2、 WGS84-地理坐标(弧度)即测绘中的地理经纬度坐标，默认是WGS84坐标系，坐标原点在椭球的质心\n\nCesium中的地理坐标单位默认是弧度制，用Cartographic变量表示,通过new Cesium.Cartographic()创建构造Cartographic对象\nvar wgs84 &#x3D; Cesium.Cartographic.fromDegrees(114, 30, 1000)\n&#x2F;&#x2F;转化为空间直角坐标系\nvar position &#x3D; Cesium.Ellipsoid.WGS84.cartographicToCartesian(wgs84);\n角度转弧度 π&#x2F;180*经纬度\n弧度变角度 180&#x2F;π*弧度\n\n3、笛卡尔直角坐标系-平面坐标系//也称屏幕坐标系 默认值为像素new Cesium.Cartesian2(x,y)\n","slug":"cesium面试题-8、笛卡尔直角坐标-空间直角坐标系-地理坐标系之间区别_new","date":"2022-12-05T07:45:12.258Z","categories_index":"GIS面试题","tags_index":"Cesium基础","author_index":"团子"},{"id":"4a96938dcfcef9166d26d3a69d444fbd","title":"6、Cesium中的默认坐标","content":"WGS:84  EPSG:4326，在国际上，每个坐标系统都会被分配一个 EPSG 代码，EPSG:4326 就是 WGS84 的代码。\n","slug":"cesium面试题-6、Cesium中的默认坐标","date":"2022-12-05T07:36:36.754Z","categories_index":"GIS面试题","tags_index":"Cesium基础","author_index":"团子"},{"id":"5a1bc60c5cc6d62481fc436dbb4c2687","title":"7、cesium空间直角坐标系的中心点在","content":"在计算机进行绘图的时候，由于不方便直接使用经纬度绘图，一般会将坐标系转换为笛卡尔坐标系（坐标系原点为椭球中心），Cesium中使用Cartesian3表示。\n","slug":"cesium面试题-7、cesium空间直角坐标系的中心点","date":"2022-12-05T07:32:25.383Z","categories_index":"GIS面试题","tags_index":"Cesium基础","author_index":"团子"},{"id":"ebe41387a4fa1f405b0f26ba896c9b8a","title":"5、gltf和glb之间的区别","content":"glTF 文件有两种拓展形式，.gltf（JSON / ASCII）或.glb（二进制）。.gltf 文件可能是自包含的，也可能引用外部二进制和纹理资源，而 .glb 文件则是完全自包含的（但使用外部工具可以将其缓冲区/纹理保存为嵌入或单独的文件，后面会提到）。\n\n\n\n\n\n\n\n\n\nglb相当于gltf的一个压缩版本\n","slug":"cesium面试题-5、gltf和glb之间的区别","date":"2022-12-05T07:29:15.556Z","categories_index":"GIS面试题","tags_index":"Cesium基础","author_index":"团子"},{"id":"6b908f4383898a6459fc7e0d489478f8","title":"4、cesium中的坐标系","content":"https://zhuanlan.zhihu.com/p/450689556\n1、笛卡尔空间直角坐标系(Cartesian3)2、WGS84 弧度坐标系（Cartographic）3、平面坐标系（Cartesian2）–&gt;屏幕坐标系\n\n\n\n\n\n\n\n\n\n单位是弧度\n","slug":"cesium面试题-4、cesium中的坐标系","date":"2022-12-05T07:26:25.386Z","categories_index":"GIS面试题","tags_index":"Cesium基础","author_index":"团子"},{"id":"2ef3671d842b4bf47224e4ed5fe87af4","title":"3、3D Tile是什么","content":"https://cesium.com/blog/2015/08/10/introducing-3d-tiles/1、3D Tiles是Cesium于2016年3月定义的一种三维模型瓦片数据结构。3D Tiles将海量的三维模型瓦片数据，以分块，分层的形式组织起来，这样就大大减轻了浏览器和图形处理单位(GPU)的负担。3D Tiles建立在glTF格式之上，并引入了三维图形领域的技术。3D Tiles还支持交互旋转和样式的设置\n\n1、对单个模型的材质修改\n2、根据建筑高度和年代，可以设置不同的显示效果\n\n2、3D Tiles是Cesium提出的处理三维地理大数据的数据格式，目前已经是OGC的数据标准之一，在web端的三维数据传输中已经得到了广泛的应用。从数据结构关系上来看，3DTiles属于Primitive，具有很高的数据加载效率。3、3D Tiles 是在glTF的基础上，加入了分层LOD的概念（可以把3D Tiles简单地理解为带有 LOD 的 glTF ），专门为流式传输和渲染海量 3D 地理空间数据而设计的，例如倾斜摄影、3D 建筑、BIM/CAD、实例化要素集和点云。它定义了一种数据分层结构和一组切片格式，用于渲染数据内容。3D Tiles 没有为数据的可视化定义明确的规则，客户可以按照自己合适的方式来可视化 3D 空间数据。同时，3D Tiles 也是 OGC 标准规范成员之一，可用于在台式机、Web端和移动应用程序中实现与海量异构3D地理空间数据的共享、可视化、融合以及交互功能。\n\n\n\n\n\n\n\n\n\n总结：  3D Tilles是Cesium于2016年定义的一种三维模型的瓦片数据结构。这种数据结构能够处理三维的地理大数据，目前已经是OGC的标注之一。它是以分块分层的形式来组织数据，这样可以大大减轻浏览器和图形处理单位(GPU)的负担。\n","slug":"cesium面试题-3、3D Tile是什么","date":"2022-12-05T07:21:40.482Z","categories_index":"GIS面试题","tags_index":"Cesium基础","author_index":"团子"},{"id":"0c56878436a4ce9d36a82dbaeb1502e4","title":"2、cesium中模型的数据有哪些","content":"\n1、gltfglTF全称是 Graphics Language Transmission Format （图形语言传输格式），是一种针对GL(WebGL，OpenGL ES以及OpenGL)接口的运行时资产传递格式，由澳大利亚的 Khronons 集团进行维护，并于2017年6月5日在GitHub上（https://github.com/KhronosGroup/glTF）公布了glTF 2.0的规范，此文也是针对于2.0版本进行介绍的。glTF通过提供高效、可扩展、可互操作的格式来传输和加载三维内容，填补了3D建模工具与现代图形应用程序之间的空白，它已成为了 Web 上的3D 对象标准（Web导出的通用标准），可以说glTF是3D 模型的JPEG格式，几乎每个3D Web框架都支持glTF。随着glTF的不断发展，glTF形成了自己庞大的生态系统，同时受到了各行业的大力支持。所以，如果有人要为你提供3D 模型，你就可以要求他们提供glTF格式的模型。glTF生态系统glTF支持的行业\n2、glb、bgltf","slug":"cesium面试题-2、cesium中模型的数据有哪些_new","date":"2022-12-05T07:18:32.618Z","categories_index":"GIS面试题","tags_index":"Cesium基础","author_index":"团子"},{"id":"4c822856ab6ae032b37188bbf15bc3df","title":"6、加载矢量数据","content":"\nGeoJSON，TopoJSON，GML，KML，ShapeFile\n","slug":"Ol面试题-6、加载矢量数据 copy","date":"2022-12-05T07:10:18.303Z","categories_index":"GIS面试题","tags_index":"Openlayer基础","author_index":"团子"},{"id":"59cb2b96c0f497aabd6fdbcc3f9976d1","title":"1、openlayer,mapbox,cesium之间的区别","content":"https://zhuanlan.zhihu.com/p/450689556\n\n\n\n地图框架\n基本信息\n优缺点\n\n\n\nCesium\n主要是实现三维地图的渲染引擎，暴露了过多了基础api。\n优点：唯一开源的WebGIS三维引擎；适用于Web强三维应用场景\n\n\nMapbox\n支持二维和三维地图，使用EPSG:3857 墨卡托坐标系。\n优点：最具美感的专题地图缺点：没有球体运用于互联网场景复杂地理信息表达，追求地图可视化效果\n\n\nOpenlayers\n仅支持二维地图，但是可以支持任意坐标系统。\n优点：二维GIS功能最丰富全面缺点：地图样式简单，难以定制高颜值的可视化效果适用于传统地理信息强GIS的二维数据Web维护和展示\n\n\n","slug":"cesium面试题-1、之间的区别","date":"2022-12-05T06:19:01.974Z","categories_index":"GIS面试题","tags_index":"Cesium基础","author_index":"团子"},{"id":"31046b0165838c0419370be0ffb0200e","title":"5、图层的方法","content":"\nlayer.setVisible(boolean)\t&#x2F;&#x2F;控制图层显示&#x2F;隐藏\nlayer.setSource\t&#x2F;&#x2F;设置数据源\nlayer.setStyle\t&#x2F;&#x2F;给图层设置样式\n","slug":"Ol面试题-5、图层的方法","date":"2022-12-05T06:17:09.736Z","categories_index":"GIS面试题","tags_index":"Openlayer基础","author_index":"团子"},{"id":"b1171900d3228410e61a848f8d62f26f","title":"3、openlayer的坐标转换","content":"var gcs4490 &#x3D; ol.proj.transform([605906.540647357,2723639.37418766], new ol.proj.Projection(&#123;code:&#39;EPSG:4548&#39;&#125;),new ol.proj.Projection(&#123;code:&#39;EPSG:4490&#39;&#125;));\n","slug":"Ol面试题-3、openlayer的坐标转换 copy","date":"2022-12-05T06:06:15.399Z","categories_index":"GIS面试题","tags_index":"Openlayer基础","author_index":"团子"},{"id":"2282b4118919e09d33d2f0d5fae540d4","title":"2、openlayer添加图层到指定位置","content":"\n\n\n\n\n\n\n\n\n\n类似于数组splice\nconst layers &#x3D; map.getLayers();\nlayers.insertAt(index,layerName);\n\n","slug":"Ol面试题-2、openlayer添加图层到指定位置 copy","date":"2022-12-05T06:04:39.736Z","categories_index":"GIS面试题","tags_index":"Openlayer基础","author_index":"团子"},{"id":"f440e8383e5696f6b68f32ff841fe291","title":"1、使用了openlayer哪些地图的功能","content":"\nopenlayer中文官网1、添加图层 addLayer\n2、交互式的画笔 \n3、创建要素\n4、控件\n5、popup弹窗和标记\n6、地图事件\n","slug":"Ol面试题-1、经纬度坐标系和投影坐标系之间的区别 copy 2","date":"2022-12-05T06:00:08.362Z","categories_index":"GIS面试题","tags_index":"Openlayer基础","author_index":"团子"},{"id":"874eaebf60649fd3e96d5d0e84b6872d","title":"4、openlayer的核心类","content":"理解：OpenLayers里的各种类，就是对GIS中各种事物的抽象（1）Map—–整个地图容器。可以理解为画板，里面什么都没有，但是一切都在里面发生~\n使用之前要引入：import Map from ‘ol/Map’;\nthis.map &#x3D; new Map(&#123;\n.....&#x2F;&#x2F;一切由此开始!!\n&#125;);\n别的类或者方法都是Map的配置项。\n（2）Layer—–图层。—–如果你学过PS，则图层概念可以类比理解~\n可以有很多个图层叠加在一起。每个图层对应一个图层包（有各种图层可选），便于管理。\n例如：ol.layer.Tile\n使用之前要引入：import {Tile as TileLayer} from “ol/layer”;\nthis.map &#x3D; new Map(&#123;\n　　target: myMap,&#x2F;&#x2F;设置地图放在页面中的哪个元素里\n　　layers: [\n　　　　new TileLayer(&#123;\n　　　　　　.....&#x2F;&#x2F;配置图层\n　　　　&#125;)\n　　],\n&#125;);\n\n（3）Source—–数据源。数据源和图层一一对应。每个数据源都对应一个资源包（有各种资源可选）。\n例如：ol.source.OSM\n使用之前要引入：import OSM from ‘ol/source/OSM’;\nconst myMap &#x3D; this.$refs.myMap;\nthis.map &#x3D; new Map(&#123;\n　　target: myMap,&#x2F;&#x2F;设置地图放在页面中的哪个元素里\n　　layers: [\n　　　　new TileLayer(&#123;\n　　　　　　source: new OSM()&#x2F;&#x2F;数据源\n　　　　&#125;)\n　　]\n&#125;);\n（4）View—–总体展示。控制地图显示的中心位置，范围，缩放层级等等。\n使用之前要引入：import View from ‘ol/View’;\nthis.map &#x3D; new Map(&#123;\n　　target: myMap,\n　　layers: [\n　　　　new TileLayer(&#123;\n　　　　　　source: new OSM()\n　　　　&#125;)\n　　],\n　　view: new View(&#123;&#x2F;&#x2F;配置展示、渲染项\n　　　　center: [0,0],&#x2F;&#x2F;显示的中心经纬度\n　　　　zoom: 4&#x2F;&#x2F;显示的缩放级别\n　　&#125;)\n&#125;);\n（5）Control—–控件一些UI组件，比如：放大缩小按钮等等。\n（6）Interaction—–交互与用户进行交互，例如：用鼠标进行拖动、放大缩小等等。\n","slug":"Ol面试题-4、openlayer的核心类","date":"2022-12-05T05:54:18.811Z","categories_index":"GIS面试题","tags_index":"Openlayer基础","author_index":"团子"},{"id":"fd0f7481b86e576c0061c7a25ce48b95","title":"9、WGS84和CGCS2000的区别","content":"\n相同点都是质心坐标系统\n区别1、扁率f不同2、历元不同3、实现框架不同WGS84，WGS是世界大地测量系统World Geodetic System的缩写，84是说此坐标系是1984年建立的；WGS84 是为GPS全球定位系统使用而建立的坐标系统，也是如今很多互联网地图采用的坐标系统； CGCS2000是2000国家大地坐标系，该系统以ITRF(国际协议地球参考框架)97参考框架为基准，参考框架历元为2000.0。当前，国际地球参考系（ITRS）和国际地球参考框架（ITRF）是世界上最精确、最权威的地心大地坐标系\n","slug":"GIS面试题-9、WGS84和CGCS2000的区别","date":"2022-12-05T05:46:58.281Z","categories_index":"GIS面试题","tags_index":"GIS基础","author_index":"团子"},{"id":"e08ae607dc8198b10360e71c8d3d3326","title":"8、瓦片金字塔","content":"\n\n\n\n\n\n\n\n\n指将一定范围内的地图按照一定的尺寸和格式，按缩放级别或者比例尺，切成若干行和列的正方形栅格图片，对切片后的正方形栅格图片被形象的称为瓦片(切片)（Tile）。\n将图片按照缩放级别和比例尺,进行切割，切割后的正方形栅格图片就是瓦片。瓦片地图金字塔模型是一种多分辨率层次模型，在统一的空间参照下，根据用户需要以不同分辨率进行存储与显示，形成分辨率由粗到细、数据量由小到大的金字塔结构。所表示的地理范围不变。金字塔的越往底层所表示的地图信息越详细，比例尺越大。首先确定地图服务平台所要提供的缩放级别的数量N，把缩放级别最高、地图比例尺最大的地图图片作为金字塔的底层，即第0层，并对其进行分块，从地图图片的左上角开始，从左至右、从上到下进行切割，分割成相同大小(比如256x256像素)的正方形地图瓦片，形成第0层瓦片矩阵;在第0层地图图片的基础上，按每2x2像素合成为一个像素的方法生成第1层地图图片，并对其进行分块，分割成与下一层相同大小的正方形地图瓦片，形成第1层瓦片矩阵;采用同样的方法生成第2层瓦片矩阵;…;如此下去，直到第N一1层，构成整个瓦片金字塔。\n\n\n\n\n\n\n\n\n\n\n\n总结：将地图按照一定的缩放级别和比例尺进行切割，切割后的正方形就是瓦片。随着地图放大缩小，整个地图呈现的数据模型就是一个瓦片金字塔的结构。\n","slug":"GIS面试题-8、瓦片金字塔_new","date":"2022-12-05T05:44:51.120Z","categories_index":"GIS面试题","tags_index":"GIS基础","author_index":"团子"},{"id":"7d540b4f1f24d70332c9e53d05becc73","title":"7、地理坐标系如何测量距离","content":"\n\n一、从理论角度解释根据投影类型(墨卡托投影)，将地理坐标转化成平面坐标,根据一定的算法，实现两点之间距离的测量。\n二、从代码角度解释https://turfjs.fenxianglu.cn/\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;lib.baomitu.com&#x2F;Turf.js&#x2F;latest&#x2F;turf.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n1、两点之间的测量var from &#x3D; turf.point([-75.343, 39.984]);\nvar to &#x3D; turf.point([-75.534, 39.123]);\nvar options &#x3D; &#123; units: &#39;miles&#39; &#125;;\n\nvar distance &#x3D; turf.distance(from, to, options);\nconsole.log(distance)\n\n2、测量线段的长度var line &#x3D; turf.lineString([[115, -32], [131, -22], [143, -25], [150, -34]]);\nvar length &#x3D; turf.length(line, &#123; units: &#39;miles&#39; &#125;);\nconsole.log(length)","slug":"GIS面试题-7、地理坐标系如何测量距离","date":"2022-12-05T05:41:23.499Z","categories_index":"GIS面试题","tags_index":"GIS基础","author_index":"团子"},{"id":"c693e9b88af9688201770c2cdc91e956","title":"6、空间数据库了解那些","content":"1、ArcGIS的Esri 地理数据库2、MapGIS  GDB3、PostGIS是最知名和最完整的空间数据库之一。它是开源数据库PostgreSQL的扩展。4、Oracle5. Microsoft SQL Server6. Amazon AuroraAmazon Aurora是一个基于云的空间数据库。它可以运行MySQL或PostgreSQL开源数据库。您可以轻松地将数据库迁移到Amazon Aurora平台，并利用其全套工具。\n","slug":"GIS面试题-6、空间数据库了解那些_new","date":"2022-12-05T05:39:25.527Z","categories_index":"GIS面试题","tags_index":"GIS基础","author_index":"团子"},{"id":"3c695c87820ef6f8848bdad37b6b1e84","title":"5、投影坐标系","content":"参考文章\n（1）墨卡托投影上面的小视频中讲到了墨卡托投影的原理，可以看到它的投影面是竖着的椭圆柱面，并且投影面与地轴方向一致，所以也叫正轴等角切/割圆柱投影。意思就是既可以切圆柱，就是球体和椭圆柱面相切；也可以割圆柱，就是球体和椭圆柱面相割。百度地图和Google Maps使用的投影方法都是墨卡托投影。\n（2）高斯-克吕格投影高斯-克吕格投影又叫横轴墨卡托投影，它的投影面是椭圆柱面，假设椭圆柱躺着，和地轴垂直，而且投影面与之相切，就是横轴墨卡托了，也可以称作等角横轴切椭圆柱投影。竖着的有三条线，中间的那条就是投影中心线，根据取法不同，可以分为3度带和6度带。需要注意3度带和6度带的起算经线是不一样的。6°分带法:从格林威治零度经线起,每6°分为一个投影带,全球共分为60个投影带。3°分带法:从东经1°30′起,每3°为一带,将全球划分为120个投影带。高斯-克吕格投影的特点主要有三个：\n\n投影后的地图，角度不变，面积会变。离中央经线越远的地区，面积变化越大。此投影合适用于导航。\n投影椭圆柱面是横着的；\n投影椭圆柱面与椭球体相切。\n\n我国1：2.5万到1：50万地形图使用6度分带法；1：5000~1：10000地形图使用3度分带法。\n（3）通用横轴墨卡托投影大家应该还听过它的江湖别称：UTM投影，它和高斯克吕格投影特别像，只不过它是割圆柱，就是球体与椭圆柱面相割。因此也被称作横轴等角割圆柱投影。\n","slug":"GIS面试题-5、投影坐标系_new","date":"2022-12-05T05:28:41.054Z","categories_index":"GIS面试题","tags_index":"GIS基础","author_index":"团子"},{"id":"ad4353fb68aefd875a81c9445d41d3bf","title":"4、地心坐标系和参心坐标系之间的区别","content":"EPSG:就是欧洲石油调查组织。地心坐标系: 以地球质心为椭球中心的，就叫地心坐标系。为了让坐标能够准确的描述某个区域和国家的，将质心移动。就是参心坐标系，简单的理解参心坐标系就是质心不在椭球中心的坐标系。\n","slug":"GIS面试题-4、地心坐标系和参心坐标系之间的区别_new","date":"2022-12-05T05:24:21.941Z","categories_index":"GIS面试题","tags_index":"GIS基础","author_index":"团子"},{"id":"6791340f14756a3924a264c9d0036bda","title":"3、倾斜摄像是什么(了解)","content":"倾斜摄影技术是国际测绘领域近些年发展起来的一项高新技术，它颠覆了以往正射影像只能从垂直角度拍摄的局限，通过在同一飞行平台上搭载多台传感器，同时从一个垂直、四个倾斜等五个不同的角度采集影像，将用户引入了符合人眼视觉的真实直观世界\n","slug":"GIS面试题-3、倾斜摄像是什么(了解)","date":"2022-12-05T05:20:08.347Z","categories_index":"GIS面试题","tags_index":"GIS基础","author_index":"团子"},{"id":"e38b86f2c24b74562816e5edf3ccfb2e","title":"2、OGC服务有几种","content":"\n1、OGC的概念OGC 全称是开放地理空间信息联盟(Open Geospatial Consortium),是一个非盈利的国际标准组织，它制定了数据和服务的一系列标准，GIS厂商按照这个标准进行开发，可保证空间数据的通用性。\n\n\n\n\n\n\n\n\n\nOGC是一个制定地理空间数据标准的组织，类似于W3C(html-css),类似于ECMA(JavaScript)。\n\n\n\n\n\n\n\n\n\nOGC和ISO/TC211共同推出了基于Web服务（XML）的空间数据互操作实现规范Web Map Service，Web Feature Service，Web Coverage Service\n\n2、服务的种类\n地图服务(WMS):Web Map ServiceWeb地图服务（WMS）利用具有地理空间位置信息的数据制作地图。其中将地图定义为地理数据可视的表现。这个规范定义了三个操作：GetCapabilities返回服务级元数据，它是对服务信息内容和要求参数的一种描述； GetMap返回一个地图影像，其地理空间参考和大小参数是明确定义了的；GetFeatureInfo（可选）返回显示在地图上的某些特殊要素的信息\n矢量服务(WFS):Web Feature ServiceWeb地图服务返回的是图层级的地图影像，Web矢量服务（WFS）返回的是矢量级的GML编码，并提供对矢量的增加、修改、删除等事务操作，是对Web地图服务的进一步深入。\n栅格服务(WCS):Web Coverage ServiceWeb栅格服务（WCS）面向空间影像数据，它将包含地理位置值的地理空间数据作为“栅格（Coverage）”在网上相互交换。\n瓦片服务(WMTS)\n\n","slug":"GIS面试题-2、OGC服务有几种","date":"2022-12-05T05:07:33.315Z","categories_index":"GIS面试题","tags_index":"GIS基础","author_index":"团子"},{"id":"7c9afd5f5977e33be520e6ca0e929bbc","title":"1、经纬度坐标系和投影坐标系之间的区别","content":"\n经度度坐标系是基于三维地球的坐标系，实现通过经纬度对地球表面的要素进行定位的坐标系。(度)\nWSG:84 \nEPSG:4326  &#x2F;&#x2F;天地图\n投影坐标系用一定的数学法则，将三维地球上的坐标映射到一个面上。(墨卡托-米)\nEPSG:3857  &#x2F;&#x2F;高德，百度，mapbox-style,腾讯地图\n三者的区别为：地理是经纬度。投影是XYZ。大地是角度。大地坐标、地理坐标均是球面的，投影坐标是平面的\n\n\n","slug":"GIS面试题-1、经纬度坐标系和投影坐标系之间的区别","date":"2022-12-05T04:46:42.917Z","categories_index":"GIS面试题","tags_index":"GIS基础","author_index":"团子"},{"id":"34a703f252949acbb57c1273f1511cc5","title":"Vue3 快速上手","content":"\n一. 概述\n1 为什么提出Vue3Vue2是一个非常优秀的框架, 好上手, 学习曲线也比较平滑. 也是目前使用最广泛的框架之一为什么尤大要重构, 推出Vue3呢?大家有兴趣可以看一下这篇专访总结起来就是\n\n\n\n\n\n\n\n\n\n更适应当下的技术环境\n要知道, 每个技术都是有局限性的. 某一方面的提升往往意味着另一方面的牺牲.\n2 提出了哪些改进\n使用TS重构\n应用了JS的新特性Proxy重写响应式\n性能的提升\nComposition API\n\n如果一定要选出一个最大的区别, 应该是Composition API\n3 Options API vs Composition API\n1) Options API的代码组织形式使用Options API实现一个功能, 需要在不同的地方编写代码\n\n状态(数据)在data中定义\n方法在methods中定义\n计算属性\n…\n\n当新添加一个功能时, 代码的组织会比较零散\n2) Composition API的代码组织\n二. 起步\n1 安装\n1) 初始化创建一个目录vue3-demo, 执行命令\nnpm init -y\n\n2) 安装Vue3从2022年2月开始, vue的默认版本更新为了vue3, 通过npm安装\nnpm i vue\n\n2 使用步骤:\n\n引入vue.js\n创建页面容器\n实例化对象&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue库 --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.global.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 创建页面容器 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const app &#x3D; &#123;\n        data() &#123;\n          return &#123;\n            msg: &#39;hello&#39;,\n          &#125;\n        &#125;,\n      &#125;\n\n      &#x2F;&#x2F; 创建Vue实例对象, 挂载到#app指定的页面容器\n      Vue.createApp(app).mount(&#39;#app&#39;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\ndata必须是一个函数\n之前Vue2中的配置项依然可以使用\n\n\n\n\n\n\n\n\n练习\n\n\n\n三. setup语法\n1 setup配置项在Vue3中, 为了向前兼容, 不影响之前的配置项创造了一个新的配置项setup, 所有的Composition API都可以在setup中使用:::infosetup是一个函数\n\n返回一个对象, 对象中定义的属性, 方法在模板中直接使用\n返回渲染函数(不常用):::\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.global.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &#123;&#123;uname&#125;&#125; -- &#123;&#123;age&#125;&#125;\n      &lt;p&gt;&#123;&#123; sayHi() &#125;&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const app &#x3D; &#123;\n        &#x2F;&#x2F; setup配置项(函数, 返回对象)\n        &#x2F;&#x2F; 在返回的对象中定义的属性, 方法 可以直接在模板中使用\n        setup() &#123;\n          &#x2F;&#x2F; 定义数据 data\n          let uname &#x3D; &#39;xiaoming&#39;\n          let age &#x3D; 20\n\n          &#x2F;&#x2F; 定义方法 methods\n          function sayHi() &#123;\n            console.log(&#96;大家好, 我是$&#123;uname&#125;, 今年$&#123;age&#125;岁了&#96;)\n            return 123\n          &#125;\n\n          return &#123;\n            uname,\n            age,\n            sayHi,\n          &#125;\n        &#125;,\n      &#125;\n\n      Vue.createApp(app).mount(&#39;#app&#39;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n这样写的代码会丢失响应式:::warning💡** 注意**不要将vue2的语法和vue3的语法混用!!:::\n2 调试工具这里我们安装最新的vue devtools工具, 可以同时支持vue2和vue3通过调试工具, 我们发现定义的数据并不是响应式的.在setup函数中, 如果要实现响应式, 需要借助\n\nref函数: 实现普通类型数据的响应式\nreactive函数: 实现引用类型数据的响应式3 ref函数使用步骤\n\n\n导入ref函数\n使用ref函数定义数据\n\n\n\n\n\n\n\n\n示例\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.global.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      &#x2F;&#x2F; 像ref, reactive, computed从Vue对象从导出的函数, 就是composition API\n      const &#123; ref &#125; &#x3D; Vue\n      const app &#x3D; &#123;\n        setup() &#123;\n          &#x2F;&#x2F; ref函数: 实现值类型数据的响应式\n          &#x2F;&#x2F; 将值类型数据(普通数据 String, Number, Boolean, undefined, null)\n          let msg &#x3D; ref(&#39;hello&#39;)\n\n          &#x2F;&#x2F; ref函数: 接收普通类型的数据作为参数, 返回一个RefImpl对象\n          console.log(msg)\n\n          return &#123;\n            msg,\n          &#125;\n        &#125;,\n      &#125;\n\n      Vue.createApp(app).mount(&#39;#app&#39;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n通过devtools修改:::info需求\n\n点击按钮修改姓名:::如何使用代码实现修改数据呢?\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue库 --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.global.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 创建页面容器 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;p&gt;姓名:&#123;&#123;uname&#125;&#125;&lt;&#x2F;p&gt;\n      &lt;button @click&#x3D;&quot;handleClick&quot;&gt;点击修改&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const &#123; ref &#125; &#x3D; Vue\n\n      const app &#x3D; &#123;\n        setup() &#123;\n          let uname &#x3D; ref(&#39;xiaoming&#39;)\n\n          function handleClick() &#123;\n            &#x2F;&#x2F; uname是一个RefImpl对象. 修改其&#96;value&#96;属性\n            uname.value &#x3D; &#39;小明&#39;\n          &#125;\n\n          return &#123;\n            uname,\n            handleClick,\n          &#125;\n        &#125;,\n      &#125;\n\n      &#x2F;&#x2F; 创建Vue实例对象, 挂载到#app指定的页面容器\n      Vue.createApp(app).mount(&#39;#app&#39;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n练习\n使用setup语法(Composition API)实现计数器\n4 reactive函数对于引用类型数据. 如对象, 数组使用ref函数比较麻烦, 在访问时, 每次都需要.value\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue库 --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.global.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 创建页面容器 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;p&gt;姓名:&#123;&#123;stu.name&#125;&#125;&lt;&#x2F;p&gt;\n      &lt;button @click&#x3D;&quot;handleClick&quot;&gt;点击修改&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const &#123; reactive &#125; &#x3D; Vue\n\n      const app &#x3D; &#123;\n        setup() &#123;\n          const stu &#x3D; reactive(&#123;\n            name: &#39;xiaoming&#39;,\n            age: 20,\n          &#125;)\n\n          function handleClick() &#123;\n            console.log(stu)\n            stu.name &#x3D; &#39;小明&#39;\n          &#125;\n\n          return &#123;\n            stu,\n            handleClick,\n          &#125;\n        &#125;,\n      &#125;\n\n      &#x2F;&#x2F; 创建Vue实例对象, 挂载到#app指定的页面容器\n      Vue.createApp(app).mount(&#39;#app&#39;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n\n区别\n\n从定义的角度\nref: 主要用于基本数据类型\nreactive: 主要用于引用数据类型\n\n\n从实现的角度\nref: 通过Object.defineProperty的get和set来实现响应式\nreactive: 通过Proxy来实现数据劫持, 通过reflect操作内部属性\n\n\n从使用的角度\nref: 需要通过.value操作数据\nreactive: 不需要.value, 直接操作数据5 computed函数使用步骤\n\n\n\n\n导入computed函数\n在setup中使用\n\n\n\n\n\n\n\n\n示例\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue库 --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.global.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 创建页面容器 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      姓: &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;data.firstName&quot; &#x2F;&gt; &lt;br &#x2F;&gt;\n      名: &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;data.lastName&quot; &#x2F;&gt; &lt;br &#x2F;&gt;\n      全名: &#123;&#123;fullName&#125;&#125;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const &#123; reactive, computed &#125; &#x3D; Vue\n\n      const app &#x3D; &#123;\n        setup() &#123;\n          const data &#x3D; reactive(&#123;\n            firstName: &#39;&#39;,\n            lastName: &#39;&#39;,\n          &#125;)\n          const fullName &#x3D; computed(() &#x3D;&gt; &#123;\n            return data.firstName + data.lastName\n          &#125;)\n\n          return &#123;\n            data,\n            fullName,\n          &#125;\n        &#125;,\n      &#125;\n\n      &#x2F;&#x2F; 创建Vue实例对象, 挂载到#app指定的页面容器\n      Vue.createApp(app).mount(&#39;#app&#39;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n优化\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue库 --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.global.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 创建页面容器 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      姓: &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;person.firstName&quot; &#x2F;&gt; &lt;br &#x2F;&gt;\n      名: &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;person.lastName&quot; &#x2F;&gt; &lt;br &#x2F;&gt;\n      全名: &#123;&#123;person.fullName&#125;&#125;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const &#123; reactive, computed &#125; &#x3D; Vue\n\n      const app &#x3D; &#123;\n        setup() &#123;\n          const person &#x3D; reactive(&#123;\n            firstName: &#39;&#39;,\n            lastName: &#39;&#39;,\n          &#125;)\n\n          person.fullName &#x3D; computed(() &#x3D;&gt; &#123;\n            return person.firstName + person.lastName\n          &#125;)\n\n          return &#123;\n            person,\n          &#125;\n        &#125;,\n      &#125;\n\n      &#x2F;&#x2F; 创建Vue实例对象, 挂载到#app指定的页面容器\n      Vue.createApp(app).mount(&#39;#app&#39;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n6 watch函数在Vue3中, 将watch也定义成一个组合式API使用步骤\n\n导入watch函数\n使用watch函数监听\n\n由于定义数据有两种方式. 监听时也分两种情况\n\n监视ref定义的数据\n监视reactive定义的数据1) 监视ref定义的数据\n\n\n\n\n\n\n\n\n示例\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.global.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;h3&gt;当前计数为: &#123;&#123;count&#125;&#125;&lt;&#x2F;h3&gt;\n      &lt;button @click&#x3D;&quot;count++&quot;&gt;点击+1&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const &#123; ref, watch &#125; &#x3D; Vue\n      const app &#x3D; &#123;\n        setup() &#123;\n          const count &#x3D; ref(0)\n\n          watch(count, (newValue, oldValue) &#x3D;&gt; &#123;\n            console.log(&#39;count改变了&#39;, newValue, oldValue)\n          &#125;)\n\n          return &#123;\n            count,\n          &#125;\n        &#125;,\n      &#125;\n\n      Vue.createApp(app).mount(&#39;#app&#39;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n2) 监视reactive定义的数据&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.global.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;h3&gt;姓名: &#123;&#123;stu.name&#125;&#125;&lt;&#x2F;h3&gt;\n      &lt;h3&gt;年龄: &#123;&#123;stu.age&#125;&#125;&lt;&#x2F;h3&gt;\n      &lt;button @click&#x3D;&quot;stu.name &#x3D; &#39;小明&#39;&quot;&gt;修改姓名&lt;&#x2F;button&gt;\n      &lt;button @click&#x3D;&quot;stu.age++&quot;&gt;年龄+1&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const &#123; reactive, watch &#125; &#x3D; Vue\n      const app &#x3D; &#123;\n        setup() &#123;\n          const stu &#x3D; reactive(&#123;\n            name: &#39;xiaoming&#39;,\n            age: 20,\n          &#125;)\n\n          watch(stu, (newValue, oldValue) &#x3D;&gt; &#123;\n            &#x2F;&#x2F; 拿不到旧的value值\n            console.log(&#39;stu变化了&#39;, newValue, oldValue)\n          &#125;)\n\n          return &#123;\n            stu,\n          &#125;\n        &#125;,\n      &#125;\n\n      Vue.createApp(app).mount(&#39;#app&#39;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n对于引用类型, watch不能监视到oldValue\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.global.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;h3&gt;姓名: &#123;&#123;stu.name&#125;&#125;&lt;&#x2F;h3&gt;\n      &lt;h3&gt;年龄: &#123;&#123;stu.age&#125;&#125;&lt;&#x2F;h3&gt;\n      &lt;button @click&#x3D;&quot;stu.name &#x3D; &#39;小明&#39;&quot;&gt;修改姓名&lt;&#x2F;button&gt;\n      &lt;button @click&#x3D;&quot;stu.age++&quot;&gt;年龄+1&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const &#123; reactive, watch &#125; &#x3D; Vue\n      const app &#x3D; &#123;\n        setup() &#123;\n          const stu &#x3D; reactive(&#123;\n            name: &#39;xiaoming&#39;,\n            age: 20,\n          &#125;)\n\n          &#x2F;&#x2F; 监听某个属性, 需要使用函数, 函数返回该属性\n          watch(() &#x3D;&gt; stu.name, (newValue, oldValue) &#x3D;&gt; &#123;\n            &#x2F;&#x2F; 拿不到旧的value值\n            console.log(&#39;stu变化了&#39;, newValue, oldValue)\n          &#125;)\n\n          return &#123;\n            stu,\n          &#125;\n        &#125;,\n      &#125;\n\n      Vue.createApp(app).mount(&#39;#app&#39;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n7 生命周期\nVue3的生命周期在调用mount(&#39;#app&#39;)后开始\nsetup在所有生命周期函数执行前调用, 因此, 在setup()中this指向window, 没有批向当前实例\nsetup主要完成composition API的初始化. created完成OptionsAPI的初始化\n在setup中最常用的生命周期有两个: onMounted和onBeforeUnmount\n\n\n\n\n\n\n\n\n示例\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.global.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;h1&gt;我是vm根实例&lt;&#x2F;h1&gt;\n      &lt;button @click&#x3D;&quot;isShow &#x3D; !isShow&quot;&gt;切换显示子组件&lt;&#x2F;button&gt;\n      &lt;Demo v-if&#x3D;&quot;isShow&quot;&gt;&lt;&#x2F;Demo&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const &#123; onMounted, onBeforeUnmount &#125; &#x3D; Vue\n\n      &#x2F;&#x2F; 创建一个Vue应用\n      const app &#x3D; Vue.createApp(&#123;\n        data() &#123;\n          return &#123;\n            isShow: true,\n          &#125;\n        &#125;,\n      &#125;)\n\n      &#x2F;&#x2F; 注册子组件\n      app.component(&#39;demo&#39;, &#123;\n        template: &#39;&lt;h3&gt;我是子组件&lt;&#x2F;h3&gt;&#39;,\n        setup() &#123;\n          onMounted(() &#x3D;&gt; &#123;\n            console.log(&#39;demo组件挂载...&#39;)\n          &#125;)\n          onBeforeUnmount(() &#x3D;&gt; &#123;\n            console.log(&#39;demo组件卸载...&#39;)\n          &#125;)\n        &#125;,\n      &#125;)\n\n      app.mount(&#39;#app&#39;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n四. 工程化创建Vue3.0项目有这样两种方式\n\n使用vue-cli\n使用vite1 使用vue-cli创建vue create vue3-project\n2 使用vite构建npm create vite\n使用vite初始化项目五. hooks函数1 什么是hooks\n\n\n\n\n\n\n\n\nhooks本质上还是一种函数, 将多个Composition API封装, 实现某个特定功能\n\n\n\n2 hooks的作用\n解耦\n复用\n\n\n\n\n\n\n\n\n示例\n\n\n将特定功能封装到一个单独的文件usePoint.js\nimport &#123; reactive, onMounted, onBeforeUnmount &#125; from &#39;vue&#39;\n\nexport default function usePoint() &#123;\n  const point &#x3D; reactive(&#123;\n    x: 0,\n    y: 0,\n  &#125;)\n\n  function onClick(event) &#123;\n    point.x &#x3D; event.pageX\n    point.y &#x3D; event.pageY\n    console.log(point.x, point.y)\n  &#125;\n\n  onMounted(() &#x3D;&gt; &#123;\n    window.addEventListener(&#39;click&#39;, onClick)\n  &#125;)\n\n  onBeforeUnmount(() &#x3D;&gt; &#123;\n    window.removeEventListener(&#39;click&#39;, onClick)\n  &#125;)\n\n  return point\n&#125;\n\n在需要时引入hooks函数\n&lt;template&gt;\n  &lt;h3&gt;子组件&lt;&#x2F;h3&gt;\n  &lt;p&gt;x的坐标: &#123;&#123; point.x &#125;&#125;--y的坐标: &#123;&#123; point.y &#125;&#125;&lt;&#x2F;p&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup&gt;\nimport usePoint from &#39;..&#x2F;hook&#x2F;usePoint&#39;\n\nconst point &#x3D; usePoint()\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n","slug":"Vue3 快速上手_new","date":"2022-12-02T14:08:01.300Z","categories_index":"Vue3","tags_index":"vue3基础","author_index":"团子"},{"id":"4c9b2e30526953f866be76eacd221516","title":"Git-新建协作项目的流程","content":"\n一. 创建远程仓库并初始化\n1 创建仓库\n2 初始化仓库\n3 创建分支\n二. 邀请成员准备好, 仓库地址\ngit@gitee.com:leerolee&#x2F;test2.git\n\n三. 本地开发\n1 clone到本地执行命令\ngit clone git@gitee.com:leerolee&#x2F;test2.git\n\n2 切换到自己分支执行命令\ngit checkout xxx\n\n3 开发\n4 提交到本地仓库执行命令\ngit add .\ngit commit -m &#39;xxx&#39;\n\n5 推送到远程执行命令\ngit push\n\n四. 合并到master组成要合并member1提交的代码\n1 切换到member1分支git checkout member1\ngit pull\n\n2 切换到master分支git checkout master\n\n3 合并member1分支git merge member1\n\n4 提交到本地仓库git add .\ngit commit -m &#39;xxx&#39;\n\n5 推送到远程仓库git push\n\n","slug":"git新建协作项目的流程_new","date":"2022-12-02T14:03:53.243Z","categories_index":"Git","tags_index":"git","author_index":"团子"},{"id":"1c12aa19f41272c69d4b92804f97aee7","title":"Git-版本管理工具","content":"\n1 安装在官网下载安装  第一次使用, 需要设置user.name和user.email\n\n\n\n\n\n\n\n\n\n示例\n# config 配置\n# --global 全局\n# user.name 配置项名称\n# brojie 配置的值\n# 示例: git config --global user.name 自己的用户名\n# 示例: git config --global user.name 自己的邮箱\n\ngit config --global user.name xxx\ngit config --global user.email xxx\n在用户的根目录C:\\Users\\默认用户下, 写全局配置文件\n2 快速体验\n1) 初始化git init\n\n\n该命令会在当前目录, 创建一个隐藏的文件夹.git(就是本地仓库)\n\n\n2) 创建文件在根目录下, 创建a.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;a文件&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    a文件\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\nu: 未追踪的状态\n\n\n3) 管理文件\n添加到暂存区\n提交到 本地仓库\n\n\n添加到暂存区点击更改处的+, 将所有未跟踪的文件 添加 到 暂存区也可以通过点击单个文件后面的+, 把该文件添加到暂存区此时, 文件的状态 变成  A\n\n\n\n\n\n\n\n\n\n命令\ngit add .\n\n\nadd: 添加, 添加到暂存区\n. : 添加所有文件提交到本地仓库\n\n\n\n\n\n\n\n\n对应的命令\n\n\ngit commit -m &#39;提交的信息&#39;\n\n\ncommit: 提交, 提交到本地仓库\n-m: 提交代码时的描述信息\n\n在第一次提交时, 需要 配置 user.name和 user.email\n在命令行, 执行如下 命令\ngit config --global user.name &#39;自已的用户名&#39;\ngit config --global user.email &#39;自己的邮箱&#39;\n\n\n\n\n\n\n\n\n\n\n\n练习\n\n创建一个文件b.html\n添加到暂存区: git add .\n提交到本地仓库: git commit -m &#39;xxx&#39;\n使用git log查看 \n\n\n3 Git流程3个区域\n\n远程仓库\n本地仓库\n工作区\n\n3个流程\n\n下载流程(第一次) clone+checkout\n提交流程(每天下班前) add+commit+push\n拉取(pull) pull4 版本切换根据commitID进行版本的切换1) 什么叫commitID每次提交时, 会产生一个唯一的id, 用来标识本次提交2) 如何查看commitIDgit log\ngit log --oneline\n3) 怎么切换版本使用本地仓库中的代码, 覆盖工作区的代码git reset --hard commitID\n\n\n\n\n\n\n\n\n\n示例\n\n\ngit reset --hard cc07217\n\n\n完成一个功能, 提交一次, 进行一个commitID\n\n通过reset切换版本.\n5 分支操作\n1) 为什么需要分支有时需要开发一个新的功能, 为了不影响master主干代码, 可以\n\n创建一个分支\n\n在分支上进行开发, 测试\n\n等功能稳定后, 再合并回主干\n2) 常用命令\n\n\n查看分支：git branch\n创建分支：git branch name\n切换分支：git checkout name\n创建+切换分支：git checkout –b name\n合并某分支到当前分支：git merge name\n删除本地分支：git branch –d name\n删除远程仓库分支： git push origin –delete name\n\n\n3) 演示\n\n\n\n\n\n\n\n\n步骤一. 创建+切换分支\ngit checkout -b develop\n\n\n\n\n\n\n\n\n\n\n步骤二. 在devlop分支上进行开发\n创建一个develop.html\n\n\n\n\n\n\n\n\n\n步骤三. 提交到本地\ngit add .\ngit commit -m &#39;develop&#39;\n\n\n\n\n\n\n\n\n\n\n步骤四. 提交到远程\ngit push origin develop\n\n\n将本地仓库的develop分支, 推送到远程仓库, 在远程仓库就可以看到develop分支\n\n\n\n\n\n\n\n\n\n\n步骤五. 切换到master分支\ngit checkout master\n\n\n\n\n\n\n\n\n\n\n步骤六. 合并\ngit merge develop\n\n再走提交流程\ngit add .\ngit commit -m &#39;merge&#39;\ngit push origin master\n\n\n6 SSH配置在Gitee的个人中心, 找到设置-&gt;SSH公钥配置点击怎样生成公钥查看文档打开终端, 执行ssh-keygen -t ed25519 -C &quot;xxxxx@xxxxx.com&quot;命令\n在这里xxx输入自己的邮箱在路径下, 打到公/私钥打开.pub文件, 复制内容, 粘贴到公钥\n\n\n\n\n\n\n\n\n\n\n结果如下\n在添加完公钥后, 输入命令\nssh -T git@gitee.com\n\n\n7 创建远程空仓库点击创建\n\n\n\n\n\n\n\n\n\n推送本地项目到远程空仓库\n将本地已有的仓库推送到远程\ngit remote add origin git@gitee.com:leerolee&#x2F;test.git\ngit push -u origin &quot;master&quot;\n\n\nremote: 操作远程仓库. add 添加. origin=&#103;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x65;&#x65;&#x2e;&#x63;&#x6f;&#109;:leerolee/test.git\npush: 推送, 将本地的代码上传到远程\n\n8 创建远程仓库并初始化\n从远程仓库clone到本地\n在目录下, 执行\ngit clone git@gitee.com:leerolee&#x2F;test1.git\n\n\n创建代码, 编写代码第一步\nnpm init -y\n第二步\nnpm install vue\n第三步创建src/index.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    index\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n第四步添加到index暂存区\ngit add .\n第五步提交到本地仓库\ngit commit -m &#39;1-初始化&#39;\n重复, 第四步, 第五步 . 在本地进行多个版本\n在需要推送的远程仓库时(下班之前, 在需要整合代码时), 执行\ngit push\n\n如果远程仓库的版本跟本地仓库不同步. 远程仓库中, 如果有其它的提交, 会比自己的本地更新此时, 需要先通过git pull命令将新的修改同步到本地\ngit pull\n\n9 多人协作开发流程","slug":"Git-版本管理工具_new","date":"2022-12-02T13:54:23.563Z","categories_index":"Git","tags_index":"git","author_index":"团子"},{"id":"18733ea1ca91c1189f20b7305ff3b5ec","title":"九. 通用后台管理项目","content":"\n一. Vue下的UI框架\n1 什么是UI框架提供了可以复用的常用组件, 比如说\n\nbutton(Form表单相关)\nTable表格\n布局相关\n\n主要实现了统一界面风格的组件, 提高代码的复用率, 尽可能少的编写CSS样式, 更快速的编写项目\n\n2 常见的UI框架PC端\n\nElement-UI: 饿了么团队(阿里)\nAntDesign Vue: 结合了AntDesign和Vue\niView: (View Ui)\n\n移动端\n\nvant-ui: 有赞团队\ncube ui: 滴滴团队\n\n\n3 如何学习UI框架\n1) 官方文档\n2) 重点突破\n布局\n表单\n表格3) 阅读源码寻找一些开源的项目, 在项目中如何使用UI框架Vue-element-admin(字节架构师)\n\n\n二. Element UI\n1 安装\n1) 创建项目使用vue create middle-end, 创建一个middle-end项目\nvue create middle-end\n\n\n\n2) 安装elementui使用插件的方式方案element\nvue add element\n\n\n2 集成\n1) 全部导入选择Fully import\n2) 选择语言支持\n\n3 启动测试执行命令\nnpm run serve\n\n\n\n\n\n\n\n\n\n\n测试\n\n\n三. Element-UI快速上手\n1 el-button组件了解组件上的属性\n\ntype: 控制颜色\n\nsize: 控制大小\n\nround: 圆角\n\ncircle: 圆形\n\nicon: 控制图标\n2 el-form组件el-form表单组件\n\nel-form-item: 表单项组件\n\n\n\n1) el-form组件属性\n\nmodel: 绑定表单数据\nlabel-width: 指定表单项中label的宽度\n设置了label-width, label和input表单元素会在同一行显示\n\n\n\n\n2) el-form-item组件属性\n\nlabel: 指定表单项的提示信息\n\n登录界面, 参考下面的两个仓库\n\n\n\n\n\n\n\n\n\n预览\n\n\n三. 需求分析\n1 原型图\n\n2 技术方案\n四. 具体实现\n1 清理vue框架\n1) 清理App.vue&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;app&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n\n只保留一个&lt;router-view&gt;: 替换显示不同的组件\n\n\n2) 删除文件\n删除components下的HelloWorld.vue\n删除views下的Home.vue和About.vue\n\n\n3) 修改路由文件在router/index.js中, 删除导入组件对象相关的代码\n\n\n\n\n\n\n\n\n\n示例\nimport Vue from &#39;vue&#39;\nimport VueRouter from &#39;vue-router&#39;\n\nVue.use(VueRouter)\n\nconst routes &#x3D; [\n  \n]\n\nconst router &#x3D; new VueRouter(&#123;\n  mode: &#39;history&#39;,\n  base: process.env.BASE_URL,\n  routes\n&#125;)\n\nexport default router\n\n\n2 规划路由\n1) 设置一级路由在router/index.js中, 编写前端的路由规则\n\n\n\n\n\n\n\n\n\n规划一级路由\n\n\n\npath\n组件\n备注\n\n\n\n/login\nZdLogin.vue\n\n\n\n/admin\nZdHome/index.vue\n\n\n\n*\nZdNotFound.vue\n\n\n\n在router/index.js配置一级路由规则\nconst routes &#x3D; [\n  &#x2F;&#x2F; 设置一级路由\n  &#123; path: &#39;&#x2F;login&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdLogin&#39;) &#125;,\n  &#123; path: &#39;&#x2F;admin&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdHome&#39;) &#125;,\n  &#123; path: &#39;*&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdNotFound&#39;) &#125;,\n]\n创建对应的路由文件\n\n\n\n\n\n\n\n\n\n示例\n&lt;template&gt;\n  &lt;div&gt;登录页&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ZdLogin&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n&lt;template&gt;\n  &lt;div&gt;404 Not Found&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n  export default &#123;\n    name: &#39;ZdNotFound&#39;,\n  &#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n&lt;template&gt;\n  &lt;div&gt;首页&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ZdHome&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n2) 规划二级路由\n\n\n\n\n\n\n\n\n规划二级路由\n\n\n\npath\n组件\n备注\n\n\n\n/admin/dashboard\nZdDashboard.vue\n\n\n\n/admin/user\nZdUser.vue\n\n\n\n/admin/category\nZdCategory.vue\n\n\n\n/admin/article\nZdArticle.vue\n\n\n\n在router/index.js配置二级路由规则\nconst routes &#x3D; [\n  &#x2F;&#x2F; 设置一级路由\n  &#123; path: &#39;&#x2F;login&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdLogin&#39;) &#125;,\n  &#x2F;&#x2F; 设置二级路由\n  &#123;\n    path: &#39;&#x2F;admin&#39;,\n    component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdHome&#39;),\n    children: [\n      &#123;\n        path: &#39;dashboard&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdHome&#x2F;ZdDashboard&#39;),\n      &#125;,\n      &#123;\n        path: &#39;user&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdHome&#x2F;ZdUser&#39;),\n      &#125;,\n      &#123;\n        path: &#39;category&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdHome&#x2F;ZdCategory&#39;),\n      &#125;,\n      &#123;\n        path: &#39;article&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdHome&#x2F;ZdArticle&#39;),\n      &#125;,\n    ],\n  &#125;,\n  &#123; path: &#39;*&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdNotFound&#39;) &#125;,\n]\n创建对应的组件文件\n3) 优化重定向\n\n\n\n\n\n\n\n\n完整示例\nimport Vue from &#39;vue&#39;\nimport VueRouter from &#39;vue-router&#39;\n\nVue.use(VueRouter)\n\nconst routes &#x3D; [\n  &#x2F;&#x2F; 设置一级路由\n  &#123; path: &#39;&#x2F;login&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdLogin&#39;) &#125;,\n  &#x2F;&#x2F; 设置二级路由\n  &#123;\n    path: &#39;&#x2F;admin&#39;,\n    component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdHome&#39;),\n    redirect: &#39;&#x2F;admin&#x2F;dashboard&#39;,\n    children: [\n      &#123;\n        path: &#39;dashboard&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdHome&#x2F;ZdDashboard&#39;),\n      &#125;,\n      &#123;\n        path: &#39;user&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdHome&#x2F;ZdUser&#39;),\n      &#125;,\n      &#123;\n        path: &#39;category&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdHome&#x2F;ZdCategory&#39;),\n      &#125;,\n      &#123;\n        path: &#39;article&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdHome&#x2F;ZdArticle&#39;),\n      &#125;,\n    ],\n  &#125;,\n  &#123;\n    path: &#39;&#x2F;&#39;,\n    redirect: &#39;&#x2F;admin&#x2F;dashboard&#39;,\n  &#125;,\n  &#123; path: &#39;*&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;ZdNotFound&#39;) &#125;,\n]\n\nconst router &#x3D; new VueRouter(&#123;\n  mode: &#39;history&#39;,\n  base: process.env.BASE_URL,\n  routes,\n&#125;)\n\nexport default router\n\n\n\n\n\n\n\n\n\n\n\n导入默认样式\n编写assets/styles/reset.css, 并导入到App.vue中\n&#x2F;* http:&#x2F;&#x2F;meyerweb.com&#x2F;eric&#x2F;tools&#x2F;css&#x2F;reset&#x2F; \n   v2.0 | 20110126\n   License: none (public domain)\n*&#x2F;\n\nhtml,\nbody,\ndiv,\nspan,\napplet,\nobject,\niframe,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\np,\nblockquote,\npre,\na,\nabbr,\nacronym,\naddress,\nbig,\ncite,\ncode,\ndel,\ndfn,\nem,\nimg,\nins,\nkbd,\nq,\ns,\nsamp,\nsmall,\nstrike,\nstrong,\nsub,\nsup,\ntt,\nvar,\nb,\nu,\ni,\ncenter,\ndl,\ndt,\ndd,\nol,\nul,\nli,\nfieldset,\nform,\nlabel,\nlegend,\ntable,\ncaption,\ntbody,\ntfoot,\nthead,\ntr,\nth,\ntd,\narticle,\naside,\ncanvas,\ndetails,\nembed,\nfigure,\nfigcaption,\nfooter,\nheader,\nhgroup,\nmenu,\nnav,\noutput,\nruby,\nsection,\nsummary,\ntime,\nmark,\naudio,\nvideo &#123;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-size: 100%;\n  font: inherit;\n  vertical-align: baseline;\n&#125;\n&#x2F;* HTML5 display-role reset for older browsers *&#x2F;\narticle,\naside,\ndetails,\nfigcaption,\nfigure,\nfooter,\nheader,\nhgroup,\nmenu,\nnav,\nsection &#123;\n  display: block;\n&#125;\nbody &#123;\n  line-height: 1;\n&#125;\nol,\nul &#123;\n  list-style: none;\n&#125;\nblockquote,\nq &#123;\n  quotes: none;\n&#125;\nblockquote:before,\nblockquote:after,\nq:before,\nq:after &#123;\n  content: &#39;&#39;;\n  content: none;\n&#125;\ntable &#123;\n  border-collapse: collapse;\n  border-spacing: 0;\n&#125;\n\n修改App.vue\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;!-- 配置一级路由的出口 --&gt;\n    &lt;router-view &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;app&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n@import url(&#39;~@&#x2F;assets&#x2F;styles&#x2F;reset.css&#39;);\n&lt;&#x2F;style&gt;\n\n\n\n\n\n\n\n\n\n\nZdDashboard.vue\n&lt;template&gt;\n  &lt;div&gt;首页&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ZdDashboard&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n\nZdUser.vue\n&lt;template&gt;\n  &lt;div&gt;用户页&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ZdUser&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n\nZdCategory.vue\n&lt;template&gt;\n  &lt;div&gt;分类页&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ZdCategory&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n\nZdArticle.vue\n&lt;template&gt;\n  &lt;div&gt;文章页&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ZdArticle&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n\n自定义404页面\n编辑ZdNotFound.vue\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;not-found&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ZdNotFound&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.not-found &#123;\n  width: 100vw;\n  height: 100vh;\n  background: url(&#39;~@&#x2F;assets&#x2F;images&#x2F;404.jpeg&#39;) no-repeat;\n  background-size: cover;\n&#125;\n&lt;&#x2F;style&gt;\n\n3 设置导航守卫\n从element-ui库中, 单独引入Message函数\n使用Message函数显示提示信息&#x2F;&#x2F; 引入Message组件\nimport &#123;Message&#125; from &#39;element-ui&#39;\n\n&#x2F;&#x2F; 设置全局前置导航守卫\nrouter.beforeEach((to, from, next) &#x3D;&gt; &#123;\n  let isLogin &#x3D; localStorage.getItem(&#39;isLogin&#39;)\n\n  if (isLogin) &#123;\n    &#x2F;&#x2F; 全部放行(想访问哪个path, 都可以直接访问)\n    next()\n  &#125; else &#123;\n    if (to.path &#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;\n      &#x2F;&#x2F; 只有想访问&#x2F;login页面, 才能访问\n      next()\n    &#125; else &#123;\n      Message(&#123;\n        type: &#39;error&#39;,\n        message: &#39;请先登录&#39;,\n        showClose: true,\n        duration: 1000\n      &#125;)\n      &#x2F;&#x2F; 想访问其它的页面, 都会回到&#x2F;login\n      next(&#39;&#x2F;login&#39;)\n    &#125;\n  &#125;\n&#125;)\n五. 实现登录页1 粒子效果粒子效果使用了一个插件vue-particles\n\n\n1) 安装插件npm install vue-particles\n\n2) 注册插件创建plugins/particles.js文件\nimport Vue from &#39;vue&#39;\nimport VueParticles from &#39;vue-particles&#39;\n\nVue.use(VueParticles)\n在main.js中加载\nimport &#39;.&#x2F;plugins&#x2F;particles.js&#39;\n\n3) 使用插件在ZdLogin.vue中引用\n&lt;vue-particles\n               class&#x3D;&quot;login-bg&quot;\n               color&#x3D;&quot;#39AFFD&quot;\n               :particleOpacity&#x3D;&quot;0.7&quot;\n               :particlesNumber&#x3D;&quot;100&quot;\n               shapeType&#x3D;&quot;circle&quot;\n               :particleSize&#x3D;&quot;4&quot;\n               linesColor&#x3D;&quot;#8DD1FE&quot;\n               :linesWidth&#x3D;&quot;1&quot;\n               :lineLinked&#x3D;&quot;true&quot;\n               :lineOpacity&#x3D;&quot;0.4&quot;\n               :linesDistance&#x3D;&quot;150&quot;\n               :moveSpeed&#x3D;&quot;3&quot;\n               :hoverEffect&#x3D;&quot;true&quot;\n               hoverMode&#x3D;&quot;grab&quot;\n               :clickEffect&#x3D;&quot;true&quot;\n               clickMode&#x3D;&quot;push&quot;\n               &#x2F;&gt;\n\n\n\ncolor: String类型。默认’#dedede’。粒子颜色。\nparticleOpacity: Number类型。默认0.7。粒子透明度。\nparticlesNumber: Number类型。默认80。粒子数量。\nshapeType: String类型。默认’circle’。可用的粒子外观类型有：“circle”,“edge”,“triangle”, “polygon”,“star”。\nparticleSize: Number类型。默认80。单个粒子大小。\nlinesColor: String类型。默认’#dedede’。线条颜色。\nlinesWidth: Number类型。默认1。线条宽度。\nlineLinked: 布尔类型。默认true。连接线是否可用。\nlineOpacity: Number类型。默认0.4。线条透明度。\nlinesDistance: Number类型。默认150。线条距离。\nmoveSpeed: Number类型。默认3。粒子运动速度。\nhoverEffect: 布尔类型。默认true。是否有hover特效。\nhoverMode: String类型。默认true。可用的hover模式有: “grab”, “repulse”, + “bubble”。\nclickEffect: 布尔类型。默认true。是否有click特效。\nclickMode: String类型。默认true。可用的click模式有: “push”, “remove”, “repulse”, “bubble”。\n\n\n2 调整结构和样式\n\n\n\n\n\n\n\n\n示例\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;login&quot;&gt;\n    &lt;vue-particles\n      class&#x3D;&quot;login-bg&quot;\n      color&#x3D;&quot;#39AFFD&quot;\n      :particleOpacity&#x3D;&quot;0.7&quot;\n      :particlesNumber&#x3D;&quot;100&quot;\n      shapeType&#x3D;&quot;circle&quot;\n      :particleSize&#x3D;&quot;4&quot;\n      linesColor&#x3D;&quot;#8DD1FE&quot;\n      :linesWidth&#x3D;&quot;1&quot;\n      :lineLinked&#x3D;&quot;true&quot;\n      :lineOpacity&#x3D;&quot;0.4&quot;\n      :linesDistance&#x3D;&quot;150&quot;\n      :moveSpeed&#x3D;&quot;3&quot;\n      :hoverEffect&#x3D;&quot;true&quot;\n      hoverMode&#x3D;&quot;grab&quot;\n      :clickEffect&#x3D;&quot;true&quot;\n      clickMode&#x3D;&quot;push&quot;\n    &#x2F;&gt;\n\n    &lt;div class&#x3D;&quot;login-container&quot;&gt;\n      &lt;h3 class&#x3D;&quot;title&quot;&gt;后台管理系统&lt;&#x2F;h3&gt;\n      &lt;el-form :model&#x3D;&quot;userForm&quot;&gt;\n        &lt;el-form-item&gt;\n          &lt;el-input\n            prefix-icon&#x3D;&quot;el-icon-user&quot;\n          &gt;&lt;&#x2F;el-input&gt;\n        &lt;&#x2F;el-form-item&gt;\n        &lt;el-form-item&gt;\n          &lt;el-input\n            prefix-icon&#x3D;&quot;el-icon-lock&quot;\n            show-password\n          &gt;&lt;&#x2F;el-input&gt;\n        &lt;&#x2F;el-form-item&gt;\n        &lt;el-form-item&gt;\n          &lt;el-button type&#x3D;&quot;primary&quot; style&#x3D;&quot;width: 100%&quot;&gt;立即登录&lt;&#x2F;el-button&gt;\n        &lt;&#x2F;el-form-item&gt;\n      &lt;&#x2F;el-form&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ZdLogin&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&#x2F;* 定制elementUI的样式 *&#x2F;\n.el-form-item &#123;\n  border: 1px solid rgba(255, 255, 255, 0.1);\n  background: rgba(0, 0, 0, 0.1);\n  border-radius: 5px;\n  color: #454545;\n&#125;\n.el-input &#123;\n  display: inline-block;\n  height: 47px;\n&#125;\n.el-input__inner &#123;\n  height: 47px;\n  margin-left: 10px;\n  padding: 12px 5px 12px 15px;\n  border: none;\n  background: transparent;\n  color: #eee;\n  appearance: none;\n  border-radius: 0px;\n&#125;\n&lt;&#x2F;style&gt;\n\n&lt;style scoped&gt;\n&#x2F;* 加上scoped: 将样式限定到当前组件 *&#x2F;\n.login &#123;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n&#125;\n.login-bg &#123;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background-color: #2d3a4b;\n  z-index: -1;\n&#125;\n.login-container &#123;\n  width: 480px;\n  padding: 35px 35px 15px 35px;\n  border-radius: 10px;\n  box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);\n&#125;\n.login-container .title &#123;\n  margin: 0px auto 40px auto;\n  font-size: 26px;\n  font-weight: 700;\n  color: #fff;\n  text-align: center;\n&#125;\n&lt;&#x2F;style&gt;\n\n3 实现逻辑\n1) 绑定数据&lt;template&gt;\n  &lt;div class&#x3D;&quot;login&quot;&gt;\n    &lt;vue-particles\n      class&#x3D;&quot;login-bg&quot;\n      color&#x3D;&quot;#39AFFD&quot;\n      :particleOpacity&#x3D;&quot;0.7&quot;\n      :particlesNumber&#x3D;&quot;100&quot;\n      shapeType&#x3D;&quot;circle&quot;\n      :particleSize&#x3D;&quot;4&quot;\n      linesColor&#x3D;&quot;#8DD1FE&quot;\n      :linesWidth&#x3D;&quot;1&quot;\n      :lineLinked&#x3D;&quot;true&quot;\n      :lineOpacity&#x3D;&quot;0.4&quot;\n      :linesDistance&#x3D;&quot;150&quot;\n      :moveSpeed&#x3D;&quot;3&quot;\n      :hoverEffect&#x3D;&quot;true&quot;\n      hoverMode&#x3D;&quot;grab&quot;\n      :clickEffect&#x3D;&quot;true&quot;\n      clickMode&#x3D;&quot;push&quot;\n    &gt;\n    &lt;&#x2F;vue-particles&gt;\n    &lt;div class&#x3D;&quot;login-container&quot;&gt;\n      &lt;el-form :model&#x3D;&quot;loginForm&quot;&gt;\n        &lt;h3 class&#x3D;&quot;title&quot;&gt;后台管理系统&lt;&#x2F;h3&gt;\n        &lt;el-form-item&gt;\n          &lt;el-input\n            v-model&#x3D;&quot;loginForm.username&quot;\n            prefix-icon&#x3D;&quot;el-icon-user&quot;\n          &gt;&lt;&#x2F;el-input&gt;\n        &lt;&#x2F;el-form-item&gt;\n        &lt;el-form-item&gt;\n          &lt;el-input\n            v-model&#x3D;&quot;loginForm.password&quot;\n            show-password\n            prefix-icon&#x3D;&quot;el-icon-lock&quot;\n          &gt;&lt;&#x2F;el-input&gt;\n        &lt;&#x2F;el-form-item&gt;\n        &lt;el-form-item&gt;\n          &lt;el-button type&#x3D;&quot;primary&quot; style&#x3D;&quot;width: 100%&quot;&gt;登录&lt;&#x2F;el-button&gt;\n        &lt;&#x2F;el-form-item&gt;\n      &lt;&#x2F;el-form&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ZdLogin&#39;,\n  data() &#123;\n    return &#123;\n      loginForm: &#123;\n        username: &#39;&#39;,\n        password: &#39;&#39;,\n      &#125;,\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.el-form-item &#123;\n  border: 1px solid rgba(255, 255, 255, 0.1);\n  background: rgba(0, 0, 0, 0.1);\n  border-radius: 5px;\n  color: #454545;\n&#125;\n.el-input &#123;\n  display: inline-block;\n  height: 47px;\n&#125;\n.el-input__inner &#123;\n  height: 47px;\n  margin-left: 10px;\n  padding: 12px 5px 12px 15px;\n  border: none;\n  background: transparent;\n  color: #eee;\n  appearance: none;\n  border-radius: 0px;\n&#125;\n&lt;&#x2F;style&gt;\n\n&lt;style scoped&gt;\n&#x2F;* 加上scoped: 将样式限定到当前组件 *&#x2F;\n.login &#123;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n&#125;\n.login-bg &#123;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background-color: #2d3a4b;\n  z-index: -1;\n&#125;\n.login-container &#123;\n  width: 480px;\n  padding: 35px 35px 15px 35px;\n  border-radius: 10px;\n  box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);\n&#125;\n.login-container .title &#123;\n  margin: 0px auto 40px auto;\n  font-size: 26px;\n  font-weight: 700;\n  color: #fff;\n  text-align: center;\n&#125;\n&lt;&#x2F;style&gt;\n\n2) 实现表单校验\n\n\n\n\n\n\n\n\n思路\n\n给el-form组件, 绑定rules属性\n给el-form-item组件, 绑定prop属性\n编写表单校验规则\n提交表单, 通过ref获取表单组件, 调用validate方法\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;login&quot;&gt;\n    &lt;vue-particles\n      class&#x3D;&quot;login-bg&quot;\n      color&#x3D;&quot;#39AFFD&quot;\n      :particleOpacity&#x3D;&quot;0.7&quot;\n      :particlesNumber&#x3D;&quot;100&quot;\n      shapeType&#x3D;&quot;circle&quot;\n      :particleSize&#x3D;&quot;4&quot;\n      linesColor&#x3D;&quot;#8DD1FE&quot;\n      :linesWidth&#x3D;&quot;1&quot;\n      :lineLinked&#x3D;&quot;true&quot;\n      :lineOpacity&#x3D;&quot;0.4&quot;\n      :linesDistance&#x3D;&quot;150&quot;\n      :moveSpeed&#x3D;&quot;3&quot;\n      :hoverEffect&#x3D;&quot;true&quot;\n      hoverMode&#x3D;&quot;grab&quot;\n      :clickEffect&#x3D;&quot;true&quot;\n      clickMode&#x3D;&quot;push&quot;\n    &#x2F;&gt;\n\n    &lt;div class&#x3D;&quot;login-container&quot;&gt;\n      &lt;h3 class&#x3D;&quot;title&quot;&gt;后台管理系统&lt;&#x2F;h3&gt;\n      &lt;el-form ref&#x3D;&quot;loginForm&quot; :model&#x3D;&quot;userForm&quot; :rules&#x3D;&quot;userRules&quot;&gt;\n        &lt;el-form-item prop&#x3D;&quot;username&quot;&gt;\n          &lt;el-input\n            v-model&#x3D;&quot;userForm.username&quot;\n            prefix-icon&#x3D;&quot;el-icon-user&quot;\n          &gt;&lt;&#x2F;el-input&gt;\n        &lt;&#x2F;el-form-item&gt;\n        &lt;el-form-item prop&#x3D;&quot;password&quot;&gt;\n          &lt;el-input\n            v-model&#x3D;&quot;userForm.password&quot;\n            prefix-icon&#x3D;&quot;el-icon-lock&quot;\n            show-password\n          &gt;&lt;&#x2F;el-input&gt;\n        &lt;&#x2F;el-form-item&gt;\n        &lt;el-form-item&gt;\n          &lt;el-button type&#x3D;&quot;primary&quot; style&#x3D;&quot;width: 100%&quot; @click&#x3D;&quot;onSubmit&quot;&gt;\n            立即登录\n          &lt;&#x2F;el-button&gt;\n        &lt;&#x2F;el-form-item&gt;\n      &lt;&#x2F;el-form&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ZdLogin&#39;,\n  data() &#123;\n    return &#123;\n      userForm: &#123;\n        username: &#39;&#39;,\n        password: &#39;&#39;,\n      &#125;,\n      userRules: &#123;\n        username: [\n          &#123;\n            required: true,\n            message: &#39;请输入用户名&#39;,\n            trigger: &#39;blur&#39;,\n          &#125;,\n        ],\n        password: [\n          &#123;\n            required: true,\n            message: &#39;请输入密码&#39;,\n            trigger: &#39;blur&#39;,\n          &#125;,\n        ],\n      &#125;,\n    &#125;\n  &#125;,\n  methods: &#123;\n    onSubmit() &#123;\n      &#x2F;&#x2F; 校验表单. 调用表单组件的validate方法\n      this.$refs[&#39;loginForm&#39;].validate((valid) &#x3D;&gt; &#123;\n        if (valid) &#123;\n          &#x2F;&#x2F; 校验成功\n          &#x2F;&#x2F; 1. 修改登录状态\n          localStorage.setItem(&#39;isLogin&#39;, 1)\n          &#x2F;&#x2F; 2. 提示消息\n          this.$message(&#123;\n            type: &#39;success&#39;,\n            message: &#39;登录成功&#39;,\n            duration: 1000,\n          &#125;)\n          &#x2F;&#x2F; 3. 跳转页面, 修改url地址\n          this.$router.push(&#39;&#x2F;admin&#x2F;dashboard&#39;)\n        &#125;\n      &#125;)\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&#x2F;* 定制elementUI的样式 *&#x2F;\n.el-form-item &#123;\n  border: 1px solid rgba(255, 255, 255, 0.1);\n  background: rgba(0, 0, 0, 0.1);\n  border-radius: 5px;\n  color: #454545;\n&#125;\n.el-input &#123;\n  display: inline-block;\n  height: 47px;\n&#125;\n.el-input__inner &#123;\n  height: 47px;\n  margin-left: 10px;\n  padding: 12px 5px 12px 15px;\n  border: none;\n  background: transparent;\n  color: #eee;\n  appearance: none;\n  border-radius: 0px;\n&#125;\n&lt;&#x2F;style&gt;\n\n&lt;style scoped&gt;\n&#x2F;* 加上scoped: 将样式限定到当前组件 *&#x2F;\n.login &#123;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n&#125;\n.login-bg &#123;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background-color: #2d3a4b;\n  z-index: -1;\n&#125;\n.login-container &#123;\n  width: 480px;\n  padding: 35px 35px 15px 35px;\n  border-radius: 10px;\n  box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);\n&#125;\n.login-container .title &#123;\n  margin: 0px auto 40px auto;\n  font-size: 26px;\n  font-weight: 700;\n  color: #fff;\n  text-align: center;\n&#125;\n&lt;&#x2F;style&gt;\n\n六. 实现首页布局\n1 布局需要使用到elementui中的容器\n\n\n1) 页面结构&lt;template&gt;\n  &lt;el-container class&#x3D;&quot;home-container&quot;&gt;\n    &lt;el-aside width&#x3D;&quot;200px&quot;&gt;侧边栏&lt;&#x2F;el-aside&gt;\n    &lt;el-container&gt;\n      &lt;el-header&gt;头部&lt;&#x2F;el-header&gt;\n      &lt;el-main&gt;\n        &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n      &lt;&#x2F;el-main&gt;\n    &lt;&#x2F;el-container&gt;\n  &lt;&#x2F;el-container&gt;\n&lt;&#x2F;template&gt;\n\n\n2) 样式&lt;style&gt;\n.el-aside &#123;\n  background-color: #666;\n&#125;\n.el-header &#123;\n  background-color: #999;\n&#125;\n.el-main &#123;\n  background-color: #eee;\n&#125;\n\n.home-container &#123;\n  height: 100vh;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n2 侧边栏找到文档, 参考\n\n在&lt;el-aside&gt;组件中, 初步使用el-menu\n&lt;el-menu&gt;\n  &lt;el-submenu&gt;导航一&lt;&#x2F;el-submenu&gt;\n  &lt;el-menu-item&gt;导航二&lt;&#x2F;el-menu-item&gt;\n&lt;&#x2F;el-menu&gt;\n\n\nel-menu: 主菜单组件 \nel-submenu: 带下拉列表的子菜单\nel-menu-item: 菜单项\n\n\n\n初步使用, 添加一个属性(尝试)\n\n1) 结构&lt;template&gt;\n  &lt;el-container class&#x3D;&quot;home-container&quot;&gt;\n    &lt;el-aside width&#x3D;&quot;200px&quot;&gt;\n      &lt;div class&#x3D;&quot;logo&quot;&gt;\n        &lt;i class&#x3D;&quot;el-icon-eleme&quot;&gt;&lt;&#x2F;i&gt;\n        &lt;h1&gt;Server Manager&lt;&#x2F;h1&gt;\n      &lt;&#x2F;div&gt;\n      &lt;el-scrollbar&gt;\n        &lt;el-menu router&gt;\n          &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;dashboard&quot;&gt;\n            &lt;i class&#x3D;&quot;el-icon-s-home&quot;&gt;&lt;&#x2F;i&gt;\n            &lt;template v-slot:title&gt;\n              &lt;span&gt;首页&lt;&#x2F;span&gt;\n            &lt;&#x2F;template&gt;\n          &lt;&#x2F;el-menu-item&gt;\n          &lt;el-submenu index&#x3D;&quot;&#x2F;admin&#x2F;user&quot;&gt;\n            &lt;!-- &lt;template v-slot:title&gt; v-slot: 可以简写成 #--&gt;\n            &lt;template #title&gt;\n              &lt;i class&#x3D;&quot;el-icon-s-custom&quot;&gt;&lt;&#x2F;i&gt;\n              &lt;span&gt;用户管理&lt;&#x2F;span&gt;\n            &lt;&#x2F;template&gt;\n            &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;user&quot;&gt;用户列表&lt;&#x2F;el-menu-item&gt;\n            &lt;el-menu-item&gt;添加用户&lt;&#x2F;el-menu-item&gt;\n            &lt;el-menu-item&gt;修改用户&lt;&#x2F;el-menu-item&gt;\n          &lt;&#x2F;el-submenu&gt;\n          &lt;el-submenu index&#x3D;&quot;&#x2F;admin&#x2F;category&quot;&gt;\n            &lt;!-- &lt;template v-slot:title&gt; v-slot: 可以简写成 #--&gt;\n            &lt;template #title&gt;\n              &lt;i class&#x3D;&quot;el-icon-menu&quot;&gt;&lt;&#x2F;i&gt;\n              &lt;span&gt;分类管理&lt;&#x2F;span&gt;\n            &lt;&#x2F;template&gt;\n            &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;category&quot;&gt;分类列表&lt;&#x2F;el-menu-item&gt;\n            &lt;el-menu-item&gt;添加分类&lt;&#x2F;el-menu-item&gt;\n            &lt;el-menu-item&gt;修改分类&lt;&#x2F;el-menu-item&gt;\n          &lt;&#x2F;el-submenu&gt;\n          &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;article&quot;&gt;\n            &lt;i class&#x3D;&quot;el-icon-document&quot;&gt;&lt;&#x2F;i&gt;\n            &lt;template v-slot:title&gt;\n              &lt;span&gt;博客管理&lt;&#x2F;span&gt;\n            &lt;&#x2F;template&gt;\n          &lt;&#x2F;el-menu-item&gt;\n        &lt;&#x2F;el-menu&gt;\n      &lt;&#x2F;el-scrollbar&gt;\n    &lt;&#x2F;el-aside&gt;\n    &lt;el-container&gt;\n      &lt;el-header&gt;Header&lt;&#x2F;el-header&gt;\n      &lt;el-main&gt;\n        &lt;!-- 设置二级路由 --&gt;\n        &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n      &lt;&#x2F;el-main&gt;\n    &lt;&#x2F;el-container&gt;\n  &lt;&#x2F;el-container&gt;\n&lt;&#x2F;template&gt;\n\n\nel-aisde下包括两个部分\nlogo区域: 是一个div. 高度是60px(为了跟el-header高度一致)\nel-scrollbar是一个可以滚动的区域. 必须有高度, el-scrollbar高度=el-aside的高度- logo区域的高度\n\n\n\n\n\n\n\n\n示例\n\n\n\n\n.home-container &#123;\n  height: 100vh;\n&#125;\n.logo &#123;\n  height: 60px;\n&#125;\n.el-scrollbar &#123;\n  height: calc(100% - 60px);\n&#125;\n\n2) 完善logo区域的布局.logo &#123;\n  height: 60px;\n  display: flex;\n  justify-content: space-evenly;\n  align-items: center;\n  font-size: 22px;\n  color: #fff;\n  white-space: nowrap;\n  background-color: #1f2d3d;\n&#125;\n\n3) 调整侧边栏的颜色background-color&#x3D;&quot;#304156&quot;\ntext-color&#x3D;&quot;#bfcbd9&quot;\nactive-text-color&#x3D;&quot;#409EFF&quot;\n\n\n给el-menu添加属性\n给el-aside添加背景颜色\n\n\n\n\n\n\n\n\n示例\n\n\n&lt;el-aside width&#x3D;&quot;200px&quot;&gt;\n      &lt;!-- logo区域: height 60px --&gt;\n      &lt;div class&#x3D;&quot;logo&quot;&gt;\n        &lt;i class&#x3D;&quot;el-icon-eleme&quot;&gt;&lt;&#x2F;i&gt;\n        &lt;h1&gt;Server Manager&lt;&#x2F;h1&gt;\n      &lt;&#x2F;div&gt;\n      &lt;!-- scrollbar的高度: aside的高度 - 60px --&gt;\n      &lt;el-scrollbar&gt;\n        &lt;el-menu\n          router\n          background-color&#x3D;&quot;#304156&quot;\n          text-color&#x3D;&quot;#bfcbd9&quot;\n          active-text-color&#x3D;&quot;#409EFF&quot;\n        &gt;\n          &lt;!-- 如果有子菜单: el-submenu --&gt;\n          &lt;!-- 如果没有子菜单: el-menu-item --&gt;\n          &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;dashboard&quot;&gt;\n            &lt;i class&#x3D;&quot;el-icon-s-home&quot;&gt;&lt;&#x2F;i&gt;\n            &lt;span&gt;首页&lt;&#x2F;span&gt;\n          &lt;&#x2F;el-menu-item&gt;\n          &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;user&quot;&gt;\n            &lt;i class&#x3D;&quot;el-icon-s-custom&quot;&gt;&lt;&#x2F;i&gt;\n            &lt;span&gt;用户管理&lt;&#x2F;span&gt;\n          &lt;&#x2F;el-menu-item&gt;\n        &lt;&#x2F;el-menu&gt;\n      &lt;&#x2F;el-scrollbar&gt;\n    &lt;&#x2F;el-aside&gt;\n.home-container &#123;\n  height: 100vh;\n&#125;\n.el-aside &#123;\n  &#x2F;* 跟el-menu的颜色一致 *&#x2F;\n  background-color: #304156;\n  &#x2F;* 用户不能选中效果 *&#x2F;\n  user-select: none;\n&#125;\n.logo &#123;\n  height: 60px;\n  display: flex;\n  justify-content: space-evenly;\n  align-items: center;\n  font-size: 22px;\n  color: #fff;\n  white-space: nowrap;\n  background-color: #1f2d3d;\n&#125;\n.el-scrollbar &#123;\n  height: calc(100% - 60px);\n&#125;\n\n3 侧边栏折叠效果\n\n\n\n\n\n\n\n\n思路\n\n声明变量isCollapse, 记录当前折叠状态\n在el-header组件中, 设置折叠效果的图标, 绑定图标的点击事件, 切换isCollapse的值\n给el-menu绑定collapse属性, 关闭动画\n\n\n1) 声明isCollapse状态在data中声明状态\n\nfalse: 展开\n\ntrue: 折叠\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ZdHome&#39;,\n  data() &#123;\n    return &#123;\n      isCollapse: false,\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n2) 设置图标在el-header组件中, 设置图标\n&lt;el-header&gt;\n  &lt;i\n    :class&#x3D;&quot;[&#39;el-icon-s-fold&#39;, isCollapse ? &#39;isCollapse&#39; : &#39;&#39;]&quot;\n    @click&#x3D;&quot;isCollapse &#x3D; !isCollapse&quot;\n  &gt;&lt;&#x2F;i&gt;\n&lt;&#x2F;el-header&gt;\n动态绑定isCollapse样式, 编写该样式\n.home-container .el-header &#123;\n  display: flex;\n  align-items: center;\n  background-color: #fff;\n  font-size: 24px;\n  color: #333;\n&#125;\n.el-header i &#123;\n  transition: all 0.3s;\n&#125;\n.isCollapse &#123;\n  transform: rotate(-180deg);\n&#125;\n\n3) menu联动&lt;el-menu router :collapse&#x3D;&quot;isCollapse&quot; :collapse-transition&#x3D;&quot;false&quot;&gt;\n  &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;dashboard&quot;&gt;\n    &lt;i class&#x3D;&quot;el-icon-s-home&quot;&gt;&lt;&#x2F;i&gt;\n    &lt;template v-slot:title&gt;\n      &lt;span&gt;首页&lt;&#x2F;span&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;el-menu-item&gt;\n  &lt;el-submenu index&#x3D;&quot;&#x2F;admin&#x2F;user&quot;&gt;\n    &lt;!-- &lt;template v-slot:title&gt; v-slot: 可以简写成 #--&gt;\n    &lt;template #title&gt;\n      &lt;i class&#x3D;&quot;el-icon-s-custom&quot;&gt;&lt;&#x2F;i&gt;\n      &lt;span&gt;用户管理&lt;&#x2F;span&gt;\n    &lt;&#x2F;template&gt;\n    &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;user&quot;&gt;用户列表&lt;&#x2F;el-menu-item&gt;\n    &lt;el-menu-item&gt;添加用户&lt;&#x2F;el-menu-item&gt;\n    &lt;el-menu-item&gt;修改用户&lt;&#x2F;el-menu-item&gt;\n  &lt;&#x2F;el-submenu&gt;\n  &lt;el-submenu index&#x3D;&quot;&#x2F;admin&#x2F;category&quot;&gt;\n    &lt;!-- &lt;template v-slot:title&gt; v-slot: 可以简写成 #--&gt;\n    &lt;template #title&gt;\n      &lt;i class&#x3D;&quot;el-icon-menu&quot;&gt;&lt;&#x2F;i&gt;\n      &lt;span&gt;分类管理&lt;&#x2F;span&gt;\n    &lt;&#x2F;template&gt;\n    &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;category&quot;&gt;分类列表&lt;&#x2F;el-menu-item&gt;\n    &lt;el-menu-item&gt;添加分类&lt;&#x2F;el-menu-item&gt;\n    &lt;el-menu-item&gt;修改分类&lt;&#x2F;el-menu-item&gt;\n  &lt;&#x2F;el-submenu&gt;\n  &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;article&quot;&gt;\n    &lt;i class&#x3D;&quot;el-icon-document&quot;&gt;&lt;&#x2F;i&gt;\n    &lt;template v-slot:title&gt;\n      &lt;span&gt;博客管理&lt;&#x2F;span&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;el-menu-item&gt;\n&lt;&#x2F;el-menu&gt;\ncollapse: 控制menu折叠的状态\n\ncollapse-transition: 关闭折叠时的动画\n4) logo联动&lt;div class&#x3D;&quot;logo&quot; v-show&#x3D;&quot;!isCollapse&quot;&gt;\n  &lt;i class&#x3D;&quot;el-icon-eleme&quot;&gt;&lt;&#x2F;i&gt;\n  &lt;h1&gt;Server Manager&lt;&#x2F;h1&gt;\n&lt;&#x2F;div&gt;\n\n\n\n\n\n\n\n\n\n\n整体示例\n&lt;template&gt;\n  &lt;el-container class&#x3D;&quot;home-container&quot;&gt;\n    &lt;el-aside :style&#x3D;&quot;obj&quot;&gt;\n      &lt;div class&#x3D;&quot;logo&quot; v-show&#x3D;&quot;!isCollapse&quot;&gt;\n        &lt;i class&#x3D;&quot;el-icon-eleme&quot;&gt;&lt;&#x2F;i&gt;\n        &lt;h1&gt;Server Manager&lt;&#x2F;h1&gt;\n      &lt;&#x2F;div&gt;\n      &lt;!-- scrollbar组件必须有固定高度 --&gt;\n      &lt;el-scrollbar&gt;\n        &lt;!-- 开启路由模式 --&gt;\n        &lt;el-menu\n          router\n          background-color&#x3D;&quot;#304156&quot;\n          text-color&#x3D;&quot;#bfcbd9&quot;\n          active-text-color&#x3D;&quot;#409EFF&quot;\n          :collapse&#x3D;&quot;isCollapse&quot;\n          :collapse-transition&#x3D;&quot;false&quot;\n        &gt;\n          &lt;!-- index是唯一标识, 要跳转的url路径 --&gt;\n          &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;dashboard&quot;&gt;\n            &lt;!-- icon图标 --&gt;\n            &lt;i class&#x3D;&quot;el-icon-s-home&quot;&gt;&lt;&#x2F;i&gt;\n            &lt;!-- title插槽 --&gt;\n            &lt;template v-slot:title&gt;\n              &lt;span&gt;首页&lt;&#x2F;span&gt;\n            &lt;&#x2F;template&gt;\n          &lt;&#x2F;el-menu-item&gt;\n          &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;user&quot;&gt;\n            &lt;i class&#x3D;&quot;el-icon-s-custom&quot;&gt;&lt;&#x2F;i&gt;\n            &lt;template #title&gt;\n              &lt;span&gt;用户管理&lt;&#x2F;span&gt;\n            &lt;&#x2F;template&gt;\n          &lt;&#x2F;el-menu-item&gt;\n          &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;category&quot;&gt;\n            &lt;i class&#x3D;&quot;el-icon-menu&quot;&gt;&lt;&#x2F;i&gt;\n            &lt;template #title&gt;\n              &lt;span&gt;分类管理&lt;&#x2F;span&gt;\n            &lt;&#x2F;template&gt;\n          &lt;&#x2F;el-menu-item&gt;\n          &lt;el-submenu index&#x3D;&quot;&#x2F;admin&#x2F;article&quot;&gt;\n            &lt;template #title&gt;\n              &lt;i class&#x3D;&quot;el-icon-document&quot;&gt;&lt;&#x2F;i&gt;\n              &lt;span&gt;文章管理&lt;&#x2F;span&gt;\n            &lt;&#x2F;template&gt;\n            &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;article&quot;&gt;添加文章&lt;&#x2F;el-menu-item&gt;\n            &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;article&quot;&gt;修改文章&lt;&#x2F;el-menu-item&gt;\n          &lt;&#x2F;el-submenu&gt;\n          &lt;el-submenu index&#x3D;&quot;&#x2F;admin&#x2F;article&quot;&gt;\n            &lt;template #title&gt;\n              &lt;i class&#x3D;&quot;el-icon-document&quot;&gt;&lt;&#x2F;i&gt;\n              &lt;span&gt;文章管理&lt;&#x2F;span&gt;\n            &lt;&#x2F;template&gt;\n            &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;article&quot;&gt;添加文章&lt;&#x2F;el-menu-item&gt;\n            &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;article&quot;&gt;修改文章&lt;&#x2F;el-menu-item&gt;\n          &lt;&#x2F;el-submenu&gt;\n          &lt;el-submenu index&#x3D;&quot;&#x2F;admin&#x2F;article&quot;&gt;\n            &lt;template #title&gt;\n              &lt;i class&#x3D;&quot;el-icon-document&quot;&gt;&lt;&#x2F;i&gt;\n              &lt;span&gt;文章管理&lt;&#x2F;span&gt;\n            &lt;&#x2F;template&gt;\n            &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;article&quot;&gt;添加文章&lt;&#x2F;el-menu-item&gt;\n            &lt;el-menu-item index&#x3D;&quot;&#x2F;admin&#x2F;article&quot;&gt;修改文章&lt;&#x2F;el-menu-item&gt;\n          &lt;&#x2F;el-submenu&gt;\n        &lt;&#x2F;el-menu&gt;\n      &lt;&#x2F;el-scrollbar&gt;\n    &lt;&#x2F;el-aside&gt;\n    &lt;el-container&gt;\n      &lt;el-header&gt;\n        &lt;i\n          :class&#x3D;&quot;[&#39;el-icon-s-fold&#39;, isCollapse ? &#39;isCollapse&#39; : &#39;&#39;]&quot;\n          @click&#x3D;&quot;handleCollapse&quot;\n        &gt;&lt;&#x2F;i&gt;\n      &lt;&#x2F;el-header&gt;\n      &lt;el-main&gt;\n        &lt;!-- 显示二级路由 --&gt;\n        &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n      &lt;&#x2F;el-main&gt;\n    &lt;&#x2F;el-container&gt;\n  &lt;&#x2F;el-container&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ZdHome&#39;,\n  data() &#123;\n    return &#123;\n      &#x2F;&#x2F; flase: 展开; true: 折叠\n      isCollapse: false,\n      obj: &#123;\n        width: &#39;200px&#39;,\n      &#125;,\n    &#125;\n  &#125;,\n  methods: &#123;\n    handleCollapse() &#123;\n      this.isCollapse &#x3D; !this.isCollapse\n      if (this.isCollapse) &#123;\n        this.obj.width &#x3D; &#39;64px&#39;\n      &#125; else &#123;\n        this.obj.width &#x3D; &#39;200px&#39;\n      &#125;\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&#x2F;* 如果要设置子组件中的样式. 没有data-v, 就不能放在scoped中写 *&#x2F;\n.el-scrollbar__wrap &#123;\n  overflow-x: hidden;\n&#125;\n&#x2F;* 隐藏水平方向的滑动条 *&#x2F;\n.el-scrollbar__bar.is-horizontal &#123;\n  display: none;\n&#125;\n&lt;&#x2F;style&gt;\n\n&lt;style scoped&gt;\n.home-container &#123;\n  height: 100vh;\n&#125;\n.el-aside &#123;\n  &#x2F;* 跟el-menu的颜色一致 *&#x2F;\n  background-color: #304156;\n  &#x2F;* 用户不能选中效果 *&#x2F;\n  user-select: none;\n&#125;\n.el-header &#123;\n  display: flex;\n  align-items: center;\n  font-size: 24px;\n  color: #333;\n&#125;\n.el-header i &#123;\n  transition: all 0.3s;\n&#125;\n.isCollapse &#123;\n  transform: rotate(-180deg);\n&#125;\n.el-main &#123;\n  background-color: #ccc;\n&#125;\n.el-scrollbar &#123;\n  height: calc(100% - 60px);\n&#125;\n.logo &#123;\n  height: 60px;\n  display: flex;\n  justify-content: space-evenly;\n  align-items: center;\n  font-size: 22px;\n  color: #fff;\n  background-color: #1f2d3d;\n&#125;\n&lt;&#x2F;style&gt;\n\n4 头像\n1) 结构使用el-avatar组件\n&lt;el-header&gt;\n  &lt;i\n    :class&#x3D;&quot;[&#39;el-icon-s-fold&#39;, isCollapse ? &#39;isCollapse&#39; : &#39;&#39;]&quot;\n    @click&#x3D;&quot;isCollapse &#x3D; !isCollapse&quot;\n  &gt;&lt;&#x2F;i&gt;\n  &lt;el-avatar :size&#x3D;&quot;50&quot; src&#x3D;&quot;&#x2F;avatar.png&quot;&gt;&lt;&#x2F;el-avatar&gt;\n&lt;&#x2F;el-header&gt;\n\n2) 样式修改el-header的样式\n.el-header &#123;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n&#125;\n\n3) 上传头像将avatar.png上传到public目录\n5 退出登录\n1) 结构使用el-dropdown组件\n&lt;el-dropdown trigger&#x3D;&quot;click&quot;&gt;\n  &lt;span&gt;\n    &lt;el-avatar :size&#x3D;&quot;40&quot; src&#x3D;&quot;&#x2F;avatar.png&quot;&gt;&lt;&#x2F;el-avatar&gt;\n    &lt;i class&#x3D;&quot;el-icon-caret-bottom&quot;&gt;&lt;&#x2F;i&gt;\n  &lt;&#x2F;span&gt;\n  &lt;template #dropdown&gt;\n    &lt;el-dropdown-menu&gt;\n      &lt;el-dropdown-item&gt;修改密码&lt;&#x2F;el-dropdown-item&gt;\n      &lt;el-dropdown-item divided @click.native.prevent&#x3D;&quot;logout&quot;&gt;\n        退出登录\n      &lt;&#x2F;el-dropdown-item&gt;\n    &lt;&#x2F;el-dropdown-menu&gt;\n  &lt;&#x2F;template&gt;\n&lt;&#x2F;el-dropdown&gt;\n\n2) 样式.el-dropdown i &#123;\n  font-size: 12px;\n  color: #5a5e66;\n&#125;\n\n3) 逻辑\n\n\n\n\n\n\n\n\n思路\n绑定el-menu-item原生点击事件\nmethods: &#123;\n  logout() &#123;\n    &#x2F;&#x2F; 1. 删除localStorage中的item\n    localStorage.removeItem(&#39;isLogin&#39;)\n    &#x2F;&#x2F; 提出退出登录\n    this.$message(&#123;\n      type: &#39;success&#39;,\n      message: &#39;退出成功&#39;,\n      duration: 500,\n    &#125;)\n    &#x2F;&#x2F; 2. 跳转到login页面\n    this.$router.push(&#39;&#x2F;login&#39;)\n  &#125;,\n&#125;,\n\n七.实现User模块\n1 页面分析每一个模块都是由\n\n面包屑\n卡片\n\n\n2 初步框架实现&lt;template&gt;\n  &lt;div&gt;\n    &lt;!-- 面包屑 --&gt;\n    &lt;el-breadcrumb separator-class&#x3D;&quot;el-icon-arrow-right&quot;&gt;\n      &lt;el-breadcrumb-item to&#x3D;&quot;&#x2F;admin&#x2F;dashboard&quot;&gt;首页&lt;&#x2F;el-breadcrumb-item&gt;\n      &lt;el-breadcrumb-item&gt;用户管理&lt;&#x2F;el-breadcrumb-item&gt;\n    &lt;&#x2F;el-breadcrumb&gt;\n    &lt;!-- 卡片 --&gt;\n    &lt;el-card class&#x3D;&quot;user-container&quot;&gt;\n      &lt;!-- 按钮+表格 --&gt;\n    &lt;&#x2F;el-card&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ZdUser&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n.user-container &#123;\n  margin-top: 20px;\n  min-height: 400px;\n&#125;\n&lt;&#x2F;style&gt;\n\n八. 实现用户列表功能\n1 按钮组\n1) template部分&lt;el-row&gt;\n  &lt;el-col :span&#x3D;&quot;10&quot;&gt;\n    &lt;!-- 按钮 --&gt;\n    &lt;el-button\n      type&#x3D;&quot;primary&quot;\n      size&#x3D;&quot;mini&quot;\n      icon&#x3D;&quot;el-icon-circle-plus-outline&quot;\n      &gt;\n      添加\n    &lt;&#x2F;el-button&gt;\n    &lt;el-button type&#x3D;&quot;danger&quot; size&#x3D;&quot;mini&quot; icon&#x3D;&quot;el-icon-delete&quot;&gt;\n      删除选中\n    &lt;&#x2F;el-button&gt;\n  &lt;&#x2F;el-col&gt;\n  &lt;el-col :span&#x3D;&quot;8&quot; :offset&#x3D;&quot;6&quot;&gt;\n    &lt;el-input\n      size&#x3D;&quot;small&quot;\n      placeholder&#x3D;&quot;请输入搜索关键字&quot;\n      prefix-icon&#x3D;&quot;el-icon-search&quot;\n      &gt;&lt;&#x2F;el-input&gt;\n    &lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;mini&quot;&gt;搜索&lt;&#x2F;el-button&gt;\n  &lt;&#x2F;el-col&gt;\n&lt;&#x2F;el-row&gt;\n\n2) style部分&lt;style&gt;\n.user-container &#123;\n  margin-top: 20px;\n  min-width: 600px;\n  height: 400px;\n&#125;\n.el-input &#123;\n  width: 70%;\n  margin-right: 10px;\n&#125;\n&lt;&#x2F;style&gt;\n\n2 表格\n1) 基本结构&lt;el-table&gt;\n  &lt;el-table-column label&#x3D;&quot;id&quot;&gt;&lt;&#x2F;el-table-column&gt;\n  &lt;el-table-column label&#x3D;&quot;用户名&quot;&gt;&lt;&#x2F;el-table-column&gt;\n  &lt;el-table-column label&#x3D;&quot;操作&quot;&gt;&lt;&#x2F;el-table-column&gt;\n&lt;&#x2F;el-table&gt;\n\n2) 数据在el-table绑定data自定义属性, 绑定到一个数组\n&lt;el-table border :data&#x3D;&quot;users&quot;&gt;\n  &lt;el-table-column label&#x3D;&quot;id&quot; prop&#x3D;&quot;id&quot;&gt;&lt;&#x2F;el-table-column&gt;\n  &lt;el-table-column label&#x3D;&quot;用户名&quot; prop&#x3D;&quot;username&quot;&gt;&lt;&#x2F;el-table-column&gt;\n  &lt;el-table-column label&#x3D;&quot;操作&quot;&gt;&lt;&#x2F;el-table-column&gt;\n&lt;&#x2F;el-table&gt;\n&lt;script&gt;\nexport default &#123;\n  name: &#39;User&#39;,\n  data() &#123;\n    return &#123;\n      users: [\n        &#123; id: 1, username: &#39;小明&#39; &#125;,\n        &#123; id: 2, username: &#39;小美&#39; &#125;,\n        &#123; id: 3, username: &#39;小胖&#39; &#125;,\n      ],\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n3) 实现操作按钮&lt;el-table-column label&#x3D;&quot;操作&quot;&gt;\n  &lt;el-button size&#x3D;&quot;mini&quot;&gt;\n    &lt;i class&#x3D;&quot;el-icon-edit&quot;&gt;&lt;&#x2F;i&gt;\n    编辑\n  &lt;&#x2F;el-button&gt;\n  &lt;el-button type&#x3D;&quot;danger&quot; size&#x3D;&quot;mini&quot;&gt;\n    &lt;i class&#x3D;&quot;el-icon-delete&quot;&gt;&lt;&#x2F;i&gt;\n    删除\n  &lt;&#x2F;el-button&gt;\n&lt;&#x2F;el-table-column&gt;\n\n4) 编写后端接口var express &#x3D; require(&#39;express&#39;)\nvar router &#x3D; express.Router()\n\n&#x2F;&#x2F; 导入db, 操作数据库\nconst &#123; getAll, getById, exec &#125; &#x3D; require(&#39;..&#x2F;db&#39;)\n\n&#x2F;**\n * 获取所有用户\n * GET &#x2F;users\n *&#x2F;\nrouter.get(&#39;&#x2F;&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 操作数据库\n  let sql &#x3D; &#96;select id, username from vue_users&#96;\n  const data &#x3D; await getAll(sql)\n  res.send(&#123;\n    code: 0,\n    message: &#39;获取用户成功&#39;,\n    result: data,\n  &#125;)\n&#125;)\n\nmodule.exports &#x3D; router\n\n5) 实现前后端对接\n安装axiosnpm i axios\n\n配置axios创建request/index.js\n&#x2F;&#x2F; 一. 导入axios包\nimport axios from &#39;axios&#39;\n\n&#x2F;&#x2F; 二. 创建axios的对象\nconst instance &#x3D; axios.create(&#123;\n  baseURL: &#39;http:&#x2F;&#x2F;localhost:3000&#39;,\n  timeout: 3000,\n&#125;)\n\n&#x2F;&#x2F; 三. 配置拦截器\n\n&#x2F;&#x2F; 给instance实例配置响应拦截器(统一处理HTTP响应)\ninstance.interceptors.response.use(\n  function (response) &#123;\n    &#x2F;&#x2F; 直接返回 后端的数据\n    return response.data\n  &#125;,\n  function (error) &#123;\n    return Promise.reject(error)\n  &#125;\n)\n\n&#x2F;&#x2F; 四. 导出实例对象\nexport default instance\n\n\n实现vue插件创建plugins/http.js\nimport Vue from &#39;vue&#39;\n\nimport instance from &#39;@&#x2F;request&#39;\n\nconst http &#x3D; &#123;\n  &#x2F;&#x2F; 在Vue的prototype对象上, 挂载$http属性\n  install(Vue) &#123;\n    Vue.prototype.$http &#x3D; instance\n  &#125;,\n&#125;\n\nVue.use(http)\n\n导入插件在main.js中, 加载文件\nimport &#39;.&#x2F;plugins&#x2F;http.js&#39;\n\n\n\n\n\n\n\n\n\n示例\n\n测试在User.vue中, 定义created生命周期函数, 完成data数据的初始化\n&lt;script&gt;\nexport default &#123;\n  name: &#39;User&#39;,\n  data() &#123;\n    return &#123;\n      users: [],\n    &#125;\n  &#125;,\n  created() &#123;\n    this.getUsers()\n  &#125;,\n  methods: &#123;\n    getUsers() &#123;\n      this.$http.get(&#39;&#x2F;users&#39;).then((res) &#x3D;&gt; &#123;\n        console.log(res)\n        this.users &#x3D; res.result\n      &#125;)\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n6) 分页当数据很多时, 一个页面显示不全, 需要使用分页\n分页的需求\n点击第1页链接, 显示第1页的数据\n\n点击第2页链接, 显示第2页的数据\n\n….\n分页的原理# 获取第一页数据\nselect id, username from vue_users limit 0, 3\n# 获取第二页数据\nselect id, username from vue_users limit 3, 3\n# 获取第三页数据\nselect id, username from vue_users limit 6, 3\n分页的公式\n分页offset &#x3D; (当前的页码 - 1) * 每页显示的记录数\n\n接口重新设计GET &#x2F;users?page&#x3D;1&amp;size&#x3D;5\npage: 当前的页码数\n\nsize: 每页显示记录数\n重写后端API&#x2F;**\n * 获取所有用户\n * GET &#x2F;users?page&#x3D;1&amp;size&#x3D;2\n *&#x2F;\nrouter.get(&#39;&#x2F;&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 解析请求参数\n  const &#123; page &#x3D; 1, size &#x3D; 2 &#125; &#x3D; req.query\n\n  &#x2F;&#x2F; 获取总数\n  let sql &#x3D; &#96;select count(*) as total from vue_users&#96;\n  const obj &#x3D; await getById(sql) &#x2F;&#x2F; &#123; total: 10 &#125;\n\n  &#x2F;&#x2F; 根据分页公式, 计算offset偏移量\n  let offset &#x3D; (page - 1) * size\n  &#x2F;&#x2F; 操作数据库\n  sql &#x3D; &#96;select id, username from vue_users limit $&#123;offset&#125;, $&#123;size&#125;&#96;\n  const data &#x3D; await getAll(sql)\n\n  res.send(&#123;\n    code: 0,\n    message: &#39;获取用户成功&#39;,\n    result: &#123;\n      total: obj.total,\n      data: data,\n    &#125;,\n  &#125;)\n&#125;)\n\n前端设置分页器&lt;el-pagination\n  @size-change&#x3D;&quot;handleSizeChange&quot;\n  @current-change&#x3D;&quot;handleCurrentChange&quot;\n  :current-page&#x3D;&quot;page&quot;\n  :page-sizes&#x3D;&quot;[2, 5, 10, 50]&quot;\n  :page-size&#x3D;&quot;size&quot;\n  layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot;\n  :total&#x3D;&quot;total&quot;\n&gt;&lt;&#x2F;el-pagination&gt;\ncurrent-page: 当前页码\n\npage-size: 每页显示的记录数\n\ntotal: 总数\n\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;User&#39;,\n  data() &#123;\n    return &#123;\n      users: [],\n      page: 1, &#x2F;&#x2F; 当前的页码数\n      size: 2, &#x2F;&#x2F; 每页显示记录数\n      total: 0, &#x2F;&#x2F; 记录总数\n    &#125;\n  &#125;,\n  created() &#123;\n    this.getUsers()\n  &#125;,\n  methods: &#123;\n    getUsers() &#123;\n      &#x2F;&#x2F; GET &#x2F;users?page&#x3D;1&amp;size&#x3D;2\n      this.$http\n        .get(&#39;&#x2F;users&#39;, &#123;\n          params: &#123; page: this.page, size: this.size &#125;,\n        &#125;)\n        .then((res) &#x3D;&gt; &#123;\n          console.log(res)\n          &#x2F;&#x2F; 1. 更新total\n          this.total &#x3D; res.result.total\n          &#x2F;&#x2F; 2. 更新users数组\n          this.users &#x3D; res.result.data\n        &#125;)\n    &#125;,\n    handleSizeChange(val) &#123;\n      &#x2F;&#x2F; 改变每页显示记录数\n      this.size &#x3D; val\n      this.getUsers()\n    &#125;,\n    handleCurrentChange(val) &#123;\n      this.page &#x3D; val\n      this.getUsers()\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n\n九.实现用户添加功能关于添加功能, 有两种方案\n\n点击添加, 弹出一个对话框\n点击添加, 转到一个新页面(组件)\n\n\n\n\n\n\n\n\n\n\n区别\n当添加页面比较简单时, 推荐使用对话框方案当添加页面比较复杂时, 推荐使用新页面方案\n:::danger由于用户添加页面比较简单, 我们不用新页面的方案. 这里只是演示:::\n创建新页面的流程\n设计入口: 当点击添加按钮时, 触发页面跳转\n\n规则路由规则: 对应的路由规则user/add\n\n创建页面组件\n\n编写页面组件\n1) 设计入口给添加按钮, 绑定click方法\n&lt;el-button\n           type&#x3D;&quot;primary&quot;\n           size&#x3D;&quot;mini&quot;\n           icon&#x3D;&quot;el-icon-circle-plus-outline&quot;\n           @click&#x3D;&quot;handleAdd&quot;\n           &gt;\n  添加\n&lt;&#x2F;el-button&gt;\nhandleAdd() &#123;\n  &#x2F;&#x2F; 跳转页面\n  this.$router.push(&#39;&#x2F;user&#x2F;add&#39;)\n&#125;,\n\n2) 规划路由规则编写router/index.js\n&#123;\n  path: &#39;&#x2F;&#39;,\n    redirect: &#39;&#x2F;dashboard&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#39;),\n        children: [\n          &#123; path: &#39;&#x2F;dashboard&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#x2F;Dashboard&#39;) &#125;,\n          &#123; path: &#39;&#x2F;user&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#x2F;User&#39;) &#125;,\n          &#123; path: &#39;&#x2F;user&#x2F;add&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#x2F;User&#x2F;Add&#39;) &#125;,\n          &#123; path: &#39;&#x2F;category&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#x2F;Category&#39;) &#125;,\n          &#123; path: &#39;&#x2F;article&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#x2F;Article&#39;) &#125;,\n        ],\n&#125;,\n\n3) 创建页面组件将User改造成文件夹. 在User文件夹下, 创建Add.vue文件\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;!-- 面包屑导航 --&gt;\n    &lt;el-breadcrumb&gt;\n      &lt;el-breadcrumb-item to&#x3D;&quot;&#x2F;&quot;&gt;首页&lt;&#x2F;el-breadcrumb-item&gt;\n      &lt;el-breadcrumb-item to&#x3D;&quot;&#x2F;user&quot;&gt;用户管理&lt;&#x2F;el-breadcrumb-item&gt;\n      &lt;el-breadcrumb-item&gt;添加用户&lt;&#x2F;el-breadcrumb-item&gt;\n    &lt;&#x2F;el-breadcrumb&gt;\n\n    &lt;el-button @click&#x3D;&quot;$router.back()&quot;&gt;返回&lt;&#x2F;el-button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;UserAdd&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n1 显示隐藏对话框&lt;!-- 对话框 --&gt;\n&lt;el-dialog\n           title&#x3D;&quot;添加用户&quot;\n           :visible.sync&#x3D;&quot;dialogVisible&quot;\n           width&#x3D;&quot;40%&quot;\n&gt;&lt;&#x2F;el-dialog&gt;\nhandleAdd() &#123;\n  &#x2F;&#x2F; 显示对话框\n  this.dialogVisible &#x3D; true\n&#125;,\n\n2 实现form表单步骤\n\n实现表单项\n\n用户名输入框\n确定, 取消按钮\n\n\n实现数据绑定\n\n实现表单规则的校验\n1) 实现表单项&lt;el-form label-width&#x3D;&quot;80px&quot;&gt;\n  &lt;el-form-item label&#x3D;&quot;用户名&quot;&gt;\n    &lt;el-input placeholder&#x3D;&quot;请输入用户名&quot;&gt;&lt;&#x2F;el-input&gt;\n  &lt;&#x2F;el-form-item&gt;\n  &lt;el-form-item label&#x3D;&quot;密码&quot;&gt;\n    &lt;el-input placeholder&#x3D;&quot;请输入密码&quot; show-password&gt;&lt;&#x2F;el-input&gt;\n  &lt;&#x2F;el-form-item&gt;\n  &lt;el-form-item&gt;\n    &lt;el-button type&#x3D;&quot;primary&quot;&gt;提交&lt;&#x2F;el-button&gt;\n    &lt;el-button&gt;取消&lt;&#x2F;el-button&gt;\n  &lt;&#x2F;el-form-item&gt;\n&lt;&#x2F;el-form&gt;\n\n2) 实现数据绑定\n给el-form组件, 添加自定义属性model\n\n给el-form-item组件, 添加v-model绑定\n&lt;el-form :model&#x3D;&quot;userForm&quot; &gt;\n  &lt;el-form-item label&#x3D;&quot;用户名&quot; &gt;\n    &lt;el-input\n              v-model&#x3D;&quot;userForm.username&quot;\n              placeholder&#x3D;&quot;请输入用户名&quot;\n              &gt;&lt;&#x2F;el-input&gt;\n  &lt;&#x2F;el-form-item&gt;\n  &lt;el-form-item&gt;\n    &lt;el-button type&#x3D;&quot;primary&quot;&gt;提交&lt;&#x2F;el-button&gt;\n    &lt;el-button&gt;取消&lt;&#x2F;el-button&gt;\n  &lt;&#x2F;el-form-item&gt;\n&lt;&#x2F;el-form&gt;\ndata() &#123;\n  return &#123;\n    users: [],\n    page: 1, &#x2F;&#x2F; 当前的页码数\n    size: 2, &#x2F;&#x2F; 每页显示记录数\n    total: 0, &#x2F;&#x2F; 记录总数\n    dialogVisible: false,\n    userForm: &#123;\n      username: &#39;&#39;,\n    &#125;,\n  &#125;\n&#125;\n\n3) 实现表单规则的校验\n给el-form组件, 绑定rules属性\n\n给el-form-item组件, 绑定prop属性\n&lt;el-form :model&#x3D;&quot;userForm&quot; :rules&#x3D;&quot;userRules&quot;&gt;\n  &lt;el-form-item label&#x3D;&quot;用户名&quot; prop&#x3D;&quot;username&quot;&gt;\n    &lt;el-input\n              v-model&#x3D;&quot;userForm.username&quot;\n              placeholder&#x3D;&quot;请输入用户名&quot;\n              &gt;&lt;&#x2F;el-input&gt;\n  &lt;&#x2F;el-form-item&gt;\n  &lt;el-form-item&gt;\n    &lt;el-button type&#x3D;&quot;primary&quot;&gt;提交&lt;&#x2F;el-button&gt;\n    &lt;el-button&gt;取消&lt;&#x2F;el-button&gt;\n  &lt;&#x2F;el-form-item&gt;\n&lt;&#x2F;el-form&gt;\ndata() &#123;\n    return &#123;\n      users: [],\n      page: 1, &#x2F;&#x2F; 当前的页码数\n      size: 2, &#x2F;&#x2F; 每页显示记录数\n      total: 0, &#x2F;&#x2F; 记录总数\n      dialogVisible: false,\n      userForm: &#123;\n        username: &#39;&#39;,\n      &#125;,\n      userRules: &#123;\n        username: [\n          &#123; required: true, message: &#39;用户名不能为空&#39;, trigger: &#39;blur&#39; &#125;,\n        ],\n      &#125;,\n    &#125;\n  &#125;,\n\n4) 实现表单校验\n给el-form添加ref属性, 进而可以通过ref属性, 获取到该组件对象\n\n给提交按钮, 绑定onSubmit方法\n&lt;el-form ref&#x3D;&quot;userForm&quot; :model&#x3D;&quot;userForm&quot; :rules&#x3D;&quot;userRules&quot;&gt;\n  &lt;el-form-item label&#x3D;&quot;用户名&quot; prop&#x3D;&quot;username&quot;&gt;\n    &lt;el-input\n      v-model&#x3D;&quot;userForm.username&quot;\n      placeholder&#x3D;&quot;请输入用户名&quot;\n      &gt;&lt;&#x2F;el-input&gt;\n  &lt;&#x2F;el-form-item&gt;\n  &lt;el-form-item&gt;\n    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;onSubmit&quot;&gt;提交&lt;&#x2F;el-button&gt;\n    &lt;el-button&gt;取消&lt;&#x2F;el-button&gt;\n  &lt;&#x2F;el-form-item&gt;\n&lt;&#x2F;el-form&gt;\nonSubmit() &#123;\n  &#x2F;&#x2F; 通过ref获取组件对象\n  this.$refs[&#39;userForm&#39;].validate((valid) &#x3D;&gt; &#123;\n    if (valid) &#123;\n      &#x2F;&#x2F; 表单验证通过\n\n      &#x2F;&#x2F; 发送ajax请求\n      this.$http.post(&#39;&#x2F;users&#39;, this.userForm).then((res) &#x3D;&gt; &#123;\n        console.log(res)\n      &#125;)\n    &#125;\n  &#125;)\n&#125;,\n\n5) 实现后端接口&#x2F;**\n * 添加用户\n * POST &#x2F;users &#123;username: &#39;test&#39;&#125;\n *&#x2F;\nrouter.post(&#39;&#x2F;&#39;, async (req, res) &#x3D;&gt; &#123;\n  const &#123; username &#125; &#x3D; req.body\n  let sql &#x3D; &#96;insert into vue_users (username) values (&#39;$&#123;username&#125;&#39;)&#96;\n  const data &#x3D; await exec(sql)\n  res.send(&#123;\n    code: 0,\n    message: &#39;添加用户成功&#39;,\n    resutl: &#123;\n      id: data.insertId,\n      username,\n    &#125;,\n  &#125;)\n&#125;)\n\n6) 前端处理回调onSubmit() &#123;\n  &#x2F;&#x2F; 通过ref获取组件对象\n  this.$refs[&#39;userForm&#39;].validate((valid) &#x3D;&gt; &#123;\n    if (valid) &#123;\n      &#x2F;&#x2F; 表单验证通过\n\n      &#x2F;&#x2F; 发送ajax请求\n      this.$http.post(&#39;&#x2F;users&#39;, this.userForm).then((res) &#x3D;&gt; &#123;\n        console.log(res)\n        &#x2F;&#x2F; 1. 关闭对话框\n        this.dialogVisible &#x3D; false\n        &#x2F;&#x2F; 2. 重新获取数据\n        this.getUsers()\n\n        &#x2F;&#x2F; 3. 清空表单\n        this.$refs[&#39;userForm&#39;].resetFields()\n      &#125;)\n    &#125;\n  &#125;)\n&#125;,\n\n7) 优化我们希望新添加的数据, 显示在前面\n\n\n\n\n\n\n\n\n\n方案\n\n\n在查询数据时, 根据id倒排序\n在实现后端接口时, 改写SQL语句\nsql &#x3D; &#96;select id, username from vue_users order by id desc limit $&#123;offset&#125;, $&#123;size&#125;&#96;\n\n十. 实现用户修改功能我们发现, 修改功能的对话框和添加对话框是一样的\n\n\n\n\n\n\n\n\n\n复用对话框\n\n定义一个状态, 标识当前是修改状态还是添加状态\n回显数据1 显示隐藏对话框1) 绑定事件给编辑按钮绑定click事件&lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;mini&quot; @click&#x3D;&quot;handleEdit&quot;&gt;\n  &lt;i class&#x3D;&quot;el-icon-edit&quot;&gt;&lt;&#x2F;i&gt;\n  编辑\n&lt;&#x2F;el-button&gt;\nhandleEdit() &#123;\n  &#x2F;&#x2F; 显示对话框\n  this.dialogVisible &#x3D; true\n&#125;,\n2) 定义状态在data中定义一个状态isEdit\n\n\ntrue: 当前是修改状态\nfalse: 当前是添加状态\n\n当点击添加, 编辑按钮时, 同步更新isEdit状态\nhandleAdd() &#123;\n  &#x2F;&#x2F; 跳转页面\n  &#x2F;&#x2F; this.$router.push(&#39;&#x2F;user&#x2F;add&#39;)\n  &#x2F;&#x2F; 更新isEdit状态, 将状态改为false\n  this.isEdit &#x3D; false\n  &#x2F;&#x2F; 显示对话框\n  this.dialogVisible &#x3D; true\n&#125;\n  \nhandleEdit() &#123;\n  &#x2F;&#x2F; 更新isEdit状态\n  this.isEdit &#x3D; true\n  &#x2F;&#x2F; 显示对话框\n  this.dialogVisible &#x3D; true\n&#125;\n在对话框的标题处, 根据isEdit状态, 动态显示添加用户或者修改用户\n&lt;el-dialog\n  :title&#x3D;&quot;isEdit ? &#39;修改用户&#39; : &#39;添加用户&#39;&quot;\n  :visible.sync&#x3D;&quot;dialogVisible&quot;\n  width&#x3D;&quot;40%&quot;\n&gt;\n\n2 回显数据\n1) 使用作用域插槽将编辑, 删除 两个按钮放入到作用域插槽中, 进而可以在父组件的模板中获取table表格的数据\n&lt;template v-slot&#x3D;&quot;users&quot;&gt;\n  &lt;el-button\n             type&#x3D;&quot;primary&quot;\n             size&#x3D;&quot;mini&quot;\n             @click&#x3D;&quot;handleEdit(users.row.id)&quot;\n             &gt;\n    &lt;i class&#x3D;&quot;el-icon-edit&quot;&gt;&lt;&#x2F;i&gt;\n    编辑\n  &lt;&#x2F;el-button&gt;\n  &lt;el-button type&#x3D;&quot;danger&quot; size&#x3D;&quot;mini&quot;&gt;\n    &lt;i class&#x3D;&quot;el-icon-delete&quot;&gt;&lt;&#x2F;i&gt;\n    删除\n  &lt;&#x2F;el-button&gt;\n&lt;&#x2F;template&gt;\n\n2) 改造修改处理函数通过形参接收到id值\nhandleEdit(id) &#123;\n  &#x2F;&#x2F; 更新isEdit状态\n  this.isEdit &#x3D; true\n  &#x2F;&#x2F; 显示对话框\n  this.dialogVisible &#x3D; true\n  console.log(id)\n&#125;,\n\n3) 调用接口, 获取数据handleEdit(id) &#123;\n  &#x2F;&#x2F; 更新isEdit状态\n  this.isEdit &#x3D; true\n  &#x2F;&#x2F; 显示对话框\n  this.dialogVisible &#x3D; true\n  console.log(id)\n  &#x2F;&#x2F; 调用接口, 获取数据\n  this.$http.get(&#96;&#x2F;users&#x2F;$&#123;id&#125;&#96;).then((res) &#x3D;&gt; &#123;\n    console.log(res)\n\n    &#x2F;&#x2F; 根据返回的数据, 更新form状态\n    this.userForm &#x3D; res.result\n  &#125;)\n&#125;,\n\n4) 实现后端接口&#x2F;**\n * 根据id获取单个用户数据\n * GET &#x2F;users&#x2F;:id\n *&#x2F;\nrouter.get(&#39;&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  const &#123; id &#125; &#x3D; req.params\n\n  let sql &#x3D; &#96;select id, username from vue_users where id&#x3D;$&#123;id&#125;&#96;\n  const data &#x3D; await getById(sql)\n\n  res.send(&#123;\n    code: 0,\n    message: &#39;获取用户成功&#39;,\n    result: data,\n  &#125;)\n&#125;)\n\n3 修改新数据\n1) 判断状态在onSubmit函数中, 判断当前的状态\n\nisEdit: true, 发送PUT请求\nisEdit: false, 发送POST请求onSubmit() &#123;\n  &#x2F;&#x2F; 通过ref获取组件对象\n  this.$refs[&#39;userForm&#39;].validate((valid) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 表单验证通过\n    if (valid) &#123;\n      if (this.isEdit) &#123;\n        &#x2F;&#x2F; isEdit&#x3D;&#x3D;true: 修改状态\n        &#x2F;&#x2F; 发送 PUT 请求\n        this.$http\n          .put(&#39;&#x2F;users&#x2F;&#39; + this.userForm.id, this.userForm)\n          .then((res) &#x3D;&gt; &#123;\n          const &#123; code, message &#125; &#x3D; res\n\n          if (code !&#x3D; 0) &#123;\n            &#x2F;&#x2F; 提示\n            this.$message.error(message)\n            return\n          &#125;\n\n          this.$message(&#123;\n            type: &#39;success&#39;,\n            message: message,\n            showClose: true,\n            duration: 1000,\n          &#125;)\n          &#x2F;&#x2F; 1. 关闭对话框\n          this.dialogVisible &#x3D; false\n          &#x2F;&#x2F; 2. 重新获取数据\n          this.getUsers()\n\n          &#x2F;&#x2F; 3. 清空表单\n          this.$refs[&#39;userForm&#39;].resetFields()\n        &#125;)\n      &#125; else &#123;\n        &#x2F;&#x2F; isEdit&#x3D;&#x3D;false: 添加状态\n        &#x2F;&#x2F; 发送 POST 请求\n        &#x2F;&#x2F; 发送ajax请求\n        this.$http.post(&#39;&#x2F;users&#39;, this.userForm).then((res) &#x3D;&gt; &#123;\n          console.log(res)\n          &#x2F;&#x2F; 1. 关闭对话框\n          this.dialogVisible &#x3D; false\n          &#x2F;&#x2F; 2. 重新获取数据\n          this.getUsers()\n\n          &#x2F;&#x2F; 3. 清空表单\n          this.$refs[&#39;userForm&#39;].resetFields()\n        &#125;)\n      &#125;\n    &#125;\n  &#125;)\n&#125;,\n2) 实现修改接口&#x2F;**\n * 修改用户\n * PUT &#x2F;users&#x2F;:id &#123;username: &#39;test-new&#39;&#125;\n *&#x2F;\nrouter.put(&#39;&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  const &#123; id &#125; &#x3D; req.params\n  const &#123; username &#125; &#x3D; req.body\n\n  let sql &#x3D; &#96;update vue_users set username&#x3D;&#39;$&#123;username&#125;&#39; where id&#x3D;$&#123;id&#125;&#96;\n\n  await exec(sql)\n\n  res.send(&#123;\n    code: 0,\n    message: &#39;修改用户成功&#39;,\n    result: &#123;\n      id,\n      username,\n    &#125;,\n  &#125;)\n&#125;)\n3) 优化整理代码的逻辑, 封装函数\nonSubmit() &#123;\n  &#x2F;&#x2F; 通过ref获取组件对象\n  this.$refs[&#39;userForm&#39;].validate((valid) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 表单验证通过\n    if (valid) &#123;\n      if (this.isEdit) &#123;\n        &#x2F;&#x2F; isEdit&#x3D;&#x3D;true: 修改状态\n        &#x2F;&#x2F; 发送 PUT 请求\n        this.editUser()\n      &#125; else &#123;\n        &#x2F;&#x2F; isEdit&#x3D;&#x3D;false: 添加状态\n        &#x2F;&#x2F; 发送 POST 请求\n        &#x2F;&#x2F; 发送ajax请求\n        this.addUser()\n      &#125;\n    &#125;\n  &#125;)\n&#125;\nasync editUser() &#123;\n  const &#123; code, message &#125; &#x3D; await this.$http.put(\n    &#39;&#x2F;users&#x2F;&#39; + this.userForm.id,\n    this.userForm\n  )\n\n  if (code !&#x3D; 0) &#123;\n    &#x2F;&#x2F; 提示\n    this.$message.error(message)\n    return\n  &#125;\n\n  this.$message(&#123;\n    type: &#39;success&#39;,\n    message: message,\n    showClose: true,\n    duration: 1000,\n  &#125;)\n  &#x2F;&#x2F; 1. 关闭对话框\n  this.dialogVisible &#x3D; false\n  &#x2F;&#x2F; 2. 重新获取数据\n  this.getUsers()\n\n  &#x2F;&#x2F; 3. 清空表单\n  this.$refs[&#39;userForm&#39;].resetFields()\n&#125;\nasync addUser() &#123;\n  const res &#x3D; await this.$http.post(&#39;&#x2F;users&#39;, this.userForm)\n\n  console.log(res)\n  &#x2F;&#x2F; 1. 关闭对话框\n  this.dialogVisible &#x3D; false\n  &#x2F;&#x2F; 2. 重新获取数据\n  this.getUsers()\n\n  &#x2F;&#x2F; 3. 清空表单\n  this.$refs[&#39;userForm&#39;].resetFields()\n&#125;\n\n","slug":"九. 通用后台管理项目_new","date":"2022-12-02T13:44:02.935Z","categories_index":"Vue","tags_index":"Vue2进阶","author_index":"团子"},{"id":"2ac0d39c07c7b83bdc6c8545bb9493ab","title":"八. Vue-router的应用","content":"\n一. 需求分析\n1 原型图从上述的原型图, 我们可以将路由分为二级\n\n/login: 登录页面\n/: 后台的首页\n/user: 显示用户管理的页面\n/article: 显示文章管理的页面\n\n\n\n\n二. 搭建环境\n1 创建工程执行命令\nvue create admin-demo\n\n\n\n\n2 清理文件\n1) 清理App.vue文件&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n2) 删除旧的组件删除views目录和components目录下的文件\n3) 清理路由文件修改router/index.js\nimport Vue from &#39;vue&#39;\nimport VueRouter from &#39;vue-router&#39;\n\nVue.use(VueRouter)\n\nconst routes &#x3D; []\n\nconst router &#x3D; new VueRouter(&#123;\n  mode: &#39;history&#39;,\n  base: process.env.BASE_URL,\n  routes,\n&#125;)\n\nexport default router\n\n三. 规划路由\n1 规划login路由\n1) 编写路由规则在router/index.js文件中, 定义路由规则/login -&gt; Login.vue\nconst routes &#x3D; [\n  &#x2F;&#x2F; 写一级路由\n  &#123; path: &#39;&#x2F;login&#39;, component: Login &#125;,\n]\n也可以使用路由懒加载\n&#x2F;&#x2F; 使用路由懒加载\n&#123; path: &#39;&#x2F;login&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Login.vue&#39;) &#125;,\n\n2) 创建组件文件在views目录下, 创建Login.vue\n&lt;template&gt;\n  &lt;div&gt;登录页面&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Login&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n2 规划/路由\n1) 编写路由规则const routes &#x3D; [\n  &#x2F;&#x2F; 写一级路由\n  &#x2F;&#x2F; 使用路由懒加载\n  &#123; path: &#39;&#x2F;login&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Login&#39;) &#125;,\n  &#123; path: &#39;&#x2F;&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#39;) &#125;,\n]\n推荐不写后缀名.vue\n\n\n\n\n\n\n\n\n\n原因\n在规划路由时, 不确定该组件下是否有子组件如果存在子组件, 那么我们通常创建文件夹与之对应\n2) 创建组件文件在views目录下, 创建Home目录, 对应Home组件因为存在子组件, 所以我们用文件夹表示\n&lt;template&gt;\n  &lt;div&gt;首页&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Home&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n3 设置一级路由出口在App.vue中, 设置路由出口\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;!-- 一级路由的出口 --&gt;\n    &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n\n4 规划user路由\n1) 编写路由规则&#123;\n  path: &#39;&#x2F;&#39;,\n  component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#39;),\n  children: [\n    &#123; path: &#39;user&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#x2F;User&#39;) &#125;,\n  ],\n&#125;,\n\n2) 创建组件文件在views/Home/User.vue文件\n&lt;template&gt;\n  &lt;div&gt;用户页面&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;User&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n5 规划article路由\n1) 编写路由规则&#123;\n  path: &#39;&#x2F;&#39;,\n  component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#39;),\n  children: [\n    &#123; path: &#39;user&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#x2F;User&#39;) &#125;,\n    &#123; path: &#39;article&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#x2F;Article&#39;) &#125;,\n  ],\n&#125;,\n\n2) 创建组件文件创建views/Home/Article.vue文件\n&lt;template&gt;\n  &lt;div&gt;文章页面&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Article&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n6 设置二级路由出口在父组件Home/index.vue中设置出口\n&lt;template&gt;\n  &lt;div&gt;\n    首页 --\n    &lt;!-- 设置二级路由的出口 --&gt;\n    &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Home&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n四. 优化\n1 设置默认路由当访问一个不匹配的路由规则时, 统一显示404\n1) 修改路由规则&#123; path: &#39;*&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;404&#39;) &#125;,\n\n\n\n\n\n\n\n\n\n示例\n\n2) 创建组件文件创建views\\404.vue\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;bg&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;style&gt;\n.bg &#123;\n  height: 100vh;\n  background-image: url(&#39;~@&#x2F;assets&#x2F;404.jpg&#39;);\n  background-repeat: no-repeat;\n  background-size: cover;\n&#125;\n&lt;&#x2F;style&gt;\n找一张404的图片, 放到assets目录下\n2 设置默认重定向目的: 当访问后台首页时, 默认显示某一种信息(通常, 指定一个二级路由)\n&#123;\n    path: &#39;&#x2F;&#39;,\n    redirect: &#39;&#x2F;user&#39;,\n    component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#39;),\n    children: [\n      &#123; path: &#39;user&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#x2F;User&#39;) &#125;,\n      &#123; path: &#39;article&#39;, component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home&#x2F;Article&#39;) &#125;,\n    ],\n  &#125;,\n\n五. 实现界面\n1 实现login界面&lt;template&gt;\n  &lt;div class&#x3D;&quot;login-container&quot;&gt;\n    用户名:\n    &lt;input type&#x3D;&quot;text&quot; &#x2F;&gt;\n    &lt;br &#x2F;&gt;\n    密码:\n    &lt;input type&#x3D;&quot;text&quot; &#x2F;&gt;\n    &lt;br &#x2F;&gt;\n    &lt;button&gt;登录&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Login&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.login-container &#123;\n  width: 400px;\n  height: 200px;\n  margin: 100px auto;\n  border: 1px solid;\n  border-radius: 5px;\n&#125;\n&lt;&#x2F;style&gt;\n编写逻辑\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;login-container&quot;&gt;\n    用户名:\n    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;username&quot; &#x2F;&gt;\n    &lt;br &#x2F;&gt;\n    密码:\n    &lt;input type&#x3D;&quot;password&quot; v-model&#x3D;&quot;password&quot; &#x2F;&gt;\n    &lt;br &#x2F;&gt;\n    &lt;button @click&#x3D;&quot;login&quot;&gt;登录&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Login&#39;,\n  data() &#123;\n    return &#123;\n      username: &#39;&#39;,\n      password: &#39;&#39;,\n    &#125;\n  &#125;,\n  methods: &#123;\n    login() &#123;\n      if (this.username &#x3D;&#x3D; &#39;admin&#39; &amp;&amp; this.password &#x3D;&#x3D; &#39;123456&#39;) &#123;\n        &#x2F;&#x2F; 登录成功\n        &#x2F;&#x2F; 跳转到&#x2F;home页面\n        &#x2F;&#x2F; 导航的两种方式\n        &#x2F;&#x2F; 1. 声明式导航: &lt;router-link&gt;标签 to属性指定path路径\n        &#x2F;&#x2F; 2. 编程式导航: router.push()方法指定path路径\n        this.$router.push(&#39;&#x2F;home&#39;)\n      &#125; else &#123;\n        alert(&#39;用户名或者密码错误&#39;)\n      &#125;\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.login-container &#123;\n  width: 400px;\n  height: 200px;\n  margin: 100px auto;\n  border: 1px solid;\n  border-radius: 5px;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n当用户名是admin, 密码是123456, 表示登录成功\n通过编程式的导航进行页面跳转(组件的切换)2 实现home布局&lt;template&gt;\n  &lt;div class&#x3D;&quot;admin-container&quot;&gt;\n    &lt;aside&gt;\n      &lt;ul&gt;\n        &lt;li&gt;文章&lt;&#x2F;li&gt;\n        &lt;li&gt;用户&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;aside&gt;\n    &lt;main&gt;\n      &lt;header&gt;&lt;&#x2F;header&gt;\n      &lt;!-- 设置二级路由的出口 --&gt;\n      &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n    &lt;&#x2F;main&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Home&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.admin-container &#123;\n  display: flex;\n  &#x2F;* viewport height *&#x2F;\n  height: 100vh;\n&#125;\n.admin-container aside &#123;\n  width: 180px;\n  background-color: pink;\n&#125;\n.admin-container main &#123;\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n&#125;\n.admin-container main header &#123;\n  height: 40px;\n  background-color: lightgreen;\n&#125;\n&lt;&#x2F;style&gt;\n六. 实现菜单点击切换功能使用router-link渲染li元素, 使其具体点击切换功能&lt;template&gt;\n  &lt;div class&#x3D;&quot;admin-container&quot;&gt;\n    &lt;aside&gt;\n      &lt;ul&gt;\n        &lt;router-link to&#x3D;&quot;&#x2F;user&quot; tag&#x3D;&quot;li&quot;&gt;用户管理&lt;&#x2F;router-link&gt;\n        &lt;router-link to&#x3D;&quot;&#x2F;article&quot; tag&#x3D;&quot;li&quot;&gt;文章管理&lt;&#x2F;router-link&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;aside&gt;\n    &lt;main&gt;\n      &lt;header&gt;&lt;&#x2F;header&gt;\n      &lt;!-- 设置二级路由的出口 --&gt;\n      &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n    &lt;&#x2F;main&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n七. 导航守卫1 作用\n\n\n校验权限\n守护组件2 使用在router/index.js中, 设置全局前置导航守卫&#x2F;&#x2F; 设置导航守卫: 全局前置导航守卫\n&#x2F;&#x2F; 在每一次访问url时, 都执行回调函数\nrouter.beforeEach((to, from, next) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; to: 到哪个path去\n  &#x2F;&#x2F; from: 从哪个path来\n  &#x2F;&#x2F; next(): 是否可以通行\n  const isLogin &#x3D; false\n\n  if (isLogin &#x3D;&#x3D; true) &#123;\n    &#x2F;&#x2F; 已登录\n    if (to.path &#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;\n      &#x2F;&#x2F; 不需要再次登录, 跳转到&#x2F;路由\n      next(&#123; path: &#39;&#x2F;&#39; &#125;)\n    &#125; else &#123;\n      &#x2F;&#x2F; 直接放行\n      next()\n    &#125;\n  &#125; else &#123;\n    &#x2F;&#x2F; 未登录\n    if (to.path !&#x3D; &#39;&#x2F;login&#39;) &#123;\n      alert(&#39;请先登录&#39;)\n      next(&#39;&#x2F;login&#39;)\n    &#125; else &#123;\n      next()\n    &#125;\n  &#125;\n&#125;)\n3 集成登录功能1) 改造login.vue实现登录逻辑&lt;template&gt;\n  &lt;div class&#x3D;&quot;login-container&quot;&gt;\n    用户名:\n    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;username&quot; &#x2F;&gt;\n    &lt;br &#x2F;&gt;\n    密码:\n    &lt;input type&#x3D;&quot;password&quot; v-model&#x3D;&quot;password&quot; &#x2F;&gt;\n    &lt;br &#x2F;&gt;\n    &lt;button @click&#x3D;&quot;handleClick&quot;&gt;登录&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Login&#39;,\n  data() &#123;\n    return &#123;\n      username: &#39;&#39;,\n      password: &#39;&#39;,\n    &#125;\n  &#125;,\n  methods: &#123;\n    handleClick() &#123;\n      &#x2F;&#x2F; admin 123456\n      if (this.username &#x3D;&#x3D; &#39;admin&#39; &amp;&amp; this.password &#x3D;&#x3D; &#39;123456&#39;) &#123;\n        &#x2F;&#x2F; 登录成功, 记录状态\n        localStorage.setItem(&#39;isLogin&#39;, 1)\n        alert(&#39;登录成功&#39;)\n        &#x2F;&#x2F; 跳转后台首页, 编程式导航\n        this.$router.push(&#39;&#x2F;&#39;)\n      &#125; else &#123;\n        alert(&#39;用户名或密码错误&#39;)\n        localStorage.setItem(&#39;isLogin&#39;, 0)\n      &#125;\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.login-container &#123;\n  width: 400px;\n  height: 200px;\n  margin: 100px auto;\n  border: 1px solid;\n  border-radius: 5px;\n&#125;\n&lt;&#x2F;style&gt;\n2) 改造导航守卫router.beforeEach((to, from, next) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; to: 到哪个path去\n  &#x2F;&#x2F; from: 从哪个path来\n  &#x2F;&#x2F; next(): 是否可以通行\n  let isLogin &#x3D; localStorage.getItem(&#39;isLogin&#39;) &#x3D;&#x3D;&#x3D; &#39;1&#39; ? true : false\n\n  if (isLogin &#x3D;&#x3D; true) &#123;\n    &#x2F;&#x2F; 已登录\n    if (to.path &#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;\n      &#x2F;&#x2F; 不需要再次登录, 跳转到&#x2F;路由\n      next(&#123; path: &#39;&#x2F;&#39; &#125;)\n    &#125; else &#123;\n      &#x2F;&#x2F; 直接放行\n      next()\n    &#125;\n  &#125; else &#123;\n    &#x2F;&#x2F; 未登录, 只能访问&#x2F;login\n    if (to.path !&#x3D; &#39;&#x2F;login&#39;) &#123;\n      alert(&#39;请先登录&#39;)\n      next(&#39;&#x2F;login&#39;)\n    &#125; else &#123;\n      next()\n    &#125;\n  &#125;\n&#125;)\n\n","slug":"八. Vue-router的应用_new","date":"2022-12-02T13:31:51.803Z","categories_index":"Vue","tags_index":"Vue2进阶","author_index":"团子"},{"id":"cecc2c1206bbeda1f590b8d01d982e2c","title":"七. Vue-router","content":"\n一. 简介\n1 什么是Vue-router\n\n\n\n\n\n\n\n\n是一个vue官方出品的管理组件切换的插件\n\n管理组件切换\n是一个插件2 为什么需要Vue-router1) SPA应用首先, 我们要了解SPA的概念\n\n\n\n\n\n\n\n\nSPA(Single Page Application)单页应用\n\n\n所有的内容都在同一个页面中渲染\n2) SPA存在的问题如何在一个页面中显示不同的内容呢?技术方案: 使用锚链接\n\n\n\n\n\n\n\n\n\n举例\n我们看小说时, 都是在同一个页面, 借助锚链接实现同一页面的不同部分的跳转\n第一章: http://localhost:5500/index.html#chap1第二章: http://localhost:5500/index.html#chap2像#chap1, #chap2…这样的锚链接, 也叫做hash路由 也称为前端路由\n3) 区分路由\n前端路由: 在同一个html页面, 显示不同的内容(组件). 进而建立了URL和组件之间的对应关系\n后端路由: 提供接口(数据)服务, 将不同请求方式+url, 映射到处理函数. 建立了URL和处理函数之间的对应关系\n\n\n二. 入门案例\n\n\n\n\n\n\n\n\n思路\n\n完成vue.js的三步曲\n引入vue.js\n创建页面容器\n实例vue实例\n\n\n使用vue-router管理路由\n引入vue-router.js\n定义组件对象\n定义路由规则\n创建路由对象\n挂载到根实例\n\n\n改造HTML\n编写路由链接router-link\n编写路由出口router-view1 完成vue.js的三步曲&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue.js 和 vue-router.js --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue@2&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 编写页面容器 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;!-- 3. 实例化对象 --&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2 使用vue-router管理路由&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue.js 和 vue-router.js --&gt;\n    &lt;!-- vue@2 对应 vue-router@3版本对应 --&gt;\n    &lt;!-- vue@3 对应 vue-router@4版本对应 --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue@2&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue-router@3&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 编写页面容器 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;!-- 3. 实例化对象 --&gt;\n    &lt;script&gt;\n      &#x2F;&#x2F; 1. 定义组件对象\n      const home &#x3D; &#123;\n        template: &#39;&lt;div&gt;Home子组件&lt;&#x2F;div&gt;&#39;,\n      &#125;\n      const about &#x3D; &#123;\n        template: &#39;&lt;div&gt;About子组件&lt;&#x2F;div&gt;&#39;,\n      &#125;\n      &#x2F;&#x2F; 2. 创建路由规则\n      const routes &#x3D; [\n        &#123; path: &#39;&#x2F;home&#39;, component: home &#125;,\n        &#123; path: &#39;&#x2F;about&#39;, component: about &#125;,\n      ]\n      &#x2F;&#x2F; 3. 创建路由实例对象\n      const router &#x3D; new VueRouter(&#123;\n        routes: routes,\n      &#125;)\n\n      &#x2F;&#x2F; 4. 将路由对象挂载到根实例\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        router,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n通过路由对象(router) 建立 URL 和 组件 之间的对应关系\nroute: 路由规则, URL和组件的对应关系\nroutes: 由路由规则组成的数组\nrouter: 路由对象, 管理路由规则(route)3 改造HTML配置路由链接和路由出口&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;!-- 一. 改造HTML --&gt;\n  &lt;!-- 配置路由链接 --&gt;\n  &lt;router-link to&#x3D;&quot;home&quot;&gt;Home&lt;&#x2F;router-link&gt;\n  &lt;router-link to&#x3D;&quot;about&quot;&gt;About&lt;&#x2F;router-link&gt;\n\n  &lt;!-- 配置路由出口 --&gt;\n  &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;div&gt;\n\n\n\n\n三. 起步\n1 手动集成\n1) 安装npm install vue-router@3\n\n2) 创建路由文件/src/router/index.js\n\n安装vue-router插件\n定义路由规则\n导出路由对象\n\n\n\n\n\n\n\n\n示例\n\n\n&#x2F;&#x2F; 一. 导入vue\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F; 二. 导入vue-router\nimport VueRouter from &#39;vue-router&#39;\n&#x2F;&#x2F; 三. 使用vue-router插件\nVue.use(VueRouter)\n\n&#x2F;&#x2F; 四. 实例化VueRouter对象\n&#x2F;&#x2F; 4.1 new\n&#x2F;&#x2F; 4.2 路由规则\nconst routes &#x3D; []\n\nconst router &#x3D; new VueRouter(&#123;\n  routes: routes,\n&#125;)\n\n&#x2F;&#x2F; 五. 导出router对象\nexport default router\n\n\n3) 导入路由对象在main.js中导入路由对象\n&#x2F;&#x2F; 导入路由对象\nimport router from &#39;.&#x2F;router&#39;\n\nnew Vue(&#123;\n  &#x2F;&#x2F; 挂载\n  router,\n  render: (h) &#x3D;&gt; h(App),\n&#125;).$mount(&#39;#app&#39;)\n\n\n2 配置路由规则\n1) 创建页面级路由文件在src/views目录下, 创建两个路由文件\n\nTodo.vue\nArticle.vue:::info\n\n说明\n\nviews目录: 存放页面级的组件\ncomponents目录: 存放公共组件, 通用组件, 小组件:::&lt;template&gt;\n  &lt;div&gt;todo页面&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Todo&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n&lt;template&gt;\n  &lt;div&gt;文章页面&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Article&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n\n2) 导入页面组件在router/index.js文件中, 导入组件\n&#x2F;&#x2F; 导入路由对象\nimport Todo from &#39;@&#x2F;views&#x2F;Todo&#39;\nimport Article from &#39;@&#x2F;views&#x2F;Article&#39;\n\n3) 编写路由规则:::info核心建立URL和组件之前的对应关系:::\nconst routes &#x3D; [\n  &#123; path: &#39;&#x2F;todo&#39;, component: Todo &#125;,\n  &#123; path: &#39;&#x2F;article&#39;, component: Article &#125;,\n]\n\n3 配置路由出口在app.vue中, 通过设置router-view显示不同的组件\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;!-- 引用组件 --&gt;\n    &lt;!-- &lt;todo&gt;&lt;&#x2F;todo&gt; --&gt;\n    &lt;!-- 路由的出口 --&gt;\n    &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n4 自动集成(重点掌握)如果使用@Vue/cli工具创建项目, 可以在构建项目时, 直接选择router\nvue create project\n\n5 示例\n\n\n\n\n\n\nWARNING\n需求实现如下效果\n\n\n\n\n\n\n\n\n\n\n参考答案\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;a href&#x3D;&quot;#&#x2F;todo&quot;&gt;显示Todo组件&lt;&#x2F;a&gt;\n    &lt;a href&#x3D;&quot;#&#x2F;article&quot;&gt;显示Article组件&lt;&#x2F;a&gt;\n    &lt;!-- 定义一个路由出口: 在哪里显示子组件 --&gt;\n    &lt;div class&#x3D;&quot;page&quot;&gt;\n      &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\na &#123;\n  padding: 0 10px;\n&#125;\n.page &#123;\n  width: 400px;\n  height: 100px;\n  border: 1px solid #000;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n三. 路由对象与路由规则\n1 路由对象$router表示路由对象\n\n包含路由规则对象\n操作路由规则对象\n主要调用其方法\npush\ngo\nreplace\n\n\n\n\n2 路由规则路由对象上的routes数组, 构成了路由规则$route\n\n解析URL\n参数\nquery\n\n\n使用其属性\n\n对应于router/index.js中定义的路由规则\n3 动态路由参数根据路由规则传参\n\n\n\n\n\n\n\n\n\n案例\n获取user的id值\n1) 创建user组件文件创建views/User.vue文件, 编写如下内容\n&lt;template&gt;\n  &lt;div&gt;获取到user的id: &#123;&#123; $route.params.id &#125;&#125;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;User&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n2) 配置路由规则修改router/index.js\n&#x2F;&#x2F; 一. 使用vue-router插件\nimport Vue from &#39;vue&#39;\nimport VueRouter from &#39;vue-router&#39;\nVue.use(VueRouter)\n\n&#x2F;&#x2F; 导入路由对象\nimport Todo from &#39;@&#x2F;views&#x2F;Todo&#39;\nimport Article from &#39;@&#x2F;views&#x2F;Article&#39;\nimport User from &#39;@&#x2F;views&#x2F;User&#39;\n\n&#x2F;&#x2F; 二. 定义路由规则(routes)\nconst routes &#x3D; [\n  &#123; path: &#39;&#x2F;todo&#39;, component: Todo &#125;,\n  &#123; path: &#39;&#x2F;article&#39;, component: Article &#125;,\n  &#123; path: &#39;&#x2F;user&#x2F;:id&#39;, component: User &#125;,\n]\n\n&#x2F;&#x2F; 三. 创建路由对象(路由器router)\nconst router &#x3D; new VueRouter(&#123;\n  routes: routes,\n&#125;)\n\n&#x2F;&#x2F; 四. 导出路由对象\nexport default router\n\n\n\n\n\n\n\n\n\n\n示例\n\n3) 编写路由的入口修改App.vue\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;a href&#x3D;&quot;#&#x2F;todo&quot;&gt;显示Todo组件&lt;&#x2F;a&gt;\n    &lt;a href&#x3D;&quot;#&#x2F;article&quot;&gt;显示Article组件&lt;&#x2F;a&gt;\n\n    &lt;a href&#x3D;&quot;#&#x2F;user&#x2F;1&quot;&gt;显示User组件, 传数据1&lt;&#x2F;a&gt;\n    &lt;!-- 定义一个路由出口: 在哪里显示子组件 --&gt;\n    &lt;div class&#x3D;&quot;page&quot;&gt;\n      &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n  mounted() &#123;\n    &#x2F;&#x2F; $router: 路由器(路由对象). 操作route规则的, 调用push&#x2F;go&#x2F;replace方法\n    console.log(this.$router)\n\n    &#x2F;&#x2F; $route: 路由规则. 操作URL的. 主要使用其属性(params, query)\n    console.log(this.$route)\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\na &#123;\n  padding: 0 10px;\n&#125;\n.page &#123;\n  width: 400px;\n  height: 100px;\n  border: 1px solid #000;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n四. router-link\n1 介绍\n1) 定义由vue-router插件实现的一个组件.\n\n2) 作用实现组件之间的切换\n\n2 使用router-link默认情况, 被渲染为a元素可能通过指定tag属性, 渲染为任意元素\n&lt;router-link to&#x3D;&quot;&#x2F;todo&quot; tag&#x3D;&quot;li&quot;&gt;显示Todo组件&lt;&#x2F;router-link&gt;\n&lt;router-link to&#x3D;&quot;&#x2F;article&quot;&gt;显示Article组件&lt;&#x2F;router-link&gt;\n渲染的DOM如下\n&lt;li&gt;显示Todo组件&lt;&#x2F;li&gt;\n&lt;a href&#x3D;&quot;#&#x2F;article&quot;&gt;显示Article组件&lt;&#x2F;a&gt;\n\n五. 编程式导航在vue-router中, 除了\n\n使用router-link实现导航外\n还可以调用$router路由器的方法, 以js代码的方式进行导航\n\n主要方法\n\npush: 会将URL压入到History记录栈中, 可以通过浏览器前进``后退按钮进行操作\nreplace: 不会将URL压入到History记录栈中\n\n\n\n\n\n\n\n\n\n\n示例\ntemplate部分\n&lt;button @click&#x3D;&quot;handleClick&quot;&gt;导航到Todo组件&lt;&#x2F;button&gt;\nscript部分\nmethods: &#123;\n  handleClick() &#123;\n    &#x2F;&#x2F; 导航到&#x2F;todo组件\n    console.log(this.$route) &#x2F;&#x2F; 保存当前的URL\n    if (this.$route.path !&#x3D; &#39;&#x2F;todo&#39;) &#123;\n      this.$router.push(&#39;&#x2F;todo&#39;)\n    &#125;\n  &#125;,\n&#125;,\n","slug":"七. Vue-router_new","date":"2022-12-02T13:28:03.719Z","categories_index":"Vue","tags_index":"Vue2进阶","author_index":"团子"},{"id":"fed418f8bc6a1a6ecc0e727de5418b9a","title":"扩展Vue组件间通信的各种方式","content":"\n1 父子组件通信\n1) 父传子\n在父组件模板中, 使用自定义属性\n\n在子组件对象中, 使用props接收\n2) 子传父\n在子组件中, 使用$emit触发自定义事件\n\n在父组件中, 监听自定义事件\n2 亲兄弟组件通信\n1) 介绍有共同父组件的兄弟叫做亲兄弟:::warning\n\n\n需求老大子组件-&gt;老二子组件:::\n\n\n\n\n\n\n\n\n\n通过父组件转发\n老大-&gt;老二老大-&gt;父组件-&gt;老二\n2) 实现\n创建项目vue create vuex-demo\n\n清理代码改造App.vue\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n创建子组件在components目录下, 创建\n\nOne.vue\nTwo.vue\n\n\n\n\n\n\n\n\n示例\n\n\n&lt;template&gt;\n  &lt;div&gt;\n    老大子组件:\n    &lt;input type&#x3D;&quot;text&quot; &#x2F;&gt;\n    &lt;button&gt;发送&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;One&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n&lt;template&gt;\n  &lt;div&gt;老二子组件&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Two&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n挂载子组件在App.vue中\n\n导入\n挂载\n引用\n\n\n\n\n\n\n\n\n示例\n\n\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;one&gt;&lt;&#x2F;one&gt;\n    &lt;two&gt;&lt;&#x2F;two&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport One from &#39;.&#x2F;components&#x2F;One.vue&#39;\nimport Two from &#39;.&#x2F;components&#x2F;Two.vue&#39;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123;\n    One,\n    Two,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n\n老大提交自定义事件改造One.vue\n&lt;template&gt;\n  &lt;div&gt;\n    老大子组件:\n    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;msg&quot; &#x2F;&gt;\n    &lt;button @click&#x3D;&quot;handleClick&quot;&gt;发送&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;One&#39;,\n  data() &#123;\n    return &#123;\n      msg: &#39;&#39;,\n    &#125;\n  &#125;,\n  methods: &#123;\n    handleClick() &#123;\n      this.$emit(&#39;send&#39;, this.msg)\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n父组件监听自定义事件\n监听老大的自定义事件\n使用老二的自定义属性传参\n\n改造App.vue\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;one @send&#x3D;&quot;handleSend&quot;&gt;&lt;&#x2F;one&gt;\n    &lt;two :msg&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;two&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport One from &#39;.&#x2F;components&#x2F;One.vue&#39;\nimport Two from &#39;.&#x2F;components&#x2F;Two.vue&#39;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123;\n    One,\n    Two,\n  &#125;,\n  data() &#123;\n    return &#123;\n      msg: &#39;&#39;,\n    &#125;\n  &#125;,\n  methods: &#123;\n    handleSend(msg) &#123;\n      this.msg &#x3D; msg\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n\n老二接收参数改造Two.vue\n&lt;template&gt;\n  &lt;div&gt;老二子组件: &#123;&#123; msg &#125;&#125;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Two&#39;,\n  props: &#123;\n    msg: &#123;\n      type: String,\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n3 表兄弟组件通信\n1) 简介:::warning需求老大-&gt;叔叔家的老二:::按照Vue的设计需要经历: 老大-&gt;父亲-&gt;爷爷-&gt;叔叔-&gt;叔叔家老二. 这个过程非常的复杂, 没有通用性\n为了解决层级结构复杂的情况, 我们需要使用全局事件总线模式\n\n\n\n\n\n\n\n\n\n什么是全局事件总线\n适合于没有明显关系的两个组件\n对于层级复杂的情况, 我们通常使用全局事件总线模式定义一个全局的事件总线对象bus所有的组件都通过一个统一的全局对象通信\n2) 实现\n创建全局事件对象在src目录下, 创建bus/index.js文件\nimport Vue from &#39;vue&#39;\n\n&#x2F;&#x2F; 这个是一个Vue实例对象\nconst bus &#x3D; new Vue()\n\nexport default bus\n\n数据提交给bus对象&lt;template&gt;\n  &lt;div&gt;\n    老大子组件:\n    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;msg&quot; &#x2F;&gt;\n    &lt;button @click&#x3D;&quot;handleClick&quot;&gt;发送&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n  import bus from &#39;..&#x2F;bus&#39;\n  \n  export default &#123;\n    name: &#39;One&#39;,\n    data() &#123;\n      return &#123;\n        msg: &#39;&#39;,\n      &#125;\n    &#125;,\n    methods: &#123;\n      handleClick() &#123;\n        &#x2F;&#x2F; 通过$emit提交, 向bus对象提交一个&#39;send&#39;事件\n        bus.$emit(&#39;send&#39;, this.msg)\n      &#125;,\n    &#125;,\n  &#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n通过bus对象监听&lt;template&gt;\n  &lt;div&gt;老二子组件: &#123;&#123; msg &#125;&#125;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport bus from &#39;..&#x2F;bus&#39;\n\nexport default &#123;\n  name: &#39;Two&#39;,\n  data() &#123;\n    return &#123;\n      msg: &#39;&#39;, &#x2F;&#x2F; msg: msg\n    &#125;\n  &#125;,\n  created() &#123;\n    bus.$on(&#39;send&#39;, (aaa) &#x3D;&gt; &#123;\n      console.log(aaa)\n      &#x2F;&#x2F; 使用箭头函数, this指向上一级作用域, 跟created中的this都指向Two组件对象\n      this.msg &#x3D; aaa\n    &#125;)\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n上述这种方式: 也叫做发布订阅模式\n4 祖孙组件通信\n1) 传静态数据\n在祖先组件中, 通过provide选项提供数据\n在后代组件中, 通过injection选项注入数据&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n  provide: &#123;\n  \tfoo: &#39;hello&#39;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Son&#39;,\n  inject: [&#39;foo&#39;],\n&#125;\n&lt;&#x2F;script&gt;\n2) 传响应式数据\n\n\n传入对象\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n  provide() &#123;\n    return &#123;\n      &#x2F;&#x2F; provide设置为一个函数, 在该函数中,this指向vm实例\n      foo: this.obj\n    &#125;\n  &#125;,\n  data() &#123;\n    return &#123;\n      obj: &#123;\n        msg: &#39;&#39;\n      &#125;\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    从app组件获取的数据: &#123;&#123;foo.msg&#125;&#125;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Son&#39;,\n  inject: [&#39;foo&#39;],\n&#125;\n&lt;&#x2F;script&gt;\n传入函数\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n  provide() &#123;\n    return &#123;\n      &#x2F;&#x2F; provide设置为一个函数, 在该函数中,this指向vm实例\n      foo: () &#x3D;&gt; this.msg\n    &#125;\n  &#125;,\n  data() &#123;\n    return &#123;\n      msg: &#39;&#39;\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    从app组件获取的数据: &#123;&#123;foo()&#125;&#125;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Son&#39;,\n  inject: [&#39;foo&#39;],\n&#125;\n&lt;&#x2F;script&gt;\n\n","slug":"补充Vue组件间通信的各种方式_new","date":"2022-12-02T13:23:47.095Z","categories_index":"补充","tags_index":"Vue组件","author_index":"团子"},{"id":"2c2fb0d64b64f05eef1b605a8211929d","title":"六. Vuex","content":"\n一. 概述\n1 Vuex是什么Vuex是一个集中式的状态管理插件, 实现所有组件的状态(数据)共享, 也是组件间通信的一种方式\n\nVuex本质上是一个Vue的插件\n主要实现所有组件的状态共享\n\n\n2 什么时候用Vuex\n\n\n\n\n\n\n\n\n\n一句话总结\n官方推荐在中大型单页应用中使用\n如何界定呢? 这里给出我自己的经验(仅供参考)\n\n需要与第三方的系统深度整合, 涉及异步获取数据, 大量使用全局变量, 业务逻辑比较复杂等情况时\n如果超过3个组件需要引用/修改同一个数据结构, 比如token, 用户收藏, 购物车中的商品\n涉及到深层嵌套的组件需要与其它组件进行数据通讯\n\n\n二. Vuex的工作原理\n1 设计思路Vuex可以理解成一个统一管理数据的仓库, 因此通常使用store表示理论上, 所有的组件都可以操作(读写)store中的数据\n\n\n\n\n\n\n\n\n\n怎样实现读数据\n可以定义一个单独的全局变量, 所有的组件从全局对象中获取数据\n\n\n\n\n\n\n\n\n\n怎样实现写数据\n如果在每个组件中各自修改全局变量, 就会引起混乱, 因此设计一个工具集中的管理写操作\n\n\n\n\n\n\n\n\n\n如何设计集中式的写操作\n所有的组件不能自己修改全局变量, 需要通知Vuex, 由Vuex集中管理, 统一修改\nOK, 这样Vuex里至少应该包含两个部分\n\nstate: 保存全局数据\nactions: 对数据进行修改的动作\n\n因此, 对于简单的状态管理, 我们使用类似于下面的store模式就可以\nVuex在设计时, 将动作拆分成了两个部分\n\nActions: 处理业务逻辑和异步任务\nMutations: 对状态的修改\n\n\n2 核心概念\n\n\n\n\n\n\n\n\n图示\n\n\n1) Actions动作, 行为\n\n2) Mutations变化, 转变\n\n3) State状态, 数据\n\n三. 起步\n1 创建vue项目使用vue脚本创建项目vuex-demo\nvue create vuex-demo\n\n编写一个基本的计数器组件\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;点击了&#123;&#123; count &#125;&#125;次&lt;&#x2F;h1&gt;\n    &lt;button @click&#x3D;&quot;increment&quot;&gt;+1&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;decrement&quot;&gt;-1&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;incrementIfOdd&quot;&gt;是奇数就+1&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;incrementAsync&quot;&gt;异步+1&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Counter&#39;,\n  data() &#123;\n    return &#123;\n      count: 0,\n    &#125;\n  &#125;,\n  methods: &#123;\n    increment() &#123;\n      this.count++\n    &#125;,\n    decrement() &#123;\n      this.count--\n    &#125;,\n    incrementIfOdd() &#123;\n      if (this.count % 2) this.count++\n    &#125;,\n    incrementAsync() &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        this.count++\n      &#125;, 500)\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n挂载到App.vue下\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;counter&gt;&lt;&#x2F;counter&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Counter from &#39;@&#x2F;components&#x2F;Counter.vue&#39;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123;\n    Counter,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n2 安装Vuex插件使用npm安装Vuex\nnpm i vuex@3\n:::tips特别说明\n\n3.x的版本: 是vue2的语法\n4.x的版本: 是vue3的语法\n5.x的版本: pinia是下一代的vuex, 状态管理:::3 配置\n\n一般在src目录下创建store/index.js\n&#x2F;&#x2F; 导入Vue\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F; 导入vuex\nimport Vuex from &#39;vuex&#39;\n\n&#x2F;&#x2F; vuex本质上是vue的一个插件, 通过Vue.use()注册\n&#x2F;&#x2F; 上所有的vue实例上挂载$store\nVue.use(Vuex)\n\n&#x2F;&#x2F; state: 状态\nconst state &#x3D; &#123;&#125;\n&#x2F;&#x2F; mutations: 修改状态\nconst mutations &#x3D; &#123;&#125;\n&#x2F;&#x2F; actions: 动作\nconst actions &#x3D; &#123;&#125;\n\n&#x2F;&#x2F; 创建并导出store对象\nexport default new Vuex.Store(&#123;\n  state,\n  mutations,\n  actions,\n&#125;)\nStore包含三个部分\n\nstate: 对象类型, 保存数据\nmutations: 对象类型, 定义方法操作数据\nactions: 对象类型, 处理逻辑和异步操作\n\n\n4 导入在main.js中, 完成store对象的导入\nimport Vue from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\n\nimport store from &#39;.&#x2F;store&#39;\n\nVue.config.productionTip &#x3D; false\n\nnew Vue(&#123;\n  store, &#x2F;&#x2F; store: store\n  render: (h) &#x3D;&gt; h(App),\n&#125;).$mount(&#39;#app&#39;)\n\n\n\n\n\n\n\n\n\n演示\n\n四. 基本使用为了熟悉Vuex的使用流程, 先了解单组件与Vuex如何交互通过单组件熟悉语法和流程, 多组件使用也是类似的\n1 完整流程完整流程分为两条线\n\n组件到Vuex, 主要是写操作, 通过向Vuex发送通知, 让Vuex修改state中的数据\nVuex到组件, 主要是读操作, 从Vuex中读取状态1) 流程图\n\n\n\n\n\n\n\n\n\n\n\n关键API\n\ndispatch(分发, 派发): 从组件分发到Actions对象的一个方法\ncommit(提交): 提交一个Mutations对象的一个方法\n\n\n2) 从组件到Actionsdispatch的两个参数\n\ntype: 对应action函数的名称\npayload(可选): 携带的数据\n\nincrement() &#123;\n  &#x2F;&#x2F; 分发一个action, 对应调用名为increment的方法\n  this.$store.dispatch(&#39;increment&#39;)\n&#125;,\n\n发现报错\n\n\n\n\n\n\n\n\n\n\n原因\n在actions对象中, 并没有定义对应的increment方法\n\n\n\n\n\n\n\n\n\n解决方法\n在actions对象中定义increment方法在increment方法中需要调用commit, 提交一个mutation, 所以这里设计了一个context参数保留了store大部分的方法, 但是出于性能考虑, 不太需要完整的store对象, 大家可以理解成一个简化版的store\nincrement(ctx, value) &#123;\n  console.log(ctx)\n&#125;,\n通过观察, 我们发现这里也是可以拿到state的\n\n\n\n\n\n\n\n\n\n思考\n能否直接在actions方法中修改state\nincrement(ctx, value) &#123;\n  console.log(ctx)\n  ctx.state.count +&#x3D; value\n&#125;,\n理论上是可以的, 但是不推荐这么做, 原因后面细讲在actions里, 最核心的工作是commit到Mutations\n\n3) 从Actions到Mutationsincrement(ctx, value) &#123;\n  ctx.commit(&#39;INCRMENT&#39;, value)\n&#125;,\n\n\n\n\n\n\n\n\n\n\n小技巧\n为了区分actions和mutations, 一般将mutations的名称大写此时, 发现没有定义相关的mutation\n\n\n\n\n\n\n\n\n\n\n解决\n定义对应的mutations, 在方法中可以拿到state, 进而对state进行操作\nINCREMENT(state, value) &#123;\n  console.log(state)\n  state.count +&#x3D; value\n&#125;,\n\n\n4) 练习\n完成decrement流程\n完成incrementIfOdd流程\n完成incrementAsync流程\n\n\n\n\n\n\n\n\n\n\n参考答案\n组件的改造在组件中通过调用dispatch分发actions\nmethods: &#123;\n  increment() &#123;\n    &#x2F;&#x2F; 分发一个action, 对应调用名为increment的方法\n    this.$store.dispatch(&#39;increment&#39;, this.num)\n  &#125;,\n  decrement() &#123;\n    this.$store.dispatch(&#39;decrement&#39;, this.num)\n  &#125;,\n  incrementIfOdd() &#123;\n  \tthis.$store.dispatch(&#39;incrementIfOdd&#39;, this.num)\n  &#125;,\n  incrementAsync() &#123;\n  \tthis.$store.dispatch(&#39;incrementAsync&#39;, this.num)\n  &#125;,\n&#125;,\n\n\n\n\n\n\n\n\n\n\nActions\nconst actions &#x3D; &#123;\n  increment(ctx, value) &#123;\n    ctx.commit(&#39;INCREMENT&#39;, value)\n  &#125;,\n  decrement(ctx, value) &#123;\n    ctx.commit(&#39;DECREMENT&#39;, value)\n  &#125;,\n  incrementIfOdd(ctx, value) &#123;\n    if (ctx.state.count % 2) ctx.commit(&#39;INCREMENTIFODD&#39;, value)\n  &#125;,\n  incrementAsync(ctx, value) &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      ctx.commit(&#39;INCREMENTASYNC&#39;, value)\n    &#125;, 500)\n  &#125;,\n&#125;\n\n\n\n\n\n\n\n\n\n\nMutations\nconst mutations &#x3D; &#123;\n  INCREMENT(state, value) &#123;\n    console.log(state)\n    state.count +&#x3D; value\n  &#125;,\n  DECREMENT(state, value) &#123;\n    state.count -&#x3D; value\n  &#125;,\n  INCREMENTIFODD(state, value) &#123;\n    state.count +&#x3D; value\n  &#125;,\n  INCREMENTASYNC(state, value) &#123;\n    state.count +&#x3D; value\n  &#125;,\n&#125;\n\n\n5) 从Vuex到组件所有的组件对象都可以通过$store访问到Vuex, 进而可以拿到state在组件中使用\n&lt;h1&gt;计数总和: &#123;&#123; $store.state.count &#125;&#125;&lt;&#x2F;h1&gt;\n\n\n2 简化流程我们发现向increment和decrement这样的操作在actions没做什么逻辑操作, 直接转发给Mutations所以, 我们思考是否可以跳过这个流程, 让组件直接commit到Mutations呢?答案是肯定的, Vuex团队也注意到了这个问题\n\n1) 流程图\n\n2) 从组件直接到Mutations\n\n\n\n\n\n\n\n\n示例\nmethods: &#123;\n  increment() &#123;\n    &#x2F;&#x2F; 分发一个action, 对应调用名为increment的方法\n    &#x2F;&#x2F; this.$store.dispatch(&#39;increment&#39;, this.num)\n    &#x2F;&#x2F; 直接使用commit提交给Mutations\n    this.$store.commit(&#39;INCREMENT&#39;, this.num)\n  &#125;,\n  decrement() &#123;\n    &#x2F;&#x2F; this.$store.dispatch(&#39;decrement&#39;, this.num)\n    &#x2F;&#x2F; 直接使用commit提交给Mutations\n    this.$store.commit(&#39;DECREMENT&#39;, this.num)\n  &#125;,\n&#125;,\n\n3 深入思考\n1) 为什么将Actions和Mutations分开Vuex设计的目的就是为中大型项目服务的\n\nActions属于分层设计, 将复杂业务解耦, 承担了类似中间件的角色\nActions处理异步任务, Mutations处理同步任务\nMutations方便调试与监控, 能更好地与devtools集成\n\n\n\n\n\n\n\n\n\n\n案例\n在组件中, 分发一个complex任务到Actions\n&lt;button @click&#x3D;&quot;$store.dispatch(&#39;complex&#39;)&quot;&gt;复杂的逻辑&lt;&#x2F;button&gt;\n\n在Actions中, 拆分成多个子任务, 完成解耦\ncomplex(ctx) &#123;\n  console.log(&#39;处理复杂逻辑...&#39;)\n  ctx.dispatch(&#39;sub1&#39;)\n&#125;,\nsub1(ctx) &#123;\n  console.log(&#39;处理子任务1...&#39;)\n  ctx.dispatch(&#39;sub2&#39;)\n&#125;,\nsub2(ctx) &#123;\n  console.log(&#39;处理子任务2...&#39;)\n  ctx.commit(&#39;INCREMENT&#39;, 1)\n&#125;,\n子任务可以设计成异步任务, 从而提高效率, 而真正对数据的修改统一放到Mutations中完成\n\n2) Vuex调试工具由于所有的数据修改统一在Mutations中完成, 只需要监控Mutations就可以完全控制state的改变, 方便大型项目中的调试, 这也是为什么不推荐在Actions中直接修改state的原因\n4 Getters配置Vuex中的Getters类似于计算属性, 用于对数据的再次加工:::warning需求统计已完成的todo项目:::\n1) 定义stateconst state &#x3D; &#123;\n  count: 0,\n  todos: [\n    &#123; id: 1, content: &#39;待办1&#39;, done: true &#125;,\n    &#123; id: 2, content: &#39;待办2&#39;, done: false &#125;,\n    &#123; id: 3, content: &#39;待办3&#39;, done: false &#125;,\n  ],\n&#125;\n\n\n2) 定义gettersconst getters &#x3D; &#123;\n  doneTodos: (state) &#x3D;&gt; &#123;\n    return state.todos.filter((todo) &#x3D;&gt; todo.done)\n  &#125;,\n&#125;\n\n\n3) 配置getters&#x2F;&#x2F; 创建并导出store对象\nexport default new Vuex.Store(&#123;\n  state,\n  mutations,\n  actions,\n  getters,\n&#125;)\n\n\n4) 在组件中调用&lt;h3&gt;已完成的待办&lt;&#x2F;h3&gt;\n&lt;ul&gt;\n  &lt;li v-for&#x3D;&quot;item in $store.getters.doneTodos&quot; :key&#x3D;&quot;item.id&quot;&gt;\n    &#123;&#123; item.content &#125;&#125;\n  &lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n\n5) 其它用法通过方法访问, 返回一个函数\n&lt;div&gt;id为2的todo: &#123;&#123; $store.getters.getTodoById(2) &#125;&#125;&lt;&#x2F;div&gt;\n\nconst getters &#x3D; &#123;\n  doneTodos: (state) &#x3D;&gt; &#123;\n    return state.todos.filter((todo) &#x3D;&gt; todo.done)\n  &#125;,\n  getTodoById: (state) &#x3D;&gt; &#123;\n    return (id) &#x3D;&gt; &#123;\n      return state.todos.find((todo) &#x3D;&gt; todo.id &#x3D;&#x3D; id)\n    &#125;\n  &#125;,\n&#125;\n\n\n五. map辅助函数\n1 为什么需要辅助函数在组件中访问state状态时, 每次都需要使用\n$store.state.xxx\n我们希望在使用的时候直接使用xxx该如何操作呢\n可以在组件中定义计算属性\ncomputed: &#123;\n  count() &#123;\n  \treturn this.$store.state.count\n  &#125;,\n  name() &#123;\n  \treturn this.$store.state.name\n  &#125;,\n  age() &#123;\n  \treturn this.$store.state.age\n  &#125;,\n&#125;,\n我们发现computed里的函数差不多, 能否使用一个统一的写法\nvuex团队也给提供了4个辅助函数\n\nmapState\nmapGetters\nmapMutations\nmapActions\n\n\n2 mapState先导入mapState等辅助函数\nimport &#123; mapState &#125; from &#39;vuex&#39;\n\n返回一个对象, 包含了计算属性函数\nmounted() &#123;\n  &#x2F;&#x2F; 返回一个对象\n  console.log(mapState([&#39;count&#39;, &#39;name&#39;, &#39;age&#39;]))\n&#125;,\n\n可以使用展开运算符...将对象展开, 和其他方法进行合并\ncomputed: &#123;\n  &#x2F;&#x2F; 使用对象的展开\n  ...mapState([&#39;count&#39;, &#39;name&#39;, &#39;age&#39;]),\n  someOther() &#123;&#125;\n&#125;,\n\n\n\n\n\n\n\n\n\n\n对象映射写法\n如果希望计算属性名称和state状态名称不一致, 可以使用对象映射的写法\n&#x2F;&#x2F; mapState(对象写法)\n...mapState(&#123; myCount: &#39;count&#39;, myName: &#39;name&#39;, myAge: &#39;age&#39; &#125;),\n\n\n3 mapGetters同理, Vuex也提供了mapGetters辅助函数\nimport &#123; mapState, mapGetters &#125; from &#39;vuex&#39;\n\n在computed中\ncomputed: &#123;\n  ...mapGetters([&#39;doneTodos&#39;, &#39;getTodoById&#39;]),\n&#125;\n\n\n4 mapMutations在methods中\n...mapMutations(&#123; increment: &#39;INCREMENT&#39;, decrement: &#39;DECRMENT&#39; &#125;),\n\n\n\n\n\n\n\n\n\n\n注意\n这里如果要传参, 只能在调用函数时传递\n&lt;button @click&#x3D;&quot;increment(num)&quot;&gt;+&lt;&#x2F;button&gt;\n&lt;button @click&#x3D;&quot;decrement(num)&quot;&gt;-&lt;&#x2F;button&gt;\n\n\n5 mapActions在methods中\n...mapActions([&#39;incrementIfOdd&#39;, &#39;incrementAsync&#39;, &#39;complex&#39;]),\n\n&lt;button @click&#x3D;&quot;incrementIfOdd(1)&quot;&gt;是奇数就+1&lt;&#x2F;button&gt;\n&lt;button @click&#x3D;&quot;incrementAsync(1)&quot;&gt;异步+1&lt;&#x2F;button&gt;\n\n六. 模块化\n1 为什么需要模块化当应用变得非常复杂时，store对象就有可能变得相当臃肿如果集中写一个文件中, 不方便管理. 此时, 可以考虑拆分成多个模块\n2 具体实现\n\n\n\n\n\n\n\n\n示例\n按照功能, 将计数器, todos拆分到不同的模块中\n\n1) 拆分计数器模块将计数器相关的功能写在modules/counter.js\n&#x2F;&#x2F; 定义一个counter模块\nexport default &#123;\n  &#x2F;&#x2F; state: 保存状态(数据)\n  state: () &#x3D;&gt; &#123;\n    return &#123;\n      count: 0,\n    &#125;\n  &#125;,\n  &#x2F;&#x2F; 修改数据的方法(同步)\n  mutations: &#123;\n    INCREMENT(state, value) &#123;\n      state.count++\n    &#125;,\n    DECREMENT(state, value) &#123;\n      state.count--\n    &#125;,\n    INCREMENTIFODD(state, value) &#123;\n      state.count++\n    &#125;,\n    INCREMENTASYNC(state, value) &#123;\n      state.count++\n    &#125;,\n  &#125;,\n  &#x2F;&#x2F; 修改数据的方法(支持异步, 相当于中间件)\n  actions: &#123;\n    increment(ctx, value) &#123;\n      ctx.commit(&#39;INCREMENT&#39;)\n    &#125;,\n    decrement(ctx, value) &#123;\n      ctx.commit(&#39;DECREMENT&#39;)\n    &#125;,\n    incrementIfOdd(ctx, value) &#123;\n      if (ctx.state.count % 2) &#123;\n        ctx.commit(&#39;INCREMENTIFODD&#39;)\n      &#125;\n    &#125;,\n    incrementAsync(ctx, value) &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        ctx.commit(&#39;INCREMENTASYNC&#39;)\n      &#125;, 1000)\n    &#125;,\n  &#125;,\n&#125;\n\n\n2) 拆分todos模块将todos相关的功能, 写在modules/todos.js\n&#x2F;&#x2F; 在这处理todos模块相关的状态\nexport default &#123;\n  state: () &#x3D;&gt; &#123;\n    return &#123;\n      todos: [\n        &#123; id: 1, content: &#39;待办1&#39;, done: true &#125;,\n        &#123; id: 2, content: &#39;待办2&#39;, done: false &#125;,\n        &#123; id: 3, content: &#39;待办3&#39;, done: false &#125;,\n      ],\n    &#125;\n  &#125;,\n  getters: &#123;\n    doneTodos: (state) &#x3D;&gt; &#123;\n      return state.todos.filter((item) &#x3D;&gt; item.done)\n    &#125;,\n    getTodoById: (state) &#x3D;&gt; &#123;\n      return (id) &#x3D;&gt; &#123;\n        return state.todos.find((item) &#x3D;&gt; item.id &#x3D;&#x3D; id)\n      &#125;\n    &#125;,\n  &#125;,\n&#125;\n\n:::info注意模块化中的state是一个函数:::\n3) 导入模块在store/index.js中导入两个模块\nimport Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\n\n&#x2F;&#x2F; 注册插件: 在Vue的原型对象上, 挂载了$store\nVue.use(Vuex)\n\nimport counter from &#39;.&#x2F;modules&#x2F;counter&#39;\nimport todos from &#39;.&#x2F;modules&#x2F;todos&#39;\nexport default new Vuex.Store(&#123;\n  modules: &#123;\n    counter,\n    todos,\n  &#125;,\n&#125;)\n\n4) 在组件中使用在App.vue中使用\ncomputed: &#123;\n  &#x2F;&#x2F; 对应state.module.xxx\n  ...mapState(&#123;mycount: state &#x3D;&gt; state.counter.count&#125;),\n  &#x2F;&#x2F; getters是挂在全局空间下, 可以直接使用\n  ...mapGetters([&#39;doneTodos&#39;, &#39;getTodoById&#39;])\n&#125;,\nmethods: &#123;\n  &#x2F;&#x2F; mutations和actions也是挂在全局空间下, 可以直接使用\n  ...mapMutations([&#39;INCREMENT&#39;, &#39;DECREMENT&#39;]),\n  ...mapActions([&#39;incrementIfOdd&#39;, &#39;incrementAsync&#39;])\n&#125;\n\n3 命名空间\n1) 为什么需要命名空间默认情况下, 所有的getters, mutations, actions都是挂在store的全局空间下.多个模块可能会存在同名的**action**, 为了更好的区分模块, 可以加上命名空间\n2) 使用在App.vue中的mapGetters``mapMutations mapActions中带上命名空间\n在模块中, 配置namespaced: true开启命名空间\n&#x2F;&#x2F; 定义一个counter的对象\nexport default &#123;\n  &#x2F;&#x2F; 开启命名空间\n  namespaced: true,\n  &#x2F;&#x2F; state: 在module模块中需要是一个函数\n  state: () &#x3D;&gt; &#123;\n    return &#123;\n      count: 0\n    &#125;\n  &#125;,\n  ....\n&#125;\nexport default &#123;\n  namespaced: true,\n  state: () &#x3D;&gt; &#123;\n    return &#123;\n      todos: [\n        &#123;id:1, content: &#39;待办1&#39;, done: true&#125;,\n        &#123;id:2, content: &#39;待办2&#39;, done: false&#125;,\n        &#123;id:3, content: &#39;待办3&#39;, done: true&#125;,\n      ]\n    &#125;\n  &#125;,\n  ...\n&#125;\ncomputed: &#123;\n  ...mapGetters(&#39;todos&#39;,[&#39;doneTodos&#39;, &#39;getTodoById&#39;])\n&#125;,\nmethods: &#123;\n  ...mapMutations(&#39;counter&#39;, [&#39;INCREMENT&#39;, &#39;DECREMENT&#39;]),\n  ...mapActions(&#39;counter&#39;, [&#39;incrementIfOdd&#39;, &#39;incrementAsync&#39;])\n&#125;\n或者使用带命名空间使用\nincrementIfOdd() &#123;\n  this.$store.dispatch(&#39;counter&#x2F;incrementIfOdd&#39;)\n&#125;,\nincrementAsync() &#123;\n  this.$store.dispatch(&#39;counter&#x2F;incrementAsync&#39;)\n&#125;","slug":"六. Vuex_new","date":"2022-12-02T12:06:41.322Z","categories_index":"Vue","tags_index":"Vue2进阶","author_index":"团子"},{"id":"64fa4b6dd0d0c25575260215905ecca7","title":"实战TabBar封装","content":"\n一. 搭建环境\n1 创建项目使用vue-cli创建项目\nvue create tabbar\n\n2 启动项目使用VSCode打开tabbar文件夹在VSCode的终端中, 执行如下命令\nnpm run serve\n\n\n\n\n\n\n\n\n\n演示\n在浏览器中访问测试\n3 清理项目\n1) 清理App.vue清理完成后的App.vue\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n2) 删除HelloWorld.vue\n二. 初步实现\n1 初步实现结构&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;div class&#x3D;&quot;tab-bar&quot;&gt;\n      &lt;div class&#x3D;&quot;tab-bar-item&quot;&gt;首页&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;tab-bar-item&quot;&gt;分类&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;tab-bar-item&quot;&gt;购物车&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;tab-bar-item&quot;&gt;我的&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n2 初步实现样式&lt;style&gt;\n.tab-bar &#123;\n  display: flex;\n  position: fixed;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  height: 40px;\n  background-color: skyblue;\n&#125;\n.tab-bar-item &#123;\n  flex: 1;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n&#125;\n&lt;&#x2F;style&gt;\n\n三. 封装TabBar组件\n1 创建组件在components目录, 创建TabBar.vue\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;tab-bar&quot;&gt;\n    &lt;div class&#x3D;&quot;tab-bar-item&quot;&gt;首页&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;tab-bar-item&quot;&gt;分类&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;tab-bar-item&quot;&gt;购物车&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;tab-bar-item&quot;&gt;我的&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;TabBar&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n2 导入组件在App.vue中导入组件\n&lt;script&gt;\n&#x2F;&#x2F; 导入组件\nimport TabBar from &#39;.&#x2F;components&#x2F;TabBar.vue&#39;\nexport default &#123;\n  name: &#39;App&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n3 挂载组件在App.vue中挂载组件\n&lt;script&gt;\n&#x2F;&#x2F; 导入组件\nimport TabBar from &#39;.&#x2F;components&#x2F;TabBar.vue&#39;\nexport default &#123;\n  name: &#39;App&#39;,\n  &#x2F;&#x2F; 挂载组件\n  components: &#123;\n    TabBar,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n4 引用组件在App.vue的模板中引用\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;!-- 引用组件 --&gt;\n    &lt;tab-bar&gt;&lt;&#x2F;tab-bar&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n5 定义样式把之前在App.vue中定义的样式放到TabBar.vue里, 表示TabBar组件的样式\n完整的TabBar.vue的示例\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;tab-bar&quot;&gt;\n    &lt;div class&#x3D;&quot;tab-bar-item&quot;&gt;首页&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;tab-bar-item&quot;&gt;分类&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;tab-bar-item&quot;&gt;购物车&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;tab-bar-item&quot;&gt;我的&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;TabBar&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.tab-bar &#123;\n  display: flex;\n  position: fixed;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  height: 40px;\n  background-color: skyblue;\n&#125;\n.tab-bar-item &#123;\n  flex: 1;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n&#125;\n&lt;&#x2F;style&gt;\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;!-- 引用组件 --&gt;\n    &lt;tab-bar&gt;&lt;&#x2F;tab-bar&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n&#x2F;&#x2F; 导入组件\nimport TabBar from &#39;.&#x2F;components&#x2F;TabBar.vue&#39;\nexport default &#123;\n  name: &#39;App&#39;,\n  &#x2F;&#x2F; 挂载组件\n  components: &#123;\n    TabBar,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n\n&lt;&#x2F;style&gt;\n\n\n6 设置插槽我们希望tab-bar组件中的结构是可以被定制(可变)\n1) 预留slot在TabBar.vue的模板中, 预留slot\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;tab-bar&quot;&gt;\n    &lt;slot&gt;&lt;&#x2F;slot&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n2) 插入内容在App.vue中, 定义tab-bar组件的子项\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;!-- 引用组件 --&gt;\n    &lt;tab-bar&gt;\n      &lt;!-- 通过列表渲染来控制TabBar中的子项 --&gt;\n      &lt;div class&#x3D;&quot;tab-bar-item&quot; v-for&#x3D;&quot;(tab, index) in tabs&quot; :key&#x3D;&quot;index&quot;&gt;\n        &#123;&#123; tab &#125;&#125;\n      &lt;&#x2F;div&gt;\n\n      &lt;!-- &lt;tab-bar-item&gt;&lt;&#x2F;tab-bar-item&gt;\n      &lt;tab-bar-item&gt;&lt;&#x2F;tab-bar-item&gt;\n      &lt;tab-bar-item&gt;&lt;&#x2F;tab-bar-item&gt;\n      &lt;tab-bar-item&gt;&lt;&#x2F;tab-bar-item&gt; --&gt;\n    &lt;&#x2F;tab-bar&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n&#x2F;&#x2F; 导入组件\nimport TabBar from &#39;.&#x2F;components&#x2F;TabBar.vue&#39;\nexport default &#123;\n  name: &#39;App&#39;,\n  &#x2F;&#x2F; 挂载组件\n  components: &#123;\n    TabBar,\n  &#125;,\n  data() &#123;\n    return &#123;\n      tabs: [&#39;首页&#39;, &#39;分类&#39;, &#39;购物车&#39;, &#39;我的&#39;],\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n\n四. 封装TabBarItem组件\n1 创建组件在components目录下, 创建TabBarItem.vue文件\n&lt;template&gt;\n  &lt;div&gt;TabBarItem&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;TabBarItem&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n2 导入组件在App.vue中导入组件\nimport TabBarItem from &#39;.&#x2F;components&#x2F;TabBarItem.vue&#39;\n\n3 挂载组件在App.vue中挂载组件\ncomponents: &#123;\n  TabBar,\n  TabBarItem,\n&#125;,\n\n4 引用组件&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;!-- 引用组件 --&gt;\n    &lt;tab-bar&gt;\n      &lt;!-- 通过列表渲染来控制TabBar中的子项 --&gt;\n      &lt;!-- &lt;div class&#x3D;&quot;tab-bar-item&quot; v-for&#x3D;&quot;(tab, index) in tabs&quot; :key&#x3D;&quot;index&quot;&gt;\n        &#123;&#123; tab &#125;&#125;\n      &lt;&#x2F;div&gt; --&gt;\n\n      &lt;tab-bar-item&gt;&lt;&#x2F;tab-bar-item&gt;\n      &lt;tab-bar-item&gt;&lt;&#x2F;tab-bar-item&gt;\n      &lt;tab-bar-item&gt;&lt;&#x2F;tab-bar-item&gt;\n      &lt;tab-bar-item&gt;&lt;&#x2F;tab-bar-item&gt;\n    &lt;&#x2F;tab-bar&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n5 定义样式设置插槽给TabBarItem组件设置自己的样式\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;tab-bar-item&quot;&gt;\n    &lt;slot&gt;&lt;&#x2F;slot&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;TabBarItem&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.tab-bar-item &#123;\n  flex: 1;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n&#125;\n&lt;&#x2F;style&gt;\n\n五. 功能完善\n1 给Item添加图标\n1) 定义属性给TabBarItem组件定义一个属性icon在TabBarItem组件中, 定义props属性\n&lt;script&gt;\nexport default &#123;\n  name: &#39;TabBarItem&#39;,\n  props: &#123;\n    icon: &#123;\n      type: String,\n      default: &#39;user&#39;\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n2) 使用iconfont导入iconfont生成的CSS\n&lt;style&gt;\n@import &#39;http:&#x2F;&#x2F;at.alicdn.com&#x2F;t&#x2F;c&#x2F;font_3660333_clz5n3z0jtw.css&#39;;\n\n.tab-bar-item &#123;\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n\n  font-size: 12px;\n  color: #fff;\n&#125;\n.tab-bar-item i &#123;\n  font-size: 18px;\n&#125;\n&lt;&#x2F;style&gt;\ncss文件\n\n自定义字体\n提供了字体图标\nicon-home\nicon-category\nicon-cart\nicon-user@font-face &#123;\n  font-family: &quot;iconfont&quot;; &#x2F;* Project id 3660333 *&#x2F;\n  src: url(&#39;&#x2F;&#x2F;at.alicdn.com&#x2F;t&#x2F;c&#x2F;font_3660333_clz5n3z0jtw.woff2?t&#x3D;1663666011563&#39;) format(&#39;woff2&#39;),\n       url(&#39;&#x2F;&#x2F;at.alicdn.com&#x2F;t&#x2F;c&#x2F;font_3660333_clz5n3z0jtw.woff?t&#x3D;1663666011563&#39;) format(&#39;woff&#39;),\n       url(&#39;&#x2F;&#x2F;at.alicdn.com&#x2F;t&#x2F;c&#x2F;font_3660333_clz5n3z0jtw.ttf?t&#x3D;1663666011563&#39;) format(&#39;truetype&#39;);\n&#125;\n\n.iconfont &#123;\n  font-family: &quot;iconfont&quot; !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n&#125;\n\n.icon-cart:before &#123;\n  content: &quot;\\e600&quot;;\n&#125;\n\n.icon-category:before &#123;\n  content: &quot;\\e601&quot;;\n&#125;\n\n.icon-home:before &#123;\n  content: &quot;\\e602&quot;;\n&#125;\n\n.icon-user:before &#123;\n  content: &quot;\\e75d&quot;;\n&#125;\n\n\n\niconfont原生的用法\n&lt;i class&#x3D;&quot;iconfont icon-cart&quot;&gt;&lt;&#x2F;i&gt;\n考虑将图标和属性关联, 将代码改造成动态绑定\n&lt;i :class&#x3D;&quot;[&#39;iconfont&#39;, &#39;icon-&#39; + icon]&quot; &#x2F;&gt;\n\n3) 样式优化&lt;style&gt;\n@import &#39;http:&#x2F;&#x2F;at.alicdn.com&#x2F;t&#x2F;c&#x2F;font_3660333_clz5n3z0jtw.css&#39;;\n\n.tab-bar-item &#123;\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n\n  font-size: 12px;\n  color: #fff;\n&#125;\n.tab-bar-item i &#123;\n  font-size: 18px;\n&#125;\n&lt;&#x2F;style&gt;\n\n2 点击高亮\n1) 声明变量在data中声明一个变量active: 表示当前元素是否高亮\n\ntrue: 高亮 – 加上current样式\n\nfalse: 不高亮 – 不加current样式\ndata() &#123;\n  return &#123;\n    active: false,\n  &#125;\n&#125;,\n\n2) 绑定点击事件给子组件的根节点, 绑定click事件\n&lt;template&gt;\n  &lt;div @click&#x3D;&quot;handleClick&quot;&gt;\n    &lt;!-- 使用iconfont --&gt;\n    &lt;!-- &lt;i class&#x3D;&quot;iconfont icon-cart&quot;&gt;&lt;&#x2F;i&gt; --&gt;\n    &lt;i :class&#x3D;&quot;[&#39;iconfont&#39;, &#39;icon-&#39; + icon]&quot; &#x2F;&gt;\n    &lt;div&gt;\n      &lt;slot&gt;&lt;&#x2F;slot&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n在methods中声明handleClick方法\nmethods: &#123;\n  handleClick() &#123;\n    this.active &#x3D; true\n  &#125;,\n&#125;,\n\n3) 动态绑定样式&lt;template&gt;\n  &lt;div :class&#x3D;&quot;[&#39;tab-bar-item&#39;, active ? &#39;current&#39; : &#39;&#39;]&quot; @click&#x3D;&quot;handleClick&quot;&gt;\n    &lt;!-- 使用iconfont --&gt;\n    &lt;!-- &lt;i class&#x3D;&quot;iconfont icon-cart&quot;&gt;&lt;&#x2F;i&gt; --&gt;\n    &lt;i :class&#x3D;&quot;[&#39;iconfont&#39;, &#39;icon-&#39; + icon]&quot; &#x2F;&gt;\n    &lt;div&gt;\n      &lt;slot&gt;&lt;&#x2F;slot&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n3 通过TabBar控制高亮显示\n1) 声明属性给TabBar传递一个value属性: 控制子项的高亮显示\n\nvalue=0: 第0项高亮\n\nvalue=1: 第1项高亮\n\n\n在&lt;tab-bar&gt;渲染时, 传入value属性值\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;!-- 引用组件 --&gt;\n    &lt;tab-bar :value&#x3D;&quot;active&quot;&gt;\n      &lt;!-- 通过列表渲染来控制TabBar中的子项 --&gt;\n      &lt;!-- &lt;div class&#x3D;&quot;tab-bar-item&quot; v-for&#x3D;&quot;(tab, index) in tabs&quot; :key&#x3D;&quot;index&quot;&gt;\n        &#123;&#123; tab &#125;&#125;\n      &lt;&#x2F;div&gt; --&gt;\n\n      &lt;tab-bar-item icon&#x3D;&quot;home&quot;&gt;首页&lt;&#x2F;tab-bar-item&gt;\n      &lt;tab-bar-item icon&#x3D;&quot;category&quot;&gt;分类&lt;&#x2F;tab-bar-item&gt;\n      &lt;tab-bar-item icon&#x3D;&quot;cart&quot;&gt;购物车&lt;&#x2F;tab-bar-item&gt;\n      &lt;tab-bar-item&gt;我的&lt;&#x2F;tab-bar-item&gt;\n    &lt;&#x2F;tab-bar&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n在App.vue的data中, 声明active属性\ndata() &#123;\n  return &#123;\n    tabs: [&#39;首页&#39;, &#39;分类&#39;, &#39;购物车&#39;, &#39;我的&#39;],\n    active: 0,\n  &#125;\n&#125;,\n\n2) 接收value值在TabBar组件中接收value值\nprops: &#123;\n  value: &#123;\n    type: Number,\n    default: 0,\n  &#125;,\n&#125;,\n\n3) 监听value的变化watch: &#123;\n  value: function () &#123;\n    this.$children.forEach((item, index) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; console.log(item)\n      &#x2F;&#x2F; if (index &#x3D;&#x3D; this.value) &#123;\n      &#x2F;&#x2F;   item.active &#x3D; true\n      &#x2F;&#x2F; &#125; else &#123;\n      &#x2F;&#x2F;   item.active &#x3D; false\n      &#x2F;&#x2F; &#125;\n      item.active &#x3D; index &#x3D;&#x3D; this.value\n    &#125;)\n  &#125;,\n&#125;,\n\n4) 实现点击切换在TabBarItem组件中监听点击事件\n\n计算当前点击组件的index下标\n触发自定义事件, 将index传递给父组件handleClick() &#123;\n    this.active &#x3D; true\n    &#x2F;&#x2F; this.$parent -- 当前组件的父组件实例对象\n    &#x2F;&#x2F; this.$children -- 当前组件的子组件实例数组\n    &#x2F;&#x2F; console.log(this.$parent.$children)\n\n    &#x2F;&#x2F; this当前点击的itme子组件.\n    &#x2F;&#x2F; indexOf: 找到当前子组件在数组中的下标\n    const index &#x3D; this.$parent.$children.indexOf(this)\n    &#x2F;&#x2F; 不推荐使用\n    &#x2F;&#x2F; this.$parent.value &#x3D; index\n    this.$parent.$emit(&#39;input&#39;, index)\n  &#125;,\n在App.vue中监听TabBar的input事件&lt;tab-bar :value&#x3D;&quot;active&quot; @input&#x3D;&quot;handleChange&quot;&gt;\n定义handleChange方法methods: &#123;\n  handleChange(n) &#123;\n    this.active &#x3D; n\n  &#125;,\n&#125;,\n5) 在组件中应用v-modelv-model是简写\n\n\n绑定了value属性\n监听了input事件\n\n就可以简写成v-model\n&lt;tab-bar v-model&#x3D;&quot;active&quot;&gt;\n\n6) 优化由于我们希望v-model可以自定义绑定的属性和监听的事件考虑在TabBar组件上配置model选项\nmodel: &#123;\n  &#x2F;&#x2F; v-model的自定义\n  prop: &#39;value&#39;, &#x2F;&#x2F; 绑定value属性\n  event: &#39;change&#39;, &#x2F;&#x2F; 监听change事件\n&#125;,\n加上model配置选后,\n&lt;tab-bar v-model&#x3D;&quot;active&quot;&gt;\n&#x2F;&#x2F; 就是如下的简写\n&lt;tab-bar :value&#x3D;&quot;active&quot; @change&#x3D;&quot;handleChange&quot;&gt;\n在点击TabBarItem时, 触发change事件\nhandleClick() &#123;\n    this.active &#x3D; true\n    &#x2F;&#x2F; this.$parent -- 当前组件的父组件实例对象\n    &#x2F;&#x2F; this.$children -- 当前组件的子组件实例数组\n    &#x2F;&#x2F;console.log(this.$parent.$children)\n\n    &#x2F;&#x2F; this当前点击的itme子组件.\n    &#x2F;&#x2F; indexOf: 找到当前子组件在数组中的下标\n    const index &#x3D; this.$parent.$children.indexOf(this)\n    &#x2F;&#x2F; 不推荐使用\n    &#x2F;&#x2F; this.$parent.value &#x3D; index\n    this.$parent.$emit(&#39;change&#39;, index)\n  &#125;,\n\n4 实现点击切换页面\n1) 创建页面组件在views目录下, 创建4个页面组件\n\nHome.vue\nCategory.vue\nCart.vue\nUser.vue&lt;template&gt;\n  &lt;div&gt;首页&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Home&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n&lt;template&gt;\n  &lt;div&gt;分类&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Category&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n&lt;template&gt;\n  &lt;div&gt;购物车&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Cart&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n&lt;template&gt;\n  &lt;div&gt;个人中心&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;User&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n2) 导入组件在App.vue中导入组件import Home from &#39;.&#x2F;views&#x2F;Home.vue&#39;\nimport Category from &#39;.&#x2F;views&#x2F;Category.vue&#39;\nimport Cart from &#39;.&#x2F;views&#x2F;Cart.vue&#39;\nimport User from &#39;.&#x2F;views&#x2F;User.vue&#39;\n3) 挂载组件在components选项中挂载components: &#123;\n  TabBar,\n  TabBarItem,\n  Home,\n  Category,\n  Cart,\n  User,\n&#125;,\n4) 使用动态组件在App.vue的模板中, 使用动态组件&lt;component :is&#x3D;&quot;views[active]&quot;&gt;&lt;&#x2F;component&gt;\n声明views数组data() &#123;\n  return &#123;\n    tabs: [&#39;首页&#39;, &#39;分类&#39;, &#39;购物车&#39;, &#39;我的&#39;],\n    views: [&#39;Home&#39;, &#39;Category&#39;, &#39;Cart&#39;, &#39;User&#39;],\n    active: 0,\n  &#125;\n&#125;,\n\n","slug":"实战TabBar封装_new","date":"2022-12-02T11:52:41.705Z","categories_index":"Vue","tags_index":"Vue2进阶","author_index":"团子"},{"id":"141d74db3507b33722aa9abc90347af3","title":"五. 插槽","content":"\n1 概述\n1) 什么是 slotslot 可以理解为预留了一个可替换的地方\n游戏卡是可以插拔的, 插游戏卡的地方就是一个插槽\n\n\n\n\n\n\n\n\n\n思考\n游戏卡插槽有什么作用?再比如, USB 接口也可以看成一个插槽. 可以插入 U 盘, 硬盘, 鼠标, 键盘…\n\n还有, CPU 槽, 内存槽. 他们的存在有什么共同点??\n\n2) 为什么需要 slot通过上面的例子, 我们可以看出\n\n通过插不同的游戏卡, 可以玩不同的游戏\n通过插不同的外设, 可以扩展电脑的功能\n通过插不同型号的 CPU(i3/i5/i7/i9), 可以更换 CPU\n\n:::info插槽最主要的作用是提供扩展性.:::\n3) Vue 中的 slot在 Vue 开发中, slot 主要应用在组件开发中, 通过在组件中预留 slot, 实现不同的功能\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;son&gt;&lt;&#x2F;son&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;template id&#x3D;&quot;tmp&quot;&gt;\n      &lt;div&gt;我是子组件&lt;&#x2F;div&gt;\n    &lt;&#x2F;template&gt;\n\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        components: &#123;\n          son: &#123;\n            template: &#39;#tmp&#39;,\n          &#125;,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n子组件的模板编译后, 会替换&lt;son&gt;所在的地方\n\n但是, 不管在&lt;son&gt;中添加任何内容, 都不起作用~\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;son&gt;\n    &lt;!-- 在子组件里写的内容不会生效 --&gt;\n    &lt;h2&gt;我是子组件的标题&lt;&#x2F;h2&gt;\n  &lt;&#x2F;son&gt;\n&lt;&#x2F;div&gt;\n\n这样, 子组件的可扩展性就很不好. 如果希望子组件中的内容可以替换怎么办??\n在子组件中预留一个插槽, 通过给子组件传递不同的内容来改变子组件\n\n2 具名插槽\n1) 作用如果需要同时使用多个插槽, 就需要给插槽取名字.就好比: 主板上同时有 CPU 槽和内存槽, 如何区分这两个插槽, 不至于把内存插到 CPU 中\n\n\n\n\n\n\n\n\n\n当然, 现实中肯定不会, 但是程序中就需要使用名字区分开\n\n2) 使用\n在子组件中, 定义具名插槽\n在引用子组件时, 通过slot属性指定要替换的插槽&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;son&gt;\n    &lt;div slot&#x3D;&quot;cpu&quot;&gt;我是CPU&lt;&#x2F;div&gt;\n    &lt;div slot&#x3D;&quot;memery&quot;&gt;我是内存&lt;&#x2F;div&gt;\n  &lt;&#x2F;son&gt;\n&lt;&#x2F;div&gt;\n\n&lt;template id&#x3D;&quot;tmp&quot;&gt;\n  &lt;div&gt;\n    &lt;slot name&#x3D;&quot;cpu&quot;&gt;&lt;&#x2F;slot&gt;\n    &lt;slot name&#x3D;&quot;memery&quot;&gt;&lt;&#x2F;slot&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n在vue2.6以后的版本, 废弃了slot属性的写法, 改为v-slot指令&lt;the-demo&gt;\n  &lt;!-- 自2.6以后, 使用template + v-slot指令 --&gt;\n  &lt;template v-slot:cpu&gt;\n    &lt;div&gt;我是cpu&lt;&#x2F;div&gt;\n  &lt;&#x2F;template&gt;\n  &lt;!-- v-slot: 可以简写成 # --&gt;\n  &lt;template #memery&gt;\n    &lt;div&gt;我是内存&lt;&#x2F;div&gt;\n  &lt;&#x2F;template&gt;\n&lt;&#x2F;the-demo&gt;\n\n没有指定的内容会全部放到&lt;slot&gt;中, 也就是默认插槽\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;son&gt;\n    &lt;div slot&#x3D;&quot;cpu&quot;&gt;我是CPU&lt;&#x2F;div&gt;\n    &lt;div slot&#x3D;&quot;memery&quot;&gt;我是内存&lt;&#x2F;div&gt;\n    &lt;hr &#x2F;&gt;\n    &lt;div&gt;我是剩余的内容&lt;&#x2F;div&gt;\n    &lt;p&gt;我也是...&lt;&#x2F;p&gt;\n  &lt;&#x2F;son&gt;\n&lt;&#x2F;div&gt;\n\n&lt;template id&#x3D;&quot;tmp&quot;&gt;\n  &lt;div&gt;\n    &lt;slot name&#x3D;&quot;cpu&quot;&gt;&lt;&#x2F;slot&gt;\n    &lt;slot name&#x3D;&quot;memery&quot;&gt;&lt;&#x2F;slot&gt;\n    &lt;!-- slot其实也有名字, 名字是default --&gt;\n    &lt;slot&gt;&lt;&#x2F;slot&gt;\n    &lt;slot name&#x3D;&quot;default&quot;&gt;&lt;&#x2F;slot&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n\n3 作用域插槽\n1) 编译作用域在 Vue 编译的过程中, 如果父子组件中定义的相同的状态, 会不会冲突呢?如果不会冲突, 具体访问的是哪个状态呢\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;button v-show&#x3D;&quot;isShow&quot;&gt;按钮&lt;&#x2F;button&gt;\n      &lt;son&gt;&lt;&#x2F;son&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;template id&#x3D;&quot;tmp&quot;&gt;\n      &lt;div&gt;\n        &lt;h3&gt;我是子组件&lt;&#x2F;h3&gt;\n        &lt;button v-show&#x3D;&quot;isShow&quot;&gt;子组件按钮&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;template&gt;\n\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          isShow: false,\n        &#125;,\n        components: &#123;\n          son: &#123;\n            template: &#39;#tmp&#39;,\n            data() &#123;\n              return &#123;\n                isShow: true,\n              &#125;\n            &#125;,\n          &#125;,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n父组件和子组件中都存在isShow.\n\n如果在父模板中使用 isShow, 访问的是父组件data中的值\n如果在子模板中使用 isShow, 访问的是子组件data中的值\n\n通过上述示例, 我们可以发现, 在父组件中是不能直接访问子组件中的状态的.\n\n\n\n\n\n\n\n\n\n需求\n\n在父模板中可定制子组件的内容\n同时使用子组件中的数据2) 为什么需要作用域插槽为了解决上述问题, 引入了作用域插槽的概念, 其核心是在父模板中访问子组件的数据\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;button v-show&#x3D;&quot;isShow&quot;&gt;按钮&lt;&#x2F;button&gt;\n  &lt;!-- 通过v-slot指令找名字为default的插槽, 并指定prop对象对应default插槽 --&gt;\n  &lt;son v-slot:default&#x3D;&quot;prop&quot;&gt;\n    &lt;!-- 通过prop对象访问show属性, 相当于访问了子组件的isShow --&gt;\n    &lt;button v-show&#x3D;&quot;prop.show&quot;&gt;子组件按钮&lt;&#x2F;button&gt;\n  &lt;&#x2F;son&gt;\n&lt;&#x2F;div&gt;\n\n&lt;template id&#x3D;&quot;tmp&quot;&gt;\n  &lt;div&gt;\n    &lt;h3&gt;我是子组件&lt;&#x2F;h3&gt;\n    &lt;!-- 在slot:default对象中, 定义自定义属性show --&gt;\n    &lt;slot :show&#x3D;&quot;isShow&quot;&gt;&lt;&#x2F;slot&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n其中, v-slot可以使用#简写\n&lt;!-- 通过v-slot指令找名字为default的插槽, 并指定prop对象对应default插槽 --&gt;\n&lt;son #default&#x3D;&quot;prop&quot;&gt;\n  &lt;!-- 通过prop对象访问show属性, 相当于访问了子组件的isShow --&gt;\n  &lt;button v-show&#x3D;&quot;prop.show&quot;&gt;子组件按钮&lt;&#x2F;button&gt;\n&lt;&#x2F;son&gt;\n\n通过同时有多个插槽, 需要借用&lt;template&gt;语法\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;button v-show&#x3D;&quot;isShow&quot;&gt;按钮&lt;&#x2F;button&gt;\n      &lt;!-- 通过v-slot指令找名字为default的插槽, 并指定prop对象对应default插槽 --&gt;\n      &lt;son&gt;\n        &lt;template #default&#x3D;&quot;prop&quot;&gt;\n          &lt;!-- 通过prop对象访问show属性, 相当于访问了子组件的isShow --&gt;\n          &lt;button v-show&#x3D;&quot;prop.show&quot;&gt;子组件按钮&lt;&#x2F;button&gt;\n        &lt;&#x2F;template&gt;\n        &lt;template #left&#x3D;&quot;left&quot;&gt;\n          &lt;h3&gt;&#123;&#123;left.info.name&#125;&#125;&lt;&#x2F;h3&gt;\n        &lt;&#x2F;template&gt;\n      &lt;&#x2F;son&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;template id&#x3D;&quot;tmp&quot;&gt;\n      &lt;div&gt;\n        &lt;h3&gt;我是子组件&lt;&#x2F;h3&gt;\n        &lt;!-- 在slot:default对象中, 定义自定义属性show --&gt;\n        &lt;slot :show&#x3D;&quot;isShow&quot;&gt;&lt;&#x2F;slot&gt;\n        &lt;slot name&#x3D;&quot;left&quot; :info&#x3D;&quot;stu&quot;&gt;&lt;&#x2F;slot&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;template&gt;\n\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          isShow: false,\n        &#125;,\n        components: &#123;\n          son: &#123;\n            template: &#39;#tmp&#39;,\n            data() &#123;\n              return &#123;\n                isShow: true,\n                stu: &#123;\n                  name: &#39;xiaoming&#39;,\n                  age: 18,\n                &#125;,\n              &#125;\n            &#125;,\n          &#125;,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3) 示例:::warning需求在父组件的模板中, 访问子组件中的变量:::\n完成Vue的三步曲&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n创建子组件\n创建组件对象\n挂载子组件\n引用子组件&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;style&gt;\n      #app &#123;\n        background-color: pink;\n      &#125;\n      .son &#123;\n        background-color: skyblue;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 需求: 在父组件的模板中, 访问到子组件的变量 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      父组件:\n      &lt;son&gt;&#123;&#123;user.username&#125;&#125;&lt;&#x2F;son&gt;\n      父组件\n    &lt;&#x2F;div&gt;\n    \n    &lt;template id&#x3D;&quot;tmp&quot;&gt;\n      &lt;div class&#x3D;&quot;son&quot;&gt;\n        &lt;hr &#x2F;&gt;\n        &lt;h3&gt;子组件&lt;&#x2F;h3&gt;\n        &lt;slot&gt;&lt;&#x2F;slot&gt;\n        &lt;hr &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;template&gt;\n    \n    &lt;script&gt;\n      &#x2F;&#x2F; 定义子组件对象\n      const son &#x3D; &#123;\n        template: &#39;#tmp&#39;,\n        data() &#123;\n          return &#123;\n            user: &#123;\n              id: 1,\n              username: &#39;小明&#39;,\n            &#125;,\n          &#125;\n        &#125;,\n      &#125;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        components: &#123;\n          son: son,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n正常情况下, 父组件的模板中不同直接使用子组件的变量如果非有使用, 报错如下\n\n\n\n\n\n\n\n\n原因\n\n\n在父组件的模板中, 只能使用父组件data中的数据\n\n\n\n\n\n\n\n\n\n解决方案\n\n在子组件的slot中定义一个 自定义属性row(名字可以随便)\n自定义属性绑定子组件data中的一个变量\n在父组件的模板中, 得到slot对象, 进一步访问slot对象上的自定义属性\n\n此时, aaa.row相当于子组件中的user\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;style&gt;\n      #app &#123;\n        background-color: pink;\n      &#125;\n      .son &#123;\n        background-color: skyblue;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 需求: 在父组件的模板中, 访问到子组件的变量 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      父组件:\n      &lt;son&gt;\n        &lt;!-- 绑定的aaa, 是一个变量. 变量表示 slot 对应的对象\n          可以通过对象名aaa访问自定义的属性, 比如aaa.row\n          自定义属性row, 跟子组件data中的user绑定的\n        --&gt;\n        &lt;template v-slot:default&#x3D;&quot;aaa&quot;&gt; &#123;&#123;aaa.row.id&#125;&#125; &lt;&#x2F;template&gt;\n\n        &lt;!-- v-slot:default 可以简写为 v-slot --&gt;\n        &lt;template v-slot&#x3D;&quot;users&quot;&gt; &#123;&#123;users.row.id&#125;&#125; &lt;&#x2F;template&gt;\n      &lt;&#x2F;son&gt;\n      父组件\n    &lt;&#x2F;div&gt;\n\n    &lt;template id&#x3D;&quot;tmp&quot;&gt;\n      &lt;div class&#x3D;&quot;son&quot;&gt;\n        &lt;hr &#x2F;&gt;\n        &lt;h3&gt;子组件&lt;&#x2F;h3&gt;\n        &lt;!-- 1. 给slot绑定自定义的属性 --&gt;\n        &lt;slot :row&#x3D;&quot;user&quot;&gt;&lt;&#x2F;slot&gt;\n        &lt;hr &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;template&gt;\n\n    &lt;script&gt;\n      &#x2F;&#x2F; 定义子组件对象\n      const son &#x3D; &#123;\n        template: &#39;#tmp&#39;,\n        data() &#123;\n          return &#123;\n            user: &#123;\n              id: 1,\n              username: &#39;小明&#39;,\n            &#125;,\n            field: &#39;姓名&#39;,\n          &#125;\n        &#125;,\n      &#125;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        components: &#123;\n          son: son,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n","slug":"五. 插槽","date":"2022-12-02T11:44:24.711Z","categories_index":"Vue","tags_index":"Vue2进阶","author_index":"团子"},{"id":"40c5fb96f20693947ff90483be3668ec","title":"扩展线上部署静态页面","content":"\n一. 项目打包在项目目录执行\nnpm run build\n会生成dist目录, 在dist目录下, 就是我们要上传到线上的文件\n二. 部署\n1 注册登录腾讯云略\n2 创建cos!\nimage.png\n3 上传打包文件\n4 设置静态网站\n","slug":"补充线上部署静态页面_new","date":"2022-12-02T11:39:28.712Z","categories_index":"补充","tags_index":"腾讯云cos","author_index":"团子"},{"id":"64c0c0bccb71428e518fe1fe8d784a6b","title":"补充Axios的使用","content":"官方文档\n一. 安装npm install axios\n安装axios库, 可以在浏览器和node环境使用.主要用于发送HTTP请求, 返回promise对象\n\nget\npost\nput\ndelete二. 快速上手1 步骤\n\n\n引入axios.js\n创建axios实例\n发送请求2 示例&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;axios&#x2F;dist&#x2F;axios.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script&gt;\n      console.log(axios)\n\n      &#x2F;&#x2F; axios可以直接调用get&#x2F;post方法\n      axios.get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;todos&#39;).then((res) &#x3D;&gt; &#123;\n        console.log(res)\n      &#125;)\n\n      &#x2F;&#x2F; 通过axios.create()创建实例\n      const instance &#x3D; axios.create()\n      instance.get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;todos&#39;).then((res) &#x3D;&gt; &#123;\n        console.log(res)\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n3 图解三. 发送带参数的GET请求GET请求分为两种\n\n\n动态参数\n查询字符串&#x2F;&#x2F; 动态参数\nGET http:&#x2F;&#x2F;localhost:3000&#x2F;todos&#x2F;1\n&#x2F;&#x2F; 查询字符串\nGET http:&#x2F;&#x2F;localhost:3000&#x2F;todos?content&#x3D;abc&amp;time&#x3D;2022\n\n\n\n\n\n\n\n\n\n示例\n\n\naxios.get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;todos&#x2F;3&#39;).then((res) &#x3D;&gt; &#123;\n  console.log(res)\n&#125;)\naxios\n  .get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;todos&#39;, &#123;\n    params: &#123;\n      name: &#39;xiaoming&#39;,\n      age: 20,\n    &#125;,\n  &#125;)\n  .then((res) &#x3D;&gt; &#123;\n    console.log(res)\n  &#125;)\n\n四. 发送post请求post请求的参数放在请求体中\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 对于post, put, patch存在请求体\n&#x2F;&#x2F; 第一个参数: url\n&#x2F;&#x2F; 第二个参数: 请求体参数\naxios\n  .post(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;todos&#39;, &#123;\n    content: &#39;test&#39;,\n    completed: 0,\n  &#125;)\n  .then((res) &#x3D;&gt; &#123;\n    console.log(res)\n  &#125;)","slug":"补充.Axios的使用_new","date":"2022-12-02T11:32:58.850Z","categories_index":"补充","tags_index":"axios","author_index":"团子"},{"id":"2f3a385f9a8a16e29dda76e13810d322","title":"四. 综合项目[vue-todo]","content":"\n一. 搭建项目\n1 使用脚手架搭建项目通过vue create vue-todo创建一个项目\nvue create vue-todo\n\n\n\n2 启动项目进入到项目目录, 执行命令\nnpm run serve\n\n\n启动一个内置的调试web server(默认8080)\n支持热更新(实时改变代码, 重新编译)\n\n\n3 测试打开浏览器, 测试\n\n\n二. 项目分析\n\n\n\n\n\n\n\n\n组件化思想\nvue项目的一个重要的特点就是组件化的思想, 一个页面由多个组件组成, 组件再包含子组件\n\n\n1 组件的拆分\n主页拆分成3个组件\n\nMainHeader: 头部\nMainTodo: 主体 \nTodoItem\nTodoInfo\n\n\nMainFooter: 底部\n\n最终形成的组件树结构如下:\n\n\n2 实现整体结构\n1) 清理App.vue\n\n\n\n\n\n\n\n\n\n示例\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123;&#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;stylus&quot;&gt;&lt;&#x2F;style&gt;\n\n\n2) 创建子组件创建App.vue的子组件\n\nMainHeader\nMainTodo\nMainFooter\n\n在components目录下, 创建三个文件\n\n\n\n\n\n\n\n\n\nMainHeader.vue\n&lt;template&gt;\n  &lt;div&gt;头部&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;MainHeader&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n\nMainTodo.vue\n&lt;template&gt;\n  &lt;div&gt;主体&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;MainTodo&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n\nMainFooter\n&lt;template&gt;\n  &lt;div&gt;底部&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;MainFooter&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n3) 挂载子组件在App.vue文件中\n\n导入组件对象\n挂载组件对象\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;script&gt;\n&#x2F;&#x2F; 导入组件对象\n&#x2F;&#x2F; 打包工具允许不写后缀(支持的后缀js, mjs, vue)\nimport MainHeader from &#39;.&#x2F;components&#x2F;MainHeader&#39;\nimport MainTodo from &#39;.&#x2F;components&#x2F;MainTodo&#39;\nimport MainFooter from &#39;.&#x2F;components&#x2F;MainFooter&#39;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  &#x2F;&#x2F; 挂载组件\n  components: &#123;\n    &#x2F;&#x2F; 属性名(组件名): 属性值(组件对象)\n    MainHeader: MainHeader,\n    MainTodo: MainTodo,\n    MainFooter: MainFooter,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n\n风格指南\n\n组件文件的命名使用驼峰法, eg: MainHeader.vue\n组件对象的名称跟文件名保持一致, eg: &#123;name: &#39;MainHeader&#39;&#125;\n\n\n4) 引用子组件在App.vue中模板中引用三个子组件\n\n\n\n\n\n\n\n\n\n示例\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;!-- 引用组件 --&gt;\n    &lt;!-- &lt;MainHeader&gt;&lt;&#x2F;MainHeader&gt; --&gt;\n    &lt;!-- \n      更推荐在HTML模板中, 使用中横线的命名\n      将大写字母替换成-(中横线)\n      由来: 在HTML中, 标签名通常是小写字母\n     --&gt;\n    &lt;main-header&gt;&lt;&#x2F;main-header&gt;\n    &lt;main-todo&gt;&lt;&#x2F;main-todo&gt;\n    &lt;main-footer&gt;&lt;&#x2F;main-footer&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n\n\n\n\n\n\n\n\n\n风格指南\n\n在HTML模板中, 我们使用中横线的命名规范\n原因 \n在HTML中, 标签名通常是小写字母\n便于和HTML原生标签区分\n\n\n\n测试如下, 可以看到App的组件树\n\n\n3 优化\n1) 将文件改造成目录当一个组件比较复杂时, 通常把这个组件放到一个文件夹下, 文件名改成index.vue\n\n\n2) 创建子组件\n\n3) 完成子组件的挂载\n\n\n\n\n\n\n\n\nTodoItem.vue\n&lt;template&gt;\n  &lt;div&gt;--TodoItem&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;TodoItem&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n\nTodoInfo.vue\n&lt;template&gt;\n  &lt;div&gt;--TodoInfo&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;TodoInfo&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n挂载引用组件, 改造MainTodo/index.vue\n\n\n\n\n\n\n\n\n\n示例\n&lt;template&gt;\n  &lt;div&gt;\n    主体\n    &lt;todo-item&gt;&lt;&#x2F;todo-item&gt;\n    &lt;todo-info&gt;&lt;&#x2F;todo-info&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport TodoItem from &#39;.&#x2F;coms&#x2F;TodoItem&#39;\nimport TodoInfo from &#39;.&#x2F;coms&#x2F;TodoInfo&#39;\n\nexport default &#123;\n  name: &#39;MainTodo&#39;,\n  components: &#123;\n    TodoItem,\n    TodoInfo,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n测试\n\n三. 项目规范\n1 配色方案参考Google Material配置方案https://blog4xk-1309331490.cos.ap-nanjing.myqcloud.com/markdown/www.materialpalette.com\n2 安装两个vscode插件\nstylus格式化工具\nstylus编译工具\n\n\n\n3. 加载背景图片\n1) 编写reset样式在assets目录创建styles\\reset.styl文件\n*\n  margin: 0\n  padding: 0\n\nbody\n  font: 14px &#39;Microsoft Yahei&#39;\n  &#x2F;&#x2F; 背景图片\n  &#x2F;&#x2F; style文件在的相对路径, 相对于当前的reset.styl这个文件\n  background-image: url(&#39;..&#x2F;images&#x2F;bg.jpg&#39;)\n  &#x2F;&#x2F; 背景图片位置固定\n  background-attachment: fixed\n  &#x2F;&#x2F; 背景不要重复\n  background-repeat: no-repeat\n  &#x2F;&#x2F; 背景位置居中\n  background-position: center center\n  &#x2F;&#x2F; 背景覆盖整个viewport\n  background-size: cover\n  &#x2F;&#x2F; 当背景没有加载时的颜色\n  background-color: #fff\n这里url中的相对路径是相对于reset.styl这个文件\n2) 加载到项目中在App.vue中, 使用@import加载reset.styl文件\n&lt;style lang&#x3D;&quot;stylus&quot;&gt;\n&#x2F;&#x2F; 在vue项目不推荐使用相对路径\n@import &#39;.&#x2F;assets&#x2F;styles&#x2F;reset.styl&#39;\n&lt;&#x2F;style&gt;\n这里的相对路径是相对App.vue但是, 由于在vue项目相对路径容易出错, 不推荐直接使用相对路径推荐使用路径别名, 参考Vue-cli的官方配置\n\n\n\n\n\n\n\n\n\n测试效果\n\n\n四. 实现MainHeader组件\n1 页面部分编写template模板内容\n&lt;template&gt;\n  &lt;header class&#x3D;&quot;main-header&quot;&gt;\n    &lt;h1&gt;TodoList&lt;&#x2F;h1&gt;\n  &lt;&#x2F;header&gt;\n&lt;&#x2F;template&gt;\n\n\n2 样式部分&lt;style lang&#x3D;&quot;stylus&quot;&gt;\n  .main-header\n    text-align: center\n    h1\n      margin: 20px\n      font-size: 100px\n      font-weight: 200\n      color: rgb(252, 157, 154)\n      &#x2F;&#x2F; 给文字阴影\n      text-shadow: 5px 5px 5px rgba(0, 0, 0, 0.1)\n&lt;&#x2F;style&gt;\n\n\n1) 优化在styles目录创建theme.styl, 在主题文件中, 定义颜色变量\n&#x2F;&#x2F; 主题颜色(变量)\n$red &#x3D; rgb(254, 67, 101)\n$lightred &#x3D; rgb(252, 157, 154)\n$yellow &#x3D; rgb(249, 205, 173)\n$ligthgreen &#x3D; rgb(200, 200, 169)\n$green &#x3D; rgb(131, 175, 155)\n\n在需要使用颜色时, 引用主题文件, 应用变量\n&lt;style lang&#x3D;&quot;stylus&quot;&gt;\n@import &#39;..&#x2F;assets&#x2F;styles&#x2F;theme.styl&#39;\n\n.main-header\n  text-align: center\n  h1\n    margin: 20px\n    font-size: 100px\n    font-weight: 200\n    color: $lightred\n    &#x2F;&#x2F; 给文字阴影\n    text-shadow: 5px 5px 5px rgba(0, 0, 0, 0.1)\n&lt;&#x2F;style&gt;\n\n\n五. 初步实现MainTodo组件\n1 核心组件的拆分大致可以拆分成如下部分\n\ninput输入框\n多个TodoItem组件\n一个TodoInfo组件\n\n\n2 页面部分&lt;template&gt;\n  &lt;div class&#x3D;&quot;main-todo&quot;&gt;\n    &lt;input class&#x3D;&quot;add-todo&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;what to do?↵&quot; autofocus &#x2F;&gt;\n    &lt;todo-item&gt;&lt;&#x2F;todo-item&gt;\n    &lt;todo-info&gt;&lt;&#x2F;todo-info&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n\n3 样式部分\n1) 整体的盒子样式&lt;style lang&#x3D;&quot;stylus&quot;&gt;\n  .main-todo\n    width: 600px\n    margin: 0 auto\n    background-color: #fff\n    box-shadow: 0 0 5px #666\n&lt;&#x2F;style&gt;\n\n\n2) 输入框的美化&lt;style lang&#x3D;&quot;stylus&quot;&gt;\n  .main-todo\n    width: 600px\n    margin: 0 auto\n    background-color: #fff\n    box-shadow: 0 0 5px #666\n    .add-todo\n      padding: 16px 16px 16px 36px\n      font-size: 24px\n      font-family: inherit &#x2F;&#x2F; ?? 加入inherit可以实现文字变细\n      font-weight: 200\n      border: none\n      outline: none\n&lt;&#x2F;style&gt;\n\n\n3) 效果优化&lt;style lang&#x3D;&quot;stylus&quot;&gt;\n.main-todo\n  width: 600px\n  margin: 0 auto\n  background-color: rgba(255, 255, 255, 0.3)\n  border-radius: 5px\n  box-shadow: 3px 3px 5px #666\n  .add-todo\n    padding: 16px 16px 16px 36px\n    width: 100%\n    background-color: rgba(255, 255, 255, 0.3)\n    font-size: 24px\n    font-family: inherit\n    font-weight: 200\n    border: none\n    outline: none\n    border-radius: 5px 5px 0 0\n    box-sizing: border-box\n&lt;&#x2F;style&gt;\n\n\n六. 实现TodoItem组件\n1 页面部分&lt;template&gt;\n  &lt;div&gt;\n    &lt;input type&#x3D;&quot;checkbox&quot; &#x2F;&gt;\n    &lt;label&gt;待办1&lt;&#x2F;label&gt;\n    &lt;button&gt;&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n\n2 样式部分\n\n\n\n\n\n\n\n\n分析\n\ncheckbox如何美化\nbutton如何美化\n\n将浏览器自带的样式隐藏, 通过after伪元素添加对应的内容\n\n1) 整体的盒子样式&lt;style lang&#x3D;&quot;stylus&quot;&gt;\n  .todo-item\n    &#x2F;&#x2F; 使用flex布局\n    display: flex\n    &#x2F;&#x2F; 水平方向 flex项目的排列(两端对齐)\n    justify-content: space-between\n    align-items: center\n    padding: 10px\n    border-top: 1px solid rgba(0, 0, 0, 0.1)\n    font-size: 24px\n&lt;&#x2F;style&gt;\n\n\n2) checkbox美化隐藏浏览器自带的样式, 通过after伪元素添加对应的内容\n&lt;style lang&#x3D;&quot;stylus&quot;&gt;\n.todo-item\n  display: flex\n  justify-content: space-between\n  align-items: center\n  padding: 10px\n  border-top: 1px solid rgba(0, 0, 0, 0.1)\n  font-size: 24px\n  input[type&#x3D;&#39;checkbox&#39;]\n    &#x2F;&#x2F; 表单元素美化的原则: 去掉浏览器自带的样式, 使用自定义样式\n    width: 40px\n    height: 40px\n    border: none\n    outline: none\n    appearance: none\n    &#x2F;&#x2F; &amp;表示父元素\n    &amp;::after\n      content: url(&#39;..&#x2F;..&#x2F;..&#x2F;assets&#x2F;images&#x2F;unChecked.svg&#39;)\n    &amp;:checked::after\n      content: url(&#39;..&#x2F;..&#x2F;..&#x2F;assets&#x2F;images&#x2F;Checked.svg&#39;)\n&lt;&#x2F;style&gt;\n\n\n3) label的设置label占据所有剩余空间\nlabel\n    flex: 1\n    margin-left: 10px\n\n\n4) button的美化隐藏浏览器自带的样式\nbutton\n    width: 40px\n    height: 40px\n    appearance: none\n    border: none\n    outline: none\n    background-color: transparent\n    cursor: pointer\n&amp;:hover\n  button::after\n    content: &#39;×&#39;\n    font-size: 30px\n    color: $lightred\n\n当鼠标经过todo-item时, 显示button的伪元素\n&amp;:hover\n  button::after\n    content: &#39;x&#39;\n    font-size: 24px\n    color: $lightred\n\n\n\n\n\n\n\n\n\n\n完整示例\n&lt;style lang&#x3D;&quot;stylus&quot;&gt;\n@import &#39;..&#x2F;..&#x2F;..&#x2F;assets&#x2F;styles&#x2F;theme.styl&#39;\n\n.todo-item\n  display: flex\n  justify-content: space-between\n  align-items: center\n  padding: 10px\n  border-top: 1px solid rgba(0, 0, 0, 0.1)\n  font-size: 24px\n  input\n    appearance: none\n    border: none\n    outline: none\n    &amp;::after\n      content: url(&#39;..&#x2F;..&#x2F;..&#x2F;assets&#x2F;images&#x2F;unChecked.svg&#39;)\n    &amp;:checked::after\n      content: url(&#39;..&#x2F;..&#x2F;..&#x2F;assets&#x2F;images&#x2F;Checked.svg&#39;)\n  label\n    flex: 1\n    padding-left: 10px\n  button\n    width: 40px\n    height: 40px\n    background-color: transparent\n    appearance: none\n    border: none\n    outline: none\n    cursor: pointer\n  &amp;:hover\n    button::after\n      content: &#39;X&#39;\n      font-size: 24px\n      color: $lightred\n&lt;&#x2F;style&gt;\n\n3 优化\n1) 路径别名在项目的根目录下, 编辑vue.config.js配置文件\n在该配置文件中, 使用CommonJS规范, 最终导出一个对象\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 导入node的核心模块\nconst path &#x3D; require(&#39;path&#39;)\n&#x2F;&#x2F; 导入用户定义的模块\nconst &#123; defineConfig &#125; &#x3D; require(&#39;@vue&#x2F;cli-service&#39;)\n\n&#x2F;&#x2F; 导出配置对象\nmodule.exports &#x3D; defineConfig(&#123;\n  transpileDependencies: true,\n  chainWebpack: (config) &#x3D;&gt; &#123;\n    config.resolve.alias\n      .set(&#39;@&#39;, path.join(__dirname, &#39;.&#x2F;src&#39;))\n      .set(&#39;assets&#39;, path.join(__dirname, &#39;.&#x2F;src&#x2F;assets&#39;))\n      .set(&#39;images&#39;, path.join(__dirname, &#39;.&#x2F;src&#x2F;assets&#x2F;images&#39;))\n      .set(&#39;styles&#39;, path.join(__dirname, &#39;.&#x2F;src&#x2F;assets&#x2F;styles&#39;))\n  &#125;,\n&#125;)\n当修改了配置文件后, 重启项目\nnpm run serve\n\n2) 使用别名\n在HTML(template)和CSS(style)中, 加上~使用\n在js(script)中, 别名可以直接使用\n\n把之前使用相对路径的地方, 改造成别名\n\n3) CSS复用在styles目录下, 创建theme.styl文件\n$red &#x3D; #fe4365\n$lightred &#x3D; #fc9d9a\n$yellow &#x3D; #f9cdad\n$ligthgreen &#x3D; #c8c8a9\n$green &#x3D; #83af9b\n在需要使用颜色的文件中, 导入theme.styl, 使用变量\n&lt;style lang&#x3D;&quot;stylus&quot;&gt;\n@import &#39;~styles&#x2F;theme.styl&#39;\n\n.main-header\n  &#x2F;&#x2F; 让整个header区域的文本水平居中\n  text-align: center\n  &#x2F;&#x2F; 设置垂直方面的间距(类似垂直方向居中)\n  padding: 50px 0\n  h1\n    color: $lightred\n    font-size: 100px\n    font-weight: 200\n    text-shadow: 5px 5px 5px rgba(0, 0, 0, 0.5)\n&lt;&#x2F;style&gt;\n在styles目录下, 创建mixins.styl文件, 编写如下代码\n&#x2F;&#x2F; mixin: 混入(函数)\nclearDefault()\n  appearance: none\n  border: none\n  outline: none\n在需要复用的地方, 引用clearDefault\n在MainTodo/index.vue中\n&#x2F;&#x2F; 引入mixin文件\n@import &#39;~styles&#x2F;mixins.styl&#39;\n在MainTodo/TodoItem.vue文件\n&#x2F;&#x2F; 引入mixin文件\n@import &#39;~styles&#x2F;mixins.styl&#39;\n\n4 逻辑:::info\n\n由父组件决定渲染多少个子组件\n由父组件决定每个子组件中应该显示什么内容:::涉及到的核心知识点: 父组件向子组件传值\n\n\n1) 定义数据在父组件的data中声明数据\nexport default &#123;\n  name: &#39;MainTodo&#39;,\n  components: &#123;\n    TodoItem,\n    TodoInfo,\n  &#125;,\n  data() &#123;\n    return &#123;\n      todos: [\n        &#123; id: 1, content: &#39;待办1&#39;, completed: 0 &#125;,\n        &#123; id: 2, content: &#39;待办2&#39;, completed: 0 &#125;,\n        &#123; id: 3, content: &#39;待办3&#39;, completed: 0 &#125;,\n      ],\n    &#125;\n  &#125;,\n&#125;\n\n2) 渲染模板在MainTodo的模板中, 通过列表渲染子组件(TodoItem)\n&lt;todo-item v-for&#x3D;&quot;item in todos&quot; :key&#x3D;&quot;item.id&quot;&gt;&lt;&#x2F;todo-item&gt;\n\n3) 父组件向子组件传参:::info\n\n在父组件的模板中, 绑定一个自定义的属性\n在子组件的对象中, 通过props接收:::改造父组件MainTodo修改 模板渲染&lt;!-- 父组件-&gt;子组件传参\n  1. 在父组件的模板中, 绑定一个自定义的属性\n  2. 在子组件的对象中, 通过props接收\n --&gt;\n&lt;todo-item v-for&#x3D;&quot;item in todos&quot; :key&#x3D;&quot;item.id&quot; :todo&#x3D;&quot;item&quot;&gt;&lt;&#x2F;todo-item&gt;\n改造子组件TodoItem修改对象的定义export default &#123;\n  name: &#39;TodoItem&#39;,\n  props: &#123;\n    todo: &#123;\n      type: Object,\n      required: true,\n    &#125;,\n  &#125;,\n&#125;\n改造子组件TodoItem渲染模板&lt;template&gt;\n  &lt;div class&#x3D;&quot;todo-item&quot;&gt;\n    &lt;input type&#x3D;&quot;checkbox&quot; &#x2F;&gt;\n    &lt;label&gt;&#123;&#123; todo.content &#125;&#125;&lt;&#x2F;label&gt;\n    &lt;button&gt;&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n七. 实现后台接口复用之前写api接口准备数据vue_todos.sql&#x2F;*\nNavicat MySQL Data Transfer\n\nSource Server         : localhost\nSource Server Version : 50733\nSource Host           : localhost:3306\nSource Database       : db2103\n\nTarget Server Type    : MYSQL\nTarget Server Version : 50733\nFile Encoding         : 65001\n\nDate: 2022-04-15 16:16:10\n*&#x2F;\n\nSET FOREIGN_KEY_CHECKS&#x3D;0;\n\n-- ----------------------------\n-- Table structure for vue_todos\n-- ----------------------------\nDROP TABLE IF EXISTS &#96;vue_todos&#96;;\nCREATE TABLE &#96;vue_todos&#96; (\n  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,\n  &#96;content&#96; varchar(255) NOT NULL COMMENT &#39;内容&#39;,\n  &#96;completed&#96; tinyint(4) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;0: 未完成 1: 已完成&#39;,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;5 DEFAULT CHARSET&#x3D;utf8;\n\n-- ----------------------------\n-- Records of vue_todos\n-- ----------------------------\nINSERT INTO &#96;vue_todos&#96; VALUES (&#39;2&#39;, &#39;待办222&#39;, &#39;0&#39;);\nINSERT INTO &#96;vue_todos&#96; VALUES (&#39;3&#39;, &#39;111&#39;, &#39;0&#39;);\nINSERT INTO &#96;vue_todos&#96; VALUES (&#39;4&#39;, &#39;222&#39;, &#39;0&#39;);\n\n在Navicat软件中, 打开数据库-&gt;运行SQL文件详见&lt;todo小项目&gt;的后台搭建八. 实现列表功能在vue中发送ajax请求, 调用后端的接口\n\n:::info在Vue项目中, 一般使用axios库, 发送ajax请求:::\n1 安装插件使用axios, vue-axios库\n1) 安装npm i axios vue-axios\n\n2) 配置在main.js入口文件中. 配置插件\n&#x2F;&#x2F; 导入axios和vue-axios\nimport axios from &#39;axios&#39;\nimport VueAxios from &#39;vue-axios&#39; &#x2F;&#x2F; vue-axios是一个vue的插件\n\n&#x2F;&#x2F; 使用Vue插件\n&#x2F;&#x2F; 插件的作用: 在Vue的原型对象上, 挂载了属性 $http\nVue.use(VueAxios, axios)\n\n3) 测试&#x2F;&#x2F; 测试\nVue.$http.get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;todos&#39;).then((res) &#x3D;&gt; &#123;\n   console.log(res)\n&#125;)\n\n2 调用接口获取数据由于数据是由MainTodo组件维护, 那么在该组件中\n\n发送请求, 获取数据\n完成data属性的初始化\n\n选择使用created生命周期函数, 在这个函数中, 获取数据\nexport default &#123;\n  name: &#39;MainTodo&#39;,\n  components: &#123;\n    TodoItem,\n    TodoInfo,\n  &#125;,\n  data() &#123;\n    return &#123;\n      todos: [],\n    &#125;\n  &#125;,\n  created() &#123;\n    &#x2F;&#x2F; 在MainTodo组件被创建时, 自动执行\n    console.log(&#39;MainTodo被创建了...&#39;)\n    &#x2F;&#x2F; 发送ajax请求\n    this.$http.get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;todos&#39;).then((res) &#x3D;&gt; &#123;\n      console.log(res)\n      &#x2F;&#x2F; 解构res, 只关心data中的数据\n      const &#123; data &#125; &#x3D; res\n      if (data.code &#x3D;&#x3D; 0) &#123;\n        this.todos &#x3D; data.result\n      &#125;\n    &#125;)\n  &#125;,\n&#125;\n\n九. 实现添加功能\n\n\n\n\n\n\n\n\n具体需求\n\n输入内容, 按下回车键, 添加一条记录\n\n如果没有输入内容, 提示信息请输入内容\n\n添加完成后, 清空输入框\n\n\n\n\n\n\n\n\n\n思路\n\n监听input输入框keyup事件-&gt;判断enter键按下-&gt;调用handleAdd方法\n\n获取input输入框的数据(双向绑定)-&gt; 发送请求\n\n\n\n1) 实现模板声明一个变量, 实现数据的双向绑定content监听keyup事件, 绑定一个处理函数handleAdd\n&lt;input\n  class&#x3D;&quot;add-todo&quot;\n  type&#x3D;&quot;text&quot;\n  placeholder&#x3D;&quot;What to do↵&quot;\n  autofocus\n  v-model&#x3D;&quot;content&quot;\n  @keyup.enter&#x3D;&quot;handleAdd&quot;\n&#x2F;&gt;\n\n2) 声明变量data() &#123;\n  return &#123;\n    todos: [],\n    content: &#39;&#39;,\n  &#125;\n&#125;,\n\n3) 声明方法methods: &#123;\n    getTodos() &#123;\n      &#x2F;&#x2F; 发送ajax请求\n      this.$http.get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;todos&#39;).then((res) &#x3D;&gt; &#123;\n        console.log(res)\n        &#x2F;&#x2F; 解构res\n        const &#123; data &#125; &#x3D; res\n        if (data.code &#x3D;&#x3D; 0) &#123;\n          this.todos &#x3D; data.result\n        &#125;\n      &#125;)\n    &#125;,\n    handleAdd() &#123;\n      &#x2F;&#x2F; console.log(&#39;@@@&#39;, this.content)\n      &#x2F;&#x2F; 判断内容不能为空\n      if (this.content.trim() &#x3D;&#x3D; &#39;&#39;) &#123;\n        alert(&#39;请输入待办内容&#39;)\n        return\n      &#125;\n      &#x2F;&#x2F; 发送post请求\n      this.$http\n        .post(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;todos&#39;, &#123; content: this.content &#125;)\n        .then((res) &#x3D;&gt; &#123;\n          const &#123; code, message, result &#125; &#x3D; res.data\n\n          if (code &#x3D;&#x3D; 0) &#123;\n            &#x2F;&#x2F; 重新获取数据\n            this.getTodos()\n            &#x2F;&#x2F; 清空输入框\n            this.content &#x3D; &#39;&#39;\n          &#125;\n        &#125;)\n    &#125;,\n  &#125;,\n由于会经常调用获取数据, 因此, 封装成一个函数\n\n十. 实现修改功能:::warning需求\n\n点击选中按钮, 将按钮变为选中样式, 并且文本显示删除线\n\n再次点击选中按钮时, 将按钮变为未选中样式, 并且文本正常显示(没有删除线):::\n\n\n\n\n\n\n\n\n\n思路\n\n切换样式\n\n动态绑定样式\n\n\n在点击单选按钮时, 发送请求, 操作数据库\n\n\n\n1 实现子组件的双向绑定在子组件中\n\n绑定checkbox的checked属性\n监听checkbox的change方法\n\n\n1) template部分&lt;template&gt;\n  &lt;div class&#x3D;&quot;todo-item&quot;&gt;\n    &lt;!-- 实现checkbox的双向绑定 --&gt;\n    &lt;!-- 实现自定义v-model --&gt;\n    &lt;input type&#x3D;&quot;checkbox&quot; :checked&#x3D;&quot;todo.completed&quot; @change&#x3D;&quot;handleChange&quot; &#x2F;&gt;\n    &lt;label&gt;&#123;&#123; todo.content &#125;&#125;&lt;&#x2F;label&gt;\n    &lt;button&gt;&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n2) methods部分实现handleChange方法在该方法中\n\n触发自定义的事件toggle\n将当前修改 的todo项的id传递给父组件methods: &#123;\n  handleChange() &#123;\n    &#x2F;&#x2F; 触发自定义事件. 提交给父组件处理\n    &#x2F;&#x2F; 应用到的核心技术点: 子组件-&gt;父组件传值\n    this.$emit(&#39;toggle&#39;, this.todo.id)\n  &#125;,\n&#125;,\n:::info原因\n\n\n子组件的状态是由父组件维护的. 需要在父组件中统一的发送请求\n\n在Vue中数据流是单向的. 只能由父组件传递给子组件, 不能反过来:::\n2 实现父组件监听自定义事件\n1) template部分&lt;todo-item\n  v-for&#x3D;&quot;item in todos&quot;\n  :key&#x3D;&quot;item.id&quot;\n  :todo&#x3D;&quot;item&quot;\n  @toggle&#x3D;&quot;handleToggle&quot;\n&gt;&lt;&#x2F;todo-item&gt;\n\n2) methods部分handleToggle(id) &#123;\n  &#x2F;&#x2F; console.log(id)\n  &#x2F;&#x2F; 1. 根据id查找对应的todos数组中的对象\n  const data &#x3D; this.todos.find((item) &#x3D;&gt; item.id &#x3D;&#x3D; id)\n  &#x2F;&#x2F; console.log(data)\n\n  &#x2F;&#x2F; 2. 更新该对象的completed的值.\n  data.completed &#x3D;&#x3D; 0 ? (data.completed &#x3D; 1) : (data.completed &#x3D; 0)\n\n  &#x2F;&#x2F; 调用put接口,\n  &#x2F;&#x2F; 发送ajax请求\n  this.$http.put(&#96;http:&#x2F;&#x2F;localhost:3000&#x2F;todos&#x2F;$&#123;id&#125;&#96;, data).then((res) &#x3D;&gt; &#123;\n    const &#123; code, message, result &#125; &#x3D; res.data\n\n    if (code &#x3D;&#x3D; 0) &#123;\n      &#x2F;&#x2F; 数据更新成功, 重新获取数据\n      this.getTodos()\n    &#125;\n  &#125;)\n&#125;,\n根据id查找todos数组中对应的对象\n\n更新该对象的completed的值\n\n调用put接口, 发送请求(PUT /todos/:id, {content: ‘’, completed: 1}\n\n\n\n3 实现动态样式\n1) 动态绑定div元素样式&lt;template&gt;\n  &lt;div :class&#x3D;&quot;[&#39;todo-item&#39;, todo.completed ? &#39;todo-completed&#39; : &#39;&#39;]&quot;&gt;\n    &lt;!-- 实现checkbox的双向绑定 --&gt;\n    &lt;!-- 实现自定义v-model --&gt;\n    &lt;input type&#x3D;&quot;checkbox&quot; :checked&#x3D;&quot;todo.completed&quot; @change&#x3D;&quot;handleChange&quot; &#x2F;&gt;\n    &lt;input\n      v-if&#x3D;&quot;isEdit&quot;\n      type&#x3D;&quot;text&quot;\n      v-model&#x3D;&quot;todoItem.content&quot;\n      @keyup.enter&#x3D;&quot;handleEdit&quot;\n      @blur&#x3D;&quot;handleEdit&quot;\n    &#x2F;&gt;\n    &lt;label v-else @click&#x3D;&quot;isEdit &#x3D; true&quot;&gt;&#123;&#123; todo.content &#125;&#125;&lt;&#x2F;label&gt;\n    &lt;button&gt;&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n2) 改造样式&lt;style lang&#x3D;&quot;stylus&quot;&gt;\n@import &#39;~styles&#x2F;theme.styl&#39;\n@import &#39;~styles&#x2F;mixins.styl&#39;\n\n.todo-item\n  display: flex\n  justify-content: space-between\n  align-items: center\n  padding: 10px\n  border-top: 1px solid rgba(0, 0, 0, 0.1)\n  font-size: 24px\n  input\n    clearDefault()\n    &amp;::after\n      content: url(&#39;~images&#x2F;unChecked.svg&#39;)\n    &amp;:checked::after\n      content: url(&#39;~images&#x2F;Checked.svg&#39;)\n  label\n    flex: 1\n    padding-left: 10px\n    transition: all 0.4s\n  button\n    width: 40px\n    height: 40px\n    background-color: transparent\n    clearDefault()\n    cursor: pointer\n  &amp;:hover\n    button::after\n      content: &#39;X&#39;\n      font-size: 24px\n      color: $lightred\n  &amp;.todo-completed\n    label\n      text-decoration: line-through\n      color: #999\n&lt;&#x2F;style&gt;\n\n4 实现内容修改\n\n\n\n\n\n\n\n\n思路: \n\n通过flag标识控制显示label或者input\n当flag=true, 显示label文本\n当flag=false, 显示input框\n\n\n监听label的双击事件, 切换flag的值, flag=false\n在显示input框时\n按回车, 更新数据, 触发自定义事件\n失去焦点, 更新数据, 触发自定义事件\n按ESC, 不更新数据1) 改造模板&lt;label v-if&#x3D;&quot;flag&quot;&gt;&#123;&#123; todo.content &#125;&#125;&lt;&#x2F;label&gt;\n&lt;input v-else type&#x3D;&quot;text&quot; &#x2F;&gt;\n在data中声明flagdata() &#123;\n  return &#123;\n    flag: true,\n  &#125;\n&#125;,\n2) 监听双击事件双击label时, 切换成input框&lt;label v-if&#x3D;&quot;flag&quot; @dblclick&#x3D;&quot;flag &#x3D; false&quot;&gt;&#123;&#123; todo.content &#125;&#125;&lt;&#x2F;label&gt;\n&lt;input v-else type&#x3D;&quot;text&quot; &#x2F;&gt;\n在input框中回显数据&lt;label v-if&#x3D;&quot;flag&quot; @dblclick&#x3D;&quot;flag &#x3D; false&quot;&gt;&#123;&#123; todo.content &#125;&#125;&lt;&#x2F;label&gt;\n&lt;input v-else type&#x3D;&quot;text&quot; :value&#x3D;&quot;todo.content&quot; &#x2F;&gt;\n3) 监听input框的事件监听keyup.enter事件和blur事件&lt;input\n  v-else\n  type&#x3D;&quot;text&quot;\n  :value&#x3D;&quot;todo.content&quot;\n  @keyup.enter&#x3D;&quot;handleUpdate&quot;\n  @blur&#x3D;&quot;handleUpdate&quot;\n&#x2F;&gt;\n在methods中定义handleUpdate事件handleUpdate(e) &#123;\n  &#x2F;&#x2F; 1. 获取新输入的value值\n  &#x2F;&#x2F; 2. 向父组件传id, value值\n  &#x2F;&#x2F; 3. 修改flag的状态为true, 变成label文本\n  this.$emit(&#39;change&#39;, this.todo.id, e.target.value)\n  this.flag &#x3D; true\n&#125;,\n在父组件中, 监听change自定义事件&lt;todo-item\n  v-for&#x3D;&quot;item in todos&quot;\n  :key&#x3D;&quot;item.id&quot;\n  :todo&#x3D;&quot;item&quot;\n  @toggle&#x3D;&quot;handleToggle&quot;\n  @change&#x3D;&quot;handleChange&quot;\n&gt;&lt;&#x2F;todo-item&gt;\n在父组件中, 定义methodshandleChange(id, content) &#123;\n  &#x2F;&#x2F; 1. 根据id查找需要修改的todo对象\n  const todo &#x3D; this.todos.find((item) &#x3D;&gt; item.id &#x3D;&#x3D; id)\n  &#x2F;&#x2F; 2. 更新todo对象的content的值\n  todo.content &#x3D; content\n\n  &#x2F;&#x2F; 3. 发送ajax请求, 调用put接口更新\n  this.$http.put(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;todos&#x2F;&#39; + id, todo).then((res) &#x3D;&gt; &#123;\n    const &#123; code, message, result &#125; &#x3D; res.data\n    if (code &#x3D;&#x3D; 0) &#123;\n      this.getData()\n    &#125;\n  &#125;)\n&#125;,\n4) 实现自动获得焦点使用自定义指令v-todo-focus,在模板部分使用指令&lt;input\n  v-else\n  v-todo-focus\n  type&#x3D;&quot;text&quot;\n  :value&#x3D;&quot;todo.content&quot;\n  @keyup.enter&#x3D;&quot;handleUpdate&quot;\n  @blur&#x3D;&quot;handleUpdate&quot;\n&#x2F;&gt;\n在配置选项中, 实现自定义指令&#x2F;&#x2F; 自定义指令\ndirectives: &#123;\n  &#39;todo-focus&#39;: &#123;\n    inserted: function (el) &#123;\n      el.focus()\n    &#125;,\n  &#125;,\n&#125;,\n5) 按Esc键取消编辑&lt;input\n  v-else\n  v-todo-focus\n  type&#x3D;&quot;text&quot;\n  :value&#x3D;&quot;todo.content&quot;\n  @keyup.enter&#x3D;&quot;handleUpdate&quot;\n  @keyup.esc&#x3D;&quot;handleCancel&quot;\n  @blur&#x3D;&quot;handleUpdate&quot;\n&#x2F;&gt;\n在methods中实现handleCancelhandleCancel() &#123;\n  this.flag &#x3D; true\n&#125;,\n改造逻辑, 当falg=false时, 才发送请求handleUpdate(e) &#123;\n  &#x2F;&#x2F; 1. 获取新输入的value值\n  &#x2F;&#x2F; 2. 向父组件传id, value值\n  &#x2F;&#x2F; 3. 修改flag的状态为true, 变成label文本\n  if (this.flag &#x3D;&#x3D; false) &#123;\n    this.$emit(&#39;change&#39;, this.todo.id, e.target.value)\n    this.flag &#x3D; true\n  &#125;\n&#125;,\n十一. 实现删除功能:::warning\n\n\n\n需求\n\n点击删除按钮时, 删除这条待办记录:::\n\n\n\n\n\n\n\n\n\n思路\n\n子组件的button触发点击事件, 向父组件提交一个自定义事件del\n\n父组件监听自定义del事件, 拿到子组件传递过来的id值\n\n调用接口, 删除数据\n\n\n\n1 实现子组件触发自定义事件\n1) template部分在子组件模板中, 监听button的点击事件\n&lt;button @click&#x3D;&quot;handleClick&quot;&gt;&lt;&#x2F;button&gt;\n\n2) script部分在methods中编写handleClick方法, 提交(触发)自定义事件del\nmethods: &#123;\n  handleClick() &#123;\n    &#x2F;&#x2F; 触发自定义事件&#39;del&#39;\n    this.$emit(&#39;del&#39;, this.todo.id)\n  &#125;,\n&#125;,\n\n2 实现父组件监听自定义事件\n1) template部分&lt;todo-item\n  v-for&#x3D;&quot;item in todos&quot;\n  :key&#x3D;&quot;item.id&quot;\n  :todo&#x3D;&quot;item&quot;\n  @toggle&#x3D;&quot;handleToggle&quot;\n  @edit&#x3D;&quot;handleEdit&quot;\n  @del&#x3D;&quot;handleDel&quot;\n&gt;&lt;&#x2F;todo-item&gt;\n\n2) script部分在父组件的methods中, 编写handleDel方法, 调用DELETE /todos/:id接口, 操作数据库\nhandleDel(id) &#123;\n  &#x2F;&#x2F; 调用接口 DELETE &#x2F;todos&#x2F;:id\n  &#x2F;&#x2F; 发送请求\n  this.$http.delete(&#96;http:&#x2F;&#x2F;localhost:3000&#x2F;todos&#x2F;$&#123;id&#125;&#96;).then((res) &#x3D;&gt; &#123;\n    const &#123; code, message, result &#125; &#x3D; res.data\n\n    if (code &#x3D;&#x3D; 0) &#123;\n      this.getTodos()\n    &#125;\n  &#125;)\n&#125;,\n\n十二. 实现TodoInfo组件\n1 页面页面组成\n\n总计\ntab选项卡\n清除按钮\n\n初步编写结构\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;todo-info&quot;&gt;\n    &lt;span&gt;1 items left&lt;&#x2F;span&gt;\n    &lt;div class&#x3D;&quot;tab&quot;&gt;\n      &lt;a href&#x3D;&quot;#&quot;&gt;all&lt;&#x2F;a&gt;\n      &lt;a href&#x3D;&quot;#&quot;&gt;active&lt;&#x2F;a&gt;\n      &lt;a href&#x3D;&quot;#&quot;&gt;completed&lt;&#x2F;a&gt;\n    &lt;&#x2F;div&gt;\n    &lt;button&gt;Clear Completed&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n1) template部分将template使用v-for指令, 列表渲染\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;todo-info&quot;&gt;\n    &lt;span&gt;1 items left&lt;&#x2F;span&gt;\n    &lt;div class&#x3D;&quot;tab&quot;&gt;\n      &lt;a href&#x3D;&quot;#&quot; v-for&#x3D;&quot;(state, index) in states&quot; :key&#x3D;&quot;index&quot;&gt;&#123;&#123; state &#125;&#125;&lt;&#x2F;a&gt;\n    &lt;&#x2F;div&gt;\n    &lt;button&gt;Clear Completed&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n2) script部分&lt;script&gt;\nexport default &#123;\n  name: &#39;TodoInfo&#39;,\n  data() &#123;\n    return &#123;\n      states: [&#39;all&#39;, &#39;active&#39;, &#39;completed&#39;],\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n2 样式\n1) 初步实现&lt;style lang&#x3D;&quot;stylus&quot;&gt;\n@import &#39;~styles&#x2F;theme.styl&#39;\n\n.todo-info\n  display: flex\n  justify-content: space-between\n  align-items: center\n  height: 30px\n  padding: 5px 10px\n  border-top: 1px solid rgba(0, 0, 0, 0.1)\n  .total\n    color: $red\n  .tab\n    display: flex\n    justify-content: space-between\n    width: 200px\n    a\n      padding: 5px 10px\n      border: 1px solid $lightred\n      color: #000\n      text-decoration: none\n      border-radius: 5px\n      &amp;.current\n        background-color: $lightred\n        color: #fff\n  button\n    padding: 5px 10px\n    height: 30px\n    background-color: $green\n    color: #fff\n    outline: none\n    border: none\n    border-radius: 5px\n&lt;&#x2F;style&gt;\n\n2) 优化将比较常用的样式封装成mixins在styles下修改mixins.styl封装btn函数\nbtn(color, border &#x3D; false)\n  padding: 5px 10px\n  border-radius: 5px\n  outline: none\n  border: none\n  cursor: pointer\n  if (border &#x3D;&#x3D; true)\n    border: 1px solid color\n  else\n    background-color: color\n    color: #fff\n\nprimaryBtn()\n  btn(rgb(252, 157, 154))\n\nprimaryBorderBtn()\n  btn(rgb(252, 157, 154), true)\n\ninfoBtn()\n  btn(rgb(131, 175, 155))\n在组件中. 改造template\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;todo-info&quot;&gt;\n    &lt;span class&#x3D;&quot;total&quot;&gt;1 items left&lt;&#x2F;span&gt;\n    &lt;div class&#x3D;&quot;tab&quot;&gt;\n      &lt;a\n        class&#x3D;&quot;btn primary border&quot;\n        v-for&#x3D;&quot;(state, index) in states&quot;\n        :key&#x3D;&quot;index&quot;\n      &gt;\n        &#123;&#123; state &#125;&#125;\n      &lt;&#x2F;a&gt;\n    &lt;&#x2F;div&gt;\n    &lt;button class&#x3D;&quot;btn info&quot;&gt;Clear Completed&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\nstyle部分\n&lt;style lang&#x3D;&quot;stylus&quot;&gt;\n@import &#39;~styles&#x2F;theme.styl&#39;\n@import &#39;~styles&#x2F;mixins.styl&#39;\n\n.todo-info\n  display: flex\n  justify-content: space-between\n  align-items: center\n  height: 30px\n  padding: 5px 10px\n  border-top: 1px solid rgba(0, 0, 0, 0.1)\n  .total\n    color: $red\n  .tab\n    display: flex\n    justify-content: space-between\n    width: 200px\n    .btn.primary.border\n      primaryBorderBtn()\n      &amp;.current\n        primaryBtn()\n  .btn.info\n    infoBtn()\n&lt;&#x2F;style&gt;\n\n3 逻辑:::warning需求\n\n统计功能\ntab切换显示不同状态的待办事项\n清除已完成:::1) 统计功能实时统计剩余的未完成的记录数\n\n\n\n\n\n\n\n\n\n\n思路\n\n定义一个计算属性, 计算出completed==0的记录数\n数据是父组件管理, 数据的显示在子组件, 父组件向子组件传参\n\n\n实现计算属性computed: &#123;\n  total() &#123;\n    &#x2F;&#x2F; 根据todos数组, 计算所有&#96;completed&#x3D;&#x3D;0&#96;的个数\n    &#x2F;&#x2F; filter: 过滤出满足条件的元素, 形成一个新数组\n    return this.todos.filter((item) &#x3D;&gt; item.completed &#x3D;&#x3D; 0).length\n  &#125;,\n&#125;,\n\n实现父子通信在父组件模板中, 使用自定义属性: total, 绑定父组件中的计算属性\n&lt;todo-info :total&#x3D;&quot;total&quot;&gt;&lt;&#x2F;todo-info&gt;\n在子组件中, 通过props接收, 可子组件模板中使用script部分\n&lt;script&gt;\nexport default &#123;\n  name: &#39;TodoInfo&#39;,\n  props: &#123;\n    total: &#123;\n      type: Number,\n    &#125;,\n  &#125;,\n  data() &#123;\n    return &#123;\n      states: [&#39;all&#39;, &#39;active&#39;, &#39;completed&#39;],\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\ntemplate部分\n&lt;span class&#x3D;&quot;total&quot;&gt;&#123;&#123; total &#125;&#125; items left&lt;&#x2F;span&gt;\n\n2) tab栏切换\n\n\n\n\n\n\n\n\n具体需求\n\n点击不同的状态, 样式会改变(高亮显示当前的状态)\n\n点击不同的状态时, 数据也会发生变化\n\n点all时, 显示所有的数据\n点active时, 显示所有未完成的记录. (completed = 0)\n点completed时, 显示所有已完成的记录. (completed = 1)\n\n\n\n\n\n\n\n\n思路\n\n\n\n子组件的按钮组绑定点击事件, 点击时改变状态\n\n状态改变时, 通过触发一个自定义事件toggle,通知父组件\n\n父组件监听自定义事件, 计算新数据\n\n\n\n实现样式切换TodoInfo组件的template部分\n&lt;a\n  v-for&#x3D;&quot;(state, index) in states&quot;\n  :key&#x3D;&quot;index&quot;\n  class&#x3D;&quot;btn primary border&quot;\n  :class&#x3D;&quot;state &#x3D;&#x3D; current ? &#39;current&#39; : &#39;&#39;&quot;\n  @click&#x3D;&quot;handleClick(state)&quot;\n&gt;\nTodoInfo组件的script部分\n&lt;script&gt;\nexport default &#123;\n  name: &#39;TodoInfo&#39;,\n  props: &#123;\n    total: &#123;\n      type: Number,\n    &#125;,\n  &#125;,\n  data() &#123;\n    return &#123;\n      states: [&#39;all&#39;, &#39;active&#39;, &#39;completed&#39;],\n      current: &#39;all&#39;, &#x2F;&#x2F; 保存当前状态\n    &#125;\n  &#125;,\n  methods: &#123;\n    handleClick(s) &#123;\n      this.current &#x3D; s\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n实现切换数据显示与此同时, 在TodoInfo组件中handleClick方法中, 触发自定义toggle事件, 将当前点击的状态传递给父组件\nmethods: &#123;\n  handleClick(s) &#123;\n    this.current &#x3D; s\n    &#x2F;&#x2F; 触发自定义事件: toggle\n    this.$emit(&#39;toggle&#39;, s)\n  &#125;,\n&#125;,\n在父组件中, 监听TodoInfo的toggle事件, 改变状态值\n&lt;todo-info :total&#x3D;&quot;total&quot; @toggle&#x3D;&quot;handleChange&quot;&gt;&lt;&#x2F;todo-info&gt;\n编写handleChange方法\nhandleChange(state) &#123;\n  this.state &#x3D; state\n&#125;,\n在data中, 定义state\ndata() &#123;\n  return &#123;\n    todos: [],\n    content: &#39;&#39;,\n    state: &#39;all&#39;,\n  &#125;\n&#125;,\n在父组件中, 设计一个计算属性, 过滤不同状态下的记录\ncomputed: &#123;\n  total() &#123;\n    &#x2F;&#x2F; 根据todos数组, 计算所有&#96;completed&#x3D;&#x3D;0&#96;的个数\n    &#x2F;&#x2F; filter: 过滤出满足条件的元素, 形成一个新数组\n    return this.todos.filter((item) &#x3D;&gt; item.completed &#x3D;&#x3D; 0).length\n  &#125;,\n  filterData() &#123;\n    switch (this.state) &#123;\n      case &#39;all&#39;:\n        return this.todos\n      case &#39;active&#39;:\n        return this.todos.filter((item) &#x3D;&gt; item.completed &#x3D;&#x3D; 0)\n      case &#39;completed&#39;:\n        return this.todos.filter((item) &#x3D;&gt; item.completed &#x3D;&#x3D; 1)\n    &#125;\n  &#125;,\n&#125;,\n在父组件模板中, 列表渲染该计算属性filterData\n&lt;todo-item\n  v-for&#x3D;&quot;item in filterData&quot;\n  :key&#x3D;&quot;item.id&quot;\n  :todo&#x3D;&quot;item&quot;\n  @toggle&#x3D;&quot;handleToggle&quot;\n  @edit&#x3D;&quot;handleEdit&quot;\n  @del&#x3D;&quot;handleDel&quot;\n&gt;&lt;&#x2F;todo-item&gt;\n\n3) 清除已完成\n\n\n\n\n\n\n\n\n思路\n\n子组件触发自定义事件del\n父组件监听事件, 调用删除已完成接口\n\nTodoInfo组件\n&lt;button class&#x3D;&quot;btn info&quot; @click&#x3D;&quot;$emit(&#39;del&#39;)&quot;&gt;Clear Completed&lt;&#x2F;button&gt;\nMainTodo组件template部分\n&lt;todo-info\n  :total&#x3D;&quot;total&quot;\n  @toggle&#x3D;&quot;handleChange&quot;\n  @del&#x3D;&quot;handleDelCompleted&quot;\n&gt;&lt;&#x2F;todo-info&gt;\nscript部分\nhandleDelCompleted() &#123;\n  &#x2F;&#x2F; 调用接口(DELETE &#x2F;todos?completed&#x3D;1)\n  this.$http\n    .delete(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;todos?completed&#x3D;1&#39;)\n    .then((res) &#x3D;&gt; &#123;\n      const &#123; code &#125; &#x3D; res.data\n      if (code &#x3D;&#x3D; 0) &#123;\n        this.getTodos()\n      &#125;\n    &#125;)\n&#125;,\n在后端提供接口\nDELETE &#x2F;todos?completed&#x3D;1\n在todos.js路由文件中, 编写处理函数\n&#x2F;**\n * 删除指定项\n * Delete &#x2F;todos?completed&#x3D;1\n *&#x2F;\nrouter.delete(&#39;&#x2F;&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 解析queryString\n  const &#123; completed &#125; &#x3D; req.query\n  &#x2F;&#x2F; 操作数据库\n  let sql &#x3D; &#96;delete from vue_todos where completed &#x3D; $&#123;completed&#125;&#96;\n  await exec(sql)\n  res.send(&#123;\n    code: 0,\n    message: &#39;删除成功&#39;,\n    result: &#39;&#39;,\n  &#125;)\n&#125;)\n\n流程图参考点击查看【processon】\n","slug":"四. 综合项目[vue-todo]_new","date":"2022-12-02T11:29:05.816Z","categories_index":"Vue","tags_index":"Vue2进阶","author_index":"团子"},{"id":"ed6909028b0dfc67b5cabe577cbaa969","title":"三. Vue-cli(前端工程化)","content":"\n1 介绍\n1)  什么是Vue-cli\n\n\n\n\n\n\n\n\nVue项目的构建工具.\n\n2) 作用\n2 安装\n1) 安装cli工具全局安装cli工具\nnpm install -g @vue&#x2F;cli\n\n\n\n\n\n\n\n\n\n备注\n如果, 安装速度比较慢, 尝试切换镜像切换到taobao镜像\n&#x2F;&#x2F; 查看当前镜像\nnpm config get registry\n&#x2F;&#x2F; 设置当前镜像\nnpm config set registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;\n还可以使用其它的包管理工具. \n\nyarn\npnpm(目前使用最多的)\n\n\n2) 创建工程通过vue命令, 创建项目\nvue create 项目名\n\n","slug":"三. Vue-cli(前端工程化)_new","date":"2022-12-02T11:18:45.329Z","categories_index":"Vue","tags_index":"Vue2进阶","author_index":"团子"},{"id":"052b2268e5fc91d131e0cb5f85224b74","title":"二. 组件","content":"\n1 什么是组件:::info组件可以理解成项目的零件:::\n项目 就是由多个 组件 构成的\n\n\n\n\n\n\n\n\n\n举例\n\n一个房子是一个Vue应用, 那么客厅/卧室/厨房/卫生间就是组件\n一个电脑是一个Vue应用, 那么硬盘/内存/主板/显示器/键盘就是组件\n\n组件分为\n\n全局组件\n局部组件2 全局组件\n\n:::info顾名思义, 全局都可以使用的组件:::\n\n1) 完成Vue三步曲在 src 目录下创建09_全局组件.html, 编写基础的vue模板\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;09_全局组件&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue.js --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 编写div元素 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;!-- 3. 编写vue实例 --&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n2) 定义全局组件\n\n\n\n\n\n\n\n\n语法\nVue.component(&#39;组件名&#39;, &#123;组件参数&#125;)\n\n\n\n\n\n\n\n\n\n\n示例\nVue.component(&#39;son&#39;, &#123;\n  &#x2F;&#x2F; 在这个对象中, 可以配置vm实例的选项\n  &#x2F;&#x2F; 1. 不能写el, 通过template或render函数指定模板\n  &#x2F;&#x2F; 2. 在组件中data选项必须是一个函数. 而不是一个对象\n  template: &#96;&lt;h3&gt;hello &#123;&#123;msg&#125;&#125;&lt;&#x2F;h3&gt;&#96;,\n  data() &#123;\n    return &#123;\n      msg: &#39;新中地&#39;,\n    &#125;\n  &#125;,\n&#125;)\n\n\n组件没有el参数\n组件需要定义模板. 通过template选项或者render选项, 原因是组件需要渲染页面, template就是需要渲染的html\n组件也是一个Vue的实例, 所以在组件中也有data/methods等\ndata必须是一个函数, 并返回一个对象\n\n\n> **练习**\n\n将计数器封装成一个组件\n:::warning注意事项\n\n不能跟HTML原生的标签名同名\n组件名称使用多个单词\n使用驼峰法命名. (在HTML中使用kebab-case 在JS中使用驼峰法) my-button:::\n\n\n\n\n\n\n\n\n示例\n\n\nVue.component(&#39;MyButton&#39;, &#123;\n  template: &#96;&lt;button @click&#x3D;&quot;count++&quot;&gt;你点了我&#123;&#123;count&#125;&#125;次&lt;&#x2F;button&gt;&#96;,\n  data() &#123;\n    return &#123;\n      count: 0,\n    &#125;\n  &#125;,\n  methods: &#123;\n    handleClick() &#123;\n      &#x2F;&#x2F; this指向当前子组件实例. vc\n      this.count++\n    &#125;,\n  &#125;,\n&#125;)\n\n3) 引用组件在html中, 通过组件名引用组件\n&lt;!-- 2. 编写div元素 --&gt;\n&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;!-- 引用组件 --&gt;\n    &lt;com1&gt;&lt;&#x2F;com1&gt;\n    &lt;com1&gt;&lt;&#x2F;com1&gt;\n    &lt;com1&gt;&lt;&#x2F;com1&gt;\n&lt;&#x2F;div&gt;\n\n我们发现每个组件互不干扰，都有自己的count值。怎么实现的？\n\n\n\n\n\n\n\n\n\n重点\n组件中的data属性必须是函数！\n当我们定义这个 &lt;com1&gt; 组件时，它的data 并不是像这样直接提供一个对象：\ndata: &#123;\n  count: 0\n&#125;\n\n取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：\ndata: function () &#123;\n  return &#123;\n    count: 0\n  &#125;\n&#125;\n\n如果 Vue 没有这条规则，点击一个按钮就会影响到其它所有实例！\n\n4) 全局使用创建一个新的vue实例vm2\nconst vm2 &#x3D; new Vue(&#123;\n    el: &#39;#app2&#39;\n&#125;)\n\n创建新的div元素app2\nhtml\n&lt;div id&#x3D;&quot;app2&quot;&gt;\n    &lt;com1&gt;&lt;&#x2F;com1&gt;\n&lt;&#x2F;div&gt;\n\n发现在app2中, 也可以引用com1组件, 这样定义的就是全局组件, 所有的vm实例都可以引用\n\n5) 小结\n\n\n\n\n\n\n\n\n全局组件的使用步骤\n\n定义组件\n引用组件\n\n\n3 局部组件一般在单页面应用(SPA)中使用较多的是局部组件:::warning局部组件只属于某一个Vue实例, 通过comopnents添加(挂载)\n\n通常将组件参数单独定义, 方便工程化时管理\n通常将组件模板单独定义, 方便工程化时管理:::\n\n\n1) 完成Vue三步曲在 src 目录下创建10_局部组件.html, 编写基础的vue模板\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;10_局部组件&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue.js --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 编写div元素 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;!-- 3. 编写vue实例 --&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n2) 定义局部组件模板部分\n&lt;!-- 组件模板 --&gt;\n&lt;template id&#x3D;&quot;tmp&quot;&gt;\n  &lt;button @click&#x3D;&quot;count++&quot;&gt;\n    你点了我&#123;&#123;count&#125;&#125;次\n  &lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\njs部分\n&#x2F;&#x2F; 定义组件对象\nconst com1 &#x3D; &#123;\n    template: &#39;#tmp&#39;, &#x2F;&#x2F; 定义组件模板\n    data() &#123; &#x2F;&#x2F; 定义属性\n        return &#123;\n            count: 0\n        &#125;\n    &#125;\n&#125;\n\n\n3) 挂载组件在vue实例中挂载组件\nconst vm &#x3D; new Vue(&#123;\n  el: &#39;#app&#39;,\n  components: &#123;\n  \t&#x2F;&#x2F; 组件名: 组件对象\n    son: com1\n  &#125;\n&#125;)\n\n\n在vue实例中, 通过components完成挂载\n\n\n4) 引用组件在html中, 通过组件名引用组件\n&lt;!-- 2. 编写div元素 --&gt;\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;!-- 引用组件 --&gt;\n  &lt;son&gt;&lt;&#x2F;son&gt;\n&lt;&#x2F;div&gt;\n\n\n5) 小结\n\n\n\n\n\n\n\n\n局部组件的使用步骤\n\n定义组件模板\n定义组件对象\n在vue实例中挂载组件\n引用组件\n\n\n4 组件的本质组件本质上也是一个Vue实例, 由VueCompoent构造函数实例化得到因此, Vue实例上的配置项都可以应用于Vue组件对象\n5 组件通信通常一个单页应用(SPA)会以一棵嵌套的组件树的形式来组织\n\n页面首先分成了顶部导航、左侧内容区、右侧边栏三部分\n\n左侧内容区又分为上下两个组件\n右侧边栏中又包含了 3 个子组件\n\n\n各个组件之间以嵌套的关系组合在一起，那么这个时候不可避免的会有组件间通信的需求\n主要分为两种情况:\n\n父向子 传递数据\n子向父 传递数据\n\n\n6 父组件向子组件传值\n1) 完成 Vue 三步曲在 src 目录下创建11_父向子传值.html, 编写基础的 vue 模板\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;11_父向子传值&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue.js --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 编写div元素 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;!-- 3. 编写vue实例 --&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n2) 定义子组件在 vue 对象中, 使用 components 定义一个局部组件\n&#x2F;&#x2F; 定义子组件\ncomponents: &#123;\n  &#x2F;&#x2F; 组件名: 组件配置对象\n  BlogPost: &#123;\n    &#x2F;&#x2F; 2.在子组件通过props接收父组件传递的属性名\n    props: [&#39;title&#39;],\n    template: &#96;&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;h3&gt;&#96;,\n  &#125;,\n&#125;,\n\n\n3) 引用子组件在 html 中通过组件名, 通过组件名引用组件\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;blog-post&gt;&lt;&#x2F;blog-post&gt;\n&lt;&#x2F;div&gt;\n\n\n4) 传值父组件向子组件传递数据的步骤\n\n修改 html, 在子组件标签中添加一个属性\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;!-- 1. 静态绑定. 属性名&#x3D;&quot;固定的值&quot; --&gt;\n  &lt;blog-post title&#x3D;&quot;第一篇blog&quot;&gt;&lt;&#x2F;blog-post&gt;\n  &lt;!-- 2. 动态绑定. 属性名在子组件中使用&#x3D;属性值在父组件中定义 --&gt;\n  &lt;blog-post :title&#x3D;&quot;title&quot;&gt;&lt;&#x2F;blog-post&gt;\n  &lt;!-- 3. 在组件上使用v-for渲染 --&gt;\n  &lt;blog-post\n    v-for&#x3D;&quot;blog in blogs&quot;\n    :key&#x3D;&quot;blog.id&quot;\n    :title&#x3D;&quot;blog.title&quot;\n  &gt;&lt;&#x2F;blog-post&gt;\n&lt;&#x2F;div&gt;\n 修改 js, 在子组件中使用 props 接收 \ncomponents: &#123;\n  &#x2F;&#x2F; 组件名: 组件配置对象\n  BlogPost: &#123;\n    &#x2F;&#x2F; 2.在子组件通过props接收父组件传递的属性名\n    props: [&#39;title&#39;],\n    template: &#96;&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;h3&gt;&#96;,\n  &#125;,\n&#125;,\n\n\n5) 使用属性绑定也可以和父组件中的一个数据绑定起来使用\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;!-- 2. 动态绑定. 属性名在子组件中使用&#x3D;属性值在父组件中定义 --&gt;\n  &lt;blog-post :title&#x3D;&quot;title&quot;&gt;&lt;&#x2F;blog-post&gt;\n&lt;&#x2F;div&gt;\n\n\n6) 在组件上使用v-for&lt;!-- 3. 在组件上使用v-for渲染 --&gt;\n&lt;blog-post\n  v-for&#x3D;&quot;blog in blogs&quot;\n  :key&#x3D;&quot;blog.id&quot;\n  :title&#x3D;&quot;blog.title&quot;\n&gt;&lt;&#x2F;blog-post&gt;\n\n&lt;script&gt;\n  &#x2F;&#x2F; 将vm实例当作父组件\n  const vm &#x3D; new Vue(&#123;\n    el: &#39;#app&#39;,\n    data() &#123;\n      return &#123;\n        title: &#39;第二篇blog&#39;,\n        blogs: [\n          &#123; id: 1, title: &#39;1111&#39; &#125;,\n          &#123; id: 2, title: &#39;2222&#39; &#125;,\n          &#123; id: 3, title: &#39;3333&#39; &#125;,\n        ],\n      &#125;\n    &#125;,\n    &#x2F;&#x2F; 定义子组件\n    components: &#123;\n      &#x2F;&#x2F; 组件名: 组件配置对象\n      BlogPost: &#123;\n        &#x2F;&#x2F; 2.在子组件通过props接收父组件传递的属性名\n        props: [&#39;title&#39;],\n        template: &#96;&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;h3&gt;&#96;,\n      &#125;,\n    &#125;,\n  &#125;)\n&lt;&#x2F;script&gt;\n\n7) 小结\n\n\n\n\n\n\n\n\n父向子传值的步骤\n\n在子组件标签中添加一个属性, 发送数据\n在子组件中通过props, 接收数据\n\n\n7 子组件向父组件传值\n1) 完成 Vue 三步曲在 src 目录下创建12_子向父传值.html, 编写基础的 vue 模板\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;12_子向父传值&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue.js --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 编写div元素 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;!-- 3. 编写vue实例 --&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n2) 定义子组件在 vue 对象中, 使用 components 定义一个局部组件\ncomponents: &#123;\n    &#x2F;&#x2F; 组件名: &#123;组件参数&#125;\n    son: &#123;\n        template: &#39;&lt;button&gt;点我&lt;&#x2F;button&gt;&#39;,\n    &#125;\n&#125;\n\n\n3) 引用子组件在 html 中通过组件名, 通过组件名引用组件\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;son&gt;&lt;&#x2F;son&gt;\n&lt;&#x2F;div&gt;\n\n\n4) 传值子组件向父组件传递数据的步骤\n\n在子组件模板中绑定一个方法 \ncomponents: &#123;\n  &#x2F;&#x2F;1. 定义组件\n  son: &#123;\n    template: &#39;&lt;button @click&#x3D;&quot;sendMsg&quot;&gt;点我&lt;&#x2F;button&gt;&#39;,\n  &#125;\n&#125;\n在方法中向父组件提交(emit)一个事件 \ncomponents: &#123;\n  &#x2F;&#x2F;1. 定义组件\n  son: &#123;\n    template: &#39;&lt;button @click&#x3D;&quot;sendMsg&quot;&gt;点我&lt;&#x2F;button&gt;&#39;,\n    methods: &#123;\n      sendMsg()&#123;\n        &#x2F;&#x2F; 调用$emit, 向父组件提交一个send事件\n      \tthis.$emit(&#39;send&#39;, &quot;子组件-&gt;父组件&quot;)\n      &#125;\n    &#125;\n  &#125;\n&#125;\n在子组件标签中监听事件(绑定方法) \n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;!-- 2. 引用组件 --&gt;\n  &lt;son @send&#x3D;&quot;handleSend&quot;&gt;&lt;&#x2F;son&gt;\n&lt;&#x2F;div&gt;\n 在父组件中编写处理程序 \nmethods: &#123;\n  handleSend(msg)&#123;\n    alert(&#39;收到子组件的数据&#39;+msg)\n  &#125;\n&#125;,\n\n\n5) 小结\n\n\n\n\n\n\n\n\n子向父传值的步骤\n\n在子组件中绑定一个方法, 向父组件提交一个事件\n在子组件标签中绑定一个方法, 监听事件\n在父组件中编写处理程序\n\n\n\n\n\n\n\n\n\n\n作业\n\n\n计数器在父组件中定义\nn在子组件中定义\n每次+n, 父组件中的计数器根据子组件中输入的值累加\n\n","slug":"二.组件_new","date":"2022-12-02T11:05:21.382Z","categories_index":"Vue","tags_index":"Vue2进阶","author_index":"团子"},{"id":"d3464fcac232efa1ce28ee1ded5dad18","title":"一. 生命周期","content":"\n1 单组件的生命周期\n1) 什么是生命周期:::info一个Vue实例从创建到销毁的整个过程:::\nVue组件也可看成一个Vue实例\n\n\n2) 生命周期函数(钩子):::info在生命周期中, 特定的时间点会被自动执行的函数:::\n\nbeforeCreate()\ncreated()\nbeforeMount()\nmounted()\nbeforeUpdate()\nupdated()\nbeforeDestroy()\ndestroyed()\n\n\n3) Vue实例到底做了一件什么事Vue实例的最主要的工作是\n将模板内容编译, 替换掉原有的html节点\n\n模板内容: 由template选项确定\n编译: 由render()方法, 将模板编译成在真实的DOM, 渲染在html文件中\n原有的html节点: 由el选项确定\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n  const vm &#x3D; new Vue(&#123;\n    el: &#39;#app&#39;,\n    template: &#39;&lt;div&gt;hello&lt;&#x2F;div&gt;&#39;,\n  &#125;)\n&lt;&#x2F;script&gt;\n\nvue实例最终就是将&lt;div&gt;hello&lt;/div&gt;替换掉了原有的html中&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;节点\n\n\n\n\n\n\n\n\n\n示例\nconst vm &#x3D; new Vue(&#123;\n  el: &#39;#app&#39;,\n  data: &#123;\n    msg: &#39;hello&#39;,\n  &#125;,\n  template: &#39;&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;&#39;,\n&#125;)\n\n这里, 会难一点点, 流程是:\n\n先解析template中的内容, 将&#123;&#123;msg&#125;&#125;替换成hello(这个过程叫作编译)\n将编译的结果&lt;div&gt;hello&lt;/div&gt;替换掉了原有的html中&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;节点\n\n在这个过程中, 会有一些时间点, 在这些时间点会自动调用一些函数. 这些就是生命周期函数\n\n\n\n\n\n\n\n\n\n示例\nconst vm &#x3D; new Vue(&#123;\n  el: &#39;#app&#39;,\n  data: &#123;\n    msg: &#39;hello&#39;,\n  &#125;,\n  template: &#39;&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;&#39;,\n  beforeCreate() &#123;\n    console.log(this, &#39;beforeCreate&#39;)\n  &#125;,\n  created() &#123;\n    console.log(this, &#39;created&#39;)\n  &#125;,\n  beforeMount() &#123;\n    console.log(this, &#39;beforeMount&#39;)\n  &#125;,\n  mounted() &#123;\n    console.log(this, &#39;mounted&#39;)\n  &#125;,\n  beforeUpdate() &#123;\n    console.log(this, &#39;beforUpdate&#39;)\n  &#125;,\n  updated() &#123;\n    console.log(this, &#39;updated&#39;)\n  &#125;,\n  beforeDestroy() &#123;\n    console.log(this, &#39;beforeDestroy&#39;)\n  &#125;,\n  destroyed() &#123;\n    console.log(this, &#39;destroyed&#39;)\n  &#125;,\n&#125;)\n\n我们发现, 有4个函数被执行了\n\nbeforeCreate()\ncreated()\nbeforeMount()\nmounted()\n\n这四个函数在整个生命周期中只执行一次\n\n4) 生命周期函数\ncreate相关函数create相关的生命周期函数有两个:\n\nbeforeCreate()\ncreated()\n\n\n\n\n\n\n\n\n\n\nbeforeCreate和created的相同点\n都是在Vue实例创建时被调用, 只执行一次\n\n\n\n\n\n\n\n\n\nbeforeCreate和created的不同点\n要搞清楚这个问题, 我们需要知道在beforeCreate和created之间, 做了什么事\n\n\n\n\n\n\n\n\n\n示例\nbeforeCreate() &#123;\n  console.dir(this.$data) &#x2F;&#x2F; undefined\n  console.log(this, &#39;beforeCreate&#39;)\n&#125;,\ncreated() &#123;\n  console.dir(this.$data) &#x2F;&#x2F; object\n  &#x2F;&#x2F; 跟数据相关, 放在created中\n  console.log(this, &#39;created&#39;)\n&#125;\n\n我们发现, 在beforeCreate中$data是undefined, 而created中$data是有值的\n因此, 我们得出一个重要结论\n\n\n\n\n\n\n\nWARNING\n重要结论如果要处理跟数据相关的逻辑, 最早在created函数中处理一般在created生命周期函数中, 完成data属性的初始化\n\n\n\n\n\n\n\n\n\n\n一句话总结\n在beforeCreate和created之间, 完成$data的代理\n\n\n\n\n\n\n\n\n\n场景\n\n如果发送ajax请求从后台拿数据, 建议放到created里\n如果要完成data数据的初始化, 建议放到created里\n\n\n\nmount相关函数mount相关的生命周期函数有两个:\n\nbeforeMount()\nmounted()\n\n\n\n\n\n\n\n\n\n\ncreate和mount的不同\ncreated结束时还不能操作DOM(操作DOM不生效, 会在mounted挂载时替换)mounted结束时才可以操作DOM\n\n\n\n\n\n\n\n\n\n示例\ncreated() &#123;\n  console.dir(this.$data)\n  &#x2F;&#x2F; 跟数据相关, 放在created中\n  console.log(this.$el, &#39;created&#39;) &#x2F;&#x2F; undefined\n&#125;,\nbeforeMount() &#123;\n  console.log(this.$el, &#39;beforeMount&#39;) &#x2F;&#x2F; &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n&#125;,\nmounted() &#123;\n  &#x2F;&#x2F; 跟DOM操作相关, 放在mounted中\n  console.log(this.$el, &#39;mounted&#39;) &#x2F;&#x2F; &lt;div&gt;hello&lt;&#x2F;div&gt;\n&#125;,\n\ncreated表示实例创建完成, 而mounted表示挂载完成, 是new Vue时的两个步骤\n怎么将这两个步骤分开呢\n\n\n\n\n\n\n\n\n\n示例\nconst vm &#x3D; new Vue(&#123;\n  &#x2F;&#x2F; 第一步: 注释掉el\n  &#x2F;&#x2F; el: &#39;#app&#39;,\n  data: &#123;\n    msg: &#39;hello&#39;,\n  &#125;,\n  template: &#39;&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;&#39;,\n  beforeCreate() &#123;\n    console.dir(this.$data)\n    console.log(this.$el, &#39;beforeCreate&#39;)\n  &#125;,\n  created() &#123;\n    console.dir(this.$data)\n    &#x2F;&#x2F; 跟数据相关, 放在created中\n    console.log(this.$el, &#39;created&#39;)\n  &#125;,\n  beforeMount() &#123;\n    console.log(this.$el, &#39;beforeMount&#39;)\n  &#125;,\n  mounted() &#123;\n    &#x2F;&#x2F; 跟dom操作相关, 放在mounted中\n    console.log(this.$el, &#39;mounted&#39;)\n  &#125;,\n  beforeUpdate() &#123;\n    console.log(this, &#39;beforUpdate&#39;)\n  &#125;,\n  updated() &#123;\n    console.log(this, &#39;updated&#39;)\n  &#125;,\n  beforeDestroy() &#123;\n    console.log(this, &#39;beforeDestroy&#39;)\n  &#125;,\n  destroyed() &#123;\n    console.log(this, &#39;destroyed&#39;)\n  &#125;,\n&#125;)\n&#x2F;&#x2F; 第二步: 调用$mount方法, 手动挂载\nvm.$mount(&#39;#app&#39;)\n\n如果不指定el选项: 不会执行mount相关的生命周期\n手动调用$mount方法挂载时, 发现mount相关的生命周期被调用了\n\n\n\n\n\n\n\n\n\nmount是把什么挂载到什么上\nmounted结束时, 将编译之后的模板挂载到了html上, 替换原有的节点.\n通过上面的分析, 我们知道了:\nVue实例化过程中最主要两步是\n\n编译\n挂载\n\n\n\n\n\n\n\n\n\n\nbeforeMount和mounted的不同点\n要搞清楚这个问题, 我们需要知道在beforeMount和mounted之间, 做了什么事\n\n\n\n\n\n\n\n\n\n示例\nbeforeMount() &#123;\n  console.log(this.$el, &#39;beforeMount&#39;) &#x2F;&#x2F; &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n&#125;,\nrender(h) &#123;\n  console.log(&#39;render in invoked&#39;)\n  return h(&#39;div&#39;, &#123;&#125;, this.msg)\n&#125;,\nmounted() &#123;\n  &#x2F;&#x2F; 跟dom操作相关, 放在mounted中\n  console.log(this.$el, &#39;mounted&#39;) &#x2F;&#x2F; &lt;div&gt;hello&lt;&#x2F;div&gt;\n&#125;,\n\n在beforeMount和mounted之间, 调用了render方法, 将模板编译成了DOM\n\n\nupdate相关函数update相关的生命周期函数有两个:\n\nbeforeUpdate()\nupdated()\n\n\n\n\n\n\n\n\n\n\nbeforeUpdate和updated的相同点\n都是在Vue的data中的数据发生改变时调用, 可以执行N次(N&gt;=1)\n\n\n\n\n\n\n\n\n\nbeforeUpdate和updated的不同点\n\nbeforeUpdate中: 数据是新的, 页面还是旧的, 还没有更新页面, 此时页面和数据是不同步的\nupdated中: 数据是新的, 页面也是新的. 此时已经完成了re-render(页面的重新渲染)\n\n\ndestroy相关的函数在destroy相关的函数有两个:\n\nbeforeDestroy(): 临死前\ndesstroyed(): 死透了\n\n调用的时机\n\n手动执行vm.$destroy()方法\n切换组件\n\n比较常用的是beforeDestroy, 在这个函数中, 释放不属于vue的一些资源(定时器)和解绑一些事件\n\n5) 常用的生命周期函数\ncreated: 完成data的初始化\nmounted: 操作DOM\nbeforeDestory: 回收资源, 解绑事件\n\n","slug":"一.生命周期_new","date":"2022-12-02T10:59:46.142Z","categories_index":"Vue","tags_index":"Vue2进阶","author_index":"团子"},{"id":"4277aac2cb081b743e86fc465443e28f","title":"六. 计算属性与侦听器","content":"\n1 计算属性\n1) 什么是计算属性:::info计算属性就是基于现有属性计算后的属性:::\n2) 计算属性的作用计算属性用于对原始数据的再次加工\n3) 案例:::warning需求实现如下效果:::\n\n使用表达式实现&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 需求: 实现字符串的反转\n          eg. abc 转换成  cba \n    --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      请输入一个字符串: &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;msg&quot; &#x2F;&gt; &lt;br &#x2F;&gt;\n      &lt;!-- 反转字符串的思路\n        1. 取出字符串中的每个字符 msg.split(&#39;&#39;) 形成一个数组\n        2. 反转数据. msg.split(&#39;&#39;).reverse() 形成一个反转数组\n        3. 将反转数组拼接. msg.split(&#39;&#39;).reverse().join(&#39;&#39;)\n      --&gt;\n      &lt;!-- 不推荐!! 在模板中书写复杂的表达式 --&gt;\n      &lt;h3&gt;反转后的字符串: &#123;&#123;msg.split(&#39;&#39;).reverse().join(&#39;&#39;)&#125;&#125;&lt;&#x2F;h3&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          msg: &#39;&#39;,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n使用方法实现&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 需求: 实现字符串的反转\n          eg. abc 转换成  cba \n    --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      请输入一个字符串: &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;msg&quot; &#x2F;&gt; &lt;br &#x2F;&gt;\n      &lt;!-- 反转字符串的思路\n        1. 取出字符串中的每个字符 msg.split(&#39;&#39;) 形成一个数组\n        2. 反转数据. msg.split(&#39;&#39;).reverse() 形成一个反转数组\n        3. 将反转数组拼接. msg.split(&#39;&#39;).reverse().join(&#39;&#39;)\n      --&gt;\n      &lt;!-- 不推荐使用方法\n        原因: 没有缓存, 每次调用方法, 代码会执行一次\n      --&gt;\n      &lt;h3&gt;反转后的字符串: &#123;&#123;reverseMsg()&#125;&#125;&lt;&#x2F;h3&gt;\n      &lt;h3&gt;反转后的字符串: &#123;&#123;reverseMsg()&#125;&#125;&lt;&#x2F;h3&gt;\n      &lt;h3&gt;反转后的字符串: &#123;&#123;reverseMsg()&#125;&#125;&lt;&#x2F;h3&gt;\n      &lt;h3&gt;反转后的字符串: &#123;&#123;reverseMsg()&#125;&#125;&lt;&#x2F;h3&gt;\n      &lt;h3&gt;反转后的字符串: &#123;&#123;reverseMsg()&#125;&#125;&lt;&#x2F;h3&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          msg: &#39;&#39;,\n        &#125;,\n        methods: &#123;\n          reverseMsg() &#123;\n            console.log(&#39;反转函数被执行了...&#39;)\n            &#x2F;&#x2F; 返回 反转后的字符串\n            return this.msg.split(&#39;&#39;).reverse().join(&#39;&#39;)\n          &#125;,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n使用计算属性实现&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 需求: 实现字符串的反转\n          eg. abc 转换成  cba \n    --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      请输入一个字符串: &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;msg&quot; &#x2F;&gt; &lt;br &#x2F;&gt;\n      &lt;!-- 反转字符串的思路\n        1. 取出字符串中的每个字符 msg.split(&#39;&#39;) 形成一个数组\n        2. 反转数据. msg.split(&#39;&#39;).reverse() 形成一个反转数组\n        3. 将反转数组拼接. msg.split(&#39;&#39;).reverse().join(&#39;&#39;)\n      --&gt;\n      &lt;!-- 推荐使用 计算属性\n        1. 有缓存的. 当计算属性生成一次后, 挂载到vm实例. \n          后继的访问, 直接使用vm实例上的属性\n        2. 方便调试\n      --&gt;\n      &lt;h3&gt;反转后的字符串: &#123;&#123;reverseMsg&#125;&#125;&lt;&#x2F;h3&gt;\n      &lt;h3&gt;反转后的字符串: &#123;&#123;reverseMsg&#125;&#125;&lt;&#x2F;h3&gt;\n      &lt;h3&gt;反转后的字符串: &#123;&#123;reverseMsg&#125;&#125;&lt;&#x2F;h3&gt;\n      &lt;h3&gt;反转后的字符串: &#123;&#123;reverseMsg&#125;&#125;&lt;&#x2F;h3&gt;\n      &lt;h3&gt;反转后的字符串: &#123;&#123;reverseMsg&#125;&#125;&lt;&#x2F;h3&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          msg: &#39;&#39;,\n        &#125;,\n        computed: &#123;\n          &#x2F;&#x2F; 编写一个函数, 这个函数会被做为该计算属性的getter\n          reverseMsg() &#123;\n            console.log(&#39;计算属性被执行了...&#39;)\n            &#x2F;&#x2F; 该函数的返回值, 做为访问计算属性的结果\n            return this.msg.split(&#39;&#39;).reverse().join(&#39;&#39;)\n          &#125;,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n4) 特点:::info\n\n有缓存\n调试方便:::\n\n\n5) 作业\n2 侦听器\n1) 什么是侦听器:::info可以通过watch配置项, 监听vm实例已经存在属性的改变:::\n2) 语法watch: &#123;\n  &#x2F;&#x2F; 监听data中的firstName属性\n  firstName() &#123;\n   &#x2F;&#x2F; 执行一系列的操作\n  &#125;,\n&#125;,\n\n3) 特点在watch对应的回调函数中, 可以获取到新值和 旧值\n\n\n\n\n\n\n\n\n\n示例\nconst vm &#x3D; new Vue(&#123;\n  el: &#39;#app&#39;,\n  data: &#123;\n    firstName: &#39;&#39;,\n    lastName: &#39;&#39;,\n  &#125;,\n  &#x2F;&#x2F; 使用watch这个配置项\n  watch: &#123;\n    &#x2F;&#x2F; 在watch对应的回调函数中, 可以得到新值和旧值\n    &#x2F;&#x2F; 对于简单数据类型, 可以获取新旧值\n    &#x2F;&#x2F; 对于引用数据类型, 不能获取旧值\n    firstName(newValue, oldValue) &#123;\n      &#x2F;&#x2F; 一对多: 监听某一个属性的改变, 做一系列的操作\n      console.log(&#39;firstName改变了...&#39;)\n      console.log(&#39;新的值:&#39;, newValue)\n      console.log(&#39;旧的值:&#39;, oldValue)\n    &#125;,\n  &#125;,\n&#125;)\n\n4) 深度侦听默认情况下, watch只会侦听data中第一层的数据. 如果改变深层次的对象, 需要开启深度侦听\ndata: &#123;\n  lastName: &#39;&#39;,\n  firstName: &#39;&#39;,\n  fullName: &#39;&#39;,\n  obj: &#123;\n    a: &#123;\n      b: &#123;\n        c: &#39;1&#39;,\n      &#125;,\n    &#125;,\n  &#125;,\n&#125;,\n此时, 侦听obj, 默认只有当obj重新赋值时, 才会触发回调\nvm.obj &#x3D; &#39;111&#39;\n如果改变obj内部的属性, 比如vm.a.b.c = &#39;2&#39;不会触发回调函数执行\n需要开启深度侦听\nwatch: &#123;\n  obj: &#123;\n    deep: true, &#x2F;&#x2F; 开启深度侦听\n    handler: function (newValue, oldValue) &#123;\n      &#x2F;&#x2F; 通过handler指定回调\n      &#x2F;&#x2F; 引用类型, 新旧值相同, 都是更新之后的数据\n      console.log(&#39;更新之前&#39;, oldValue)\n      console.log(&#39;更新之后&#39;, newValue)\n      \n      console.log(\n        &#39;开启深度侦听, 不管多少层, 只要数据变化, 都可以被侦听到...&#39;\n      )\n    &#125;,\n  &#125;,\n&#125;,\n\n3 区别\n是否会在vm实例中挂载新属性? \ncomputed会\nwatch不会\n\n\n对应关系\ncomputed是多对一, 可以同时监听多个值改变, 最终计算得到一个新的属性\nwatch是一对多, 主要监听一个属性的变化, 执行多种逻辑\n\n\n能否获取新旧值?\ncomputed不能\nwatch能4 过滤器\n\n\n\n\n1) 什么是过滤器:::info过滤器是一个函数, 主要完成对数据的格式化:::\n2) 语法&#123;&#123; 表达式 | 过滤器1 | 过滤器2 ...&#125;&#125;\n将表达式的结果作为过滤器1参数, 再将过滤器1的结果作为过滤器2的参数, 依次类推\n\n3) 分类\n全局过滤器\n局部过滤器\n\n\n4) 示例&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;过滤器&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;金额: &#123;&#123;price | formatPrice&#125;&#125;&lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          price: 85,\n        &#125;,\n        filters: &#123;\n          formatPrice(value) &#123;\n            console.log(value)\n\n            return &#39;¥&#39; + value.toFixed(2) + &#39;元&#39;\n          &#125;,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n5 作业:::warning需求实现如下购物车效果:::\n","slug":"六. 计算属性与侦听器_new","date":"2022-12-02T09:43:08.004Z","categories_index":"Vue","tags_index":"Vue2基础","author_index":"团子"},{"id":"2bf64ee2a2c6d7942433bae3817e775f","title":"五. Vue模板语法","content":"\n1 简介\n\n\n\n\n\n\n\n\n什么是模板\n:::info由Vue解析的HTML字符串:::\n\n\n\n\n\n\n\n\n\n什么是模板语法\n:::info在模板字符串中, 具有特殊意义的语法:::\n\n\n2 分类:::info模板语法分为\n\n插值语法\n指令语法:::\n\n\n1) 插值语法\n语法\n\n\n\n\n\n\n\n\n在&#123;&#123;&#125;&#125;`中书写的语法\n\n`&#123;&#123;&#125;&#125;里书写js表达式, 叫做 插值表达式\n应用主要应用于文本节点\n示例&lt;div id&#x3D;&quot;app&quot;&gt;\n  &#123;&#123;msg&#125;&#125;\n&lt;&#x2F;div&gt;\n\n2) 指令语法\n语法\n\n\n\n\n\n\n\n\n以v-开头的指令. \n在属性值中书写js表达式, 叫做 指令表达式\n应用主要应用于属性节点\n示例&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;百度&lt;&#x2F;a&gt;\n\n常用指令\n单向绑定: v-bind, 简写为:\n\n双向绑定: v-model\n\n方法绑定: v-on, 简写为@\n\n条件渲染: v-if\n\n列表渲染: v-for\n3 属性绑定\n1) 定义:::info影响只能从data到view\n\n数据的改变  会  影响视图\n\n视图的改变  不会  影响数据:::\n2) 示例&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;单向绑定&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue.js --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 编写div元素 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;!-- 3. 编写vue实例 --&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n属性绑定\n:::info将 非表单标签 的一个属性和data中的一个变量绑定:::\nhtml部分\n&lt;!-- 完整的写法 --&gt;\n&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;百度&lt;&#x2F;a&gt;\n&lt;!-- 简写(推荐) --&gt;\n&lt;a :href&#x3D;&quot;xzd&quot;&gt;新中地&lt;&#x2F;a&gt;\n\nvue官方更推荐简写的方式\njs部分\nconst vm &#x3D; new Vue(&#123;\n  el: &#39;#app&#39;,\n  data: &#123;\n    url: &#39;http:&#x2F;&#x2F;baidu.com&#39;\n  &#125;\n&#125;)\n\n\n将a标签href属性和data中的url变量绑定\n相当于&lt;a href=&quot;http://baidu.com&quot;&gt;&lt;/a&gt;\n\n\n\n\n\n\n\n\nWARNING\n💡 特别说明在指令后面的引号中, 可以使用类似于&#123;&#123;&#125;&#125;中一样的语法.\n\n可以使用 js表达式\n直接访问vm实例上的属性和方法\n不能是js语句:::\n\n\n4 事件绑定\n1) 什么是事件绑定:::info将JS事件和对应的处理函数绑定:::\n2) 语法v-on:事件名&#x3D;&quot;函数名&quot;\n&#x2F;&#x2F; 简写\n@事件名&#x3D;&quot;函数名&quot;\n\n\n\n\n\n\n\n\n\n示例\n给一个按钮绑定点击事件template部分\n&lt;button @click&#x3D;&quot;handleClick&quot;&gt;点击&lt;&#x2F;button&gt;\njs部分\nmethods: &#123;\n  handleClick() &#123;\n    alert(&#39;hello&#39;)\n  &#125;\n&#125;\n\n\n\nmethods中定义的函数会挂载到vm实例对象上\n\nmethods中定义的普通函数内部this指向vm\n\nmethods中, 不推荐使用箭头函数\n\nmethods中定义的方法不能和data中定义的同名\n3) 是否加括号\n不加括号(70%): 直接写函数名称, 可以在回调函数中, 直接拿到事件对象event\n\n加括号(20%): 加括号主要为了传参, 在回调函数中, 拿到参数\n\n加括号(10%): 有时, 除了拿到参数外, 还需要原生的事件对象, 通过$event传递\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;事件处理函数&lt;&#x2F;title&gt;\n    &lt;!-- 完成vue三步曲 --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;ul&gt;\n        &lt;li v-for&#x3D;&quot;item in todos&quot; @click&#x3D;&quot;handleClick&quot;&gt;&#123;&#123;item.content&#125;&#125;&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          todos: [\n            &#123; id: 1, content: &#39;待办1&#39; &#125;,\n            &#123; id: 2, content: &#39;待办2&#39; &#125;,\n            &#123; id: 3, content: &#39;待办3&#39; &#125;,\n          ],\n        &#125;,\n        methods: &#123;\n          &#x2F;&#x2F; 不写参数\n          &#x2F;&#x2F; handleClick() &#123;\n          &#x2F;&#x2F;   console.log(&#39;li被点击了...&#39;)\n          &#x2F;&#x2F; &#125;,\n          &#x2F;&#x2F; 写参数\n          handleClick(e) &#123;\n            console.log(e.target)\n          &#125;,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;事件处理函数&lt;&#x2F;title&gt;\n    &lt;!-- 完成vue三步曲 --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 需求: 当点击待办事项时, 获取到该条记录的id值 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;ul&gt;\n        &lt;!-- v-on: 绑定方法\n        1. 不写括号\n        a. 在方法定义时, 不写参数(70%) \n        b. 在方法定义时, 写一个参数, 表示原生的事件对象\n        2. 写括号\n        a. 传递自定义参数(20%)\n        b. 传递自定义参数+事件对象(使用$event)\n        --&gt;\n        &lt;li v-for&#x3D;&quot;item in todos&quot; @click&#x3D;&quot;handleClick(item.id, $event)&quot;&gt;\n          &#123;&#123;item.content&#125;&#125;\n        &lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          todos: [\n            &#123; id: 1, content: &#39;待办1&#39; &#125;,\n            &#123; id: 2, content: &#39;待办2&#39; &#125;,\n            &#123; id: 3, content: &#39;待办3&#39; &#125;,\n          ],\n        &#125;,\n        methods: &#123;\n          handleClick(id, e) &#123;\n            console.log(e) &#x2F;&#x2F; 原生的事件对象\n            console.log(id)\n          &#125;,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n4) 事件修饰符在绑定事件的时候, 可以添加事件修饰符, 常用的事件修饰符如下:\n\n.prevent: 阻止默认行为\n\n.stop: 阻止冒泡\n\n.once: 事件只会触发一次\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;事件修饰符&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引用vue.js --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 编写页面容器 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;button @click&#x3D;&quot;&quot;&gt;点击&lt;&#x2F;button&gt;\n      &lt;!-- 给ul绑定click事件 --&gt;\n      &lt;ul @click&#x3D;&quot;ulClick&quot;&gt;\n        &lt;!-- 给li绑定click事件 --&gt;\n        &lt;!-- \n          常见的事件修饰符\n            .stop: 事件修饰符(阻止冒泡) \n            .prevent: 阻止默认行为\n            .once: 该事件只会触发一次\n          事件修饰符可以连用\n        --&gt;\n        &lt;li @click.once.stop&#x3D;&quot;liClick&quot;&gt;1&lt;&#x2F;li&gt;\n        &lt;li&gt;2&lt;&#x2F;li&gt;\n        &lt;li&gt;3&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n    \n    &lt;!-- 3. 实例化vue对象 --&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        methods: &#123;\n          ulClick() &#123;\n            console.log(&#39;ul被点击&#39;)\n          &#125;,\n          &#x2F;&#x2F; liClick(e) &#123;\n          &#x2F;&#x2F;   e.stopPropagation()\n          \n          &#x2F;&#x2F;   console.log(&#39;li被点击&#39;)\n          &#x2F;&#x2F; &#125;,\n          liClick() &#123;\n            console.log(&#39;li被点击&#39;)\n          &#125;,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n5) 按键修饰符:::info主要针对 键盘事件:::常用按键修饰符\n\n.enter: 回车键\n\n.up: 上\n\n.down: 下\n\n.left: 左\n\n.right: 右\n\n\n系统功能键\n\n.ctrl\n.alt\n.shift\n\n\n4 双向绑定\n1) 定义:::info数据和视图间的绑定是双向的\n\n数据的改变 会 影响视图\n视图的改变 会 影响数据:::2) 示例&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;双向绑定&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      用户名: &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;username&quot; &#x2F;&gt;\n      &#123;&#123;username&#125;&#125;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          username: &#39;&#39;,\n        &#125;\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3) 原理\n\n\n\n\n\n\n\n\n双向绑定的原理\n\n\n\n通过绑定input框的value属性和data中的一个变量, 实现了数据-&gt;视图的绑定\n监听input框的input事件, 当事件触发时, 更新data中的变量, 实现了视图-&gt;数据的绑定\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;双向绑定&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;!-- 自定义v-model, 手动实现v-model的功能 --&gt;\n      &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;user&quot; v-on:input&#x3D;&quot;handleInput&quot; &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          user: &#39;&#39;,\n        &#125;,\n        methods: &#123;\n          &#x2F;&#x2F; 当input事件触发时, 就会调用该函数\n          handleInput(e) &#123;\n            console.log(e)\n            console.log(e.target.value)\n\n            this.user &#x3D; e.target.value\n          &#125;,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n演示\n:::info对于input框, v-model默认\n\n绑定value属性\n监听input事件:::\n\n:::tips💡 注意不同的表单元素, 绑定的属性和监听的事件不同:::详见官方文档\n\n\n\n\n\n\n\n\n\n作业实现一个form表单\n\n6 条件渲染\n1) 什么是条件渲染:::info当条件满足时, 渲染到页面\n主要指令: v-if和v-show\n\n\n2) 示例\n完成vue的3步曲\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;05_条件渲染&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue.js --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 编写div元素 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;!-- 3. 编写vue实例 --&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n编写页面与逻辑\n\n\n\n\n\n\n\n\n示例\nhtml部分\n&lt;!-- 2. 编写div元素 --&gt;\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;div v-if&#x3D;&quot;flag&quot;&gt;这是用v-if渲染的元素&lt;&#x2F;div&gt;\n  &lt;div v-show&#x3D;&quot;flag&quot;&gt;这是用v-show渲染的元素&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\njs部分\n&lt;script&gt;\n  const vm &#x3D; new Vue(&#123;\n    el: &#39;#app&#39;,\n    data: &#123;\n      flag: true\n    &#125;\n  &#125;)\n&lt;&#x2F;script&gt;\n\n\n当flag为true时, 两个元素都可以显示\n当flag为false时, 两个元素都不显示, 区别是 \nv-if: 不会创建元素\nv-show: 创建元素, 但是display=none\n\n\n\n\n3) 使用表达式在指令表达式中, 除了使用变量外, 还可以使用表达式\n&lt;div v-if&#x3D;&quot;flag &#x3D;&#x3D; true&quot;&gt;这是用v-if渲染的元素&lt;&#x2F;div&gt;\n\n\n\n\n\n\n\n\n\n\n案例\n:::tips💡 需求通过按钮控制元素的显示/隐藏:::\n\n\n\n\n\n\n\n\n\n示例\nhtml部分\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;button @click&#x3D;&quot;flag &#x3D; !flag&quot;&gt;切换&lt;&#x2F;button&gt;\n  &lt;div v-if&#x3D;&quot;flag&quot;&gt;这是用v-if渲染的元素&lt;&#x2F;div&gt;\n  &lt;div v-show&#x3D;&quot;flag&quot;&gt;这是用v-show渲染的元素&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\n\n绑定按钮的点击事件 \n当flag==true时点击, flag先取反, 再保存, 此时flag为false\n当flag==false时点击, flag先取反, 再保存, 此时flag为true\n\n\n\n\n7 列表渲染\n1) 什么是列表渲染:::info列表渲染也称”循环渲染”, 通过v-for遍历数组或者对象:::\n2) 遍历数组\n获取元素如果只希望得到每个数组元素的值, 不需要得到下标\n\n\n\n\n\n\n\n\n\n语法\nv-for&#x3D;&quot;item in items&quot;\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;06_列表渲染&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue.js --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 编写div元素 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;ul&gt;\n        &lt;li v-for&#x3D;&quot;item in items&quot;&gt;&#123;&#123; item &#125;&#125;&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n    &lt;!-- 3. 编写vue实例 --&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          items: [&#39;test1&#39;, &#39;test2&#39;, &#39;test3&#39;]\n        &#125;\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n获取元素和下标如果只希望得到每个数组元素的值和下标\n\n\n\n\n\n\n\n\n\n语法\nv-for&#x3D;&quot;(item, index) in items&quot;\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;06_列表渲染&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue.js --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 编写div元素 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;ul&gt;\n        &lt;li v-for&#x3D;&quot;(item, index) in items&quot;&gt;&#123;&#123; index &#125;&#125;--&#123;&#123; item &#125;&#125;&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n    &lt;!-- 3. 编写vue实例 --&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          items: [&#39;test1&#39;, &#39;test2&#39;, &#39;test3&#39;]\n        &#125;\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n3) 遍历对象\n只取值: v-for=&quot;value in obj&quot;\n取键和值: v-for=&quot;(value, key) in obj&quot;\n取键和值和索引: v-for=&quot;(value, key, index) in obj&quot;\n\n\n4) 绑定key在遍历时, 通常会给每个渲染的元素绑定一个唯一值key\n\n什么是keykey是Vue内置的属性, 不会渲染到DOM中\n\n语法&lt;li v-for&#x3D;&quot;item in items&quot; :key&#x3D;&quot;item.id&quot;&gt;\n\n\nkey的作用key是vue给每个元素定义的唯一标识, 来用复用DOM\n:::tips💡 需求\n\n制作一个人员列表, 如下\n\n\n\n在输入框中依次输入对应的名字\n当点击按钮时, 在列表的最上方添加一个用户: 小强:::\n\n\n\n\n\n\n\n\n示例\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;key的作用&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;h1&gt;用户列表&lt;&#x2F;h1&gt;\n      &lt;button @click&#x3D;&quot;add&quot;&gt;添加一个用户&lt;&#x2F;button&gt;\n      &lt;ul&gt;\n        &lt;li v-for&#x3D;&quot;item in users&quot;&gt;\n          &#123;&#123;item.name&#125;&#125;\n          &lt;input type&#x3D;&quot;text&quot; &#x2F;&gt;\n        &lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          users: [\n            &#123; id: 1, name: &#39;小明&#39;, age: 20 &#125;,\n            &#123; id: 2, name: &#39;小美&#39;, age: 18 &#125;,\n            &#123; id: 3, name: &#39;小胖&#39;, age: 2 &#125;,\n          ],\n        &#125;,\n        methods: &#123;\n          add() &#123;\n            this.users.unshift(&#123; id: 4, name: &#39;小强&#39;, age: 22 &#125;)\n          &#125;,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n期望的结果实际的情况为什么会出现这种现象呢?\n\n\n\n\n\n\n\n\n\n原因\nvue在渲染每个元素时, 会给元素设置一个自定义属性key\n\n根据元素的key直接复用之前的DOM, 不会生成新的DOM\n\n\n\n8 样式绑定\n1) 什么是样式绑定:::info通过绑定class属性 或者 style属性 修改样式:::\n2) 绑定class属性有两种语法\n\n数组写法\n对象写法\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;绑定class修改样式&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;style&gt;\n      .red &#123;\n        color: pink;\n      &#125;\n      .blue &#123;\n        color: skyblue;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;!-- 原生的CSS写法 --&gt;\n      &lt;span class&#x3D;&quot;red&quot;&gt;红色的文字&lt;&#x2F;span&gt;\n\n      &lt;!-- 绑定class属性 -- 对象的写法 --&gt;\n      &lt;span :class&#x3D;&quot;obj&quot;&gt;对象的写法&lt;&#x2F;span&gt;\n\n      &lt;!-- 绑定class属性 -- 数组的写法 (推荐)--&gt;\n      &lt;span :class&#x3D;&quot;arr&quot;&gt;数组的写法&lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          obj: &#123;\n            red: true,\n          &#125;,\n          arr: [&#39;red&#39;, &#39;blue&#39;],\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n3) 绑定style属性对象写法\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;绑定style修改样式&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;!-- 原生的写法 --&gt;\n      &lt;span style&#x3D;&quot;color: red; font-size: 32px&quot;&gt;红色的文字&lt;&#x2F;span&gt;\n      &lt;!-- 绑定对象 --&gt;\n      &lt;span :style&#x3D;&quot;obj&quot;&gt;可变颜色的文字&lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          obj: &#123;\n            color: &#39;blue&#39;,\n            &#x2F;&#x2F; 去掉中划线, 使用大写字母\n            fontSize: &#39;40px&#39;,\n          &#125;,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n4) 作业:::warning💡 需求实现京东tab栏切换:::\n\n\n\n\n\n\n\n\n\n参考答案\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;style&gt;\n      * &#123;\n        margin: 0;\n        padding: 0;\n      &#125;\n      li &#123;\n        list-style: none;\n      &#125;\n      .menu-tab &#123;\n        margin: 50px auto;\n        height: 40px;\n        min-width: 800px;\n        border: 1px solid #eee;\n        border-bottom: 1px solid #e4393c;\n        background-color: #f7f7f7;\n      &#125;\n      .menu-tab li &#123;\n        display: inline-block;\n        padding: 0 25px;\n        line-height: 40px;\n        font-size: 14px;\n        color: #666;\n        cursor: pointer;\n      &#125;\n      .menu-tab li:hover &#123;\n        color: #e4393c;\n      &#125;\n      .menu-tab li.current &#123;\n        color: #fff;\n        background-color: #e4393c;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 一. 实现静态页面\n      1. HTML结构\n      2. CSS样式\n    --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;ul class&#x3D;&quot;menu-tab&quot;&gt;\n        &lt;!-- 当点击li元素时, 给li元素添加class属性, 属性值为current --&gt;\n        &lt;li\n          v-for&#x3D;&quot;(item,index) in menus&quot;\n          :class&#x3D;&quot;index &#x3D;&#x3D; active ? &#39;current&#39; : &#39;&#39;&quot;\n          @click&#x3D;&quot;handleClick(index)&quot;\n        &gt;\n          &#123;&#123;item&#125;&#125;\n        &lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;!-- 二. 实现业务逻辑 --&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          menus: [\n            &#39;商品介绍&#39;,\n            &#39;规格与包装&#39;,\n            &#39;售后保障&#39;,\n            &#39;商品评价(100万+)&#39;,\n            &#39;手机社区&#39;,\n          ],\n          active: 0,\n        &#125;,\n        methods: &#123;\n          handleClick(i) &#123;\n            console.log(i)\n            this.active &#x3D; i\n          &#125;,\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n","slug":"五. Vue模板语法_new","date":"2022-12-02T08:05:49.083Z","categories_index":"Vue","tags_index":"Vue2基础","author_index":"团子"},{"id":"038e2b47ac293a17a4e188acb02dbb61","title":"四. MVVM模型","content":"\n1 什么是MVVM模型:::infoMVVM由 Model(数据模型)  View(视图) 和 VM(ViewModel) 组成:::\n\n1) 核心思想实现 数据 与 视图 的 双向绑定\n各自的作用\n\nModel(数据模型):     操作数据\nView(视图):         显示数据\nVM:             模型与视图间的双向操作\n\n\n\n2) 原理在MVVM之前, 开发人员需要从后端获取数据,  然后通过DOM操作Model渲染到View中.\n当用户操作了视图, 再通过DOM获取View中的数据, 同步到Model中而VM的作用就是把DOM操作完全的封装起来, 开发人员不用再关心Model和View之间如何影响\n\n只要 Model 发生改变, View 就可以自然的表现出来\n只要用户操作了 View, Model 中的数据也会跟着变化\n\n\n\n2 示例\n\n\n\n\n\n\nWARNING\n💡 需求当在输入框中输入字符时, 同步显示到页面中\n\n\n\n1) 完成Vue的三步曲在src目录下创建一个新的文件: 02_MVVM模型.html\n\n\n引入vue.js\n\n\n\n\n\n\n\n\n示例\n&lt;!-- 1. 引入vue.js --&gt;\n&lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n编写div元素\n\n\n\n\n\n\n\n\n示例\n&lt;!-- 2. 编写div元素 --&gt;\n&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n编写vue实例\n\n\n\n\n\n\n\n\n示例\n&lt;!-- 3. 编写vue实例 --&gt;\n&lt;script&gt;\n  const vm &#x3D; new Vue(&#123;\n    el: &#39;#app&#39;,\n    data: &#123;&#125;\n  &#125;)\n&lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n2) 编写页面\n\n\n\n\n\n\n\n\n分析\n页面由文字, input框, 内容显示三部分组成\n\n\n\n\n\n\n\n\n\n示例\n&lt;!-- 2. vue的主操作区 --&gt;\n&lt;div id&#x3D;&quot;app&quot;&gt;\n    在这里输入的内容会在下面显示: &lt;input v-model&#x3D;&quot;msg&quot; type&#x3D;&quot;text&quot;&gt;\n    &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h3&gt;\n&lt;&#x2F;div&gt;\n\n\nv-model表示双向绑定, 将输入框中的内容和vue实例中的msg属性绑定\n&#123;&#123;&#125;&#125;是插值表达式, 用来显示msg的数据\n\n\n3) 编写逻辑这里的逻辑比较简单, 只需要在data部分, 添加一个msg变量就可以\n\n\n\n\n\n\n\n\n\n示例\n&lt;script&gt;\n  const vm &#x3D; new Vue(&#123;\n    el: &#39;#app&#39;,\n    data: &#123;\n      msg: &#39;&#39;\n    &#125;\n  &#125;)\n&lt;&#x2F;script&gt;\n\n\n\n4) 测试使用live Server测试(使用到的插件: live Server)\n\n\n5) 调试工具为了方便调试vue, 可以在chrome浏览器中安装vue-devtools.\n\n\n\n\n:::tips📖 小结\n\nvue使用的三步曲(引入vue.js div元素 vue实例)\ndata中的内容就是M(模型), div中的内容是V(视图), vue实例是VM:::\n\n","slug":"四. MVVM模型_new","date":"2022-12-02T07:56:03.005Z","categories_index":"Vue","tags_index":"Vue2基础","author_index":"团子"},{"id":"8f523ce4af9881778f9f63851115ecc9","title":"三. Vue实例","content":"\n1 属性和方法Vue 应用的核心就是 Vue 实例 , 一个基本的 Vue 实例包括如下图所示:\nnew Vue(&#123;\n  el: &#39;#app&#39;,\n  data: &#123;&#125;,\n  methods: &#123;&#125;\n&#125;)\n\n\nel: 表示要操作的页面元素\ndata: 数据, 可以理解为面向对象中类的”属性“\nmethods: 方法, 可以理解为面向对象中类的”方法“\n\n\n1) 属性在vue实例中, 通过data选项配置的各种数据 叫属性, 也叫状态\n\n2) 方法在vue实例中, 通过methods配置其主要作用是\n\n响应视图中的事件\n修改属性 (data 里的数据)\n\n\n\n\n\n\n\n\nWARNING\n重要结论\n\n属性就是用来 保存 数据的\n方法就是用来 修改 数据的:::\n\n\n2 计数器案例:::warning**💡 需求: **实现一个简单的计数器点击按钮, 计数器值+1:::\n\n3 加法器案例:::warning**💡 需求: **实现一个简单的加法器两个输入框,填写两个数字, 点击=号时, 计算结果\n\n\n\n1) 完成 Vue 的三步曲在 src 目录下创建03_加法器.html\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;03_加法器&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入vue.js --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 2. 编写div元素 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;!-- 3. 编写vue实例 --&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n2) 编写页面\n\n\n\n\n\n\n\n\n分析\n:::info页面由两个 input 框和一个按钮, 再加一个 input 框组成:::\n\n\n\n\n\n\n\n\n\n示例\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;input type&#x3D;&quot;text&quot; &#x2F;&gt;+&lt;input type&#x3D;&quot;text&quot; &#x2F;&gt;\n  &lt;button&gt;&#x3D;&lt;&#x2F;button&gt;\n  &lt;input type&#x3D;&quot;text&quot; &#x2F;&gt;\n&lt;&#x2F;div&gt;\n\n\n3) 编写逻辑\n绑定属性html 部分\n&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;input v-model&#x3D;&quot;first&quot; type&#x3D;&quot;text&quot;&gt;+&lt;input v-model&#x3D;&quot;second&quot; type&#x3D;&quot;text&quot;&gt;\n    &lt;button&gt;&#x3D;&lt;&#x2F;button&gt;\n    &lt;input v-model&#x3D;&quot;result&quot; type&#x3D;&quot;text&quot;&gt;\n&lt;&#x2F;div&gt;\n\n\n使用 v-model 绑定属性\n\njs 部分\nconst vm &#x3D; new Vue(&#123;\n  el: &#39;#app&#39;, &#x2F;&#x2F; 元素\n  data: &#123;\n    first: 0,\n    second: 0,\n    result: 0\n  &#125;, &#x2F;&#x2F; 属性\n  methods: &#123;&#125; &#x2F;&#x2F; 方法\n&#125;)\n\n\n绑定方法html 部分\n&lt;button v-on:click&#x3D;&quot;add&quot;&gt;&#x3D;&lt;&#x2F;button&gt;\n\n\n使用 v-on 绑定click方法\n\njs 部分\nmethods: &#123;\n    add() &#123;\n        this.result &#x3D; parseInt(this.first) + parseInt(this.second)\n    &#125;\n&#125; &#x2F;&#x2F; 方法\n\n\n\n\n\n\n\n\n\n\n完整示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Vue实例&lt;&#x2F;title&gt;\n    &lt;!-- 1.1 引入vue.js --&gt;\n    &lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- \n    像Vue2.x版本, 将所有的配置项放到构造函数中的方式\n    叫做 options API(声明式编程)\n    像Vue3.x版本, 将相同功能的代码组合到一起\n    叫做 composition API(函数式编程)\n  --&gt;\n    &lt;!-- 1.2 编写页面容器 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;first&quot; &#x2F;&gt;\n      +\n      &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;second&quot; &#x2F;&gt;\n      &lt;!-- v-on: 监听某个事件. 当点击按钮时, 执行对应的函数 --&gt;\n      &lt;button v-on:click&#x3D;&quot;handleClick&quot;&gt;&#x3D;&lt;&#x2F;button&gt;\n      &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;result&quot; &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n    &lt;!-- 1.3 实例化vue对象 --&gt;\n    &lt;script&gt;\n      const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n          first: 0,\n          second: 0,\n          result: 0,\n        &#125;,\n        methods: &#123;\n          handleClick() &#123;\n            &#x2F;&#x2F; 如果获取data中的数据\n            &#x2F;&#x2F; this指向vm实例\n            &#x2F;&#x2F; 为什么? 因为data, methods中定义的内容直接挂载(代理)到vm实例对象上\n            console.log(this)\n            &#x2F;&#x2F; 通过this得到first, second, result数据\n            this.result &#x3D; parseInt(this.first) + parseInt(this.second)\n          &#125;,\n        &#125;,\n      &#125;)\n      console.log(vm)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n:::warning💡 Q&amp;A\n\n在methods的函数中的this指向什么?\n\n答: 指向vm实例\n\n为什么指向vm实例?\n\n答: data和methods中定义的属性和方法都会被挂载到vm实例上, 当调用handleClick时, 实际上执行的是vm.handleClick()::::::tips📖 小结\n\ndata: 保存 数据\nmethods: 改变 数据:::\n\n\n3 作业根据上面的学习, 能否自己动手编写一个四则运算, 效果如下:\n\n\n","slug":"三. Vue实例_new","date":"2022-12-02T07:45:14.541Z","categories_index":"Vue","tags_index":"Vue2基础","author_index":"团子"},{"id":"f633b9b7ebaccaa57757f7c5003e83b0","title":"二. Vue快速上手","content":"\n1 搭建开发环境\n1) 初始化使用如下指令初始化\nnpm init -y\n\n发现在目录下会多一个文件package.json, 这个文件用来管理该项目使用了哪些包\n2) 安装vue执行如下命令安装vue\nnpm install vue@2 --save\n\n以上命令可以简写为\nnpm i vue@2\n\n在项目目录会产生一个文件夹node_modules和一个文件package-lock.json\n在package.json文件中, 会多如下内容:::tips💡  特别说明Vue的默认版本, Vue 3在2022 年 2 月 7 日成为新_的默认版本_因此, 在安装时, 我们需要通过npm i vue@2指定vue的版本为2.x:::\n在node_modules里就是vue了\n:::info📖 vue的各种版本说明    vue.js是完整版, (在初学阶段使用)\n\ncommon: 使用CommonJS规范导入导出module.exports这种文件不能在浏览器中使用\nesm(ES Module): 使用ES的模块规范导入导出export default\nruntime: 运行时版本, 相对于编译版本, 体积更小, 效率更高:::\n\n\n3) 小结:::tips💡 使用Npm安装Vue分为两步\n\n项目初始化: npm init -y\n安装vue: npm install vue:::\n\n\n2 起步案例做为第一个案例, 主要给大家介绍vue的最基本使用.\n\n\n\n\n\n\n\n\n\nvue使用的3步曲(重点)\n:::danger\n\n引入vue.js\n编写页面(视图)\n编写vue实例:::1) 引入vue.js\n\n在html的头部, 通过&lt;script src&gt;引入vue.js\n\n\n\n\n\n\n\n\n\n示例\n&lt;!-- 1. 引入vue.js --&gt;\n&lt;script src&#x3D;&quot;..&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n2) 编写页面(视图)在boby中, 编写一个div元素, id为app, 所有视图部分将在这部分渲染\n\n\n\n\n\n\n\n\n\n示例\n&lt;!-- 2. 编写页面 --&gt;\n&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n3) 编写vue实例在body的最末尾, 使用&lt;script&gt;, 编写vue实例\n\n\n\n\n\n\n\n\n\n示例\n&lt;!-- 3. 编写vue实例 --&gt;\n&lt;script&gt;\n  const vm &#x3D; new Vue(&#123;\n    el: &#39;#app&#39;, &#x2F;&#x2F; 对应操作的元素, 必填参数\n    data: &#123;&#125;, &#x2F;&#x2F; 数据部分\n    methods: &#123;&#125; &#x2F;&#x2F; 方法部分\n  &#125;)\n&lt;&#x2F;script&gt;\n\n\nel(element元素): 表示vue实例操作页面元素\ndata(数据): 数据部分\nmethods(方法): 方法部分\n\n\n\n\n\n\n\n\n\n\n演示\n\n4) 渲染数据\n定义数据在data中定义数据\n\n\n\n\n\n\n\n\n\n示例\n&lt;!-- 3. 编写vue实例 --&gt;\n&lt;script&gt;\n  const vm &#x3D; new Vue(&#123;\n    el: &#39;#app&#39;, &#x2F;&#x2F; 对应操作区的元素, 必填参数\n    data: &#123;\n      msg: &#39;hello world&#39;\n    &#125;, &#x2F;&#x2F; 数据部分\n    methods: &#123;&#125; &#x2F;&#x2F; 方法部分\n  &#125;)\n&lt;&#x2F;script&gt;\n\n使用键值对方式定义数据. 其中\n\nmsg: 相当于变量名\n&#39;hello world&#39;: 相当于变量值\n\n\n\n\n\n\n\n\n\n\n扩展\n:::info声明式编程需要什么就声明什么.:::与之对应的是命令式编程:::info命令式编程按照步骤, 执行命令:::在jQuery中使用的就是命令式编程\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n在页面中渲染\n\n\n\n\n\n\n\n\n示例\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &#123;&#123; msg &#125;&#125;\n&lt;&#x2F;div&gt;\n\n\n通过&#123;&#123;&#125;&#125;(插值表达式)在data部分定义的变量\n\n\n\n\n\n\n\n\n\n\n演示\n\n","slug":"二. Vue快速上手_new","date":"2022-12-02T07:21:33.958Z","categories_index":"Vue","tags_index":"Vue2基础","author_index":"团子"},{"id":"50e76213b8e48ed7ab8926d9188dc1c3","title":"一. Vue简介","content":"\n1 什么是Vue:::infoVue是一个动态构建用户界面的** 渐进式** JS框架. 遵循MVVM模式:::\n\n构建用户界面: 将数据转换成界面\n渐进式: 自底向上慢慢改进\n简单应用: 当成jQuery的代替品\n中型应用: 应用组件化, 重构某个(某些)页面\n大型应用: 使用全家桶开发\n\n\n遵循MVVM模式\n\n\n\n\n\n\n\n\n扩展知乎-如何理解Vue是一个渐进式框架Vue的发展历程\n\n\n\n2 Vue的优点Vue做为目前主流的三大前端框架. 具有如下优点\n\n上手容易\n平滑的学习曲线\n友好的文档\n活跃的社区\n\nVue框架集众家所长\n\n借鉴了Angular的模板语法和数据绑定\n借鉴了React的组件化和虚拟DOM3 Vue的特点Vue框架主要有如下特点\n\n\n数据驱动\n声明式\n组件化开发\n\n","slug":"一. Vue简介","date":"2022-12-02T06:17:27.478Z","categories_index":"Vue","tags_index":"Vue2基础","author_index":"团子"},{"id":"cb58856aab1bae0ffaf05d1a0e7fac83","title":"Express从入门到精通","content":"\n一. Express简介Express 是一个极简而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。Express中文官网\n\n\n\n\n\n\n\n\n\n为什么说Express是一个极简的框架\nExpress的核心只有两个部分\n\n路由\n中间件\n\nExpress提供了基本的路由处理和中间件功能, 几乎所有功能的实现都由一个个独立的中间件完成\n\n1 路由路由可以认为是一种找到数据的路径, 或者说是URL+处理函数\n\n通过URL来区分不同的资源(页面或数据)\n通过处理函数来返回资源(页面或数据)\n\n前端通过URL请求数据.\n后端通过不同的路由, 调用对应的方法, 返回指定的数据\n\n\n2 中间件顾名思义, 中间件就是在什么的中间\n\n\n\n\n\n\n\n\n\n在请求和响应中间的处理程序\n有时候从请求到响应的业务比较复杂, 将这些复杂的业务拆开成一个个功能独立的函数, 就是中间件\n对于处理请求来说，在响应发出之前，可以在请求和响应之间做一些操作，并且可以将这个处理结果传递给下一个函数继续处理\nexpress 中间件函数，帮助拆解主程序的业务逻辑，\n并且每一个的中间件函数处理的结果都会传递给下一个中间件函数。\n就好比工厂里流水线工人清洗一个箱子:\n第一个人清洗侧面，第二个人清洗底面，第三个人清洗顶面，。。。\n这条流水线结束后，箱子也就清洗干净了\n各做各的，不相互影响，又彼此协作\n\n\n\n二. 安装及使用express也是一个node的包, 可以npm来安装\n\n1 安装npm i express\n\n\n2 使用:::info步骤\n\n导入express包\n实例化对象\n编写路由(中间件)\n监听端口:::\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 1. 引入express包\nconst express &#x3D; require(&#39;express&#39;)\n&#x2F;&#x2F; 2. 实例化对象\nconst app &#x3D; express()\n&#x2F;&#x2F; 3. 编写路由\napp.get(&#39;&#x2F;&#39;, function(req, res) &#123;\n  res.send(&#39;hello world&#39;)\n&#125;)\n&#x2F;&#x2F; 4. 监听端口\napp.listen(3000)\n\n\n三. 路由路由模块由三部分组成\n\n 请求方式 \n URL \n 处理函数 \n\n路由模块主要方法是 app.METHOD\n\n\n\n\n\n\n\n\n\n练习\n&#x2F;&#x2F; 需求:\n&#x2F;&#x2F;    1. 当GET请求&#x2F;或者&#x2F;index.html时, 返回 &#39;首页&#39;\n&#x2F;&#x2F;    2. 当GET请求&#x2F;list.html时, 返回 &#39;列表页&#39;\n&#x2F;&#x2F;    3. 当GET请求&#x2F;detail.html时, 返回 &#39;详情页&#39;\n&#x2F;&#x2F;    4. 其它情况 返回, &#39;404 Not Found&#39;\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 1. 导入express包\nconst express &#x3D; require(&#39;express&#39;)\n&#x2F;&#x2F; 2. 实例化app对象\nconst app &#x3D; express()\n&#x2F;&#x2F; 3. 编写路由(根据不同的path, 返回不同的内容)\napp.get(&#39;&#x2F;&#39;, function (req, res) &#123;\n  &#x2F;&#x2F; req: request(请求对象)\n  &#x2F;&#x2F; res: response(响应对象)\n  res.send(&#39;首页&#39;)\n&#125;)\napp.get(&#39;&#x2F;index.html&#39;, function (req, res) &#123;\n  res.send(&#39;首页&#39;)\n&#125;)\napp.get(&#39;&#x2F;list.html&#39;, function (req, res) &#123;\n  res.send(&#39;列表页&#39;)\n&#125;)\napp.get(&#39;&#x2F;detail.html&#39;, function (req, res) &#123;\n  res.send(&#39;详情页&#39;)\n&#125;)\napp.get(&#39;*&#39;, function (req, res) &#123;\n  res.send(&#39;404 Not Found&#39;)\n&#125;)\n&#x2F;&#x2F; 4. 监听端口\napp.listen(3000, function () &#123;\n  console.log(&#39;server is running on http:&#x2F;&#x2F;localhost:3000&#39;)\n&#125;)\n\n\n1 请求方式请求方式就是HTTP协议的请求方式, 常见的有\n\nget: 对应app.get()–查询\npost: 对应app.post()–创建(新增)\nput: 对应app.put()–修改\ndelete: 对应app.delete()–删除\n\n\n2 URLURL的写法\n&#x2F;&#x2F; 第一种, 不带参数\napp.get(&#39;&#x2F;users&#39;, function(req, res) &#123;\n  res.send(&#39;hello world&#39;)\n&#125;)\n&#x2F;&#x2F; 第二种, 带参数\napp.get(&#39;&#x2F;users&#x2F;:id&#39;, function(req, res) &#123;\n  res.send(&#39;hello world&#39;)\n&#125;)\n&#x2F;&#x2F; 第三种, 正则表达式, 以html结尾\n&#x2F;&#x2F; 请求index.html abc.html\napp.get(&#x2F;.html$&#x2F;, function(req, res) &#123;\n  res.send(&#39;hello world&#39;)\n&#125;)\n\n\n3 处理函数\n\n\n\n\n\n\n\n\n语法\nfunction(req, res, next) &#123;\n  &#x2F;&#x2F; todo\n&#125;\n\n在处理函数中, 有两个形参\n\nreq(请求对象)\nres(响应对象)\n\n\n1) 请求对象请求对象包含了一次请求中的所有数据(http请求头, 请求参数…)\n\n\n\n\n\n\n\n\n\n示例\napp.get(&#39;&#x2F;&#39;, function (req, res) &#123;\n  console.log(req)\n&#125;)\n\n\n2) 获取请求参数常见的请求\n\nGET请求: 通过URL\nURL的path部分, eg /users/1\nURL的queryString部分, eg /users?page=1&amp;size=5\n\n\nPOST请求: 通过body\n\n\n\n\n\n\n\n\n语法\n\n\n&#x2F;&#x2F; 对于GET请求的path传参\nreq.params\n&#x2F;&#x2F; 对于GET请求的queryString传参\nreq.query\n\n\n\n\n\n\n\n\n\n\n示例: get请求\n&#x2F;&#x2F; 1.导入express包\nconst express &#x3D; require(&#39;express&#39;)\n&#x2F;&#x2F; 2.实例化app对象\nconst app &#x3D; express()\n&#x2F;&#x2F; 3.编写路由\n\n&#x2F;**\n * 获取用户id&#x3D;1的用户信息\n * GET &#x2F;users&#x2F;:id\n * eg. GET &#x2F;users&#x2F;1 返回&#123;id:1, name: &#39;xiaoming&#39;, age: 20&#125;\n *&#x2F;\napp.get(&#39;&#x2F;users&#x2F;:id&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 请求对象(包含所有http请求信息)\n  console.log(req.params)\n  &#x2F;&#x2F; 查询数据库, 得到user对象, 返回\n  res.send(&#123;\n    id: 1,\n    name: &#39;xiaoming&#39;,\n    age: 20,\n  &#125;)\n&#125;)\n&#x2F;**\n * 获取所有用户(限定条件: 第1页,每页显示5条)\n * GET &#x2F;users\n * 请求参数 urlencoded [?page&#x3D;1&amp;size&#x3D;5]queryString\n * 响应数据 [&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;]\n *&#x2F;\napp.get(&#39;&#x2F;users&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 通过req.query获取GET请求中的queryString的值\n  console.log(req.query)\n  res.send([\n    &#123; id: 1, name: &#39;xiaoming&#39; &#125;,\n    &#123; id: 2, name: &#39;xiaomei&#39; &#125;,\n    &#123; id: 3, name: &#39;xiaopang&#39; &#125;,\n  ])\n&#125;)\n&#x2F;&#x2F; 4.监听端口\napp.listen(3000)\n\n\n\n\n\n\n\n\n\n\n\n示例: post请求\n&#x2F;&#x2F; 1. 导入express包\nconst express &#x3D; require(&#39;express&#39;)\n&#x2F;&#x2F; 2. 实例化app对象\nconst app &#x3D; express()\n&#x2F;&#x2F; 3. 编写路由\n&#x2F;**\n * 创建用户\n * POST &#x2F;users\n * 请求参数: &#123;name: &#39;xiaoming&#39;, age: 20&#125;\n * 响应: &#123;id: 5, name: &#39;xiaoming&#39;, age: 20&#125;\n *&#x2F;\napp.post(&#39;&#x2F;users&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 解析req中的请求体参数\n  let postData &#x3D; &#39;&#39;\n  req.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 把所有的post的数据拼接\n    postData &#x3D; postData + data\n  &#125;)\n  req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 当所有的数据接收完成\n    &#x2F;&#x2F; 将postData字符串-&gt;JSON格式的对象\n    const obj &#x3D; JSON.parse(postData)\n    console.log(obj) &#x2F;&#x2F; 在后端的控制台中观察(Cmd窗口)\n    res.send(obj) &#x2F;&#x2F; 将数据返回客户端(浏览器Network中观察)\n  &#125;)\n&#125;)\n&#x2F;&#x2F; 4. 监听端口\napp.listen(3000)\n\n\n根据id查找对应的数据并返回\n编写post.http\nPOST http:&#x2F;&#x2F;localhost:3000&#x2F;\nContent-Type: application&#x2F;json\n\n&#123;\n\t&quot;name&quot;: &quot;xiaoming&quot;\n&#125;\n\n\n3) 响应对象响应对象用于向客户端返回数据, 在处理函数中需要调用以返回数据\n常用的有两个\n\nres.send(): 返回各种类型\nres.json(): 返回json格式的数据\n\n\n\n\n\n\n\n\n\n\n作业\n实现一个商品模块\nconst db &#x3D; [\n  &#123;id: 1, name: &#39;iphone13&#39;, price: &#39;5299&#39;, number: &#39;10&#39;&#125;,\n  &#123;id: 2, name: &#39;MacBookPro M1&#39;, price: &#39;11999&#39;, number: &#39;20&#39;&#125;,\n  &#123;id: 3, name: &#39;iPad Pro&#39;, price: &#39;4899&#39;, number: &#39;30&#39;&#125;\n]\n\n写5个接口\n\n获取所有数据\n根据id获取单个数据\n新增数据\n修改数据\n删除数据\n\n\n四. 中间件中间件的设计模式符合软件工程中的经典模式 CP 模式\n\nCore: 核心\nPulgin: 插件\n\n比如\n\n浏览器, 最核心的是浏览器, 可以通过插件扩展功能\nVSCode, 最核心的是代码编辑, 可能通过安装各种插件实现不同的功能\n\n这里的中间件类似于Plugin的作用. 可以通过使用中间件来实现丰富的功能\n1 中间件类型\n2 应用级中间件在Express中, 使用app.use或者app.METHOD注册的中间件叫做应用级中间件:::info中间件就是一个函数:::\napp.use(&#39;path&#39;, function (req, res, next) &#123;\n  next()\n&#125;)\n\n\n\n\n\n\n\n\n\n\n在中间件中需要通过调用next()执行下一个中间件\n如果不执行next(), 也没有调用send(). 这次请求将会被挂起\n中间件从影响范围上, 又分为全局中间件和局部中间件\n1) 全局中间件一般, 使用app.use 注册全局中间件\n\n\n\n\n\n\n\n\n\n全局中间件: 给每个路由规则都添加中间件处理函数\napp.use(function (req, res, next) &#123;\n  console.log(&#39;我是一个全局中间件, 影响所有的路由规则&#39;)\n&#125;)\n\n\n2) 局部中间件可以使用app.use或者app.METHOD注册局部中间件\n\n\n\n\n\n\n\n\n\n局部中间件: 给某一个特定的路由规则添加中间件处理函数\napp.use(&#39;&#x2F;users&#39;, function (req, res, next) &#123;\n  console.log(&#96;这里是一个局部中间件, 只影响&#x2F;users路由&#96;)\n  next()\n&#125;)\n\n\n\n\n\n\n\n\n\n示例一\n&#x2F;&#x2F; 不写第一个参数, 给所有访问都注册了一个中间件\napp.use(function (req, res, next) &#123;\n  console.log(&#39;Time:&#39;, Date.now())\n  next()\n&#125;)\n\n\n\n\n\n\n\n\n\n\n示例二\napp.use(&#39;&#x2F;user&#x2F;:id&#39;, function (req, res, next) &#123;\n  console.log(&#39;Request Type:&#39;, req.method)\n  next()\n&#125;)\n\napp.get(&#39;&#x2F;user&#x2F;:id&#39;, function (req, res, next) &#123;\n  res.send(&#39;USER&#39;)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n示例三\n可以同时注册多个中间件函数\napp.use(&#39;&#x2F;user&#x2F;:id&#39;, function (req, res, next) &#123;\n  console.log(&#39;Request Type:&#39;, req.method)\n  next()\n&#125;, function (req, res, next) &#123;\n  console.log(&#39;Request Params:&#39;, req.params.id)\n  next()\n&#125;)\n\napp.get(&#39;&#x2F;user&#x2F;:id&#39;, function (req, res, next) &#123;\n  res.send(&#39;USER&#39;)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n示例四\napp.use除了注册函数做为中间件外, 还可注册一个express.Router()对象\nconst router &#x3D; express.Router()\napp.use(&#39;&#x2F;user&#x2F;:id&#39;, router)\n\n\n\n\n\n\n\n\n\n作业\n:::warning需求\n\n编写一个中间件: 是一个全局中间件, 记录请求的时间 Date.now()\n编写一个中间件: 是一个局部中间件, 只有当匹配/users路由时执行. 记录请求的方法\n编写一个中间件: 是一个局部中间件, 只有当匹配/users/:id路由时执行. 记录id值\n当匹配/users/:id时执行, 返回 ‘用户的id是XX’:::&#x2F;**\n * 全局中间件: app.use(全局中间件)\n * 局部中间件: app.use(&#39;路由&#39;, 局部中间件)\n *&#x2F;\nconst express &#x3D; require(&#39;express&#39;)\nconst app &#x3D; express()\n\n&#x2F;&#x2F; 编写一个中间件: 是一个全局中间件, 记录请求的时间 Date.now()\napp.use(function (req, res, next) &#123;\n  console.log(&#96;当前时间: $&#123;Date.now()&#125;&#96;)\n  next()\n&#125;)\n\n&#x2F;&#x2F; 处理 &#x2F;users 接口\n&#x2F;&#x2F; 编写一个中间件: 是一个局部中间件, 只有当匹配&#x2F;users路由时执行. 记录请求的方法\napp.use(&#39;&#x2F;users&#39;, function (req, res, next) &#123;\n  console.log(&#96;请求的方法是: $&#123;req.method&#125;&#96;)\n  next()\n&#125;)\napp.get(&#39;&#x2F;users&#39;, function (req, res) &#123;\n  res.send(&#39;用户信息...&#39;)\n&#125;)\n\n&#x2F;&#x2F; 处理 &#x2F;users&#x2F;:id 接口\napp.use(&#39;&#x2F;users&#x2F;:id&#39;, function (req, res, next) &#123;\n  console.log(&#96;请求的id是: $&#123;req.params.id&#125;&#96;)\n  next()\n&#125;)\napp.get(&#39;&#x2F;users&#x2F;:id&#39;, function (req, res) &#123;\n  res.send(&#96;用户的id是$&#123;req.params.id&#125;&#96;)\n&#125;)\n\n&#x2F;&#x2F; app.get(\n&#x2F;&#x2F;   &#39;&#x2F;users&#x2F;:id&#39;,\n&#x2F;&#x2F;   function (req, res, next) &#123;\n&#x2F;&#x2F;     console.log(&#96;请求的id是: $&#123;req.params.id&#125;&#96;)\n&#x2F;&#x2F;     next()\n&#x2F;&#x2F;   &#125;,\n&#x2F;&#x2F;   function (req, res) &#123;\n&#x2F;&#x2F;     res.send(&#96;用户的id是$&#123;req.params.id&#125;&#96;)\n&#x2F;&#x2F;   &#125;\n&#x2F;&#x2F; )\n\napp.listen(3000)\n\n3 路由级中间件\n\nexpress.Router()对象也可以注册中间件.\n使用router.use或者router.METHOD注册的中间件叫做路由级中间件\nvar app &#x3D; express()\nvar router &#x3D; express.Router()\n\nrouter.use(function (req, res, next) &#123;\n  console.log(&#39;Time:&#39;, Date.now())\n  next()\n&#125;)\nrouter.get(&#39;&#x2F;users&#x2F;&#39;, function(req, res) &#123;\n  res.send(&#39;hello&#39;)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n路由级中间件的应用\n当路由很多的时候, 如果全部写在app入口会使用文件过大, 不好维护. 可以把不同的路由拆分成多个模块\nconst express &#x3D; require(&#39;express&#39;)\nconst userRouter &#x3D; require(&#39;.&#x2F;routes&#x2F;users.js&#39;)\n\nconst app &#x3D; express()\napp.use(function (req, res, next) &#123;\n  console.log(req.url)\n  next()\n&#125;)\n&#x2F;&#x2F; 加载路由\napp.use(&#39;&#x2F;users&#39;, userRouter)\n\napp.listen(3000)\n\nconst express &#x3D; require(&#39;express&#39;)\n\nconst router &#x3D; express.Router()\n\nrouter.get(&#39;&#x2F;&#39;, function(req, res) &#123;\n  &#x2F;&#x2F; 返回所有用户信息\n  const data &#x3D; [\n    &#123;id:1, username: &#39;xiaoming&#39;, age: 20&#125;,\n    &#123;id:2, username: &#39;xiaomei&#39;, age: 18&#125;,\n    &#123;id:3, username: &#39;xiaopang&#39;, age: 1&#125;,\n  ]\n  res.json(data)\n&#125;)\n\nrouter.get(&#39;&#x2F;:id&#39;, function(req, res) &#123;\n  &#x2F;&#x2F; 返回所有用户信息\n  const user &#x3D; &#123;id:1, username: &#39;xiaoming&#39;, age: 20&#125;\n  res.json(user)\n&#125;)\n\nmodule.exports &#x3D; router\n\n\n5 小结路由级中间件的操作步骤:::warning步骤\n\n编写routes/路由文件 \n导入express包\n创建路由对象\n编写相关路由\n导出路由对象\n\n\n在入口文件中导入路由对象\n注册中间件:::\n\n\n五. 数据库操作\n1 安装mysql库参考npm包的官方文档\nnpm i mysql\n\n\n2 入门案例操作数据库, 就是模拟客户端. 向MySQL的服务端发送SQL语句. 基本步骤如下:\n\n引入mysql包\n创建数据库连接\n连接数据库\n执行SQL查询\n关闭连接\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 1. 引入mysql包\nconst mysql &#x3D; require(&#39;mysql&#39;)\n\n&#x2F;&#x2F; 2. 创建数据库连接\nconst con &#x3D; mysql.createConnection(&#123;\n  host: &#39;localhost&#39;,\n  user: &#39;root&#39;,\n  password: &#39;123456&#39;,\n  database: &#39;db&#39;\n&#125;)\n\n&#x2F;&#x2F; 3. 连接数据库\ncon.connect()\n\n&#x2F;&#x2F; 4. 执行查询\ncon.query(&#39;select * from student&#39;, function (err, res) &#123;\n  if (err) throw err\n\n  console.log(res)\n&#125;)\n\n&#x2F;&#x2F; 5. 关闭连接\ncon.end()\n\n\n3 集成到express\n\n\n\n\n\n\n\n\n示例\n获取所有的用户\n&#x2F;&#x2F; 1. 导入express包\nconst express &#x3D; require(&#39;express&#39;)\n&#x2F;&#x2F; 2. 实例化app对象\nconst app &#x3D; express()\n&#x2F;&#x2F; 3. 路由\n&#x2F;**\n * 获取所有的用户信息\n *&#x2F;\napp.get(&#39;&#x2F;users&#39;, function (req, res) &#123;\n  &#x2F;&#x2F; 导入mysql的包\n  const mysql &#x3D; require(&#39;mysql&#39;)\n  &#x2F;&#x2F; 创建连接\n  const con &#x3D; mysql.createConnection(&#123;\n    host: &#39;127.0.0.1&#39;,\n    user: &#39;root&#39;,\n    password: &#39;123456&#39;,\n    database: &#39;user&#39;,\n  &#125;)\n  &#x2F;&#x2F; 连接数据\n  con.connect()\n  &#x2F;&#x2F; 执行sql语句\n  let sql &#x3D; &#39;select * from student&#39;\n  con.query(sql, function (err, data) &#123;\n    if (err) throw err\n    &#x2F;&#x2F; 返回结果\n    res.send(data)\n  &#125;)\n&#125;)\n&#x2F;&#x2F; 4. 监听端口\napp.listen(3000)\n\n\n\n\n\n\n\n\n\n\n练习\n实现 /users/:id根据id获取用户信息\n\n\n\n\n\n\n\n\n\n参考答案\n&#x2F;**\n * 根据id获取用户信息\n * GET &#x2F;users&#x2F;:id\n *&#x2F;\napp.get(&#39;&#x2F;users&#x2F;:id&#39;, function (req, res) &#123;\n  &#x2F;&#x2F; 一. 解析请求数据\n  const id &#x3D; req.params.id\n  &#x2F;&#x2F; 二. 操作数据库\n  &#x2F;&#x2F; 导入mysql的包\n  const mysql &#x3D; require(&#39;mysql&#39;)\n  &#x2F;&#x2F; 创建连接\n  const con &#x3D; mysql.createConnection(&#123;\n    host: &#39;127.0.0.1&#39;,\n    user: &#39;root&#39;,\n    password: &#39;123456&#39;,\n    database: &#39;user&#39;,\n  &#125;)\n  &#x2F;&#x2F; 连接数据\n  con.connect()\n  &#x2F;&#x2F; 执行sql语句\n  let sql &#x3D; &#96;select * from student where id&#x3D;$&#123;id&#125;&#96;\n  con.query(sql, function (err, data) &#123;\n    if (err) throw err\n    &#x2F;&#x2F; 返回结果\n    res.send(data)\n  &#125;)\n&#125;)\n我们发现操作数据库部分的代码是重复的. 因此, 我们需要对这部分的内容进行封装(模块化编程的思想)\n\n4 封装mysql在src下创建db/index.js, 编写如下内容\n&#x2F;&#x2F; 封装数据库的操作\n&#x2F;&#x2F; 1. 导入mysql包\nconst mysql &#x3D; require(&#39;mysql&#39;)\n&#x2F;&#x2F; 2. 创建数据库连接\nconst con &#x3D; mysql.createConnection(&#123;\n  host: &#39;127.0.0.1&#39;,\n  port: 3306,\n  user: &#39;root&#39;,\n  password: &#39;123456&#39;,\n  database: &#39;db&#39;,\n&#125;)\n&#x2F;&#x2F; 3. 连接数据库\ncon.connect()\n\n&#x2F;&#x2F; 4. 编写操作\n&#x2F;**\n * 获取所有数据\n * @param &#123;string&#125; sql : 执行的sql语句\n * @return &#123;promise&#125;\n *&#x2F;\nfunction getAll(sql) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    con.query(sql, (err, data) &#x3D;&gt; &#123;\n      if (err) reject(err)\n\n      resolve(data)\n    &#125;)\n  &#125;)\n&#125;\n\n&#x2F;**\n * 获取所有数据\n * @param &#123;string&#125; sql : 执行的sql语句\n * @return &#123;promise&#125;\n *&#x2F;\nfunction getOne(sql) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    con.query(sql, (err, data) &#x3D;&gt; &#123;\n      if (err) reject(err)\n\n      &#x2F;&#x2F; data是一个数组\n      &#x2F;&#x2F; if (data.length !&#x3D; 0) &#123;\n      &#x2F;&#x2F;   &#x2F;&#x2F; 查询到了数据\n      &#x2F;&#x2F;   resolve(data[0])\n      &#x2F;&#x2F; &#125; else &#123;\n      &#x2F;&#x2F;   resolve(null)\n      &#x2F;&#x2F; &#125;\n      data.length !&#x3D; 0 ? resolve(data[0]) : resolve(null)\n    &#125;)\n  &#125;)\n&#125;\n\n&#x2F;**\n * 执行sql语句\n * @param &#123;string&#125; sql : 执行的sql语句\n * @return &#123;promise&#125;\n *&#x2F;\nfunction exec(sql) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    con.query(sql, (err, data) &#x3D;&gt; &#123;\n      if (err) reject(err)\n\n      resolve(data)\n    &#125;)\n  &#125;)\n&#125;\n\n&#x2F;&#x2F; 暴露3个方法\nmodule.exports &#x3D; &#123;\n  getAll,\n  getOne,\n  exec,\n&#125;\n\n封装后的操作\n&#x2F;&#x2F; 1. 导入express\nconst express &#x3D; require(&#39;express&#39;)\nconst &#123; getAll, getOne &#125; &#x3D; require(&#39;.&#x2F;db&#39;)\n&#x2F;&#x2F; 2. 实例化app对象\nconst app &#x3D; express()\n&#x2F;&#x2F; 3. 编写路由\n&#x2F;**\n * GET &#x2F;users: 获取所有的用户信息\n * 返回: [&#123;&#125;, &#123;&#125;, &#123;&#125;]\n *&#x2F;\n&#x2F;&#x2F; app.get(&#39;&#x2F;users&#39;, (req, res) &#x3D;&gt; &#123;\n&#x2F;&#x2F;   &#x2F;&#x2F; 完成数据库的操作\n&#x2F;&#x2F;   let sql &#x3D; &#96;select * from users&#96;\n&#x2F;&#x2F;   getAll(sql).then((data) &#x3D;&gt; &#123;\n&#x2F;&#x2F;     res.send(data)\n&#x2F;&#x2F;   &#125;)\n&#x2F;&#x2F; &#125;)\n\napp.get(&#39;&#x2F;users&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 完成数据库的操作\n  let sql &#x3D; &#96;select * from users&#96;\n  const data &#x3D; await getAll(sql)\n  res.send(data)\n&#125;)\n\n&#x2F;**\n * GET &#x2F;users&#x2F;:id 根据id获取单个用户的信息\n * 返回: &#123;&#125;\n *&#x2F;\n&#x2F;&#x2F; app.get(&#39;&#x2F;users&#x2F;:id&#39;, (req, res) &#x3D;&gt; &#123;\n&#x2F;&#x2F;   &#x2F;&#x2F; 一. 解析请求参数, id\n&#x2F;&#x2F;   const &#123; id &#125; &#x3D; req.params\n&#x2F;&#x2F;   &#x2F;&#x2F; 二. 操作数据库\n&#x2F;&#x2F;   let sql &#x3D; &#96;select * from users where id&#x3D;$&#123;id&#125;&#96;\n&#x2F;&#x2F;   getOne(sql).then((data) &#x3D;&gt; &#123;\n&#x2F;&#x2F;     res.send(data)\n&#x2F;&#x2F;   &#125;)\n&#x2F;&#x2F; &#125;)\n\napp.get(&#39;&#x2F;users&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析请求参数, id\n  const &#123; id &#125; &#x3D; req.params\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;select * from users where id&#x3D;$&#123;id&#125;&#96;\n  const data &#x3D; await getOne(sql)\n  res.send(data)\n&#125;)\n&#x2F;&#x2F; 4. 监听端口\napp.listen(3000)\n\n\n5 使用async…await语法&#x2F;&#x2F; 1. 导入express包\nconst express &#x3D; require(&#39;express&#39;)\n\n&#x2F;&#x2F; process是当前node的进程对象. cwd(current working directory)\n&#x2F;&#x2F; 在node中不推荐使用相对路径, 相对路径 相当于 cwd()\n&#x2F;&#x2F; console.log(process.cwd())\n&#x2F;&#x2F; 导入db(数据库操作的包)\n&#x2F;* \ndb &#x3D; &#123;\n  getAll,\n  getById,\n  exec,\n&#125;\n*&#x2F;\n&#x2F;&#x2F; const db &#x3D; require(&#39;.&#x2F;db&#x2F;index&#39;)\nconst &#123; getAll, getById, exec &#125; &#x3D; require(&#39;.&#x2F;db&#x2F;index&#39;)\n&#x2F;&#x2F; 2. 实例化app对象\nconst app &#x3D; express()\n\n&#x2F;&#x2F; 处理请求体的数据. 使用express.json()中间件\napp.use(express.json())\n&#x2F;&#x2F; 3. 路由\n&#x2F;**\n * 获取所有的用户信息\n * GET &#x2F;users\n *&#x2F;\napp.get(&#39;&#x2F;users&#39;, async function (req, res) &#123;\n  &#x2F;&#x2F; 编写sql语句\n  let sql &#x3D; &#39;select * from student&#39;\n  &#x2F;&#x2F; 执行sql语句\n  &#x2F;&#x2F; getAll返回一个promise对象. 调用then方法得到data数据\n  &#x2F;&#x2F; await等待promise返回结果, 将结果作为表达式的值返回\n  const data &#x3D; await getAll(sql)\n  res.send(data)\n&#125;)\n\n&#x2F;**\n * 根据id获取用户信息\n * GET &#x2F;users&#x2F;:id\n *&#x2F;\napp.get(&#39;&#x2F;users&#x2F;:id&#39;, async function (req, res) &#123;\n  &#x2F;&#x2F; 一. 解析请求数据\n  const id &#x3D; req.params.id\n  &#x2F;&#x2F; 二. 操作数据库\n  &#x2F;&#x2F; 2.1 编写sql语句\n  let sql &#x3D; &#96;select * from student where id&#x3D;$&#123;id&#125;&#96;\n  &#x2F;&#x2F; 2.2 执行sql语句\n  const data &#x3D; await getById(sql)\n  res.send(data)\n&#125;)\n\n&#x2F;**\n * 新增用户\n * POST &#x2F;users &#123;name: &#39;test&#39;, age: 20&#125;\n *&#x2F;\napp.post(&#39;&#x2F;users&#39;, async function (req, res) &#123;\n  &#x2F;&#x2F; 一. 解析请求数据\n  console.log(req.body)\n  &#x2F;&#x2F; 对象的解构, 将body对象解构出name和age两个变量\n  const &#123; name, age &#125; &#x3D; req.body\n  &#x2F;&#x2F; console.log(name, age)\n  &#x2F;&#x2F; 二. 操作数据库\n  &#x2F;&#x2F; 2.1 编写sql语句(插入3个点: 表, 字段, 值)\n  let sql &#x3D; &#96;insert into student (name, age) values (&#39;$&#123;name&#125;&#39;, $&#123;age&#125;)&#96;\n  &#x2F;&#x2F; !!!!!!!!!!!!!! 重要调试技巧. 当sql执行出错时, 打印sql, 到控制台执行\n  console.log(sql)\n  &#x2F;&#x2F; 2.2 执行sql语句\n  const data &#x3D; await exec(sql)\n  res.send(&#123;\n    id: data.insertId,\n    name: name,\n    age: age,\n  &#125;)\n&#125;)\n\n&#x2F;**\n * 修改用户\n * PUT &#x2F;users&#x2F;:id &#123;name:&#39;xiaoming-new&#39;, age: 21&#125;\n *&#x2F;\napp.put(&#39;&#x2F;users&#x2F;:id&#39;, async function (req, res) &#123;\n  &#x2F;&#x2F; 一. 解析请求数据\n  const id &#x3D; req.params.id\n  &#x2F;&#x2F; 二. 操作数据库\n  const &#123; name, age &#125; &#x3D; req.body\n  &#x2F;&#x2F; 2.1 编写sql语句(更新4个点 表, 字段, 值, 条件)\n  let sql &#x3D; &#96;update student set name&#x3D;&#39;$&#123;name&#125;&#39;, age&#x3D;$&#123;age&#125; where id&#x3D;$&#123;id&#125;&#96;\n  &#x2F;&#x2F; 2.2 执行sql语句\n  await exec(sql)\n\n  res.send(&#123;\n    id: id,\n    name: name,\n    age: age,\n  &#125;)\n&#125;)\n\n&#x2F;**\n * 删除用户\n * DELETE &#x2F;users&#x2F;:id\n *&#x2F;\napp.delete(&#39;&#x2F;users&#x2F;:id&#39;, async function (req, res) &#123;\n  &#x2F;&#x2F; 一. 解析请求数据\n  const id &#x3D; req.params.id\n  &#x2F;&#x2F; 二. 操作数据库\n  &#x2F;&#x2F; 2.1 编写sql语句\n  let sql &#x3D; &#96;delete from student where id&#x3D;$&#123;id&#125;&#96;\n  &#x2F;&#x2F; 2.2 执行sql语句\n  await exec(sql)\n\n  res.status(204).send(&#39;&#39;)\n&#125;)\n&#x2F;&#x2F; 4. 监听端口\napp.listen(3000)\n\n","slug":"Express从入门到精通","date":"2022-12-02T05:19:27.058Z","categories_index":"服务端","tags_index":"express","author_index":"团子"},{"id":"67fd54f357341c37b5e6f85e86c46aff","title":"33_Todo小项目完成","content":"昨日回顾1,搭建基本环境\n2,后台查询所有的功能\n3,解决时间显示问题\n4,抽取数据库配置信息单独放在一个文件中\n5,异常处理\n\n\n\n后台实现查询一个\n\t对参数进行判断\n新增\n\t返回新增后的数据\n\t\t先新增,然后拿到新增的id进行查询,将查询的数据返回\n修改\n\t跟之前一样,只需要修改内容\n删除\n\t实际是调用修改的sql语句,修改deleted_time\n\n\n\n前台实现1,主界面搭建\n\t\n2,查询所有\n\t * 思路\n     * 发送ajax请求,获取数据,遍历拼接\n3,新增\n *     思路:\n *          监听文本框的键盘事件\n *          判断文本框的内容是否为空,为空给出提示,并且返回\n *          不为空,发送ajax请求,获取数据\n *          拿到数据,根据code进行判断,成功,重新获取所有列表,失败就弹出提示信息\n\n4,修改\n * 思路\n *      1,监听li元素的点击,点击li元素的时候,使用input将p标签替换\n *      2,阻止input和span的冒泡事件\n *      3,监听新创建的input框的回车和失去焦点事件\n *      4,当回车或者焦点事件被触发的时候,判断是否有内容,有的话就更新数据库,否则就返回\n\n5,删除\n * 思路\n *      通过a标签向上找到li元素绑定的id\n *      发送请求,到数据库中删除代办\n *      请求成功之后,获取所有代办\n\n\n\n","slug":"day33_课堂笔记","date":"2022-12-01T14:20:58.395Z","categories_index":"项目","tags_index":"Todolist","author_index":"团子"},{"id":"0fc374236e6bc7b1f82600ab48634b27","title":"综合案例-Todo小项目","content":"老板: 立项产品经理: 需求分析-&gt; 需求文档: \n\n需求点(文字形式的描述)\n原型图(图形的描述)\n\nUI设计师: 原型图 -&gt; 静态产品图技术经理: 技术分析 -&gt; 设计文档\n\n流程图\n数据库设计\n接口设计\n\n项目成员: 编码实现测试人员: 编码测试运维人员: 部署/上线\n一. 需求分析评估工期, 敏捷开发(最小原型, 快速迭代)时间/人力/质量\n1.需求点1. 添加待办\n在文本框内输入内容\n\n按回车添加代办\n\n如果文本框中没有内容，提示’内容不能为空’\n\n如果文本框中有内容, 添加到最上方\n\n添加完之后，清空文本框的内容\n2. 修改待办\n点击待办内容, 能够修改其中的内容\n\n修改完成, 按Enter(回车键) 或者 失去焦点时, 更新内容, 同时更新时间\n\n更新的内容不能为空\n3. 删除待办\n点击删除按钮, 删除对应的todo待办事项\n2.原型图二. 技术分析技术评估\n\n\n\n人力成本: 项目团队的人员配置(1~2前端, 1后端, 1个UI, 1测试, 1运维) 全栈(全干)\n\n进度: 项目目标分解成里程碑\n\n经济成本: 人月 58K3月 = 120K = 12W\n1. 技术选型平台\n\n操作系统: windows 10\n\n开发平台: VSCode V16.2\n\n测试平台: Chrome/FireFox – 是否兼容IE6/7/8\n\n文档平台: 语雀/ApiFox/Swagger\n\n代码平台: github/gitee9\n\n\n框架\n\n前端jQuery\n后端Express\n\n技术栈\n\n前端: H5+CSS+jQuery\nnode+Express+MySQL2. 数据库设计\n\n\n\n\n\n\n\n\nxzd_todos表\n\n\n\n\n\n字段名\n类型\n属性\n备注\n\n\n\nid\nint\n主键, 自增\nid\n\n\ncontent\nvarchar(255)\n非空, 默认值’’\n待办事项的内容\n\n\ncreated_time\ndatetime\nCURRENT_TIMESTAMP\n创建时间\n\n\nupdated_time\ndatetime\nCURRENT_TIMESTAMP, on UPDATE  CURRENT_TIMESTAMP\n更新时间\n\n\ndeleted_time\ndatetime\n\n默认值为null, 删除时记录删除时间\n\n\nCREATE TABLE &#96;xzd_todos&#96; (\n  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键id&#39;,\n  &#96;content&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;待办事项内容&#39;,\n  &#96;created_time&#96; timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;updated_time&#96; timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,\n  &#96;deleted_time&#96; timestamp NULL DEFAULT NULL COMMENT &#39;默认值为null, 表示没有删除; 如果存在时间, 说明在时间被删除&#39;,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;\n\n3. 接口设计1) baseURLhttp:&#x2F;&#x2F;localhost:3000\n\n2) 待办模块获取所有待办\n\n\n\n\n\n\n\n\n请求\n请求方式: GET\n请求URL: /todos\nGET &#x2F;todos\n\n\n\n\n\n\n\n\n\n\n成功的响应\n&#123;\n  &quot;code&quot;: 0,\n  &quot;msg&quot;: &quot;获取所有待办成功&quot;,\n  &quot;result&quot;: [\n    &#123;&quot;id&quot;:1, &quot;content&quot;: &quot;待办1&quot;, &quot;updated_time&quot;: &quot;2021-11-26 11:15:23&quot;&#125;\n  ]\n&#125;\n\n\n\n\n\n\n\n\n\n\n错误的响应\n&#123;\n  &quot;code&quot;: 100101,\n  &quot;message&quot;: &quot;获取所有待办失败&quot;,\n  &quot;result&quot;: &#123;\n    &quot;code&quot;: &quot;ER_BAD_FIELD_ERROR&quot;,\n    &quot;errno&quot;: 1054,\n    &quot;sqlMessage&quot;: &quot;Unknown column &#39;delete_time&#39; in &#39;where clause&#39;&quot;,\n    &quot;sqlState&quot;: &quot;42S22&quot;,\n    &quot;index&quot;: 0,\n    &quot;sql&quot;: &quot;select id, content, updated_time from xzd_todos where delete_time is null&quot;\n  &#125;\n&#125;\n根据id获取单个待办\n\n\n\n\n\n\n\n\n请求\n请求方式 GET\n请求地址 /todos/:id\nGET &#x2F;todos&#x2F;:id\nGET &#x2F;todos&#x2F;1\n\n\n\n\n\n\n\n\n\n\n成功的响应\n&#123;\n  &quot;code&quot;: 0,\n  &quot;msg&quot;: &quot;获取待办成功&quot;,\n  &quot;result&quot;: &#123;&quot;id&quot;:1, &quot;content&quot;: &quot;待办1&quot;, &quot;updated_time&quot;: &quot;2021-11-26 11:15:23&quot;&#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n失败的响应\n&#123;\n  &quot;code&quot;: 100102,\n  &quot;message&quot;: &quot;查询单个待办失败&quot;,\n  &quot;result&quot;: &#123;\n    &quot;code&quot;: &quot;ER_NO_SUCH_TABLE&quot;,\n    &quot;errno&quot;: 1146,\n    &quot;sqlMessage&quot;: &quot;Table &#39;db2201.xzd_todo&#39; doesn&#39;t exist&quot;,\n    &quot;sqlState&quot;: &quot;42S02&quot;,\n    &quot;index&quot;: 0,\n    &quot;sql&quot;: &quot;select id, content, updated_time from xzd_todo where id&#x3D;1 and deleted_time is null&quot;\n  &#125;\n&#125;\n\n&#123;\n  &quot;code&quot;: 100103,\n  &quot;message&quot;: &quot;id对应的数据不存在&quot;,\n  &quot;result&quot;: &quot;&quot;\n&#125;\n\n&#123;\n  &quot;code&quot;: 100104,\n  &quot;message&quot;: &quot;id必须为数字&quot;,\n  &quot;result&quot;: &quot;&quot;\n&#125;\n添加待办\n\n\n\n\n\n\n\n\n请求\n请求方式 POST\n接口地址 /todos\nPOST &#x2F;todos\n\n请求参数\n&#123;\n\t&quot;content&quot;: &quot;待办2&quot;\n&#125;\n\n\n\n\n\n\n\n\n\n\n响应\n&#123;\n  &quot;code&quot;: 0,\n  &quot;msg&quot;: &quot;添加成功&quot;,\n  &quot;result&quot;: &#123;&quot;id&quot;:1, &quot;content&quot;: &quot;待办1&quot;, &quot;updated_time&quot;: &quot;2021-11-26 11:15:23&quot;&#125;\n&#125;\n\n修改待办\n\n\n\n\n\n\n\n\n请求\n请求方式 PUT\n请求地址 /todos/1\nPUT &#x2F;todos&#x2F;:id\nPUT &#x2F;todos&#x2F;1\n\n请求参数\n&#123;\n\t&quot;content&quot;: &quot;待办2&quot;\n&#125;\n\n\n\n\n\n\n\n\n\n\n响应\n&#123;\n  &quot;code&quot;: 0,\n  &quot;msg&quot;: &quot;更新成功&quot;,\n  &quot;result&quot;: &#123;&quot;id&quot;:1, &quot;content&quot;: &quot;待办1&quot;, &quot;updated_time&quot;: &quot;2021-11-26 11:15:23&quot;&#125;\n&#125;\n\n删除待办\n\n\n\n\n\n\n\n\n请求\n请求方式 DELETE\n请求地址 /todos/:id\nDELETE &#x2F;todos&#x2F;:id\nDELETE &#x2F;todos&#x2F;1\n\n\n\n\n\n\n\n\n\n\n响应\n&#123;\n  &quot;code&quot;: 0,\n  &quot;msg&quot;: &quot;删除成功&quot;,\n  &quot;result&quot;: &#39;&#39;\n&#125;\n三. 后端实现1 搭建项目通过express脚手架创建一个项目, 默认运行在3000端口\nexpress --no-view api\n2 安装依赖在后端项目的根目录下, api目录, 执行如下命令(最好进入api目录下   cd api  )\n1) 开发环境依赖npm i nodemon -D\n\n2) 安装mysql依赖npm i mysql\n\n3) 安装cors中间件npm i cors\n\n4) 安装所有依赖npm install\n\n3 启动项目修改package.json, 使用nodemon启动项目\n&quot;scripts&quot;: &#123;\n\t&quot;start&quot;: &quot;nodemon .&#x2F;bin&#x2F;www&quot;\n&#125;,\n\n运行\nnpm run start\n\n测试\n\n4 注册cors中间件修改app.js\n&#x2F;&#x2F; 导入cors中间件的包\nconst cors &#x3D; require(&#39;cors&#39;)\n\n&#x2F;&#x2F; 注册全局中间件\napp.use(cors())\n\n\n\n\n\n\n\n\n\n示例\n\n5 规划路由1) 创建路由模块在routes目录下, 创建todos.js文件\n&#x2F;&#x2F; 一. 导入express\n&#x2F;&#x2F; 二. 实例化router对象\n&#x2F;&#x2F; 三. 编写路由规则\n&#x2F;&#x2F; 四. 导出router对象\n\n\n\n\n\n\n\n\n\n示例\n\n&#x2F;&#x2F; 一. 导入express\nconst express &#x3D; require(&#39;express&#39;)\n&#x2F;&#x2F; 二. 实例化router对象\nconst router &#x3D; express.Router()\n&#x2F;&#x2F; 三. 编写路由规则\nrouter.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;\n  res.send(&#39;todos&#39;)\n&#125;)\n&#x2F;&#x2F; 四. 导出router对象\nmodule.exports &#x3D; router\n2) 导入路由对象在app.js中导入路由对象\n&#x2F;&#x2F; 导入todosRouter对象\nconst todosRouter &#x3D; require(&#39;.&#x2F;routes&#x2F;todos&#39;)\n&#x2F;&#x2F; 注册路由\napp.use(&#39;&#x2F;todos&#39;, todosRouter)\n\n\n\n\n\n\n\n\n\n\n示例\n\n\n\n\n\n\n\n\n\n\n测试\n(略)\n6 复用数据库模块把db模块复制到目录下\n在todos.js文件中, 加载数据库操作的方法\n&#x2F;&#x2F; 导入数据库操作的方法\nconst &#123; getAll, getById, exec &#125; &#x3D; require(&#39;..&#x2F;db&#39;)\n7 实现接口1) 获取所有待办在todos.js文件中, 编写对应的路由\n&#x2F;**\n * 获取所有待办\n * GET &#x2F;todos\n *&#x2F;\nrouter.get(&#39;&#x2F;&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 操作数据库\n  let sql &#x3D; &#96;select id, content, updated_time from xzd_todos where deleted_time is null&#96;\n\n  try &#123;\n    &#x2F;&#x2F; 需要测试的代码\n    const data &#x3D; await getAll(sql)\n    res.send(&#123;\n      code: 0,\n      message: &#39;获取所有待办成功&#39;,\n      result: data,\n    &#125;)\n  &#125; catch (err) &#123;\n    &#x2F;&#x2F; 处理异常情况(错误处理)\n    res.send(&#123;\n      code: 100101, &#x2F;&#x2F; 10: 第一个版; 01: todos模块; 01: 错误\n      message: &#39;获取所有待办失败&#39;,\n      result: debug ? err : &#39;&#39;,\n    &#125;)\n  &#125;\n&#125;)\n实现 debug的配置.创建config/index.js文件, 内容如下\nmodule.exports &#x3D; &#123;\n  debug: true,\n  mysql: &#123;\n    host: &#39;127.0.0.1&#39;,\n    port: 3306,\n    user: &#39;root&#39;,\n    password: &#39;123456&#39;,\n    database: &#39;db2201&#39;,\n    timezone: &#39;SYSTEM&#39;, &#x2F;&#x2F; 解决 时间 显示的 格式问题\n  &#125;,\n&#125;\n在数据库层, db/index.js改造如下\n&#x2F;&#x2F; 导入配置文件(给mysql对象起别名)\nconst &#123; mysql: dbconfig &#125; &#x3D; require(&#39;..&#x2F;config&#39;)\n\n&#x2F;&#x2F; 2. 创建连接\nconst con &#x3D; mysql.createConnection(dbconfig)\n2) 根据id获取单个待办&#x2F;**\n * 根据id获取todo\n * GET &#x2F;todos&#x2F;:id\n *&#x2F;\nrouter.get(&#39;&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  console.log(req.params)\n  &#x2F;&#x2F; 一. 解析请求数据(id)\n  const &#123; id &#125; &#x3D; req.params\n\n  &#x2F;&#x2F; 对请求的参数格式进行校验\n  const reg &#x3D; &#x2F;^\\d+$&#x2F;\n\n  if (!reg.test(id)) &#123;\n    res.send(&#123;\n      code: 100104,\n      message: &#39;id必须为数字&#39;,\n      result: &#39;&#39;,\n    &#125;)\n    return\n  &#125;\n\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;select id, content, updated_time from xzd_todos where id&#x3D;$&#123;id&#125; and deleted_time is null&#96;\n  console.log(sql)\n  &#x2F;&#x2F; 三. 返回结果\n  try &#123;\n    var data &#x3D; await getById(sql)\n  &#125; catch (err) &#123;\n    res.send(&#123;\n      code: 100102,\n      message: &#39;查询单个待办失败&#39;,\n      result: debug ? err : &#39;&#39;,\n    &#125;)\n  &#125;\n\n  &#x2F;&#x2F; 判断...\n  if (data) &#123;\n    &#x2F;&#x2F; 成功\n    res.send(&#123;\n      code: 0,\n      message: &#39;查询单个待办成功&#39;,\n      result: data,\n    &#125;)\n  &#125; else &#123;\n    &#x2F;&#x2F; 根据id没有查询到结果\n    res.status(404).send(&#123;\n      code: 100103,\n      message: &#39;id对应的数据不存在&#39;,\n      result: &#39;&#39;,\n    &#125;)\n  &#125;\n&#125;)\n3) 添加待办&#x2F;**\n * 新增todo\n * POST &#x2F;todos &#123;content: &#39;todo-test&#39;&#125;\n *&#x2F;\nrouter.post(&#39;&#x2F;&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析请求数据(body)\n  const &#123; content &#125; &#x3D; req.body\n  &#x2F;&#x2F; console.log(content)\n  &#x2F;&#x2F; 请求参数的校验, 不能为空\n  if (!content) &#123;\n    &#x2F;&#x2F; 出错!! content &#x3D;&#x3D; undefined\n    res.send(&#123;\n      code: 100105,\n      message: &#39;content格式错误&#39;,\n      result: &#39;&#39;,\n    &#125;)\n    return\n  &#125;\n\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;insert into xzd_todos (content) values (&#39;$&#123;content&#125;&#39;)&#96;\n  try &#123;\n    var &#123; insertId &#125; &#x3D; await exec(sql)\n  &#125; catch (err) &#123;\n    res.send(&#123;\n      code: 100106,\n      message: &#39;添加待办失败&#39;,\n      result: debug ? err : &#39;&#39;,\n    &#125;)\n    return\n  &#125;\n  sql &#x3D; &#96;select id, content, updated_time from xzd_todos where id&#x3D;$&#123;insertId&#125;&#96;\n  try &#123;\n    const data &#x3D; await getById(sql)\n    &#x2F;&#x2F; 三. 结果返回\n    res.send(&#123;\n      code: 0,\n      message: &#39;添加待办成功&#39;,\n      result: data,\n    &#125;)\n  &#125; catch (err) &#123;\n    res.send(&#123;\n      code: 100106,\n      message: &#39;添加待办失败&#39;,\n      result: debug ? err : &#39;&#39;,\n    &#125;)\n  &#125;\n&#125;)\n4) 更新待办&#x2F;**\n * 修改todo\n * PUT &#x2F;todos&#x2F;:id &#123;content: &#39;todo-new&#39;&#125;\n *&#x2F;\nrouter.put(&#39;&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析请求参数\n  const &#123; id &#125; &#x3D; req.params\n  const &#123; content &#125; &#x3D; req.body\n  &#x2F;&#x2F; todo: 参数的校验\n\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;update xzd_todos set content&#x3D;&#39;$&#123;content&#125;&#39; where id&#x3D;$&#123;id&#125;&#96;\n  await exec(sql)\n\n  res.send(&#123;\n    code: 0,\n    message: &#39;更新待办成功&#39;,\n    result: &#123;\n      id: id,\n      content: content,\n    &#125;,\n  &#125;)\n&#125;)\n5) 删除待办&#x2F;**\n * 删除todo\n * DELETE &#x2F;todos&#x2F;:id\n *&#x2F;\nrouter.delete(&#39;&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析请求数据\n  const &#123; id &#125; &#x3D; req.params\n  &#x2F;&#x2F; todo: 请求参数的校验\n\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;update xzd_todos set deleted_time &#x3D; NOW() where id&#x3D;$&#123;id&#125;&#96;\n  await exec(sql)\n\n  &#x2F;&#x2F; 三. 返回结果\n  res.send(&#123;\n    code: 0,\n    message: &#39;删除成功&#39;,\n    result: &#39;&#39;,\n  &#125;)\n&#125;)\n\n四. 前端实现1 结构&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Todo List&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 一.完成HTML的结构 --&gt;\n    &lt;div class&#x3D;&quot;todo&quot;&gt;\n      &lt;div class&#x3D;&quot;header&quot;&gt;\n        添加待办:\n        &lt;input id&#x3D;&quot;add&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按回车添加待办&quot; &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;list&quot;&gt;\n        &lt;ul&gt;\n          &lt;!-- &lt;li&gt;\n            &lt;p&gt;待办1&lt;&#x2F;p&gt;\n            &lt;span&gt;上次更新:2022-02-26 11:15:23&lt;&#x2F;span&gt;\n            &lt;a href&#x3D;&quot;#&quot;&gt;删除&lt;&#x2F;a&gt;\n          &lt;&#x2F;li&gt;\n          &lt;li&gt;\n            &lt;p&gt;待办2&lt;&#x2F;p&gt;\n            &lt;span&gt;上次更新:2022-02-26 11:15:23&lt;&#x2F;span&gt;\n            &lt;a href&#x3D;&quot;#&quot;&gt;删除&lt;&#x2F;a&gt;\n          &lt;&#x2F;li&gt; --&gt;\n        &lt;&#x2F;ul&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2 样式在index.html中引用两个样式\n&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;reset.css&quot; &#x2F;&gt;\n&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;index.css&quot; &#x2F;&gt;\n1) reset样式* &#123;\n  margin: 0;\n  padding: 0;\n&#125;\n\nli &#123;\n  list-style: none;\n&#125;\n\na &#123;\n  text-decoration: none;\n&#125;\n2) 业务样式编写index.css\n.todo &#123;\n  width: 400px;\n  margin: 50px auto;\n&#125;\n\n.todo .header &#123;\n  height: 40px;\n  padding: 0 20px;\n  background-color: skyblue;\n  color: #fff;\n  line-height: 40px;\n&#125;\n\n.todo .header input &#123;\n  height: 30px;\n  padding-left: 10px;\n  color: #333;\n  border: none;\n  outline: none;\n&#125;\n\n.todo .list &#123;\n  min-height: 200px;\n  margin-top: 20px;\n  border: 1px solid #ccc;\n&#125;\n\n.todo .list li &#123;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin: 10px auto;\n  padding: 5px 20px;\n  background-color: #eee;\n&#125;\n\n.todo .list li span &#123;\n  margin-right: 5px;\n  font-size: 12px;\n  color: #999;\n&#125;\n\n.todo .list li p &#123;\n  flex: 1;\n&#125;\n3 交互在index.html中引用jQuery\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;3.6.0&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n在index.html中引用 业务代码index.js\n&lt;script src&#x3D;&quot;js&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;  注意在代码的最下面引入js文件!!!!!!!!!!!\n\n获取所有待办const BASE_URL &#x3D; &#39;http:&#x2F;&#x2F;localhost:3000&#39;\n\n&#x2F;&#x2F; 获取列表(所有待办)\nfunction getTodos() &#123;\n  &#x2F;&#x2F; 发送ajax请求, 调用 GET &#x2F;todos接口\n  $.ajax(&#123;\n    type: &#39;GET&#39;,\n    url: &#96;$&#123;BASE_URL&#125;&#x2F;todos&#96;,\n    success: function (res) &#123;\n      console.log(res)\n      &#x2F;&#x2F; 解构res对象\n      const &#123; code, message, result &#125; &#x3D; res\n      if (code &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 成功, 遍历result(数组)\n        result.forEach((item) &#x3D;&gt; &#123;\n          &#x2F;&#x2F; 在ul的后面添加li元素\n          $(&#39;.list ul&#39;).append(&#96;&lt;li&gt;\n          &lt;p&gt;$&#123;item.content&#125;&lt;&#x2F;p&gt;\n          &lt;span&gt;上次更新:$&#123;item.updated_time&#125;&lt;&#x2F;span&gt;\n          &lt;a href&#x3D;&quot;#&quot;&gt;删除&lt;&#x2F;a&gt;\n          &lt;&#x2F;li&gt;&#96;)\n        &#125;)\n      &#125; else &#123;\n        alert(message)\n      &#125;\n    &#125;,\n  &#125;)\n&#125;\n\ngetTodos()\n添加待办&#x2F;&#x2F; 添加待办\n&#x2F;&#x2F; 一. 监听add这个input框的回车事件\n&#x2F;&#x2F; 1.1 判断input框架的内容为空, 提示&quot;不能为空&quot;, 返回\n&#x2F;&#x2F; 1.2 判断input框架的内容不为空, 发送ajax请求, [POST &#x2F;todos]接口\n&#x2F;&#x2F; 1.3 拿到数据后, 判断是否失败, 如果成功, 重新加载数据\n$(&#39;#add&#39;).keyup((e) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; console.log(e)\n  &#x2F;&#x2F; 如果按下的键是回车键\n  if (e.keyCode &#x3D;&#x3D;&#x3D; 13) &#123;\n    &#x2F;&#x2F; 获取input框架的值\n    var inputValue &#x3D; $(&#39;#add&#39;).val()\n\n    &#x2F;&#x2F; 去掉首尾的空白字符\n    if (inputValue.trim() &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;\n      alert(&#39;待办事项不能为空&#39;)\n      return\n    &#125;\n\n    &#x2F;&#x2F; 发送ajax请求, 请求[POST &#x2F;todos]接口\n    $.ajax(&#123;\n      type: &#39;POST&#39;,\n      url: &#96;$&#123;BASE_URL&#125;&#x2F;todos&#96;,\n      data: &#123; content: inputValue &#125;,\n      success: function (res) &#123;\n        &#x2F;&#x2F; 清空输入框的数据\n        $(&#39;#add&#39;).val(&#39;&#39;)\n\n        const &#123; code, message &#125; &#x3D; res\n        if (code &#x3D;&#x3D;&#x3D; 0) &#123;\n          &#x2F;&#x2F; 重新获取列表\n          getTodos()\n        &#125; else &#123;\n          alert(message)\n        &#125;\n      &#125;,\n    &#125;)\n  &#125;\n&#125;)\n发现了一个问题, 当添加时会重复出现多条记录\n\n\n\n\n\n\n\n\n\n解决方法\n在getTodos时, 先清空子节点\n&#x2F;&#x2F; 获取列表(所有待办)\nfunction getTodos() &#123;\n  &#x2F;&#x2F; 发送ajax请求, 调用 GET &#x2F;todos接口\n  $.ajax(&#123;\n    type: &#39;GET&#39;,\n    url: &#96;$&#123;BASE_URL&#125;&#x2F;todos&#96;,\n    success: function (res) &#123;\n      console.log(res)\n      &#x2F;&#x2F; 解构res对象\n      const &#123; code, message, result &#125; &#x3D; res\n      if (code &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 清空ul中的数据\n        $(&#39;.list ul&#39;).empty()\n        &#x2F;&#x2F; 成功, 遍历result(数组)\n        result.forEach((item) &#x3D;&gt; &#123;\n          &#x2F;&#x2F; 在ul的后面添加li元素\n          $(&#39;.list ul&#39;).append(&#96;&lt;li&gt;\n                                  &lt;p&gt;$&#123;item.content&#125;&lt;&#x2F;p&gt;\n                                  &lt;span&gt;上次更新:$&#123;item.updated_time&#125;&lt;&#x2F;span&gt;\n                                  &lt;a href&#x3D;&quot;#&quot;&gt;删除&lt;&#x2F;a&gt;\n                                &lt;&#x2F;li&gt;&#96;)\n        &#125;)\n      &#125; else &#123;\n        alert(message)\n      &#125;\n    &#125;,\n  &#125;)\n&#125;\n修改待办&#x2F;&#x2F; 修改待办\n&#x2F;&#x2F; 当点击文字时, 变成一个可以输入的框. 拿到之前的数据\n$(&#39;.list&#39;).on(&#39;click&#39;, &#39;li&#39;, function () &#123;\n  &#x2F;&#x2F; on---监听动态创建的元素的事件\n  &#x2F;&#x2F; console.log($(this).find(&#39;p&#39;).text())\n  &#x2F;&#x2F; console.log($(this).find(&#39;span&#39;).text())\n  const content &#x3D; $(this).find(&#39;p&#39;).text()\n  const date &#x3D; $(this).find(&#39;span&#39;).text()\n\n  $(this).html(\n    &#96;&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;$&#123;content&#125;&quot;&#x2F;&gt;&lt;span&gt;$&#123;date&#125;&lt;&#x2F;span&gt;&lt;a href&#x3D;&quot;#&quot;&gt;删除&lt;&#x2F;a&gt;&#96;\n  )\n&#125;)\n\n&#x2F;&#x2F; 阻止input的点击事件向上冒泡\n$(&#39;.list&#39;).on(&#39;click&#39;, &#39;input&#39;, function (e) &#123;\n  e.stopPropagation()\n&#125;)\n\n&#x2F;&#x2F; 监听新创建的input框的回车事件\n$(&#39;.list&#39;).on(&#39;keyup&#39;, &#39;input&#39;, function (e) &#123;\n  if (e.keyCode &#x3D;&#x3D; 13) &#123;\n    &#x2F;&#x2F; 判断当前输入框的值为空\n    if ($(this).val().trim() &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;\n      alert(&#39;待办内容不能为空&#39;)\n      return\n    &#125;\n\n    const id &#x3D; $(this).parent().attr(&#39;data-index&#39;)\n    console.log(id)\n    &#x2F;&#x2F; 发送ajax请求\n    $.ajax(&#123;\n      type: &#39;PUT&#39;,\n      url: &#96;$&#123;BASE_URL&#125;&#x2F;todos&#x2F;$&#123;id&#125;&#96;,\n      data: &#123; content: $(this).val() &#125;,\n      success: function (res) &#123;\n        &#x2F;&#x2F; 重新获取数据\n        const &#123; code, message &#125; &#x3D; res\n        if (code &#x3D;&#x3D;&#x3D; 0) &#123;\n          getTodos()\n        &#125; else &#123;\n          alert(message)\n        &#125;\n      &#125;,\n    &#125;)\n  &#125;\n&#125;)\n$(&#39;.list&#39;).on(&#39;blur&#39;, &#39;input&#39;, function () &#123;\n  &#x2F;&#x2F; 判断当前输入框的值为空\n  if ($(this).val().trim() &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;\n    alert(&#39;待办内容不能为空&#39;)\n    return\n  &#125;\n\n  const id &#x3D; $(this).parent().attr(&#39;data-index&#39;)\n  console.log(id)\n  &#x2F;&#x2F; 发送ajax请求\n  $.ajax(&#123;\n    type: &#39;PUT&#39;,\n    url: &#96;$&#123;BASE_URL&#125;&#x2F;todos&#x2F;$&#123;id&#125;&#96;,\n    data: &#123; content: $(this).val() &#125;,\n    success: function (res) &#123;\n      &#x2F;&#x2F; 重新获取数据\n      const &#123; code, message &#125; &#x3D; res\n      if (code &#x3D;&#x3D;&#x3D; 0) &#123;\n        getTodos()\n      &#125; else &#123;\n        alert(message)\n      &#125;\n    &#125;,\n  &#125;)\n&#125;)\n删除待办&#x2F;&#x2F; 删除待办\n$(&#39;.list&#39;).on(&#39;click&#39;, &#39;a&#39;, function (e) &#123;\n  &#x2F;&#x2F; 阻止a元素向上冒泡\n  e.stopPropagation()\n\n  const id &#x3D; $(this).parent().attr(&#39;data-index&#39;)\n\n  $.ajax(&#123;\n    type: &#39;DELETE&#39;,\n    url: &#96;$&#123;BASE_URL&#125;&#x2F;todos&#x2F;$&#123;id&#125;&#96;,\n    success: function (res) &#123;\n      const &#123; code &#125; &#x3D; res\n      if (code &#x3D;&#x3D;&#x3D; 0) &#123;\n        getTodos()\n      &#125;\n    &#125;,\n  &#125;)\n&#125;)\n五. 联调六. 测试七. 部署八. 运维","slug":"综合案例-Todo小项目","date":"2022-12-01T14:18:16.930Z","categories_index":"项目","tags_index":"Todolist","author_index":"团子"},{"id":"b455dd2018d164911d1cb5d5e588f15b","title":"32_todolist项目练习及讲解","content":"1,后端基本功能实现环境的搭建\n\t1,生成api后端目录\n\t2,安装额外的nodemon,mysql,cors包\n\t3,集成nodemon,使用cors中间件\n\t4,创建todos.js路由模块\n\t5,导入数据库操作模块,编写具体的路由\n\n\n增删改查基本功能\n\t\n\n2,处理时间显示问题const con &#x3D; mysql.createConnection(&#123;\n    host:&#39;localhost&#39;,\n    port:3306,\n    user:&#39;root&#39;,\n    password:&#39;1234&#39;,\n    database:&#39;db2022_01&#39;,\n    timezone:&#39;SYSTEM&#39; &#x2F;* 使用系统时区 *&#x2F;\n  &#125;)\n\n3,提取mysql的配置目的\n\tmysql的配置经常会改变,方便后面操作\n\t还可以额外增加一个debug属性,将来根据这属性的值,来决定是否显示错误信息\n\t(在测试环境中,显示错误信息,在线上环境,不显示错误信息)\n做法\n\t1,在api下创建一个config文件夹,然后在创建一个index.js文件\n\t2,将mysql的配置信息剪切到index.js中,并导出\n\t3,在db文件夹下的index.js中导入mysql的配置信息并使用\n\n4,实现异常处理异常的两种处理方式\t\n\t1,throw(甩锅)\n\t\t抛出异常,一般是抛出一个异常对象(error)\n\t\t如果不进行处理的话,程序就会停止运行,后面的代码就无法执行\n\t\t\n\t2,try-catch(接盘)\n\t\t可以让程序在出了异常之后,后续代码能够正常执行,增强程序的健壮性\n\t\t\n\t\t语法\n\t\t\ttry&#123;\n\t\t\t\t可能会出现异常的代码\n\t\t\t&#125;catch(error)&#123;\n\t\t\t\t处理异常对象的代码\n\t\t\t&#125;\n\n做法\n\t&#x2F;&#x2F;导入调试的标记\n\tconst&#123;debug&#125; &#x3D; require(&#39;..&#x2F;config&#39;);\n\t\n\t\n\t  &#x2F;&#x2F;处理异常\n       try &#123;\n            const data &#x3D; await getAll(sql)\n            res.send(&#123;\n                    code:0,\n                    msg:&#39;获取所有代办成功&#39;,\n                    result:data\n            &#125;)\n       &#125; catch (error) &#123;\n            res.send(&#123;\n                code:100101,&#x2F;&#x2F;10代表第一个版本,01代表todolist项目,01代表第一个错误\n                msg:&#39;获取所有代办失败&#39;,\n                result: debug? error : &#39;&#39;\n            &#125;)\n       &#125;\n\n","slug":"day32_课堂笔记","date":"2022-12-01T14:15:54.316Z","categories_index":"项目","tags_index":"Todolist","author_index":"团子"},{"id":"106826aea6b9ab5ab35ab7da587e641c","title":"31_用户管理系统前端增删改完成","content":"昨日回顾1,将数据库操作的代码命名为index.js,放在db文件夹下.方便管理\n\n2,脚手架的使用及项目环境搭建(项目代码生成器)\n\t安装\n\t创建项目名,express --no-view backEnd 生成后端目录\n\t安装包(自带的包,mysql cors,nodemon)\n\t更改启动方式(node -&gt; nodemon)\n\t启动 进入后端目录,使用npm run start\n\t复制mysql操作的模块,并引入\n\t引入cors的模块,并使用\n\t\n3,编写后台代码\n\t找对路径,在user的路由模块中进行操作\n\t提供增删改查的路由,并调用相应的处理函数进行处理\n\t\n4,编写前台代码(查询)\n\t1,先写页面骨架\n\t2,再写样式\n\t3,发送ajax请求\n\t4,处理返回的数据,展示数据\n\t\n\n前台实现新增\n\t1,编写add.html页面骨架\n\t2,在style.css中,添加add.html的样式\n\t3,监听add按钮的点击,在点击事件中,获取用户输入的姓名和年龄进行判断\n\t4,如果为空,直接返回,否则,就发送post请求,提交到后台,修改数据库中的数据\n\t5,修改成功,弹出提示,并跳转到list.html页面\n\t\n修改\n\t1,编写edit.html页面的骨架\n\t2,在list.html页面为 修改的a标签 的href中拼接id属性\n\t3,在edit.html页面中获取跳转过来的路径携带过来的id的值\n\t4,发送ajax请求,根据id查找响应的用户,回显数据\n\t5,给按钮添加点击事件,获取用户输入的用户名和年龄进行判断\n\t6,如果为空,直接返回,否则,就发送put请求,提交到后台,修改数据库中的数据\n\t7,修改成功,弹出提示,并跳转到list.html页面\n\t\n删除\n\t1,在list.html页面为 删除的a标签的onclick属性中 设置方法,传入id\n    2,实现删除的方法,删除之前先弹出确认信息\n    3,如果确认删除,就发送ajax请求,删除数据库中的数据\n    4,删除成功,跳回当前页面\n\n","slug":"day31_课堂笔记","date":"2022-12-01T14:14:07.773Z","categories_index":"服务端","tags_index":"express","author_index":"团子"},{"id":"5a9c51c782f6d4d77fd9a0571cb97c4f","title":"Express框架应用-实现用户模块","content":"\n一. 需求分析\n1 系统框架选择前后端分离的系统架构\n\n\n2 具体的业务需求\n有一个页面, 可以展示用户的列表\n有一个页面, 可以添加用户信息\n有一个页面, 可以修改用户信息\n点击删除按钮, 可以删除用户信息\n\n\n\n二. 技术方案\n1 数据库设计\n\n\n\n\n\n\n\n\n用户表  (users)\n\n\n\n字段名\n类型\n备注\n\n\n\nid\nint\n主键, 自增\n\n\nname\nvarchar(255)\n用户的姓名\n\n\nage\ntinyint unsigned\n用户的年龄\n\n\n使用Navicate建表\n\n2 接口设计\n1) baseURLhttp:&#x2F;&#x2F;localhost:3000\n\n\n2) 用户模块\n获取所有用户\n\n\n\n\n\n\n\n\n请求\n请求方式: GET请求URL: /users\nGET &#x2F;users\n\n\n\n\n\n\n\n\n\n响应\n[\n  &#123;\n    &quot;id&quot;: 1,\n    &quot;name&quot;: &quot;xiaoming&quot;,\n    &quot;age&quot;: 20\n\t&#125;,\n  &#123;\n    &quot;id&quot;: 2,\n    &quot;name&quot;: &quot;xiaomei&quot;,\n    &quot;age&quot;: 18\n\t&#125;,\n]\n\n\n根据id获取单个用户\n\n\n\n\n\n\n\n\n请求\n请求方式 GET请求地址 /users/:id\nGET &#x2F;users&#x2F;:id\nGET &#x2F;users&#x2F;1\n\n\n\n\n\n\n\n\n\n\n响应\n&#123;\n  &quot;id&quot;: 1,\n  &quot;name&quot;: &quot;xiaoming&quot;,\n  &quot;age&quot;: 20\n&#125;\n\n\n添加用户\n\n\n\n\n\n\n\n\n请求\n请求方式 POST接口地址 /users\nPOST &#x2F;users\n\n请求参数\n&#123;\n\t&quot;name&quot;: &quot;xiaoming&quot;,\n\t&quot;age&quot;: 20\n&#125;\n\n\n\n\n\n\n\n\n\n\n响应\n&#123;\n  &quot;id&quot;: 1,\n  &quot;name&quot;: &quot;xiaoming&quot;,\n  &quot;age&quot;: 20\n&#125;\n\n\n修改用户\n\n\n\n\n\n\n\n\n请求\n请求方式 PUT请求地址 /users/1\nPUT &#x2F;users&#x2F;:id\nPUT &#x2F;users&#x2F;1\n\n请求参数\n&#123;\n\t&quot;name&quot;: &quot;xiaoming-new&quot;,\n\t&quot;age&quot;: 200\n&#125;\n\n\n\n\n\n\n\n\n\n\n响应\n&#123;\n  &quot;id&quot;: 1,\n  &quot;name&quot;: &quot;xiaoming-new&quot;,\n  &quot;age&quot;: 200\n&#125;\n\n\n删除用户\n\n\n\n\n\n\n\n\n请求\n请求方式 DELETE请求地址 /users/:id\nDELETE &#x2F;users&#x2F;:id\nDELETE &#x2F;users&#x2F;1\n\n\n\n\n\n\n\n\n\n\n响应\n空\n\n\n三. 技术实现\n1 后端\n1) 项目搭建\n安装express脚手架执行命令, 全局安装脚本架(也称为项目生成器)\nnpm i express-generator -g\n\n安装完成后, 在全局会多一个命令\nexpress\n\n\n通过脚手加搭建项目在根目录下, 执行命令\nexpress --no-view backEnd\n\n\n在目录下创建一个backEnd的目录, 作为后端项目的目录\n--no-view: 创建一个数据服务, 不提供页面服务\n\n\n安装相关依赖进入backEnd目录, 执行命令, 根据package.jsoon中的依赖项, 安装项目所有的依赖\n\ncookie-parser: 解析cookie的中间件\ndebug: 调试代码的中间件\nexpress: express框架包\nmorgan: 记录日志的中间件\n\nnpm install\n\n\n启动项目使用nodemon启动项目,将nodemon作为开发时依赖安装\nnpm i nodemon -D\n\n会在package.json中, 生成devDependencies\n&quot;devDependencies&quot;: &#123;\n  &quot;nodemon&quot;: &quot;^2.0.15&quot;\n&#125;\n\n修改pagckage.json中的脚本\n&quot;scripts&quot;: &#123;\n  &quot;start&quot;: &quot;nodemon .&#x2F;bin&#x2F;www&quot;\n&#125;,\n\n执行\nnpm run start\n\n使用浏览器测试\n\n\n2) 实现获取所有用户编写router/users.js文件\nrouter.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 编写sql语句\n  &#x2F;&#x2F; 二. 执行sql语句, 获得结果\n  &#x2F;&#x2F; 三. 返回数据\n&#125;)\n\n\n安装mysql包npm i mysql\n\n\n复用数据库操作模块\n修改配置\n导入db模块\n\n\n\n\n\n\n\n\n\n示例\nconst &#123; getAll, getById, exec &#125; &#x3D; require(&#39;..&#x2F;db&#39;)\n&#x2F;&#x2F; 编写接口\n&#x2F;&#x2F; GET &#x2F;users\nrouter.get(&#39;&#x2F;&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 编写sql语句\n  let sql &#x3D; &#39;select * from users&#39;\n  &#x2F;&#x2F; 二. 执行sql语句, 获得结果\n  const users &#x3D; await getAll(sql)\n  &#x2F;&#x2F; 三. 返回数据\n  res.send(users)\n&#125;)\n\n\n测试创建test/users.http测试文件\n@baseURL &#x3D; http:&#x2F;&#x2F;localhost:3000\n\n###\nGET &#123;&#123;baseURL&#125;&#125;&#x2F;users\n\n\n\n3) 实现根据id获取单个用户&#x2F;&#x2F; 根据id获取单个用户\n&#x2F;&#x2F; GET &#x2F;users&#x2F;:id -&gt; &#123;&#125;\nrouter.get(&#39;&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析参数\n  let &#123; id &#125; &#x3D; req.params\n\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;select * from users where id&#x3D;$&#123;id&#125;&#96;\n  const user &#x3D; await getById(sql)\n\n  &#x2F;&#x2F; 三. 返回结果\n  res.send(user)\n&#125;)\n\n测试\n\n4) 实现添加用户&#x2F;&#x2F; 添加用户\n&#x2F;&#x2F; POST &#x2F;users &#123;&quot;name&quot;:&quot;test&quot;, &quot;age&quot;:20&#125;\nrouter.post(&#39;&#x2F;&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析参数\n  const &#123; name, age &#125; &#x3D; req.body\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;insert into users (name, age) values (&#39;$&#123;name&#125;&#39;, &#39;$&#123;age&#125;&#39;)&#96;\n  &#x2F;&#x2F; console.log(sql)\n  const resData &#x3D; await exec(sql)\n  &#x2F;&#x2F;console.log(resData)\n  &#x2F;&#x2F; 三. 返回结果\n  res.send(&#123;\n    id: resData.insertId,\n    name, &#x2F;&#x2F; name: name\n    age, &#x2F;&#x2F; age: age\n  &#125;)\n&#125;)\n\n测试\n\n5) 实现修改接口&#x2F;&#x2F; 修改用户\n&#x2F;&#x2F; PUT &#x2F;users&#x2F;:id &#123;&quot;name&quot;:&quot;test-new&quot;, &quot;age&quot;:30&#125;\nrouter.put(&#39;&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析参数\n  let &#123; id &#125; &#x3D; req.params\n  let &#123; name, age &#125; &#x3D; req.body\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;update users set name&#x3D;&#39;$&#123;name&#125;&#39;, age&#x3D;&#39;$&#123;age&#125;&#39; where id&#x3D;$&#123;id&#125;&#96;\n  const resData &#x3D; await exec(sql)\n  &#x2F;&#x2F; 三. 返回结果\n  console.log(resData)\n  res.send(&#123;\n    id,\n    name,\n    age,\n  &#125;)\n&#125;)\n\n测试\n\n6) 实现删除接口&#x2F;&#x2F; 删除用户\nrouter.delete(&#39;&#x2F;:id&#39;, async (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 一. 解析参数\n  let &#123; id &#125; &#x3D; req.params\n  &#x2F;&#x2F; 二. 操作数据库\n  let sql &#x3D; &#96;delete from users where id &#x3D; &#39;$&#123;id&#125;&#39;&#96;\n  await exec(sql)\n  &#x2F;&#x2F; 三. 返回结果\n  res.status(204).send(&#39;&#39;)\n&#125;)\n\n测试\n\n2 前端前后端交互流程图点击查看【processon】\n\n1) 创建index.html\n编写页面结构&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;用户列表&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;用户列表&lt;&#x2F;h1&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;a href&#x3D;&quot;.&#x2F;add.html&quot; class&#x3D;&quot;add-btn&quot;&gt;添加用户&lt;&#x2F;a&gt;\n      &lt;table class&#x3D;&quot;user-list&quot;&gt;\n        &lt;tr&gt;\n          &lt;th&gt;id&lt;&#x2F;th&gt;\n          &lt;th&gt;name&lt;&#x2F;th&gt;\n          &lt;th&gt;age&lt;&#x2F;th&gt;\n          &lt;th&gt;操作&lt;&#x2F;th&gt;\n        &lt;&#x2F;tr&gt;\n      &lt;&#x2F;table&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n编写样式* &#123;\n  margin: 0;\n  padding: 0;\n&#125;\n\na &#123;\n  text-decoration: none;\n&#125;\ntable,\nth,\ntd &#123;\n  border: 1px solid #000;\n&#125;\n\n\n.container &#123;\n  width: 80%;\n  padding: 20px 50px;\n&#125;\n.container .add-btn &#123;\n  &#x2F;* 第一段: position display *&#x2F;\n  display: inline-block;\n\n  &#x2F;* 第二段: 盒子模型 margin padding border width height *&#x2F;\n  padding: 12px 20px;\n  border: 1px solid #169bd5;\n\n  &#x2F;* 第三段: 背景相关 *&#x2F;\n  background-color: #ecf5ff;\n  &#x2F;* 第四段: 文本相关 *&#x2F;\n  color: #169bd5;\n  line-height: 1;\n  text-align: center;\n  cursor: pointer;\n\n  &#x2F;* 第五段: CSS3新增属性 *&#x2F;\n  border-radius: 5px;\n  box-sizing: border-box;\n  transition: all 0.2s;\n&#125;\n.container .add-btn:hover &#123;\n  background-color: #fff;\n  color: #169bd5;\n&#125;\n.container .user-list &#123;\n  margin-top: 20px;\n  width: 500px;\n  border: 1px solid #000;\n  border-spacing: 0px;\n  border-collapse: collapse;\n  text-align: center;\n&#125;\n\n.form-item &#123;\n  margin: 20px auto;\n&#125;\n\n.form-item input &#123;\n  padding: 0 15px;\n  border: 1px solid #dcdfe6;\n  height: 40px;\n\n  color: #606266;\n  outline: none;\n  transition: border-color 0.2s cubic-bezier(0.645, 0.045, 0.355, 1);\n  border-radius: 4px;\n&#125;\n\n.form-item input:focus &#123;\n  border-color: #409eff;\n&#125;\n\n\n\n编写js引入jquery, 使用npm下载. 使用离线版文件\n&lt;script src&#x3D;&quot;.&#x2F;lib&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n发送ajax请求\n&#x2F;&#x2F; 调用接口(获取所有用户)\n$.ajax(&#123;\n  url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;,\n  type: &#39;GET&#39;,\n  success: function (res) &#123;\n    console.log(res)\n  &#125;,\n&#125;)\n\n发现报错:\n\n\n\n\n\n\n\n\n\n原因\n发生了跨域请求\n\n\n\n\n\n\n\n\n\n跨域请求\n\n由于浏览器同源策略导致跨域问题\n当浏览器从一个域向另一个域发送请求时, 它认为这种请求不安全, 不允许发送\n\n域 = 协议  + 域名 + 端口\n\n\n\n\n\n\n\n\n\n最常用的解决方案\n在服务端开启CORS, 在服务端回复的响应头中, 加入特殊的头信息, 允许浏览器发送跨域请求在后端安装cors中间件https://www.npmjs.com/package/cors\nnpm i cors\n\n在app.js中导入cors中间件\nconst cors &#x3D; require(&#39;cors&#39;)\n\n全局注册cors()中间件\napp.use(cors())\n\n\n\n\n\n\n\n\n\n\n改造前台\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;用户列表&lt;&#x2F;title&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;css&#x2F;reset.css&quot; &#x2F;&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;css&#x2F;index.css&quot; &#x2F;&gt;\n    &lt;script src&#x3D;&quot;.&#x2F;lib&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;用户列表&lt;&#x2F;h1&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;a href&#x3D;&quot;.&#x2F;add.html&quot; class&#x3D;&quot;add-btn&quot;&gt;添加用户&lt;&#x2F;a&gt;\n      &lt;table class&#x3D;&quot;user-list&quot;&gt;\n        &lt;tr&gt;\n          &lt;th&gt;id&lt;&#x2F;th&gt;\n          &lt;th&gt;name&lt;&#x2F;th&gt;\n          &lt;th&gt;age&lt;&#x2F;th&gt;\n          &lt;th&gt;操作&lt;&#x2F;th&gt;\n        &lt;&#x2F;tr&gt;\n      &lt;&#x2F;table&gt;\n    &lt;&#x2F;div&gt;\n    &lt;script src&#x3D;&quot;.&#x2F;js&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n&#x2F;&#x2F; 通过jquery发送ajax请求. 调用接口, 获取数据\n$.ajax(&#123;\n  url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;,\n  type: &#39;GET&#39;,\n  success: function (res) &#123;\n    &#x2F;&#x2F; 发送请求, 获取的数据存放在res里\n    console.log(res)\n\n    &#x2F;&#x2F; 遍历res数组\n    res.forEach((item) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 渲染table表格\n      let str &#x3D; &#96;&lt;tr&gt;\n                  &lt;td&gt;$&#123;item.id&#125;&lt;&#x2F;td&gt;\n                  &lt;td&gt;$&#123;item.name&#125;&lt;&#x2F;td&gt;\n                  &lt;td&gt;$&#123;item.age&#125;&lt;&#x2F;td&gt;\n                  &lt;td&gt;\n                    &lt;a href&#x3D;&quot;.&#x2F;edit.html&quot;&gt;修改&lt;&#x2F;a&gt;\n                    &lt;a href&#x3D;&quot;#&quot;&gt;删除&lt;&#x2F;a&gt;\n                  &lt;&#x2F;td&gt;\n                &lt;&#x2F;tr&gt;&#96;\n\n      $(&#39;.user-list&#39;).append(str)\n    &#125;)\n  &#125;,\n&#125;)\n\n\n2) 创建add.html\n编写页面结构&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;添加用户&lt;&#x2F;title&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;css&#x2F;reset.css&quot; &#x2F;&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;css&#x2F;index.css&quot; &#x2F;&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;添加用户&lt;&#x2F;h1&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;div class&#x3D;&quot;form-item&quot;&gt;\n        用户名:\n        &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; name&#x3D;&quot;name&quot; placeholder&#x3D;&quot;请输入用户名&quot; &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;form-item&quot;&gt;\n        年龄:\n        &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;age&quot; name&#x3D;&quot;age&quot; placeholder&#x3D;&quot;请输入年龄&quot; &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n      &lt;button id&#x3D;&quot;btn&quot; class&#x3D;&quot;add-btn&quot;&gt;添加&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n编写样式.form-item &#123;\n  margin: 20px auto;\n&#125;\n.form-item input &#123;\n  padding-left: 15px;\n  border: 1px solid #dcdfe6;\n  height: 40px;\n\n  color: #606266;\n  outline: none;\n  cursor: pointer;\n\n  border-radius: 4px;\n  transition: border-color 0.2s cubic-bezier(0.645, 0.045, 0.355, 1);\n&#125;\n.form-item input:focus &#123;\n  border-color: #409eff;\n&#125;\n\n编写js\n3) 创建edit.html\n修改入口$.ajax(&#123;\n  url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;,\n  type: &#39;GET&#39;,\n  success: function (res) &#123;\n    &#x2F;&#x2F; console.log(res)\n    &#x2F;&#x2F; 遍历res数组\n    &#x2F;&#x2F; 创建一个tr元素, 追加到表格的最后\n    res.forEach((item) &#x3D;&gt; &#123;\n      const tr &#x3D; &#96;&lt;tr&gt;\n                    &lt;td&gt;$&#123;item.id&#125;&lt;&#x2F;td&gt;\n                    &lt;td&gt;$&#123;item.name&#125;&lt;&#x2F;td&gt;\n                    &lt;td&gt;$&#123;item.age&#125;&lt;&#x2F;td&gt;\n                    &lt;td&gt;\n                      &lt;a href&#x3D;&quot;.&#x2F;edit.html?id&#x3D;$&#123;item.id&#125;&quot;&gt;修改&lt;&#x2F;a&gt;\n                      &lt;a href&#x3D;&quot;#&quot; onclick&#x3D;&quot;handleDel($&#123;item.id&#125;)&quot;&gt;删除&lt;&#x2F;a&gt;\n                    &lt;&#x2F;td&gt;\n                  &lt;&#x2F;tr&gt;&#96;\n      $(&#39;.user-list&#39;).append(tr)\n    &#125;)\n  &#125;,\n&#125;)\n\n编写页面&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;修改用户&lt;&#x2F;title&gt;\n    &lt;!-- 二. 编写样式 --&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;reset.css&quot; &#x2F;&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;list.css&quot; &#x2F;&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.6.0&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 一. 编写HTML结构 --&gt;\n    &lt;h1&gt;修改用户&lt;&#x2F;h1&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;div class&#x3D;&quot;form-item&quot;&gt;\n        用户名:\n        &lt;input\n               type&#x3D;&quot;text&quot;\n               id&#x3D;&quot;username&quot;\n               name&#x3D;&quot;username&quot;\n               placeholder&#x3D;&quot;请输入用户名&quot;\n               &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;form-item&quot;&gt;\n        年龄:\n        &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;age&quot; name&#x3D;&quot;age&quot; placeholder&#x3D;&quot;请输入年龄&quot; &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n      &lt;button id&#x3D;&quot;btn&quot; class&#x3D;&quot;add-btn&quot;&gt;提交&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n    &lt;script&gt;\n      &#x2F;&#x2F; 三. 发送ajax请求, 根据id查找用户的信息\n      &#x2F;&#x2F; console.log(window.location)\n      &#x2F;&#x2F; console.log(window.location.search)\n      &#x2F;&#x2F; console.log(window.location.search.replace(&#39;?&#39;, &#39;&#39;))\n      &#x2F;&#x2F; console.log(window.location.search.replace(&#39;?&#39;, &#39;&#39;).split(&#39;&#x3D;&#39;))\n      &#x2F;&#x2F; console.log(window.location.search.replace(&#39;?&#39;, &#39;&#39;).split(&#39;&#x3D;&#39;)[1])\n      const id &#x3D; window.location.search.replace(&#39;?&#39;, &#39;&#39;).split(&#39;&#x3D;&#39;)[1]\n      $.ajax(&#123;\n        type: &#39;GET&#39;,\n        url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;&#39; + id,\n        success: function (res) &#123;\n          console.log(res)\n          &#x2F;&#x2F; 设置input的值\n          $(&#39;#username&#39;).val(res.name)\n          $(&#39;#age&#39;).val(res.age)\n        &#125;,\n      &#125;)\n      \n      &#x2F;&#x2F; 绑定btn的click事件\n      $(&#39;#btn&#39;).click(function () &#123;\n        &#x2F;&#x2F; 获取input新输入的值\n        const name &#x3D; $(&#39;#username&#39;).val()\n        const age &#x3D; $(&#39;#age&#39;).val()\n        \n        if (name &#x3D;&#x3D; &#39;&#39; || age &#x3D;&#x3D; &#39;&#39;) &#123;\n          alert(&#39;用户名密码不能为空&#39;)\n          return\n        &#125;\n        \n        &#x2F;&#x2F; 发送put请求\n        $.ajax(&#123;\n          type: &#39;PUT&#39;,\n          url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;&#39; + id,\n          data: &#123; name, age &#125;,\n          success: function (res) &#123;\n            alert(&#39;更新成功&#39;)\n            window.location.href &#x3D; &#39;.&#x2F;index.html&#39;\n          &#125;,\n        &#125;)\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n4) 实现删除&#x2F;&#x2F; 处理删除\nfunction handleDel(id) &#123;\n  &#x2F;&#x2F; 通过id参数得到 要删除的 数据的id\n  $.ajax(&#123;\n    type: &#39;DELETE&#39;,\n    url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;&#39; + id,\n    success: function (res) &#123;\n      window.location.href &#x3D; &#39;.&#x2F;index.html&#39;\n    &#125;,\n  &#125;)\n&#125;\n","slug":"Express框架应用-实现用户模块","date":"2022-12-01T14:09:41.043Z","categories_index":"服务端","tags_index":"express","author_index":"团子"},{"id":"dec91e97c264ed31b95d6e5abfa5eeb8","title":"30_用户管理系统后台实现及前台查询所有","content":"昨日回顾改造了express后台的增删改查\n\t一,使用数组实现\n\t\t弊端\n\t\t\t数据不能持久存储,只是在内存中存储\n\t二,中间件优化\n\t\t1,优化处理请求体\n\t\t\tapp.use(express.json())\n\t\t\tapp.use(express.urlencoded())\n\t\t2,处理跨域请求\n\t\t\tapp.use(cors())\n\t三,数据库实现\n\t\t好处\n\t\t\t可以让数据持久化的存在文件中\n\t\t步骤\n\t\t\t1,导包,创建连接,连接数据库\n\t\t\t2,在路由(处理函数)中\n\t\t\t\t1,获取请求参数\n\t\t\t\t2,编写sql语句\n\t\t\t\t3,执行sql语句返回数据\n\t四,抽取数据库代码\n\t\t目的\n\t\t\t将业务逻辑代码和处理数据库的代码剥离出去\n\t\t\t方便后期维护,实现数据库代码的重用\n\t\t步骤\n\t\t\t把关于数据库的操作单独放在一个js文件中(对query这个方法进行了封装)\n\t\t\t\t1,导包,创建连接,连接数据库剪切到一个文件中\n\t\t\t\t2,提供查询所有getAll(),查询一个getByid(),增删改exec()\n\t\t\t\t3,这些方法都返回一个promise对象,异常通过reject返回,数据通过resolve返回\n\t\t\t\t4,导出方法\n\t五,用es7语法糖简化异步的调用\n\t\t目的\n\t\t\t简化代码,提高开发效率\n\t\t做法\n\t\t\t1,调用数据库方法的前面加上await关键字,就可以获取then方法执行的结果\n\t\t\t2,由于await只能放在异步函数中,在外面的处理函数前面加上async关键字\n\t六,修改数据库操作的文件的文件名和所在文件夹\n\t\t一般将文件名修改为index.js,将来不可以写文件名,默认会加载index.js\n\t\t一般将数据库操作的文件放在db文件夹下,将来方便程序员去维护\n\nexpress集成nodemon集成步骤\n\t1,在package.json中修改script脚本\n\t\t&#39;dev&#39;:&#39;要执行文件的路径&#39;\n\t2,使用npm run dev 执行代码\n\t\t\n\n\n\n用户管理系统搭建1,分析具体需求\n2,设计数据库,建表(用之前的学生表即可)\n3,设计接口\n\t前台:发送请求的url,需要的参数\n\t后台:返回数据的格式\n4,编写代码\n\t1,先写后端\n\t\texpress脚手架快速生成\n\t\t   1,全局安装脚手架 npm i express-generator -g\n\t\t   2,创建项目文件夹,在这个文件夹内使用express --no-view backEnd生成后端目录\n\t\t   3,进入后端backEnd目录内,使用npm install安装package.json配置的相关依赖(包)\n\t\t   4,继续使用命令npm i nodemon -D 安装nodemon包,\n\t\t   5,修改启动脚本(&quot;start&quot;: &quot;nodemon .&#x2F;bin&#x2F;www&quot;)\n\t\t   6,继续使用命令安装mysql和cors包,安装好之后就可以在package.json看到配置\n\t\t   7,在终端使用npm run start运行,在浏览器输入http:&#x2F;&#x2F;localhost:3000&#x2F;访问欢迎页\n\t\t   \n\t\t   8,导入数据库操作的模块 \n\t\t   \t \t将之前写好的db文件夹直接拷贝到backEnd文件夹下\n\t\t   \t \t在routes文件夹下的users.js文件中导入数据库操作模块\n\t\t   \t \t\tconst &#123;getAll,getById,exec&#125; &#x3D; require(&#39;..&#x2F;db&#39;);\n\t\t   \t \t\t\n\t\t   9,导入跨域请求的模块\n\t\t   \t\t在app.js中导入 const cors &#x3D; require(&#39;cors&#39;);\n\t\t   \t\t在app.js中注册 app.use(cors())  注册路由之前注册\n\n\n\n后端编写流程1,在用户路由模块users.js下编写代码\n2,编写获取所有用户,使用get请求,调用getAll()方法,返回所有用户的数组(data)\n3,编写获取一个用户,使用get请求,调用getById()方法,返回指定id的用户(data)\n4,编写新增一个用户,使用post请求,调用exec()方法,返回新增的用户(data.insertId)\n5,编写修改一个用户,使用put请求,调用exec()方法,返回新增的用户(无需data)\n5,编写删除一个用户,使用delete请求,调用exec()方法,设置状态码,返回空字符串(无需data)\n\n\n\n前端编写流程一,显示所有用户\n\t1,新建fontEnd文件夹\n\t2,新建3个html页面\n\t3,编写list.html页面的骨架\n\t4,编写基本样式base.css\n\t5,编写list页面样式style.css\n\t6,引入jquery,发送ajax请求(已经引入了cors处理跨域请求)\n\t7,遍历获取到的数据,动态拼接tr元素,追加到table下面\n\n","slug":"day30_课堂笔记","date":"2022-12-01T14:07:10.846Z","categories_index":"服务端","tags_index":"express","author_index":"团子"},{"id":"841af1c8d1a60dd62055f0a0655c6017","title":"29_express集成数据库操作并封装","content":"昨日回顾中间件\n\t概念\n\t\t业务处理中间环节.(一个处理函数)\n\t规则\n\t\t(req,res,next) next可以将调用关系流转到下一个函数\n    分类\n    \t按照作用范围\n    \t\t局部生效的中间件(某些访问路径,某个路由调用)\n    \t\t全局生效的中间件(所有访问路径,通过use调用)\n    \t按照级别来分\n    \t\t内置中间件\n    \t\t\texpress.json()\n    \t\t\texpress.urlencoded()\n    \t\t\texpress.static()\n    \t\t第三方中间件\n    \t\t\tcors()\n    \t\t应用级别中间件\n    \t\t\t绑定app上,可以是全局,也可以是局部\n    \t\t路由级别中间件\n    \t\t\t绑定到路由对象 express.router() 上\n    模块化路由\n    \t由来\n    \t\t方便对路由的分类和管理\n    \t实现\n    \t\t根据不同的实体创建不同的js文件\n    \t\t在每个js文件中创建路由对象,加载具体的路由,再导出\n    \t\t在入口函数中使用app.use()注册路由模块\n\nnode连接数据库其实就是使用第三方包 mysql 操作数据库,需要下载mysql包\n\n1,导入mysql包\n2,创建连接(createConnection方法)\n\t传入 host port user password database\n3,连接数据库(connect方法)\n4,执行sql语句(query方法)\n5,关闭数据库连接(end())\n\n增删改查_数组实现(优化)&#x2F;&#x2F;使用内置中间件处理请求体\napp.use(express.json())\napp.use(express.urlencoded())\n&#x2F;&#x2F;使用第三方中间件处理跨域问题  --- 需要下载安装\napp.use(cors())  \n\n增删改查_数据库实现思路\n\t1,将数据库导包,创建连接,连接,这三个步骤拷贝进去\n\t2,在路由里面 编写sql语句,执行sql语句并返回数据\n\n增删改查_提取数据库操作目的\n\t将数据库操作的代码单独放到一个文件中,便于后期代码的维护\n做法\n\t1,将数据库导包,创建连接,连接的代码剪切过去,放在一个js文件中\n\t2,提供查询所有getAll,查询单个getById,增删改exec方法,方法里面用promise封装\n\t3,导出这3个方法\n\t4,在后台代码中,导入这个js文件,解构这3个方法并使用\n\n语法糖_async_awaitasync\n\t概念\n\t\t异步的意思\n\t作用\n\t\t可以将同步函数变成异步函数(调用函数返回就是promise对象),就可以使用then方法调用\n\t使用\n\t\t定义\n            async function m1()&#123;\n                return 222\n            &#125;\n         调用\n         \tconst p &#x3D; m1()\t\n       \t\tp.then(data &#x3D;&gt;&#123;\n                console.log(data);&#x2F;&#x2F;222\n            &#125;)\n            \nawait\n\t概念\n\t\t等待的意思\n\t作用\n\t\tawait可以等待 他后面的 promise对象执行之后,拿到返回的结果\n\t注意\n\t\tawait不能单独使用,必须跟async连用,存在于异步函数中\n\t\tawait后面必须要跟一个promise对象,如果不是promise对象,自动转成promise对象\n\t\tawait表达式,返回的是promise执行后的结果\n\t使用\n\t\t&#x2F;&#x2F;在外面套一个异步的函数的壳子fn\n        async function fn()&#123;\n\n            async function m1()&#123;\n                return 222\n            &#125;\n\n            const res &#x3D; await m1() \n            console.log(res);\n        &#125;\n\n        &#x2F;&#x2F;执行fn\n        fn()\t\n\n\n\n增删改查_es7语法改写app.get(&#39;&#x2F;users&#39;, async function(req,res)&#123;\n    &#x2F;&#x2F;获取请求参数(这里不需要)\n\n    &#x2F;&#x2F;编写sql语句\n    let sql &#x3D; &#39;select * from student&#39;\n\n    &#x2F;&#x2F;执行sql语句\n    const data &#x3D; await getAll(sql) \n\n    &#x2F;&#x2F;发给浏览器\n    res.send(data)\n    \n&#125;)\n\n","slug":"day29_课堂笔记","date":"2022-12-01T14:04:33.270Z","categories_index":"服务端","tags_index":"express","author_index":"团子"},{"id":"8a9733c9b1d5d35d078b2db4ec97b51b","title":"restful","content":"一. 接口编程简介1 背景​    随着互联网的发展, 尤其是移动互联为代表的Web3.0时代. 客户端层出不穷, 以APP、微信、PC浏览器为代表, 服务端业务逻辑是基本一致的. \n​    那么有没有一种方式可以做到”一次编写,随时接入”呢?\n目前比较流行的方案就是”接口编程“\n \n2 什么是接口编程​    一般来说接口编程是基于HTTP协议, 通过URL请求对应的服务器资源(Resource).\n1) 什么是URL在HTTP协议中, URL的组成如下\nSchema:&#x2F;&#x2F;host[:port]&#x2F;path[?query-string]\n\n\nSchema: 使用的协议类型, 如http/https/ftp等\nhost:     主机域名或IP\nport:     端口号(可选)\npath:     路径\nquery-string: 查询参数(可选)\n\n例子:\nhttp://api.local.com/movies\nhttps://api.local.com:8080/articles?id=100\n2) 什么是资源\n狭义上讲, 所有在服务器保存的数据(如:音乐/视频/文章/个人信息…)都是服务器端资源.\n广义上讲, 任何服务器端的对象(如:应用程序/数据库记录/算法…)都可以看作资源.\n\n3 接口编程的作用\n\n\n\n\n\n\n\n\n主要是实现了前后端的分离\n后端(服务器)为前端(APP端/PC浏览器端/微信端)提供一个简单并且统一的方式(URL), 返回前端需要的数据(Resource).这样不管是APP还是Web浏览器, 只需要通过HTTP协议都可以实现同样的操作. \n二. RESTful设计六要素是不是所有前后端分离的设计都叫RESTful呢? 不是!!!\nful是一个后缀, 意思是”像什么一样的” windful\nRESTful是一种软件设计风格, 主要用于有客户端与服务端交互的软件.  主要包括6个方面\n\n资源路径(URL)\nHTTP动词(Method)\n过滤信息(query-string)\n状态码(Status-code)\n错误信息(Error)\n返回结果(Result)\n\n如下图所示:\n\n\n如果一个软件符合这些约定(风格), 我们就说这个软件是RESTful的\n1 资源路径标准的RESTful API中, 每个资源路径对应一个唯一的资源, 所以规定网址中不能有动词, 只能有名词, 并且一般来说为复数.\n比如:\nhttp://api.local.com/movies----表示电影资源 \nhttp://api.local.com/images----表示图片资源\nhttp://api.local.com/musics----表示音乐资源\nhttp://api.local.com/articles----表示文章资源\n2 Http动词对于资源, 一般有4个操作, CURD(增/删/改/查)\nGET:     从服务器获取资源(一项或多项)\nPOST:    在服务器新建一个资源\nPUT:    在服务器更新资源, 服务器返回完整的属性\nDELETE:    从服务器删除资源\nHEAD:    从服务器获取信息(响应头)\nPATCH:    在服务器更新资源, 服务器只返回更新的属性\n\n例子: \nPOST /articles     –    创建文章内容\nGET /articles/1    –    获取主键id为1的文章\n3 过滤信息(请求数据)当服务端需要返回的数据很多时, 服务器不可能全部返回\n此时, 我们可以在客户端携带过滤信息, 比如: 分页信息\n\n例子:\n?page=1                    –    第一页的信息\n?offset=10&amp;per_page=10    –    每页10条, 偏移10\n4 响应状态码服务端返回的信息, 用来告诉客户端操作结果\n\n\n\n状态码\n含义\n说明\n\n\n\n200\nOK\n操作成功, 并返回数据\n\n\n201\nCREATED\n新建成功\n\n\n204\nNO CONTENT\n删除成功\n\n\n400\nBAD REQUEST\n请求语法错误\n\n\n403\nForbidden\n请求没有权限的资源\n\n\n404\nNOT FOUND\n没有找到请求的资源\n\n\n5 错误处理如果状态码是4xx或者5xx, 需要告诉客户端对应的错误信息. 以Json格式返回\n{\n“error”: “错误信息”,\n}\n6 返回结果针对不同的操作, 服务需要返回的结果应该符合这样的规范\nGET /collections         –    返回资源列表(数组) \nGET /collections/:id        –    返回单个资源 eg. /collections/1\nPOST /collections        –    返回新生成的资源\nPUT /collections/:id        –    返回资源的完整属性\nPATCH /collections/:id    –    返回被修改的属性\nDELETE /collections/:id    –    返回204状态码+空文档 \n三. 工具1 服务端工具json-serverjson-server一个快速成形的RESTful接口服务工具, 使用json-server可以快速的搭建一个RESTful服务端\n第一步: 使用npm i json-server -g 全局安装\n第二步: 新建一个data.json做为数据源\ndata.json如下\n&#123;\n  &quot;users&quot;: [\n    &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;xiaoming&quot;, &quot;age&quot;: 20&#125;,\n    &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;xiaomei&quot;, &quot;age&quot;: 18&#125;,\n    &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;xiaopang&quot;, &quot;age&quot;: 1&#125;\n  ]\n&#125;\n\n第三步: 启动服务端\njson-server -w data.json\n\n会在localhost:3000端口启动一个RESTful服务\n2 客户端1) postman这里给大家安利一个工具postman. 这个是在接口编程中使用非常多的一个工具\nPostman是一个非常好用的免费API测试工具. 主要用于模拟发送Http请求.\n官网地址: https://www.getpostman.com/\n2) REST Client\nREST Client是一个非要好用的VSCode插件, 可以快速的测试RESTful接口\n第一步: 安装REST Client\n第二步: 编写test.http\nGET http:&#x2F;&#x2F;localhost:3000&#x2F;users HTTP&#x2F;1.1\n\n第三步: 点击Send Request\n\n\n\n\n\n\n\n\n\n演示\n\n四. 前后端分离与接口文档1 什么是前后端分离所谓前后端分离, 如下图所示:\n \n由上图可知, 一个项目有两个服务器\n前端服务器: 显示页面\n后端服务器: 提供数据\n通过API接口实现前后端的交互!\n2 前后端分离的好处\n提高开发效率: 前后端开发人员可是同时开发, 互不影响\n\n提高复用性: 后端通过统一的API提供数据, 这样可以同时为web前端/app前端/微信端提供数据\n\n\n3 接口文档咱们去公司之后, 经常会面临写接口文档的工作, 那么咱们看下接口文档怎么写\n见附件: [API接口文档.md](./API 接口文档.md)\n","slug":"restful","date":"2022-12-01T13:59:58.678Z","categories_index":"服务端","tags_index":"restful","author_index":"团子"},{"id":"8a078447816c8261f3fa2174ce069557","title":"API接口文档","content":"API 接口文档API 接口说明\n  接口基准地址：http://localhost:3000\n  或者接口基准地址: http://www.brojie.cn:5051/api/v1或者http://api.brojie.cn:5051/v1\n  使用 HTTP Status Code 标识状态\n  数据返回格式统一使用 JSON\n\n支持的请求方法\n  GET（SELECT）：从服务器取出资源（一项或多项）。\n  POST（CREATE）：在服务器新建一个资源。\n  PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\n  DELETE（DELETE）：从服务器删除资源。\n\n通用返回状态说明\n\n\n状态码\n含义\n说明\n\n\n\n200\nOK\n请求成功\n\n\n201\nCREATED\n创建成功\n\n\n204\nDELETED\n删除成功\n\n\n400\nBAD REQUEST\n请求的地址不存在或者包含不支持的参数\n\n\n401\nUNAUTHORIZED\n未授权\n\n\n403\nFORBIDDEN\n被禁止访问\n\n\n404\nNOT FOUND\n请求的资源不存在\n\n\n422\nUnprocesable entity\n[POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误\n\n\n500\nINTERNAL SERVER ERROR\n内部错误\n\n\n\n\n\n\n\n\n用户管理用户数据列表\n请求路径：http://localhost:3000/users\n请求方法：get\n响应参数\n\n\n\n\n参数名\n参数说明\n备注\n\n\n\nid\nid\n不必须\n\n\nname\n用户名\n不必须\n\n\nage\n年龄\n不必须\n\n\n\n响应状态码\n\n\n参数名\n参数说明\n备注\n\n\n\nstatus\n响应码\n200: 成功\n\n\n\n\n\n响应数据\n\n[\n  &#123;\n    &quot;name&quot;: &quot;鸣人&quot;,\n    &quot;age&quot;: &quot;12&quot;,\n    &quot;id&quot;: 1\n  &#125;,\n  &#123;\n    &quot;id&quot;: 2,\n    &quot;name&quot;: &quot;佐助&quot;,\n    &quot;age&quot;: 11\n  &#125;,\n  &#123;\n    &quot;id&quot;: 3,\n    &quot;name&quot;: &quot;自来也&quot;,\n    &quot;age&quot;: 52\n  &#125;,\n  &#123;\n    &quot;id&quot;: 4,\n    &quot;name&quot;: &quot;卡卡西&quot;,\n    &quot;age&quot;: 28\n  &#125;\n]\n\n添加用户\n请求路径：http://localhost:3000/users\n请求方法：post\n请求参数\n\n\n\n\n参数名\n参数说明\n备注\n\n\n\nname\n用户名称\n不能为空\n\n\nage\n用户年龄\n不能为空\n\n\n\n响应参数\n\n\n\n\n参数名\n参数说明\n备注\n\n\n\nid\n用户 ID\n\n\n\nname\n用户名\n\n\n\nage\n年龄\n\n\n\n\n响应状态码\n\n\n\n参数名\n参数说明\n备注\n\n\n\nstatus\n响应码\n201: 成功\n\n\n\n响应数据\n\n\n&#123;\n  &quot;name&quot;: &quot;xiaoming&quot;,\n  &quot;age&quot;: &quot;20&quot;,\n  &quot;id&quot;: 5\n&#125;\n\n\n编辑用户\n请求路径：users/:id\n请求方法：put\n请求参数\n\n\n\n\n参数名\n参数说明\n备注\n\n\n\nid\n用户 id\n不能为空 参数是url参数:id\n\n\n\n响应参数\n\n\n\n\n参数名\n参数说明\n备注\n\n\n\nid\n用户 ID\n\n\n\nname\n用户名\n\n\n\nage\n年龄\n\n\n\n\n响应数据\n\n&#x2F;&#x2F; 200表示成功 404表示失败\n&#123;\n  &quot;name&quot;: &quot;xiaoming&quot;,\n  &quot;age&quot;: &quot;20&quot;,\n  &quot;id&quot;: 5\n&#125;\n\n删除用户\n请求路径：users/:id\n请求方法：delete\n请求参数\n\n\n\n\n参数名\n参数说明\n备注\n\n\n\nid\n用户 id\n不能为空参数是url参数:id\n\n\n\n响应参数\n\n响应数据\n\n\n&#x2F;&#x2F; 200 表示成功 404表示失败\n&#123;\n&#125;","slug":"API 接口文档","date":"2022-12-01T13:57:09.488Z","categories_index":"服务端","tags_index":"api","author_index":"团子"},{"id":"d9294510272c3f8944ed00db23e606c1","title":"ajax","content":"一. 什么是AJAX1 概念\n\n\n\n\n\n\n\n\nAsynchronous  Javascript  And  Xml (异步javascript和xml)\nAJAX 不是新的编程语言，而是一种使用现有标准的新方法\nAJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容\n这里的xml是一种数据格式, 现在更多的使用json数据格式\n现在, 一般用作前后端分离的数据解决方案.\n2 同步和异步\n\n\n\n\n\n\n\n\n同步: 同一时间只能做一件事. 阻塞式\n服务端在处理时, 客户端只能等待\n\n\n\n\n\n\n\n\n\n\n异步: 同一时间可以处理多件事, 非阻塞\n\n3 使用场景\nbaidu地图\nbaidu联想搜索\n接口编程\n\n二. 原生Ajax的使用在浏览器中, 可以通过创建XMLHttpRequest对象来使用ajax.一般步骤如下:\n\n创建XMLHttpRequest对象\n设置请求方式\n发送请求\n获取响应数据, 处理返回结果\n\n1 发送get请求1) 入门案例\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n      &#x2F;&#x2F; 1.创建ajax对象\n      var xhr &#x3D; new XMLHttpRequest()\n      &#x2F;&#x2F; 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求\n      &#x2F;&#x2F; 1)请求方式 2)请求地址\n      xhr.open(&#39;get&#39;, &#39;.&#x2F;test.txt&#39;)\n      &#x2F;&#x2F; 3.发送请求\n      xhr.send()\n      &#x2F;&#x2F; 4.获取服务器端响应到客户端的数据\n      xhr.onload &#x3D; function () &#123;\n        console.log(xhr.responseText)\n      &#125;\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2) 处理json数据&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n      &#x2F;&#x2F; 1.创建ajax对象\n      var xhr &#x3D; new XMLHttpRequest()\n      &#x2F;&#x2F; 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求\n      &#x2F;&#x2F; 1)请求方式 2)请求地址\n      xhr.open(&#39;get&#39;, &#39;.&#x2F;test.json&#39;)\n      &#x2F;&#x2F; 3.发送请求\n      xhr.send()\n      &#x2F;&#x2F; 4.获取服务器端响应到客户端的数据\n      xhr.onload &#x3D; function () &#123;\n        &#x2F;&#x2F; 将返回的数据转换成json格式\n        var data &#x3D; JSON.parse(xhr.responseText)\n        console.log(data)\n      &#125;\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3) 处理带参数的get请求之前, 我们都是直接获取一个文件. \n现在我们请求一个URL地址. 做前后端分离\n\n\n\n\n\n\n\n\n\n什么是前后端分离\n前端通过请求一个URL地址向后端请求数据, 后端处理对应的URL请求返回指定格式的数据\n\n前端可以专心的做数据展示\n后端专心的做数据逻辑处理\n前后端通过URL交换数据, 这个URL就是数据接口API\n\n\n\n\n\n\n\n\n\n\n使用json-server\n这里, 我们先使用一个工具json-server来做为简易的服务端\n第一步: 使用npm i json-server -g全局安装\n第二步: 新建一个data.json做为数据源\ndata.json如下\n&#123;\n  &quot;users&quot;: [\n    &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;xiaoming&quot;, &quot;age&quot;: 20&#125;,\n    &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;xiaomei&quot;, &quot;age&quot;: 18&#125;,\n    &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;xiaopang&quot;, &quot;age&quot;: 1&#125;\n  ]\n&#125;\n\n第三步: 启动服务端\njson-server -w data.json\n\n会在localhost:3000端口启动一个Restful服务\n如果前端请求’localhost:3000/users?id=1’时\n相当于发送一个get请求, 并携带id=1的参数, 表示前端想获取id=1的用户信息\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n      &#x2F;&#x2F; 1.创建ajax对象\n      var xhr &#x3D; new XMLHttpRequest()\n      &#x2F;&#x2F; 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求\n      &#x2F;&#x2F; 1)请求方式 2)请求地址\n      &#x2F;&#x2F; get请求的参数写在URL中\n      xhr.open(&#39;get&#39;, &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users?id&#x3D;1&#39;)\n      &#x2F;&#x2F; 3.发送请求\n      xhr.send()\n      &#x2F;&#x2F; 4.获取服务器端响应到客户端的数据\n      xhr.onload &#x3D; function () &#123;\n        var data &#x3D; JSON.parse(xhr.responseText)\n        console.log(data)\n      &#125;\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2 发送post请求&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    用户名: &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; &#x2F;&gt; \n    年龄: &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;age&quot; &#x2F;&gt;\n    &lt;button id&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt;\n    \n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n      var btn &#x3D; document.getElementById(&#39;submit&#39;)\n      var username &#x3D; document.getElementById(&#39;name&#39;).value\n      var age &#x3D; document.getElementById(&#39;age&#39;).value\n\n      btn.addEventListener(&#39;click&#39;, function () &#123;\n        &#x2F;&#x2F; 1.创建ajax对象\n        var xhr &#x3D; new XMLHttpRequest()\n        &#x2F;&#x2F; 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求\n        &#x2F;&#x2F; 1)请求方式 2)请求地址\n        xhr.open(&#39;post&#39;, &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;)\n        &#x2F;&#x2F; 设置请求头\n        xhr.setRequestHeader(&#39;content-type&#39;, &#39;application&#x2F;json&#39;)\n        &#x2F;&#x2F; 3.发送请求\n        var params &#x3D; &#123; name: username, age: age &#125;\n        xhr.send(JSON.stringify(params))\n        &#x2F;&#x2F; 4.获取服务器端响应到客户端的数据\n        xhr.onload &#x3D; function () &#123;\n          var data &#x3D; JSON.parse(xhr.responseText)\n          console.log(data)\n        &#125;\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n如果使用form格式, 请求头需要设置为application/x-www-form-urlencoded\n\n\n\n\n\n\n\n\n\n示例\nvar params &#x3D; &#39;name&#x3D;&#39;+ username +&#39;&amp;age&#x3D;&#39; + age;\n&#x2F;&#x2F; 配置ajax对象\nxhr.open(&#39;post&#39;, &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;);\n&#x2F;&#x2F; 设置请求参数格式的类型（post请求必须要设置）\nxhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application&#x2F;x-www-form-urlencoded&#39;);\n&#x2F;&#x2F; 发送请求\nxhr.send(params);\n\n使用键值对的方式发送数据\n三. jQuery中的Ajax1 $.ajax()方法jQuery提供了方便的方式, 封装了ajax请求的方法\n\n\n\n\n\n\n\n\n\n语法\n$.ajax(&#123;\n  url: &#39;请求地址&#39;,\n  type: &#39;GET&#x2F;POST&#39;,&#x2F;&#x2F; 请求类型\n  data: &#123;&#125;, &#x2F;&#x2F; 请求参数\n  dataType: &#39;json&#39;, &#x2F;&#x2F; 返回的数据格式\n  success: function (res) &#123;&#125;, &#x2F;&#x2F; 成功的回调\n  error: function(err) &#123;&#125; &#x2F;&#x2F; 出错的回调\n&#125;)\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n      $.ajax(&#123;\n        url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;,\n        data: &#123; id: 1 &#125;,\n        dataType: &#39;json&#39;,\n        success: function (res) &#123;\n          console.log(res)\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\njQuery中的默认的content-type是x-www-form-urlencoded\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    用户名: &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; &#x2F;&gt; 年龄: &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;age&quot; &#x2F;&gt;\n    &lt;button id&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n      $(&#39;#submit&#39;).click(function () &#123;\n        var name &#x3D; $(&#39;#name&#39;).val()\n        var age &#x3D; $(&#39;#age&#39;).val()\n\n        $.ajax(&#123;\n          url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;,\n          type: &#39;post&#39;,\n          data: &#123; name: name, age: age &#125;,\n          dataType: &#39;json&#39;,\n          success: function (res) &#123;\n            console.log(res)\n          &#125;,\n        &#125;)\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n2 $.get()方法$.get()是发送get请求的简写方式\n\n\n\n\n\n\n\n\n\n语法\n$.get(&quot;url&quot;, &#123;params&#125;, callback)\n\n\n\n\n\n\n\n\n\n\n示例\n$.get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;, &#123;id: 1&#125;, function(res) &#123;\n  console.log(res)\n&#125;)\n\n3 $.post()方法$.post()是发送post请求的简写方式\n\n\n\n\n\n\n\n\n\n语法\n$.post(&quot;url&quot;, &#123;params&#125;, callback)\n\n\n\n\n\n\n\n\n\n\n示例\n$.post(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;, &#123;name: &#39;xxp&#39;, age: 1&#125;, function(res) &#123;\n  console.log(res)\n&#125;)\n\n四. 跨域请求1 什么是跨域请求当从一个域A向另一个域B发送请求时, 就叫做跨域请求\n这里的域指的是这样的一个概念：协议 + 域名 + 端口号均相同，那么就是同一个域.\n如: \n\nhttp://localhost:8080 请求https://localhost:8080是跨域请求, 协议不同\nhttp://localhost:8080 请求http://www.baidu.com是跨域请求, 域名不同\nhttp://localhost:8080 请求http://localhost:3000/users是跨域请求, 端口不同\n\n2 跨域请求的问题由于浏览器同源策略的限制, 浏览器是不允许发送跨域请求的.\n但是, 我们做前后端分离, 前端和后端通常是不在同一个域.如\n前端运行在http://localhost:5500 \n后端运行在http://localhost:3000 \n3 模拟跨域请求后端\n&#x2F;&#x2F; 引入http核心模块\nvar http &#x3D; require(&#39;http&#39;)\n\n&#x2F;&#x2F; 引入url核心模块\nvar url &#x3D; require(&#39;url&#39;)\n\n&#x2F;&#x2F; 创建web服务器\nvar server &#x3D; http.createServer()\n\n&#x2F;&#x2F; 处理请求\nserver.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 设置响应头\n  res.writeHead(&#39;200&#39;, &#123;\n    &#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf-8&#39;,\n  &#125;)\n\n  &#x2F;&#x2F; 分析路由\n  var data &#x3D; url.parse(req.url, true)\n  var pathname &#x3D; data.pathname\n  var query &#x3D; data.query\n\n  if (pathname &#x3D;&#x3D; &#39;&#x2F;&#39; || pathname &#x3D;&#x3D; &#39;&#x2F;index&#39;) &#123;\n    &#x2F;&#x2F; 处理get请求\n    if (req.method &#x3D;&#x3D; &#39;GET&#39;) &#123;\n      &#x2F;&#x2F; 打印在后端控制台\n      console.log(query)\n      &#x2F;&#x2F; 返回给浏览器\n      res.end(query.username)\n    &#125;\n  &#125; else if (pathname &#x3D;&#x3D; &#39;&#x2F;users&#39;) &#123;\n    res.end(JSON.stringify(&#123; name: &#39;xxp&#39;, age: 1 &#125;))\n  &#125; else &#123;\n    res.writeHead(&#39;404&#39;)\n    res.end(&#39;Not Found&#39;)\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; 监听3000端口\nserver.listen(3000)\n\nconsole.log(&#39;server is running on localhost:3000&#39;)\n\n\n前端\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n      $.ajax(&#123;\n        url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#39;,\n        data: &#123; id: 1 &#125;,\n        dataType: &#39;json&#39;,\n        success: function (res) &#123;\n          console.log(res)\n        &#125;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n\n演示\n\n4 如何解决跨域问题目前, 最主流的方式是CORS, 通过在服务端设置响应头, 允许跨域请求\n跨源资源共享 Cross-Origin Resource Sharing(CORS) 是一个新的 W3C 标准，它新增的一组HTTP首部字段，允许服务端其声明哪些源站有权限访问哪些资源。换言之，它允许浏览器向声明了 CORS 的跨域服务器，发出 XMLHttpReuest 请求，从而克服 Ajax 只能同源使用的限制\n配置上非常简单, 只需要在后端设置响应头即可\n&#x2F;&#x2F; 设置响应头\nres.writeHead(&#39;200&#39;, &#123;\n  &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,\n&#125;)\n\n上述代码表示允许所有域名的跨域请求. 更多设置, 参考: 知乎-跨域请求的四种方案\n\n\n\n\n\n\n\n\n\n扩展\n为什么使用json-server的时候没有出问题?\njson-server默认是允许跨域请求的\n\n","slug":"ajax","date":"2022-12-01T13:55:44.684Z","categories_index":"服务端","tags_index":"ajax","author_index":"团子"},{"id":"6bf0818317072d9a48cc178884cabdd5","title":"27_接口编程_ajax_express入门","content":"昨日回顾一,基础的web服务器\n\t1,导模块\n\t2,创建服务器\n\t3,绑定请求事件\n\t4,设置端口监听\n\n二,解决中文乱码\n\t res.setHeader(&#39;content-type&#39;,&#39;text&#x2F;html;charset&#x3D;utf-8&#39;)\n\n三,根据不同url响应不同的数据\n\t获取请求路径\n\t\t const &#123;pathname&#125; &#x3D; url.parse(req.url,true)\n\t\t \n四,获取get请求的参数\n\tconst &#123;pathname,query&#125; &#x3D; url.parse(req.url,true)\n\t\n五,获取post请求的参数\n\t let postData &#x3D; &#39;&#39;\n     req.on(&#39;data&#39;,data &#x3D;&gt; &#123; postData +&#x3D; data&#125;)\n     req.on(&#39;end&#39;,()&#x3D;&gt;&#123;\n          console.log(postData);&#x2F;&#x2F;username&#x3D;zhangsan&amp;password&#x3D;123\n           &#x2F;&#x2F;使用querystring内置对象解析post请求的数据\n           const obj &#x3D; qs.parse(postData)\n           console.log(obj);&#x2F;&#x2F;&#123; username: &#39;zhangsan&#39;, password: &#39;123&#39; &#125;\n                \n           &#125;)\n           \n六,用promise封装 获取post请求参数的过程 \n     function getPostData(req)&#123;\n        return new Promise((resolve,reject)&#x3D;&gt;&#123;\n\n            let postData &#x3D; &#39;&#39;\n            req.on(&#39;data&#39;,data &#x3D;&gt; &#123; postData +&#x3D; data&#125;)\n            req.on(&#39;end&#39;,()&#x3D;&gt;&#123;\n                const obj &#x3D; qs.parse(postData)\n                resolve(obj)&#x2F;&#x2F;将obj放在结果属性中,将来调用then方法的时候,就能拿到结果\n            &#125;)\n        &#125;)\n    &#125;\n    \n七,访问静态资源\n\tres.end(fs.readFileSync(相对路径))\n\n\n\n接口编程概念接口概念\n\t其实就是一个规范,比如电脑usb接口,设计好usb的标准之后,做电脑和做外设的,就可以分别生产,生产好之后,直接就可以插上去使用\n\n接口文档概念\n\t就是接口的说明文档,它是我们调用接口(请求后台数据的)的依据\n\t接口文档中包含了对接口的url,参数,以及输出内容的说明\n\t我们参照接口文档,就能方便的知道接口的作用,以及接口是如何调用的\n\n接口编程概念\n\t就是前后端按照约定好的规则(接口文档)进行编程,编好之后进行联调就可以了\n\t具体体现,其实就是http协议中的请求和响应\n\t前端,主要是发送请求(明确 请求的url 和 请求方式 以及 请求参数)\n\t后端,主要是做出响应(明确 响应状态码 和 状态码描述 以及 返回具体的数据)\n\t\n接口编程好处\n\t实现前后端分离,便于协同开发\n\n\n\nrestful接口设计概念\n\t一种接口设计风格,主要用于有客户端和服务端交互的软件\n\t\n接口设计六要素\n\t前端\n\t\t资源路径:请求的url(http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;login)\n\t\tHTTP动词:请求方式(get)\n\t\t过滤信息:请求参数(username&#x3D;zhangsan&amp;password&#x3D;123)\n\t后台\n\t\t状态码(status-code):登录成功:200\n\t\t错误信息(error):服务器内部错误\n\t\t返回结果(date或者result):返回登录用户相关信息\n\t\t\n常用的HTTP动词\n\tGET:获取资源(一个或者多个)  --获取所有图书列表,获取单个图书信息\n\tPOST:新增资源             --添加一个图书\n\tPUT:修改资源              --修改某一个图书的信息\n\tDELETE:删除资源           --删除某一个图书\n\n\n\nrestful接口体验json-server概念\n\t一个快速成形的RESTful接口服务工具, 使用json-server可以快速的搭建一个RESTful服务端\n\t\n搭建服务端\n\t1,安装json-server软件(npm i json-server -g) \n\t2,创建一个data.json作为数据源\n\t3,启动服务端(json-server -w data.json)\n\t\n模拟前端(发送Restful风格的请求)\n\t查询\n\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;users 查询所有\n\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;users?id&#x3D;1 查询一个\n\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1  查询一个\n\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;users?id&#x3D;1&amp;id&#x3D;2  查询多个\n\n\t新增\n\t\tPOST http:&#x2F;&#x2F;localhost:3000&#x2F;users  需要加上请求体\n\n\t修改\n\t\tPUT http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1 需要加上请求体\n\n\t删除\n\t\tDELETE http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1 \n\nAJAX概念概念\n\t异步的js和xml技术(网络通讯中xml已经被json替换了)\n\t\n\t描述一个用户\n\t\txml方式\n\t\t\t&lt;user&gt;\n\t\t\t\t&lt;username&gt;张三&lt;&#x2F;username&gt;\n\t\t\t\t&lt;password&gt;123&lt;&#x2F;password&gt;\n\t\t\t&lt;&#x2F;user&gt;\n\t\tjson\n\t\t\t&#123;&quot;username&quot;:&quot;张三&quot;,&quot;password&quot;:&quot;123&quot;&#125;\n\n作用\n\t1,实现网页和服务器间的数据交换(请求后台数据)\n\t2,在不刷新整个页面的基础上,更新部分网页内容(局部刷新)\n\t3,一般作为前后端分离中请求后台数据的解决方案\n\t\n同步和异步\n\t同步:同一时间,只能做一件事情,阻塞式\n\t异步:同一时间,可以做多件事情,非阻塞式的(多线程的)\n\t\n应用场景\n\t百度注册(失去焦点的时候校验用户是否被注册)\n\t百度搜索框(根据用户的输入提示不同信息)\n\t百度地图(按需加载)\n\n原生的ajax使用XMLHttpRequest对象来发送请求,但是有兼容性问题\n\n&#x2F;&#x2F;1,创建ajax对象\nconst xhr &#x3D; new XMLHttpRequest()\n&#x2F;&#x2F;2,设置请求方式和url\nxhr.open(&#39;get&#39;,&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;2&#39;)\n&#x2F;&#x2F;3,发送请求\nxhr.send()\n&#x2F;&#x2F;4,设置回调函数\nxhr.onload &#x3D; function()&#123;\n\tconsole.log(xhr.responseText);\n&#125;\n\nconsole.log(&#39;执行结束.....&#39;);\n\n\n\njquery的ajax通用格式\n\t$.ajax(&#123;\n\t\turl:&#39;&#39;,&#x2F;&#x2F;请求的地址\n\t\ttype:&#39;&#39;,&#x2F;&#x2F;请求方式\n\t\tdata:&#123;&#125;,请求的参数\n\t\tdataType:&#39;&#39;,&#x2F;&#x2F;返回的数据格式(默认是json,可以不用写)\n\t\tsuccess:function(res)&#123;&#125;,&#x2F;&#x2F;成功的回调函数\n\t\terror:function(err)&#123;&#125;,&#x2F;&#x2F;失败的回调函数\n\t&#125;)\n\t\nget简化方式\n\t$.get(url, [data], [callback], [type])   后面3个参数是可选的\n        url:待载入页面的URL地址\n        data:待发送 Key&#x2F;value 参数。\n        callback:载入成功时回调函数。\n        type:返回内容格式，xml, html, script, json, text, _default\n        \n \npost简化方式\n\t$.post(url, [data], [callback], [type])   后面3个参数是可选的\n        url:待载入页面的URL地址\n        data:待发送 Key&#x2F;value 参数。\n        callback:载入成功时回调函数。\n        type:返回内容格式，xml, html, script, json, text, _default\t\n\n\n\nExpress简介概念\n\tExpress 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。\n\t\n本质\n\t对之前的内置模块http进行了封装,使用起来更加的方便\n\t\n核心\n\t可以设置中间件来响应 HTTP 请求。\n\t定义了路由表用于执行不同的 HTTP 请求动作\n\t\n核心概念\n\t路由\n\t\t根据不同的url路径,调用后台不同的处理函数\n\t中间件\n\t\t从请求开始到响应结束这个业务流程中的所有中间处理环节\n\n安装及使用安装\n\t新建一个英文的目录(目录名不要用express或express开头)\n\t进入这个目录,进行初始化(其实是生成了一个package.json配置文件)\n\t安装express,使用npm i express命令 \n使用\n\t1,导入express包\n\t2,实例化express对象\n\t3,处理请求\n\t4,设置端口监听\n\t\n区别(跟之前用http创建web服务的区别)\n\t1,不需要处理乱码问题\n\t2,不需要判断请求方式\n\t\n\tres.send() 和 res.end()区别\n\t\tend:其实原生的http模块中的方法,express也支持,只能传字符串,不能处理乱码问题\n\t\tsend:express中封装的方法,可以传任意类型,并且可以处理乱码问题\n\nexpress路由概念\n\t根据不同的url路径,调用后台不同的处理函数\n\t\n语法\n\tapp.请求方式(访问路径,处理函数)\n\t\t请求方式:get,post,put,delete,常用的是前两个\n\t\t访问路径:也可以正则(* 通配符)\n\t\t处理函数:匿名函数,匹配到不同路径,就会执行\n注意事项\n\t1,匹配顺序:从上到下\n\t2,只有请求方式和访问路径,同时匹配成功,express才会将这次请求转移到对应的处理函数处理\n\n","slug":"day27_课堂笔记","date":"2022-12-01T13:54:02.386Z","categories_index":"服务端","tags_index":"","author_index":"团子"},{"id":"7602872111d99ce5490d2dd6567dd4a3","title":"28_express增删改查","content":"昨日回顾接口编程\n\t接口\n    \t规范,定义前后端交互的规范\n\t接口编程\n    \t前后端按照约定好的规则(接口文档中)进行编程.\nrestful\n\t概念\n    \t一种接口设计风格\n     六要素\n     \t前端\n        \t访问路径\n            请求方式\n            \tget 获取\n                post 新增\n                put 修改\n                delete 删除\n            请求参数\n        后端\n        \t状态码和描述\n            错误信息\n            返回数据\n            \n     具体的请求\n     \t查询\n\t\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;goods\n\t\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;goods&#x2F;1\n     \t新增\n        \tPOST http:&#x2F;&#x2F;localhost:3000&#x2F;good  \n\t\t\tname&#x3D;xiaomi&amp;price&#x3D;1999\n     \t修改\n        \tPUT http:&#x2F;&#x2F;localhost:3000&#x2F;good&#x2F;2  \n\t\t\tname&#x3D;xiaomi&amp;price&#x3D;1999\n     \t删除\n        \tDELETE http:&#x2F;&#x2F;localhost:3000&#x2F;goods&#x2F;2\n      \najax\n\t概念\n    \t异步的js和xml技术\n    作用\n    \t请求后台数据,异步刷新\t\n\t使用\n    \t原生的ajax\n        \t使用xmlhttpRequest对象\n        jquery的ajax\n        \t通用方式\n            \t$.ajax(&#123;\n                    url:请求路径\n                    type:请求方式\n                    data:请求参数\n                    dataType:返回的数据格式(默认是json)\n\t\t\t\t\tsuccess:function(res)&#123;&#125; &#x2F;&#x2F;成功\n\t\t\t\t\terror:function(err)&#123;&#125; &#x2F;&#x2F;失败\n                &#125;)\n            简化方式\n            \t$.get(访问路径,请求参数,回调函数)\n\t\t\t\t$.post(访问路径,请求参数,回调函数)\n\nexpress\n\t概念\n    \t基于nodejs的第三方框架,快速搭建一个完整功能的网站\n\t特性\n    \t路由\n        \t根据不同url路径和请求方式,调用后台不同的处理函数\n\t\t中间件\n        \t从请求到响应中间的所有处理环节\n    安装\n    \t初始化\n        \tnpm init -y\n\t\t安装\n        \tnpm i express\n        基本使用\n        \t导包\n            实例化对象\n            处理请求\n            设置端口监听\n        简单路由\n        \tapp.请求方式(访问路径,处理函数)\n\t\t\t匹配方式:从上到下\n            只有请求方式和访问路径都匹配才会执行后面的处理函数\n\n跨域请求问题概念\n\t从一个请求跳到另外一个请求,如果这两个请求的协议,域名和端口只要有一个不同,那么这次请求就是跨域请求(演示出错的问题:从5500端口跳到3000报错)\n\n火狐报错提示\n\t已拦截跨源请求：同源策略禁止读取位于 http:&#x2F;&#x2F;localhost:3000&#x2F;users 的远程资源。（原因：CORS 头缺少 &#39;Access-Control-Allow-Origin&#39;）\n\t\n解决方案\n\tres.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;) &#x2F;&#x2F;允许跨域请求\n\n\n\nExpress增删改查查询\n\tget方式  --&gt; app.get()\n\t\n\t查询所有 http:&#x2F;&#x2F;localhost:3000&#x2F;users   后台: &#x2F;users  直接返回数组\n\t查询一个 http:&#x2F;&#x2F;localhost:3000&#x2F;users?id&#x3D;1  后台: &#x2F;users  通过req.query获取参数\n\t查询一个 http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1  后台 &#x2F;users&#x2F;:id  通过req.params获取参数\n\t\n新增\n\tpost方式 --&gt; app.post()\n\t\n\t前台\n\t\thttp:&#x2F;&#x2F;localhost:3000&#x2F;users  application&#x2F;json &#123;&quot;name&quot;:&quot;赵六&quot;,&quot;age&quot;:26&#125;\n\t后台\n\t\t获取请求体数据\n\t\t设置新增用户的id\n\t\t把新增的用户添加到数组\n修改\n\tput方式 --&gt; app.put()\n\t\n\t前台\n\t\thttp:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1  application&#x2F;json &#123;&quot;name&quot;:&quot;赵六&quot;,&quot;age&quot;:26&#125;\n\t后台\n\t\t获取要修改元素的id\n\t\t获取请求体数据\n\t\t查找id相同的元素进行修改\n\t\t\n删除\n\tdelete方式 --&gt; app.delete()\n\t\n\t前台\n\t\thttp:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1\n\t后台\n\t\t获取要修改元素的id\n\t\t查找id相同的元素进行删除\n\n\n\n抽取及中间件简化抽取请求体&#x2F;&#x2F;封装一个中间件函数\n\n&#x2F;&#x2F;抽取获取请求体数据的方法\nfunction getPostData(req,res,next)&#123;\n    &#x2F;&#x2F;解决跨域请求\n    res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)\n\n    &#x2F;&#x2F;监听req的data和end事件\n    let postData &#x3D; &#39;&#39;\n    req.on(&#39;data&#39;,data &#x3D;&gt; postData +&#x3D; data) \n    req.on(&#39;end&#39;,()&#x3D;&gt;&#123; \n            &#x2F;&#x2F;使用JSON解析\n            const obj &#x3D; JSON.parse(postData)\n            \n            &#x2F;&#x2F;解决的第一问题:获取的请求体数据如果传递给下一个函数,使用req对象\n            &#x2F;&#x2F;(在req中自定义一个body属性,来存数据,将来在下一个函数中,就可以通过req.body拿到数据)\n            req.body &#x3D; obj\n\n            &#x2F;&#x2F;解决第二个问题:如果在当前函数中继续调用下一个函数(使用next参数)\n            next() &#x2F;&#x2F;作用:可以把函数的调用移交到下一个处理函数\n         &#125;)\n&#125;\n\n&#x2F;&#x2F;调用中间件函数\napp.post(&#39;&#x2F;users&#39;,getPostData,function(req,res)&#123;\n    \n    &#x2F;&#x2F;获取请求体数据\n    const user &#x3D; req.body\n\n    &#x2F;&#x2F;设置新增用户的id为数组长度+1\n    user.id &#x3D; db.length + 1\n\n    &#x2F;&#x2F;把新增的用户添加到数组\n    db.push(user)\n\n    &#x2F;&#x2F;发送数组给浏览器\n    res.send(db)\n    \n&#125;)\n\n中间件函数概念(middleWare)\n\t特指业务流程的中间处理环节,本质就是一个function处理函数\n\t\n调用流程\n\t当一个请求到达express服务器之后,可以连续调用多个中间件,从而对这次请求进行预处理\n\t\n分类\n\t按照作用范围来分\n\t\t局部生效的中间件\n\t\t全局生效的中间件\n\t按照级别来分\n\t\texpress内置中间件\n\t\texpress第三方中间件\n\t\t应用级中间件\n\t\t路由级中间件\n\t\t\n注意\n\t中间件函数的形参列表中,必须包含next参数\n\t跟之前的路由处理函数不同(路由处理函数只包含req和res参数)\n\tnext作用:实现多个中间件连续调用的关键,表示把流转关系移交到写一个中间件或者处理函数\n\n\n\n中间件的范围划分局部生效的中间件概念\n\t只在某些访问路径中使用的中间件,叫做局部生效的中间件\n举例\n\tgetPostData中间件,只在新增和修改的路由中生效,是局部生效的中间件\n注意\n\t1,一定要在路由之前注册中间件\n\t2,客户端发送过来的请求,可以连续调用多个中间件进行处理\n\t3,执行完中间件的业务代码之后,不要忘记调用next()\n\t4,为了防止代码逻辑混乱,调用next()之后,不要写额外代码\n\t5,连续调用多个中间件,多个中间件之间,共享req和res对象\n\n全局生效的中间件概念\n\t客户端发起的任何请求,到达服务器后,都会触发的中间件,叫做全局生效的中间件\n使用\n\t通常使用 app.use(中间件函数),来定义一个全局生效的中间件\n\n\n\n中间件的级别划分内置中间件概念\n\t由express官方提供的,主要有3个常见的内置中间件\n分类\n\texpress.json\n\t\t解析json格式的请求体数据\n\texpress.urlencoded\n\t\t解析url-encode格式的请求体数据\n\texpress.static\n\t\t快速托管静态资源,可以帮助加载html文件,图片,css样式\n\n第三方中间件概念\n\t由第三方个人或者团体开发的,使用之前需要下载\n分类\n\tcors() 处理跨域请求\n使用\n\tnpm i cors 下载跨域请求的包\n\tconst cors &#x3D; require(&#39;cors&#39;);  导入 cors 包\n\tapp.use(cors())  引入第三方中间件处理跨域请求\n原理\n\t在每一个响应中添加响应头:Access-Control-Allow-Credentials: true\n\n应用级中间件概念\n\t通过app.use(),或者app.get(),app.post()绑定到app实例上的中间件\n注意\n\t应用级中间件,可以是全局生效的,也可以是局部生效的,只不过都要绑定到app上\n\n模块化路由(额外)产生的原因\n\t1,当路由很多的时候,如果全部写在app入口文件,文件就会太大,不好维护\n\t2,项目中有不同类型的请求路径(用户相关,商品相关)都放在一个文件中,不好维护\n\t3,为了方便对路由进行模块化的管理,express不建议将路由直接挂载到app上,而是推荐\n\t\t将路由抽成单独的模块\n\t\t\n使用步骤\n\t1,创建路由模块对应的js文件,放在routes文件夹下\n\t2,调用express.router()创建路由器对象\n\t3,向路由对象上挂载具体的路由\n\t4,使用module.exports向外共享路由对象\n\t5,在入口文件中,使用app.use()注册路由模块\n\n路由级中间件概念\n\t绑定到路由对象(express.router()创建的)的中间件\n注意\n\t路由级中间件用处不是很多,了解一下就行\n\n","slug":"day28_课堂笔记","date":"2022-12-01T13:54:02.386Z","categories_index":"服务端","tags_index":"express","author_index":"团子"},{"id":"7bc9d1c1cb8c4ecce97b26cdf0cc3331","title":"26_手写web服务_处理get_post请求参数","content":"昨日回顾内置模块\n\tfs 处理文件\n\t\treadFile()\n\t\twriteFile()\n\tpath 处理路径\n\t\tjoin()\n\thttp 服务器相关\n\t\tcreateServer()\n\t\t\n包(第三方模块)\n\t概念\n\t\t由第三方个人或者团队开发出来的免费模块\n\t作用\n\t\t封装了内置模块,提高效率\n\t使用\n\t\tnpm 包管理工具\n\t\t\tnpm i 包名\n\t\t\tnpm uninstall 包名\n\t\tnrm 镜像管理工具\n\t组成\n\t\tnode-modules \n\t\t\t自定义包名\n\t\t\t\tdist 发布目录\n\t\t\t\t\tindex.js 头文件,引入其他源文件\n\t\t\t\tsrc\n\t\t\t\t\t存放源码\n\t\t\t\tpackage.json 配置文件 (npm init -y)\n\t\t\t\t\tname 包名\n\t\t\t\t\tversion 版本号\n\t\t\t\t\tmain 入口文件\n\t\t手写包步骤\n\t\t\t1,创建包名文件夹\n\t\t\t2,初始化\n\t\t\t3,创建包的目录结构\n\t\t\t\tdist\n\t\t\t\tsrc\n\t\t\t4,创建index.js,修改package.json里面main属性\n\t\t\t5,编写源码\n\t\t\t6,编写index.js\n\t\t导入规则(require(&#39;calc&#39;))\n\t\t\t1,看是不是内置模块\n\t\t\t2,到node-modules找\n\t\t\t3,先找同名文件\n\t\t\t4,再找同名文件夹,如果有,就去package.json里面main属性找入口文件\n\t\t\t5,没有package.json,找index.js\n\t\t\t6,都没有就报错\n\t服务器概念\n\t\t通讯3要素\n\t\t\tip \n\t\t\t端口\n\t\t\t协议\n\t\turl\n\t\t\t统一资源定位符\n\t\t\t协议 域名(ip) 端口 资源路径\n\t\thttp协议\n\t\t\t概念\n\t\t\t\t超文本传输协议\n\t\t\t作用\n\t\t\t\t规定服务器和浏览器传输数据的规范\n\t\t\t请求消息(浏览器传给服务器)\n\t\t\t\t格式\n\t\t\t\t\t请求行\n\t\t\t\t\t\t请求方式 请求的uri 协议版本(可以省略)\n\t\t\t\t\t请求头\n\t\t\t\t\t\t键值对,告诉服务器我浏览器的一些信息\n\t\t\t\t\t\tuser-agent:浏览器的版本型号\n\t\t\t\t\t请求体\n\t\t\t\t\t\t只有在post请求中才有\n\t\t\t响应消息(服务器传给浏览器)\n\t\t\t\t格式\n\t\t\t\t\t响应行\n\t\t\t\t\t\t协议版本 状态码 状态码描述\n\t\t\t\t\t响应头\n\t\t\t\t\t\t键值对,告诉浏览器我服务器的一些信息\n\t\t\t\t\t\tcontent-type 设置发送的数据的格式和编码\n\t\t\t\t\t响应体\n\t\t\t\t\t\t显示在body的正文\n\t\t\t\t\t\t\n\t\t\t请求对象和响应对象\n\t\t\t\trequest对象(req对象)\n\t\t\t\t\t里面封装请求的消息,主要提供获取方法\n\t\t\t\t\t\t获取请求方式 req.method\n\t\t\t\t\t\t获取请求的url req.url\n\t\t\t\tresponse对象(res对象)\n                \t里面就封装了响应消息,主要提供设置方法\n                \t\t设置响应头 res.setHeader()\n                \t\t设置响应体 res.send()\n\t\t\t\n\n手写web服务1,基本的web服务&#x2F;&#x2F;1,导入模块\n&#x2F;&#x2F;2,创建web服务器\n&#x2F;&#x2F;3,绑定事件,处理请求\n&#x2F;&#x2F;4,设置端口,进行监听\n\n2,处理中文乱码产生的原因\n\t前后编码不一致\n\t\t服务器发送数据:使用ISO-8859-1(拉丁文),不支持中文的\n\t\t浏览器接收数据并解析:中文的window使用GBK(国标)\n解决\n\t使用响应对象,设置响应头,统一编码\n\t\tres.setHeader(&#39;content-type&#39;,&#39;text&#x2F;html;charset&#x3D;utf-8&#39;)\n\t\t告诉浏览器我发送数据的格式是utf-8,将来浏览器接收之后,就会以utf-8编码来解析\n\n3,处理路由路由:\n\t根据不同的请求url,响应不同的数据\n\thttp:&#x2F;&#x2F;localhost:3000&#x2F; 或者 http:&#x2F;&#x2F;localhost:3000&#x2F;index  响应首页\n\thttp:&#x2F;&#x2F;localhost:3000&#x2F;list  响应列表页\n\thttp:&#x2F;&#x2F;localhost:3000&#x2F;detail 响应详情页\n\thttp:&#x2F;&#x2F;localhost:3000&#x2F;aaa    页面找不到\n\n思路\n\t1,先通过请求对象req中的url属性,获取到请求的url\n\t2,再通过url的内置模块解析获取出来的url.得到url对象\n\t3,从url对象的 pathname属性中 拿到值\n\t\n\thttp:&#x2F;&#x2F;    localhost   :   3000    &#x2F;detail   ?    id&#x3D;1\n\t 协议\t\t\tip&#x2F;域名        端口     pathname      query\n\t \nurl.parse(urlStr,true) 参数问题\n\t第二个参数是true,得到的url对象如下\n        Url &#123;\n          protocol: null,\n          slashes: null,\n          auth: null,\n          host: null,\n          port: null,\n          hostname: null,\n          hash: null,\n          search: &#39;?id&#x3D;1&#39;,\n          query: [Object: null prototype] &#123; id: &#39;1&#39; &#125;, &#x2F;&#x2F;这里的query的值是对象\n          pathname: &#39;&#x2F;detail&#39;,\n          path: &#39;&#x2F;detail?id&#x3D;1&#39;,\n          href: &#39;&#x2F;detail?id&#x3D;1&#39;\n        &#125;\n        \n    第二个参数是false(默认),得到的url对象如下\n        Url &#123;\n          protocol: null,\n          slashes: null,\n          auth: null,\n          host: null,\n          port: null,\n          hostname: null,\n          hash: null,\n          search: &#39;?id&#x3D;1&#39;,\n          query: &#39;id&#x3D;1&#39;,   &#x2F;&#x2F;这里的query的值是字符串\n          pathname: &#39;&#x2F;detail&#39;,\n          path: &#39;&#x2F;detail?id&#x3D;1&#39;,\n          href: &#39;&#x2F;detail?id&#x3D;1&#39;\n        &#125;\n\n\n\n4,处理get请求数据需求:\n\t假设发送的get请求是 http:&#x2F;&#x2F;localhost:3000&#x2F;detail?id&#x3D;1\n\t 需要获取 url 后面拼接的参数 id &#x3D; 1.\n\t 将来我会通过id&#x3D;1去数据库查询具体的商品数据\n\t \n思路\n\t首先需要判断请求的路径是不是以&#x2F;detail开头的\n\t如果是的话,再判断请求的方式是不是get\n\t如果是的话,解析获取到的url,拿到里面query属性的值\n\t\n应用\n\t查询单个数据的操作(后面会讲)\n\n\n\n5,处理post请求数据需求\n\t模拟登录,一般是post请求(可以安装REST Client 模拟客户端发送post请求)\n\t请求url就是   http:&#x2F;&#x2F;localhost:3000&#x2F;\n\t请求体 就是   username&#x3D;zhangsan&amp;password&#x3D;123\n\t\n\t如何拿到 username和password的值\n\t\n思路\n\t监听request的 date数据变化事件  和 end 数据接收完成 事件\n\t在date事件中进行累加\n\t在end事件中打印最终的数据\n\t\n应用\n\t登录操作,新增操作\n\n\n\n6,封装post请求(Promise)原因\n\t获取post请求的数据,是一个固定写法,将来经常会用到\n\t并且获取请求数据是一个异步的操作,推荐使用promise封装\n\t\n步骤\n\t定义一个方法,方法返回一个promise对象\n\t因为创建promise对象,需要传一个函数\n\t将 要封装的代码 放在 这个函数的函数体里面\n\t将 代码的结果  放在 resolve()方法的参数里面 返回 ,将来调用then方法的时候就能拿到\n\t\n执行流程\n\t调用封装的getPostData(),得到promise对象,\n\t然后调用promise的then方法,通过then方法的第一个函数的参数date.\n\t就可以拿到之前promise对象中函数执行的结果\n\t最后进行打印\n\n\n\n7,处理静态资源需求\n\t当浏览器地址栏输入 http:&#x2F;&#x2F;localhost:3000&#x2F; 或者 http:&#x2F;&#x2F;localhost:3000&#x2F;index\n\t显示新闻首页\n\t\n思路\n\t1,解析请求路径,判断pathname是(&#x2F;或者&#x2F;index)\n\t2,读取public路径下的文件,并返回\n\n\n\nnodemon使用由来\n\t1,之前使用node执行程序,如果文件修改了,都需要重启,效率比较低\n\t2,使用nodemon,相当于node升级版本,可以监控文件的变化,自动进行重启.提高效率\n安装\n\tnpm i nodemon -g 全局安装nodemon\n使用\n\tnodemon 文件路径 启动服务\n\t\n终端启动爆红(没有管理员权限)解决\n\thttps:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43682519&#x2F;article&#x2F;details&#x2F;116788807\n\n\n\n端口占用解决打开cmd\n\t输入 netstat -anno 就可以查看到当前程序运行的端口\n\n\n","slug":"day26_课程笔记","date":"2022-12-01T13:46:15.874Z","categories_index":"服务端","tags_index":"http","author_index":"团子"},{"id":"3c7a1f4a7818f7c459334d17943f7066","title":"25_包概念_http协议_请求响应","content":"昨日回顾nodejs\n\t概念\n\t\t提供了js代码的运行环境\n\t\t可以使用它来开发后台\n\t组成\n\t\tECMAScript语法\n\t\t内置模块\n\t\t第三方模块\n模块化编程\n\t概念\n\t\t按照固定的规则,把一个大的js文件拆分成若干个小文件(模块)\n\t好处\n\t\t提高代码的复用性,可维护性,按需加载,便于协同开发\n\t规则\n\t\t导入\n\t\t\trequire()\n\t\t导出\n\t\t\tmodule.exports\n\t\t\t\t和exports混用的时候问题:require()引入的永远是module.exports指向的对象\n分类\n\t内置模块\n\t\tfs,path,http\n\t自定义模块\n\t\t自己创建的js文件\n\t第三方模块\n\t\t第三方开发出来的,用之前需要下载\n作用域\n\t模块中的成员只能在当前模块内部访问,如果想要在外部使用,需要进行导出\n共享问题\n\t使用module.exports和exports都可以进行导出\n\trequire()引入的永远是module.exports指向的对象\n\t在一个模块中,不建议混用,习惯使用module.exports\n\n内置模块\n\tfs模块\n\t\t作用\n\t\t\t处理文件\n\t\t方法\n\t\t\treadFile(路径,编码,回调函数)\n\t\t\twriteFile(路径,数据,回调函数)\n\tpath模块\n\t\t作用\n\t\t\t处理路径的\n\t\t方法\n\t\t\tdirname()\n\t\t\tjoin()\n\t\t\textname()\n\t\t\tbasename()\n\thttp模块\n\t\t作用\n\t\t\t用来搭建web服务器\n\t\t方法\n\t\t\tcreateServer()\n\n\n\n包的操作包的概念来源\n\t跟内置模块和自定义模块不同,是由第三方个人或者团队开发出来的,免费给其他人使用\n\thttps:&#x2F;&#x2F;www.npmjs.com&#x2F;\n好处\n\t包其实是基于内置模块封装出来的,提供了一个更高级,更方便的API,提高了开发效率\n\t包和内置模块的关系,类似jquery和原生js之间的关系\n\nnpm包管理工具概念\n\t是由美国的一家公司提供的,用来管理包的,现在已经被集成到nodejs中\n安装\n\t无需安装.在安装node的时候,已经自动安装了\n查看版本\n\tnpm -v 查看版本号\n安装第三方软件\n\tnpm i 包名              安装包\n\tnpm uninstall 包名      卸载包\n\nnrm镜像管理工具概念\n\t解决国外网速慢的原因,可以使用国内的镜像\n使用\n\tnpm install nrm -g 安装镜像管理工具\n\tnrm ls 列出所有的镜像\n\tnrm use taobao 使用淘宝的镜像\n\npackage规范组成\n\tnode-modules \n\t\t用来存放所有已经安装到本地的包,require导入第三方包的时候,都是从这个目录汇总查找\n\tpackage.json\n\t\t当前包的配置文件,用于记录当前包的下载信息,例如包名,版本号,下载地址\n\t\tname:包名\n\t\tversion:版本\n\t\tmain:包的入口\n规范\n\t1,包必须以单独的目录存在\n\t2,包的顶级目录下必须包含package.json配置文件\n\t3,package.json中必须包含name(包名),version(版本号),main(包的入口)三个属性\n\t\n手写一个包(计算器calc 计算两个数的加减法)\n\t1,创建文件夹\n\t\t在node-modules下创建一个calc文件夹\n\t2,初始化这个文件夹\n\t\t使用cd命令进入calc文件夹\n\t\t使用npm init -y来初始化这个包,会在calc下创建一个package.json的配置文件\n\t3,创建包的目录结构\n\t\t1,创建src文件夹,用于存储源码\n\t\t2,创建dist文件夹,用于发布目录\n\t\t3.在dist文件夹下创建一个index.js文件,就是程序的入口文件\n\t\t4,修改package.json配置文件中的main属性值为&#39;dist&#x2F;index.js&#39;\n\t4,编写源码(src下面)\n\t\t1,在src下创建一个add.js,实现加法,并用module.exports导出\n\t\t2,在src下创建一个sub.js,实现减法,并用module.exports导出\n\t5,编写头文件(dist文件夹下的index.js里面)\n\t\t将源码里面的文件都导入进去,然后module.exports导出\n\t\t这么做的目的是,将来只需要引入头文件,就可以将整个源码中的文件引入\n\t6,使用自定义的calc包\n\t\t1,导入 const calc &#x3D; require(&#39;calc&#39;);\n\t\t2,使用 const m1 &#x3D; calc.add(1,2)\n\t\t\n\t\t\n\n模块加载机制加载步骤\n\t1,nodejs会假设它是一个内置模块  const calc &#x3D; require(&#39;calc&#39;);\n\t2,如果不是内置模块,就会去当前目录下的node_modules中查找\n\t3,首先看有么有该名字的js文件,如果有的话,就加载js文件\n\t4,如果没有该名字的js文件,就看是否有改名字的文件夹\n\t5,查看改文件夹中的package.json中的main选项,确定模块的入口文件\n\t6,如果进入文件夹之后,没有package.json文件,加载index.js\n\t7,如果连index.js文件都没有,就会报错\n\t\n加载注意\n\t1,模块在第一次加载后会被缓存,也就是多次调用require(),不会导致模块被加载多次\n\t2,不管是那种模块,都是优先从缓存中加载,从而提高加载速度\n\t3,内置模块是由nodejs官方提供,加载优先级最高\n\t\n一般规则\n\t--先内置模块\n\t--到node_modules中找\n\t--同名的js文件\n\t--同名的文件夹下的main指定的入口文件\n\t--同名的文件夹下的index.js\n\n\n\n服务器概念概念\n\t本质就是一台电脑,性能比个人电脑高很多\n\t\n\t负责存放和对外提供资源的电脑,叫做服务器\n\t负责获取和消费资源的电脑,叫做客户端\n\t\n网络通讯的三要素\n\tip:设备在网络中的唯一标识\n\t端口:程序在设备中的唯一标识\n\t协议:规定了浏览器和服务器之间数据的传输形式\n\t\t浏览器发什么样的数据给服务器,服务器才能解析\n\t\t服务器发什么样的数据给浏览器,浏览器才能解析\n\n\n\nURL地址概念\n\t统一资源定位符,可以定位互联网上的唯一一个资源\n\thttps:&#x2F;&#x2F;detail.tmall.com:80&#x2F;item.htm?id&#x3D;653413567689  淘宝某一个商品的url地址\n\t\n组成\n\t通讯协议: https:&#x2F;&#x2F;\n\tip或者域名: detail.tmall.com (这个域名将来会被DNS域名解析器解析为一个ip地址)\n\t端口: 80(一般网站默认使用80端口)\n\t资源的名称(存放位置): item.htm?id&#x3D;653413567689\n\t\n\t学生管理系统首页页面: http:&#x2F;&#x2F;localhost:3000&#x2F;index.js\n\nHTTP协议概念\n\t超文本传输协议\n作用\n\t规定了客户端和服务端进行网络内容传输所遵循的规范\n\t浏览器传给服务器什么样格式的数据,服务器才能解析\n\t服务器传给浏览器什么样格式的数据,浏览器才能解析\n特点\n\t基于请求和响应模型\n\t必须先有请求,再有响应\n\t请求和响应成对出现的\n\t\t请求成功,200\n\t\t请求失败,404,500\n\n请求消息概念\n\t客户端给服务器的消息,告诉服务器,我浏览器的一些信息\n组成\n\t请求行\n\t\t请求方式 请求的URI(统一资源标识符,前面没有协议) 协议版本\n\t\n\t请求头\n\t\tuser-agent:浏览器的版本型号\n\t\tcontent-type:发给服务器的数据格式\n\t\taccept:浏览器能够支持的返回内容的类型\n\t\taccept-language:浏览器期望获取自然语言的顺序\n\t请求体\n\t\t只有post请求方式才有\n\t\t\n常见的请求方式\n\tget请求\n\t\t数据拼接在地址栏后面,相对的不安全,只能拼接少量的数据\n\t\t一般用于从服务器获取数据(京东获取某个商品的详细信息,传一个商品的id)\n\tpost请求\n\t\t数据保存在请求体中,相对的安全,可以传递大量数据\n\t\t一般用于向服务器提交数据(表单,文件上传下载)\n\n响应消息概念\n\t服务器发给客户端的信息,告诉浏览器我发给你的消息的数据类型及特点\n组成\n\t响应行\n\t\t格式: 协议版本 状态码 状态码描述\n\t响应头\n\t\tcontent-type:告诉浏览器,我发送数据的类型和编码\n\t\tcontent-length:发给浏览器内容的字节长度\n\t响应体\n\t\t将来显示到页面正文的内容\n\t\t\n常用的响应状态码\n\t2XX 成功 200\n\t3XX 重定向 302\n\t4XX 客户端错误 404\n\t5XX 服务端错误 500 \n\t\nrestful风格,通过不同的请求方式调用不同的方法,来实现不同的功能(后面会讲)\n\tget:查询(查询一个,查询所有)\n\tpost:新增\n\tput:修改\n\tdelete:删除\n\n\n\n请求响应对象由来\n\t由于请求消息和响应消息,都是字符串,操作这些字符串很麻烦\n\tnode就将请求响应消息封装成了请求对象和响应对象\n分类\n\t请求对象(request对象)\n\t\t封装了请求消息,一般用于获取数据(获取请求方式request.getMethod,获取请求体)\n\t响应对象(response对象)\n\t\t封装了响应消息,一般用于设置数据(设置响应状态码)\n\n\n请求响应流程\n","slug":"day25_课堂笔记","date":"2022-12-01T13:40:54.834Z","categories_index":"服务端","tags_index":"http","author_index":"团子"},{"id":"8ad32db149f95208d6fb34755e75039a","title":"Node快速入门","content":"一. Node概述1 Node是什么\n\n\n\n\n\n\n\n\nNode是一个基于Chrome V8引擎的JavaScript代码运行环境\n运行环境\n\n浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript代码的运行环境\nNode（软件）能够运行JavaScript代码，Node就是JavaScript代码的运行环境\n\n2 Node的安装Node官网：https://nodejs.org/en/\nNode中文官网: http://nodejs.cn/\n在官网安装下载\nwin+R打开cmd\n\n在cmd中输入node -v查看\n\n输入node, 进入到node的命令行, 执行js代码\n\n按两次ctrl+C退出node命令行\n3 Node的组成一开始, 几乎没有人把js当成一门真正的编程语言, 认为它只是运行在浏览器上小脚本而已. 事实上也如此, js的作者用10天写出的这个小玩意最开始仅仅只是为了做表单的验证, 节省一点带宽. 后来经过不断的发展, 慢慢完善, 但是依然存在一个缺陷: 没有模块的概念. 这对做大型项目是非常不利的\n网景 liveScript-&gt;JavaScript \nIE: JScript\njs的官方规范(ECMAScript)主要是规定: 词法, 语法, 表达式, 函数, 对象这些东西. \nW3C组织主要推进HTML5和web标准化, 这些过程基本上都是发生在前端. \n服务端的规范相当落后. 主要集中在这些方面:\n\n没有模块系统\n标准库较少(比如I/O操作, 文件系统)\n没有标准接口(比如几乎没有如何操作数据库的统一接口)\n缺乏包管理系统\n\n这个时候, CommonJS规范出现, 定义和完善了js的这些功能, Node可以被认为是对CommonJS规范的代码实现\n\n这张图, 很好的说明了Node与浏览器, W3C, CommonJS组织, ECMAScript之间的关系\n二. 模块化开发1 为什么需要模块化开发\n\n\n\n\n\n\n\n\n问题一: 文件依赖关系不明确\n一般认为，后加载的文件可能需要依赖于先加载的文件，比如\n01-依赖关系.html\n&lt;script src&#x3D;&quot;js&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;js&#x2F;scroll.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;js&#x2F;swiper.jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n\n现在我们在01-依赖关系.html使用了一个方法\n$(&#39;#fade&#39;).swiper(&#123;\n  type: &#39;fade&#39;,\n  src: scr,\n  arrow: true,\n&#125;)\n\n如果仅仅从代码上看. 很难分析出$()方法是在jquery.js还是在scroll.js中\n如果代码越来越复杂, 这种依赖关系更加难以维护, 在大型工程项目中尤为明显\n\n\n\n\n\n\n\n\n\n问题二: 命名冲突\njs还存在一个问题, 就是命名冲突, 后定义的变量会覆盖之前定义的变量\n02-命名冲突.html\n&lt;script src&#x3D;&quot;a.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;b.js&quot;&gt;&lt;&#x2F;script&gt;\n\n&lt;script&gt;\n  console.log(str) &#x2F;&#x2F; b文件中的str\n&lt;&#x2F;script&gt;\n\na.js\nvar str &#x3D; &#39;a文件中的str&#39;\n\nb.js\nvar str &#x3D; &#39;b文件中的str&#39;\n\n如果在a.js和b.js中同时定义了str变量, 由于b.js后加载, 会覆盖a.js中定义的str变量\n这在大项目中是非常危险的, 一旦你在自己的代码中改写了一个变量的值, 而这个变量恰好其他人也使用了, 会引用程序的崩溃, 并且无从查起\n\n\n\n\n\n\n\n\n\n扩展\n当然, 早期人们可以通过自执行匿名函数解决这个问题, 但是这种方案现在已经被CommonJS规范取代了.\n当然, 如果仔细深入的研究Node, 你会发现Node的实现也仅仅是在每个文件的最外层包裹一层自执行匿名函数\n在早些年, 没有模块化规范时, 可以定义一个自执行匿名函数(IIFE). \n由于函数会产生局部作用域, 在函数内定义的变量和函数不会污染全局\n如果其它文件需要使用, 就通过return将内部的成员暴露给外部\nconst moduleFoo &#x3D; (function () &#123;\n  const name &#x3D; &#39;xiaoming&#39;\n\n  function sayHi() &#123;\n    console.log(&#39;hello &#39; + name)\n  &#125;\n\n  return &#123;\n    name,\n    sayHi,\n  &#125;\n&#125;)()\n\n2 Node中的模块规范Node是对CommonJS规范的一种代码实现, 所以在Node中使用的就是CommonJS模块规范\n1) 模块\n\n\n\n\n\n\n\n\n每个文件被看成一个单独的模块,模块与模块之间是独立的\n如何理解呢?\n在一个文件(模块)中定义的变量, 在另一个文件(模块)中无法直接使用\n\n\n\n\n\n\n\n\n\n示例\n定义a.js\nvar str &#x3D; &#39;模块a中的str&#39;\n\n定义b.js\n&#x2F;&#x2F; 通过require, 表示引用a.js\nrequire(&#39;.&#x2F;a.js&#39;)\nconsole.log(str)\n\n\n\n\n\n\n\n\n\n\n演示\n\n2) 导出\n\n\n\n\n\n\n\n\n如果希望外部能使用当前模块中的变量/函数, 需要使用exports导出\n\nexports是一个对象\n将希望导出的变量/函数挂载到exports对象上, 表示导出\n所谓挂载就是给exports对象添加属性或者方法\n\n\n\n\n\n\n\n\n\n\n示例\n04-导出\na.js\nvar str &#x3D; &#39;a模块中的str变量&#39;\n\nfunction add(x, y) &#123;\n  return x + y\n&#125;\n\n&#x2F;&#x2F; 在exports对象上挂载str属性\nexports.str &#x3D; str\n&#x2F;&#x2F; 在exports对象上挂载add方法\nexports.add &#x3D; add\n\nb.js\n&#x2F;&#x2F; 导入a模块, a是一个对象, 相当于a模块中的exports对象\nvar a &#x3D; require(&#39;.&#x2F;a.js&#39;)\n\nconsole.log(a)\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n\n\n\n\n\n\n\n\n思考\n\n从上面的案例可知, 如果向外暴露(导出)属性或者方法, 可以使用exports. 但是如果想导出整个对象怎么办\n\n\n\n\n\n\n\n\n\n尝试\na_obj.js\nvar str &#x3D; &#39;a_obj模块中的str&#39;\n\nfunction add(x, y) &#123;\n  return x + y\n&#125;\n\nexports &#x3D; &#123;\n  str: str,\n  add: add,\n&#125;\n\nb_obj.js\nvar a_obj &#x3D; require(&#39;.&#x2F;a_obj.js&#39;)\n\nconsole.log(a_obj) &#x2F;&#x2F; &#123;&#125;\n\n\n\n\n\n\n\n\n\n\n演示\n\n通过尝试, 我们发现打印出来是一个空对象, 说明不能通过exports导出新对象\n\n实际上, Node在实现CommonJS模块规范时, \n每个模块都存在一个内置对象module表示当前模块\n\n\n\n\n\n\n\n\n\n在导出时, 实际导出的是module.exports. 而exports是它的引用\n上述代码相当于\nvar str &#x3D; &#39;a_obj模块中的str&#39;\n\nfunction add(x, y) &#123;\n  return x + y\n&#125;\n&#x2F;&#x2F; 给exports重新赋值一个对象, 并不影响module.exports\nexports &#x3D; &#123;\n  str: str,\n  add: add,\n&#125;\n\nmodule.exports &#x3D; &#123;&#125;\n\n\n\n\n\n\n\n\n\n\n图解\n\n\n\n\n\n\n\n\n\n\n结论\n\nexpots通过挂载属性向外暴露变量或者函数, 但是不能暴露对象\n一般情况下使用module.exports\n\n\n\n\n\n\n\n\n\n\n扩展: exports存在的意义\n那既然一般都是使用module.exports, 那exports存在的意义是什么呢?\n因为, 在CommonJS规范中规定模块的导出必须通过exports. Node在实现时也就保留了下来. 在实际使用时, 大部分都是直接用module.exports\n\n\n\n\n\n\n\n\n\n面试题\n该模块导出的是什么?\nvar str &#x3D; &#39;str&#39;\n\nfunction add(x, y) &#123;\n  return x + y\n&#125;\n\nexports.str &#x3D; str\nexports.add &#x3D; add\n\nexports &#x3D; &#123;\n  a: &#39;a&#39;,\n  b: &#39;b&#39;,\n&#125;\n\n答案: &#123; str: &#39;str&#39;, add: [Function: add] &#125;\n\n\n\n\n\n\n\n\n\n图解\n\n3) 导入在Node中导入模块, 需要经历3个步骤\n\n路径分析\n文件定位\n编译执行\n\nNode中的模块可以分为两类:\n\nNode提供的模块, 称为核心模块\n用户编写的模块, 称为文件模块(或者: 包package)\n\n\n\n\n\n\n\n\n\n\n核心模块\n对于核心模块的导入, 如fs, http, path等, 直接使用模块名\nconst fs &#x3D; require(&#39;fs&#39;)\nconst http &#x3D; require(&#39;http&#39;)\nconst path &#x3D; require(&#39;path&#39;)\n\n\n\n\n\n\n\n\n\n\n文件模块\n对于文件模块的导入, 情况比较复杂, 放在稍后一点讲解\n三. 核心模块Node的核心模块比较多, 这里我们重点介绍跟文件操作相关的path和fs\n更多的使用, 参考Node官网 API部分: http://nodejs.cn/api/ \n1 path模块path模块, 主要功能是对路径进行操作\n1) 使用步骤\n导入核心模块\n调用相关API\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 1.导入path模块\nconst path &#x3D; require(&#39;path&#39;)\n\n&#x2F;&#x2F; 2.调用API\n\n&#x2F;&#x2F; 当前文件的完整路径\nconsole.log(__filename) \n&#x2F;&#x2F; 当前文件所在目录\nconsole.log(path.dirname(__filename)) \n\n2) 常用API\n\n\n\n\n\n\n\n\npath.join()\npath.join() 方法会将所有给定的 path 片段连接到一起\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 1.导入path模块\nconst path &#x3D; require(&#39;path&#39;)\n\n&#x2F;&#x2F; 2.调用API\n\n&#x2F;&#x2F; 当前文件所有目录\nconsole.log(__dirname)\n\n&#x2F;&#x2F;当前目录下的fs子目录\nlet fs_path &#x3D; path.join(__dirname, &#39;fs&#39;)\nconsole.log(fs_path)\n\n2 fs模块fs模块(file system)文件操作系统, 主要功能是对目录/文件进行操作\n\n\n\n\n\n\n\n\n\n读文件\nfs.readFile(path, [options], callback)\n\npath: 需要读取文件的路径\noptions: 编码格式, 一般为’utf8’\ncallback: 回调函数\nerr: 错误对象\ndata: 数据\n\n\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 1.导入fs核心模块\nconst fs &#x3D; require(&#39;fs&#39;)\n\n&#x2F;&#x2F; 2.读取文件\nfs.readFile(&#39;1.txt&#39;, &#39;utf8&#39;, (err, data) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 如果文件读取出错 err 是一个对象 包含错误信息\n  &#x2F;&#x2F; 如果文件读取正确 err 是 null\n  if (err) throw err\n  \n  console.log(data)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n写文件\nfs.writeFile(file, data[, options], callback)\n\nfile: 需要写入的文件\ndata: 需要写入的数据\noptions: 编码格式等, 一般为’utf8’\ncallback: 回调函数\nerr: 出错对象\n\n\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 1.导入fs核心模块\nconst fs &#x3D; require(&#39;fs&#39;)\n\n&#x2F;&#x2F; 2.写文件\nfs.writeFile(&#39;index.html&#39;, &#39;&lt;h1&gt;Hello&lt;&#x2F;h1&gt;&#39;, &#39;utf8&#39;, err &#x3D;&gt; &#123;\n  if (err) throw err\n\n  console.log(&#39;写入成功&#39;)\n&#125;)\n\n四. 文件模块文件模块是由程序员基于Node环境编写并发布的代码, 通过由多个文件组成放在一个文件夹中, 所以也叫做包\n在编程界, 有一句经典的名言: ‘不要重复造轮子’, 文件模块就相当于已经造好的轮子, 我们需要一个功能时直接拿来使用就可以了. 因此, 文件模块最大的作用是: 代码复用\n1 npm包管理工具由于包太多了不好查找和维护, 自然会出现管理工具, npm(node package manager)就是其中非常出色的一个\n1) npm基本使用npm在安装node时, 会被自动安装, 首先通过命令查看npm是否已经安装\n在cmd命令行执行npm -v, 查看npm的版本信息\n\n\n\n\n\n\n\n\n\n\n安装包\nnpm install 包名称\n\n\n\n\n\n\n\n\n\n示例\n如果我们想安装jquery, 执行npm install jquery即可\n\n\n\n\n\n\n\n\n\n演示\n\n\n\n\n\n\n\n\n\n\n删除包\nnpm uninstall 包名称\n\n\n\n\n\n\n\n\n\n示例\n执行npm uninstall jquery\n\n\n\n\n\n\n\n\n\n演示\n\n2) 镜像与nrm由于npm是国外的网站, 包的下载速度比较慢, 有时不稳定会导致安装出错. 为了解决这个问题, 我们可以使用国内镜像, 镜像源就是一个和npm官网一样的网站(像镜子一样), 只不过在国内, 这样更加稳定, 并且速度也很快.\n\n\n\n\n\n\n\n\n\nnrm是一个镜像管理工具\n执行命令\nnpm install nrm -g\n\n\n-g: 表示全局安装\n\n全局安装会在C:\\Users\\mayn\\AppData\\Roaming\\npm路径下生成一个可执行命令, 这样就可以在命令行执行了\n\n在命令行执行\nnrm ls\n\n显示可用镜像\n\n使用nrm use切换镜像\nnrm use taobao\n\n更多命令, 使用nrm -h查看\n\n\n\n\n\n\n\n\n\n小结\n如果安装工具类的包, 一般加-g, 全局安装\n2 package规范每个发布在npm上的包都遵循统一的规范, 这个规范也就被称为’package规范’. 以jquery为例\n├─dist &#x2F;&#x2F; 项目发布目录\n├─external\n│  └─sizzle\n│      └─dist\n└─src &#x2F;&#x2F; 源代码\n└─package.json &#x2F;&#x2F; 包配置文件\n└─README.md &#x2F;&#x2F; 说明文件\n\n其中, 最重要的是package.json文件\n&#123;\n  &quot;name&quot;: &quot;&quot;, &#x2F;&#x2F; 包名称\n  &quot;version&quot;: &quot;1.0.0&quot;, &#x2F;&#x2F; 版本\n  &quot;description&quot;: &quot;&quot;, &#x2F;&#x2F; 描述\n  &quot;main&quot;: &quot;index.js&quot;, &#x2F;&#x2F; 入口文件\n  &quot;scripts&quot;: &#123; &#x2F;&#x2F; 脚本\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;&#125;, &#x2F;&#x2F; 项目依赖\n  &quot;devDependencies&quot;: &#123;&#125;, &#x2F;&#x2F; 开发时依赖\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;, &#x2F;&#x2F; 作者\n  &quot;license&quot;: &quot;ISC&quot;\n&#125;\n\n3 手写一个package通过自己手写一个简单的包, 我们来了解package规范\n1) 创建一个文件夹在node_modules下创建一个文件夹calc, 这个文件夹也就是一个package\n\n2) 初始化打开calc, 执行命令\nnpm init -y\n\n\n-y: 表示使用默认值初始化\n\n\n\n\n\n\n\n\n\n\n演示\n\n会在calc里生成package.json配置文件, 如下\n&#123;\n  &quot;name&quot;: &quot;calc&quot;, &#x2F;&#x2F; 包名称\n  &quot;version&quot;: &quot;1.0.0&quot;, &#x2F;&#x2F; 版本\n  &quot;description&quot;: &quot;&quot;, &#x2F;&#x2F; 描述\n  &quot;main&quot;: &quot;index.js&quot;, &#x2F;&#x2F; 入口文件\n  &quot;scripts&quot;: &#123; &#x2F;&#x2F; 脚本\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;, &#x2F;&#x2F; 作者\n  &quot;license&quot;: &quot;ISC&quot;\n&#125;\n\n其中, 最重要的是main, 用来指定: 其他人加载这个package时, 实际引入的文件是哪一个\n3) 创建目录结构创建如图所示的目录结构\n\n修改package.json的入口文件\n\n在dist目录下创建index.js, 作为入口文件\n4) 编写代码\n\n\n\n\n\n\n\n\nsrc/add.js\nfunction add (x, y) &#123;\n  return x + y\n&#125;\n\nmodule.exports &#x3D; add\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n\n\n\n\n\n\n\n\nsrc/sub.js\nmodule.exports &#x3D; function (x, y) &#123;\n  return x - y\n&#125;\n\n\n\n\n\n\n\n\n\n\ndist/index.js\nconst add &#x3D; require(&#39;..&#x2F;src&#x2F;add.js&#39;)\nconst sub &#x3D; require(&#39;..&#x2F;src&#x2F;sub.js&#39;)\n\nmodule.exports &#x3D; &#123;\n  add,\n  sub\n&#125;\n\n\n\n\n\n\n\n\n\n\n演示\n\n5) 使用package在node_modules同级目录创建test.js测试文件\nconst calc &#x3D; require(&#39;calc&#39;)\n\nconsole.log(calc.add(1, 2))\n\n\n\n\n\n\n\n\n\n\n演示\n\nrequire加载的流程:\n\n在node_modules下找calc目录\n解析package.json文件, 找到指定的入口文件:’dist/index.js’\n\n4 导入规则1) 以名称开头\n\n\n\n\n\n\n\n\n示例\nrequire(&#39;fs&#39;)\nrequire(&#39;calc&#39;)\n\n\nNode.js会假设它是核心模块\n如果不是核心模块Node.js会去当前目录下的node_modules中查找\n首先看是否有该名字的JS文件\n再看是否有该名字的文件夹\n查看该文件夹中的package.json中的main选项确定模块入口文件\n如果没有package.json文件, 加载index.js\n否则找不到报错\n\n2) 以路径开头\n\n\n\n\n\n\n\n\n示例\nrequire(&#39;.&#x2F;find&#39;)\nrequire(&#39;..&#x2F;add.js&#39;)\n\n\n如果模块后缀省略，先找同名JS文件再找同名JS文件夹\n如果找到了同名文件夹，找文件夹中的index.js\n如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件\n如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到\n\n五. 服务端编程Node最显著的特点就是将js扩展到了服务端, 使得可以使用js编写服务端程序. \n1 概念1) 服务器\n\n\n\n\n\n\n\n\n提供服务的机器, 也就是电脑, 跟普通的电脑相比, 服务器一般性能更好\n\n\n\n\n\n\n\n\n\n\n服务器集群\n\n\nhttp服务器: 提供http服务的电脑\n数据库服务器: 提供数据存储服务的电脑\n\n2) 服务所谓服务, 就是运行在电脑上的一个应用程序.\n在生活中, 我们都有去食堂吃饭的经历, 在食堂里有不同的窗口, 每个窗口卖的食品不一样, 就像提供的服务不一样\n\n在计算机网络中. 通过IP地址可以唯一的确定某一台电脑, 通过端口就可以唯一的确定这个电脑提供的服务\n\n\n\n\n\n\n\n\n\n结论\n服务 = IP + Port\n3) 服务端程序所谓服务端程序, 就是提供服务的程序, 通过运行在服务器上\n一般情况下, 服务端程序和客户端程序运行在不同的电脑上, 这两个程序要能通信(发送数据)就需要一个统一的标准, 这个标准就是协议, 在Web服务中使用的是Http协议\n2 Http协议Http是一种网络协议, 规定了web服务器与浏览器之前的交互语言, 是一种一问一答协议\n\n由浏览器发起请求(request)\n由web服务器针对请求生成响应(response)\n\n\n\n1) URLURL(Uniform Resource Locator), 统一资源定位符\n在计算机网络中, 可以通过统一资源定位符(URL)请求对应的服务器资源(Resource)\nSchema:&#x2F;&#x2F;host[:port]&#x2F;path[?query-string]\n\n\nSchema: 使用的协议类型, 如http/https/ftp等\nhost:     主机域名或IP\nport:     端口号(可选)\npath:     路径\nquery-string: 查询参数(可选)\n\n\n\n\n\n\n\n\n\n\n 示例\nhttp:&#x2F;&#x2F;api.local.com&#x2F;movies\nhttps:&#x2F;&#x2F;api.local.com:8080&#x2F;articles?id&#x3D;100\n\n\n\n\n\n\n\n\n\n\n资源\n\n狭义上讲, 所有在服务器保存的数据(如:音乐/视频/文章/个人信息…)都是服务器端资源.\n广义上讲, 任何服务器端的对象(如:应用程序/数据库记录/算法…)都可以看作资源.\n\n2) Http请求HTTP请求由三部分组成, 分别是:     \n\n请求行\n请求头\n请求体\n\n如下图所示\n \n请求行请求行的格式如下：\nMethod Request-URL HTTP-Version CRLF\n\n\nMethod：    HTTP请求的类型, 如:GET/POST/PUT/DELETE\nRequest-URL:     HTTP请求的唯一标识符, 如: /test.hmtl\nHTTP-Version:    HTTP协议版本, 如HTTP/1.1\nCRLF:         回车换行 CR(回车\\n)  LF(换行\\r)\n\n例子: GET /test.html HTTP/1.1 (CRLF) \n请求行以”空格”分割, 除结尾的外CR和LF外, 不允许出现单独的CR或LF字符\n请求头请求头包含许多有关的前端环境和请求正文的有用信息. \n请求体请求体主要包含前端发送给后端的数据\n对于GET请求, 一般不需要请求体, 因为GET参数直接体现在URL上\n对于POST请求, 需要请求体, 请求体里保存POST参数\n3) Http响应同样, HTTP响应也是由三部分组成, 分别是: \n\n响应行\n响应头\n响应体\n\n响应报文如下图所示:\n \n响应行响应行的格式如下：\nHTTP-Version Status-Code Reason-Phrase CRLF\n\n\nHTTP-Version：    HTTP协议版本, 如HTTP/1.1\nStatus-Code:         响应状态码, 如200/401/500\nReason-Phrase:    描述信息\nCRLF:             回车换行 CR(回车\\n)  LF(换行\\r)\n\n\n\n\n\n\n\n\n\n\n示例\nHTTP/1.1 200 OK\n状态码\n\n1xx：指示信息–表示请求已接收，继续处理。\n2xx：成功–表示请求已被成功接收、理解、接受。\n3xx：重定向–要完成请求必须进行更进一步的操作。\n4xx：客户端错误–请求有语法错误或请求无法实现。\n5xx：服务器端错误–服务器未能实现合法的请求。\n\n常见的状态码\n\n200 OK：客户端请求成功。\n400 Bad Request：客户端请求有语法错误，不能被服务器所理解。\n401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate一起使用。\n403 Forbidden：服务器收到请求，但是拒绝提供服务。\n404 Not Found：请求资源不存在，举个例子：输入了错误的URL。\n500 Internal Server Error：服务器发生不可预期的错误。\n\n响应头响应头是后端(服务器)返回给前端(客户端)的信息.\n响应体响应体是后端(服务器)返回给前端(客户端)的数据.\n比如: 一个html页面代码, 一张图片, 一个json数据…\n3 手写http服务程序Node提供了Http核心模块, 方便我们快速构建一个http服务程序\n1) 最简单的http服务程序\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 引入http核心模块\nconst http &#x3D; require(&#39;http&#39;)\n\n&#x2F;&#x2F; 创建web服务器\nconst server &#x3D; http.createServer()\n\n&#x2F;&#x2F; 处理请求\nserver.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n  res.end(&#39;&lt;h1&gt;hello&lt;&#x2F;h1&gt;&#39;)\n&#125;)\n\n&#x2F;&#x2F; 监听3000端口\nserver.listen(3000)\n\n\n\n\n\n\n\n\n\n\n演示\n\n2) 处理中文字符\n\n\n\n\n\n\n\n\n示例\n如果响应里包含中文会怎样?\n注意, 修改代码后要重启服务\nres.end(&#39;&lt;h1&gt;这是一个web服务器&lt;&#x2F;h1&gt;&#39;)\n\n\n\n\n\n\n\n\n\n\n演示\n\n我们发现会出现乱码. 我们需要在响应头里添加编码格式\nserver.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 设置响应头\n  res.writeHead(200, &#123;\n    &#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf-8&#39;,\n  &#125;)\n  res.end(&#39;&lt;h1&gt;这是一个web服务器&lt;&#x2F;h1&gt;&#39;)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n\n\n\n\n\n\n\n\nnodemon\n每次修改代码都需要手动重启服务. 这并不友好, 而且容易忘记. 这里, 大家可以安装nodemon工具\nnpm install nodemon -g\n\n然后, 使用nodemon来执行js文件, nodemon会监听文件的变化, 并且重新执行\n\n3) 处理路由\n\n\n\n\n\n\n\n\n分析URL\n不论是get请求还是post请求, 作为服务端而言, 首先要知道请求的URL\n在Node中, 可以通过url核心模块进行分析, 参考 官方文档\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 导入url模块\nconst url &#x3D; require(&#39;url&#39;)\n\n&#x2F;&#x2F; 通过url.parse方法, 返回url对象\nconst str &#x3D; &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;index&#39;\nconst obj &#x3D; url.parse(str, true)\nconsole.dir(obj)\n\n\n\n\n\n\n\n\n\n\n输出\nUrl &#123;\n  protocol: &#39;http:&#39;,\n  slashes: true,\n  auth: null,\n  host: &#39;localhost:3000&#39;,\n  port: &#39;3000&#39;,\n  hostname: &#39;localhost&#39;,\n  hash: null,\n  search: null,\n  query: [Object: null prototype] &#123;&#125;,\n  pathname: &#39;&#x2F;index&#39;,\n  path: &#39;&#x2F;index&#39;,\n  href: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;index&#39;\n&#125;\n\n这里我们最关心的是\n\npathname: 请求的路由\n\n通过路由, 服务端可以区分具体的资源, 比如\n\n/和index: 首页\nlist: 列表页\ndetail: 详情页\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 引入http核心模块\nconst http &#x3D; require(&#39;http&#39;)\n\n&#x2F;&#x2F; 引入url核心模块\nconst url &#x3D; require(&#39;url&#39;)\n\n&#x2F;&#x2F; 创建web服务器\nconst server &#x3D; http.createServer()\n\n&#x2F;&#x2F; 处理请求\nserver.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 设置响应头\n  res.writeHead(&#39;200&#39;, &#123;\n    &#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf-8&#39;,\n  &#125;)\n\n  &#x2F;&#x2F; 分析路由\n  const &#123; pathname &#125; &#x3D; url.parse(req.url, true)\n\n  if (pathname &#x3D;&#x3D; &#39;&#x2F;&#39; || pathname &#x3D;&#x3D; &#39;&#x2F;index&#39;) &#123;\n    res.end(&#39;首页&#39;)\n  &#125; else if (pathname &#x3D;&#x3D; &#39;&#x2F;list&#39;) &#123;\n    res.end(&#39;列表页&#39;)\n  &#125; else &#123;\n    res.writeHead(&#39;404&#39;)\n    res.end(&#39;Not Found&#39;)\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; 监听3000端口\nserver.listen(3000)\n\nconsole.log(&#39;server is running on localhost:3000&#39;)\n\n4) 处理GET请求对于同一个URL, 可以发起不同类型的请求, 处理请求, 主要是分析请求的参数\n由于GET参数直接在URL中, 在处理URL时, 通过query就可以得到\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 导入url模块\nconst url &#x3D; require(&#39;url&#39;)\n\n&#x2F;&#x2F; 通过url.parse方法, 返回url对象\nconst str &#x3D; &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;index?username&#x3D;xiaopang&#39;\nconst obj &#x3D; url.parse(str, true)\nconsole.dir(obj)\n\n\n\n\n\n\n\n\n\n\n输出\nUrl &#123;\n  protocol: &#39;http:&#39;,\n  slashes: true,\n  auth: null,\n  host: &#39;localhost:3000&#39;,\n  port: &#39;3000&#39;,\n  hostname: &#39;localhost&#39;,\n  hash: null,\n  search: &#39;?username&#x3D;xiaopang&#39;,\n  query: [Object: null prototype] &#123; username: &#39;xiaopang&#39; &#125;,\n  pathname: &#39;&#x2F;users&#x2F;index&#39;,\n  path: &#39;&#x2F;users&#x2F;index?username&#x3D;xiaopang&#39;,\n  href: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;index?username&#x3D;xiaopang&#39;\n&#125;\n\n\n\n\n\n\n\n\n\n\n处理get请求\n&#x2F;&#x2F; 引入http核心模块\nconst http &#x3D; require(&#39;http&#39;)\n\n&#x2F;&#x2F; 引入url核心模块\nconst url &#x3D; require(&#39;url&#39;)\n\n&#x2F;&#x2F; 创建web服务器\nconst server &#x3D; http.createServer()\n\n&#x2F;&#x2F; 处理请求\nserver.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 设置响应头\n  res.writeHead(&#39;200&#39;, &#123;\n    &#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf-8&#39;,\n  &#125;)\n\n  &#x2F;&#x2F; 分析路由\n  const &#123; query, pathname &#125; &#x3D; url.parse(req.url, true)\n\n  if (pathname &#x3D;&#x3D; &#39;&#x2F;&#39; || pathname &#x3D;&#x3D; &#39;&#x2F;index&#39;) &#123;\n    &#x2F;&#x2F; 处理get请求\n    if (req.method &#x3D;&#x3D; &#39;GET&#39;) &#123;\n      &#x2F;&#x2F; 打印在后端控制台\n      console.log(query)\n      &#x2F;&#x2F; 返回给浏览器\n      res.end(query.username)\n    &#125;\n  &#125; else if (pathname &#x3D;&#x3D; &#39;&#x2F;list&#39;) &#123;\n    res.end(&#39;列表页&#39;)\n  &#125; else &#123;\n    res.writeHead(&#39;404&#39;)\n    res.end(&#39;Not Found&#39;)\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; 监听3000端口\nserver.listen(3000)\n\nconsole.log(&#39;server is running on localhost:3000&#39;)\n\n5) 处理POST请求对于POST请求, 由于参数在数据报文中, 只有等数据传输完成才可以进行处理. \n主要使用request提供的data和end事件来处理\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 引入http核心模块\nconst http &#x3D; require(&#39;http&#39;)\n\n&#x2F;&#x2F; 引入url核心模块\nconst url &#x3D; require(&#39;url&#39;)\n\n&#x2F;&#x2F; 创建web服务器\nconst server &#x3D; http.createServer()\n\n&#x2F;&#x2F; 处理请求\nserver.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 设置响应头\n  res.writeHead(&#39;200&#39;, &#123;\n    &#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf-8&#39;,\n  &#125;)\n\n  &#x2F;&#x2F; 分析路由\n  const &#123; query, pathname &#125; &#x3D; url.parse(req.url, true)\n\n  if (pathname &#x3D;&#x3D; &#39;&#x2F;&#39; || pathname &#x3D;&#x3D; &#39;&#x2F;index&#39;) &#123;\n    &#x2F;&#x2F; 处理get请求\n    if (req.method &#x3D;&#x3D; &#39;GET&#39;) &#123;\n      &#x2F;&#x2F; 显示页面\n      console.log(query)\n    &#125; else if (req.method &#x3D;&#x3D; &#39;POST&#39;) &#123;\n      let post_data &#x3D; &#39;&#39;\n      &#x2F;&#x2F; post数据传递\n      req.on(&#39;data&#39;, (data) &#x3D;&gt; (post_data +&#x3D; data))\n      &#x2F;&#x2F; post数据传输完成\n      req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n        console.log(post_data)\n        res.end(post_data)\n      &#125;)\n    &#125;\n  &#125; else if (pathname &#x3D;&#x3D; &#39;&#x2F;list&#39;) &#123;\n    res.end(&#39;列表页&#39;)\n  &#125; else &#123;\n    res.writeHead(&#39;404&#39;)\n    res.end(&#39;Not Found&#39;)\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; 监听3000端口\nserver.listen(3000)\n\nconsole.log(&#39;server is running on localhost:3000&#39;)\n\n监听request的两个事件\n\ndata: 当服务端收到post数据时调用\nend: 当服务端收集完post数据时调用\n\n6) 处理静态资源\n\n\n\n\n\n\n\n\n静态资源\n像html, js, css, 图片这些数据都属于静态资源\n如果我们直接在end方法里通过字符串返回html, 显然不够友好.\n最好是能以文件的形式保存, 通过读取文件的方式返回\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 引入http核心模块\nconst http &#x3D; require(&#39;http&#39;)\n\n&#x2F;&#x2F; 引入url核心模块\nconst url &#x3D; require(&#39;url&#39;)\n\n&#x2F;&#x2F; 引入path核心模块\nconst path &#x3D; require(&#39;path&#39;)\n&#x2F;&#x2F; 引入fs核心模块\nconst fs &#x3D; require(&#39;fs&#39;)\n\n&#x2F;&#x2F; 创建web服务器\nconst server &#x3D; http.createServer()\n\n&#x2F;&#x2F; 读取静态资源\nfunction resolveStatic(file) &#123;\n  &#x2F;&#x2F; 将网络路由转换成服务器端真实路径\n  const realPath &#x3D; path.join(__dirname, &#39;public&#x2F;&#39; + file)\n\n  &#x2F;&#x2F; 同步读取文件\n  return fs.readFileSync(realPath)\n&#125;\n\n&#x2F;&#x2F; 处理请求\nserver.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 设置响应头\n  res.writeHead(&#39;200&#39;, &#123;\n    &#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf-8&#39;,\n  &#125;)\n\n  &#x2F;&#x2F; 分析路由\n  const &#123; pathname &#125; &#x3D; url.parse(req.url, true)\n\n  if (pathname &#x3D;&#x3D; &#39;&#x2F;&#39; || pathname &#x3D;&#x3D; &#39;&#x2F;index&#39;) &#123;\n    const html &#x3D; resolveStatic(&#39;index.html&#39;)\n    res.end(html)\n  &#125; else if (pathname &#x3D;&#x3D; &#39;&#x2F;list&#39;) &#123;\n    res.end(&#39;列表页&#39;)\n  &#125; else &#123;\n    res.writeHead(&#39;404&#39;)\n    res.end(&#39;Not Found&#39;)\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; 监听3000端口\nserver.listen(3000)\n\nconsole.log(&#39;server is running on localhost:3000&#39;)\n\n","slug":"Node快速入门","date":"2022-12-01T13:38:48.627Z","categories_index":"服务端","tags_index":"node","author_index":"团子"},{"id":"d15fe50aabdeda8cc871dc1941f0910d","title":"24_node概念_模块化_内置模块","content":"昨日回顾单表约束\n\t主键约束\n\t非空约束\n\t唯一约束\n多表约束\n\t外键\n单表查询\n\t查询所有\n\t条件查询\n\t模糊查询\n\t聚合函数查询\n\t分组查询\n\t排序查询\n\t分页查询\n\t书写顺序\n\t\tselect -- from -- where -- group by -- having -- order by -- limit\n\t执行顺序\n\t\tfrom -- where -- group by -- having -- select -- order by -- limit\n多表关系\n\t一对一\n\t\t在任意一方添加外键指向另一方的主键,并且让外键唯一\n\t一对多\n\t\t在多的一方添加外键指向一的一方的主键\n\t多对多\n\t\t建立一个中间表,至少有两个字段,分别作为外键指向多的一方的主键\n多表查询\t\n\t交叉查询\n\t\t笛卡尔值,是其他查询的基础\n\t内连接查询\n\t\t两张表的交集\n\t外连接查询\n\t\t左外连接\n\t\t\t左边的全部+交集\n\t\t右外连接\n\t\t\t右边的全部+交集\n\t子查询\n\t\t结果是单行单列: &gt; &#x3D; &lt; 连接\n\t\t结果是多行单列: in any all exists\n\t\t结果是多行多列: 当作一个虚拟的表来参与查询\n\t自关联查询\n\t\t特殊表,将一张表当作两张表用,起不同的别名,加上关联条件\n\t\t\n\t内连接查询\n\t\t1,要查什么\n\t\t2,查这些需要动用哪几张表\n\t\t3,搞清表与表之间的关联关系\n\nNode概念概念简单的说 Node.js 就是运行在服务端的 JavaScript。\nNode.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。\nNode.js 是一个事件驱动 I&#x2F;O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。\n\n作用1,提供了js的运行环境(就是保证代码正常运行所必要的环境,他提供了很多内置模块保证js代码的执行)\n2,可以通过js来开发后台(很早的一种方式,成本比较低)\n\n组成ECMAScript\n\t和js中的基础语法是一样的\n内置模块\n\tfs 文件相关模块\n\tpath 路径相关模块\n\thttp 服务器相关\n第三方模块\n\texpress 路由,可以快速构建web应用\n\tmysql 可以通过js代码操作mysql数据库\n\n学习路径js\n\tECMAScript基础语法+浏览器的内置对象(DOM+BOM)+第三方库(jquery)\nnode\n\tECMAScript基础语法+内置模块(fs,path,http)+第三方模块(express,mysql等)\n\n\n\n模块化模块化概念概念\n\t遵循固定的规则,把一个大文件,拆成独立并且相互依赖的多个小文件(把代码进行模块化拆分)\n\t也是一个封装的思想,类似于函数(方法),都是对代码的封装\n\t但是函数和方法都只能在当前文件中使用,无法跨文件使用\n\t所以模块化就解决了这个文件,他其实是把代码放在一个单独的js文件中\n\t这样就可以跨文件使用,就是模块化的思想\n好处\n\t提高代码的复用性\n\t提高代码的可维护性\n\t可以实现按需加载\n\n模块化分类根据模块的来源不同\n\t内置模块\n\t\t由node官方提供的,例如 fs,path,http等\n\t自定义模块\n\t\t用户自己创建的每一个js文件,都是自定义模块\n\t第三方模块\n\t\t由第三方开发出来的,并且是官方提供的,使用之前需要下载\n\n模块化使用1,写一个js文件\n\t其实就是创建了一个自定义模块\n2,通过require(路径)方法加载自定义模块\n\t其实就是把刚才写好的模块复制进去\n\n模块作用域概念\n\t在自定义模块中,定义的变量,方法等成员,只能在当前模块使用\n全局变量污染问题\n\t\n\t1,传统方式引入模块\n\t\t模块1:let num &#x3D; 10\n\t\t模块2:let num &#x3D; 20\n\t\t\n\t\t在html中引入这两个模块\n\t\t\t&lt;script src&#x3D;&quot;.&#x2F;05_模块作用域_全局变量1_没有导出.js&quot;&gt;&lt;&#x2F;script&gt;\n\t\t\t&lt;script src&#x3D;&quot;.&#x2F;06_模块作用域_全局变量2_没有导出.js&quot;&gt;&lt;&#x2F;script&gt;\n\n\t\t运行的时候,就会报错,报变量重复定义,就出现全局变量的污染问题\n\t\t\n\t2,node引入模块化的规范(模块中的变量不能直接跨模块访问,必须要先导出,再导入)\n\t\t模块1:\n\t\t\tlet num &#x3D; 10\n\t\t\tmodule.exports.num &#x3D; num  &#x2F;&#x2F;导出\n\t\t模块2:\n\t\t\tlet num &#x3D; 20\n\t\t\tmodule.exports.num &#x3D; num\n\t\t\t\n\t\t引入模块1和模块2(必须要定义两个不同的变量来接收,这样num就存在于这两个变量中)\n\t\t\tconst n1 &#x3D; require(&#39;.&#x2F;08_模块作用域_全局变量1_有导出&#39;);\n\t\t\tconst n2 &#x3D; require(&#39;.&#x2F;09_模块作用域_全局变量2_有导出&#39;);\n\t\t\tconsole.log(n1.num);\n\t\t\tconsole.log(n2.num);\n\t\n\t结论\n\t\t因为不同的模块中,可能定义相同的变量名或者方法名,如果模块间能直接访问,就会出现冲突问题\n\t\t为了避免这种情况,node定义了一个规范,模块中的变量和方法只能在当前模块中访问,如果想跨\t\t 模块使用,必须先导出,再导入才能使用\n\n模块间共享module对象\n\t在每一个自定义模块中,都有一个module对象,他里面存储了和当前模块相关的信息\n\texports: &#123;&#125; &#x2F;&#x2F;这属性就是用来导出数据的,默认是&#123;&#125;\n\t\nmodule.exports对象\n\t这个对象的作用就是将模块中的成员共享出去,供外界使用\n\t将来外界既可以通过 require()方法导入自定义模块,进而拿到module.exports共享的数据\n\t\nexports对象\n\t由于module.exports单词写起来比较复杂,为了简化书写,node提供了exports对象\n\t默认情况下,module.exports对象和exports对象指向同一个对象\n\t\nmodule.exports和exports 使用误区\n\t使用require导入模块的时候,永远以module.exports指向的对象为准\n\t为了防止混乱,不要在同一个模块中同时使用exports和module.exports\n\t一般习惯使用module.exports对象\n\n\n\n内置模块fs模块概念\n\t官方提供的用于操作文件的模块.提供一系列操作文件的属性和方法,方便用户操作文件\n\t\n使用\n\t1,导入\n\t\tconst fs &#x3D; require(&#39;fs&#39;)\n\t2,调用方法\n\t\tfs.readFile() 读取指定文件的数据\n\t\tfs.writeFile() 向指定的文件写入数据\n\t\t\n语法\n\tfs.readFile(path[, options], callback)\n\t\tpath:文件路径,必要参数\n\t\toptions:编码等可选操作\n\t\tcallback:回调函数(读取文件完成之后,调用的函数)\n\t\t\n\tfs.writeFile(path, data[, options], callback)\n\t\tpath:文件路径,必要参数\n\t\tdata:要写入的数据,必要参数\n\t\toptions:编码等可选操作\n\t\tcallback:回调函数(读取文件完成之后,调用的函数)\n\npath模块概念\n\t用于处理路径的模块,提供了处理文件和目录路径的实用工具\n方法\n\tpath.dirname(p)返回路径中代表文件夹的部分\n\tpath.join([path1][, path2][, ...])用于连接路径。\n\tpath.extname(p) 返回路径中文件的后缀名\n\tpath.basename(p[, ext])返回路径中最后一部分,如果第二个参数传后缀名,获取出来的就没后缀\n","slug":"day24_课程笔记","date":"2022-12-01T13:34:25.200Z","categories_index":"服务端","tags_index":"node","author_index":"团子"},{"id":"037fa750d83c04acd7b65b954d7307d0","title":"23_外键_多表关系_多表查询","content":"昨日回顾数据库概念\n\t存储数据的文件系统,通过标准的sql访问,方便对数据管理\n\t\n安装\n\tmysql\n\tNavicat\n\t\n应用\n\t一般一个项目创建一个数据库\n\t一个实体创建一张表\n\t一个对象的实例就是在表里面添加一条数据\nsql\n\t结构化的查询语句\n       DDL 定义语句\n       DML 操作语句\n       DQL 查询语句\n       DCL 控制语句\n\n数据类型\n\t整形\n\t\tint\n\t小数\n\t\tfloat\n\t\tdouble\n\t日期\n\t\tdate\n\t\ttime\n\t\tdateTime\n\t\ttimeStamp\n\t字符串\n\t\tchar\n\t\tvarchar\n字段属性\n\t不为空\n\t\tnot null\n\t默认值\n\t\tdefault\n\t主键\n\t\tprimary key\n\t自增\n\t\tauto_increment\n\t注释\n\t\tcomment\n\t唯一\n\t\tunique\n\n表记录的操作\n\t增\n\t\tinsert into 表名 values (值1,值2,...)\n\t删\n\t\tdelete from 表名 where 条件\n\t改\n\t\tupdate 表名 set 字段名 &#x3D; 字段值 where 条件\n\n单表约束主键约束\n\tprimary key (默认是非空并且唯一的)\n非空约束\n\tnot null\n唯一约束\n\tunique\n\n单表查询查询所有\n\tselect * from 表名\n\n条件查询\n\tselect * from 表名 where 条件\n\t\n模糊查询\n\tselect * from 表名 where 字段名 like (%代表0个或者多个字符,_代表一个字符)\n\t\n聚合函数查询\n\tmax()\n\tmin()\n\tsum()\n\tavg()\n\tcount(*)\n\t查询出来的数据都是一个单值,只有一个值\n\n排序查询 \n\torder by 字段名称 (asc升序 desc降序)\n\n分组查询\n\tgroup by 字段名称 \n\t\n\t注意:分组之后的查询字段,要么是分组字段,要么是聚合函数(是一个单值,对每一组做统计),其他字段,没有任何意义!!!\n\n分页查询\n\tLIMIT 起始索引,每页显示的条数;\n\t公式：起始索引 &#x3D; (当前页数-1) * 每页显示的条数\n\t\n书写的顺序(读起来更像一段话)\n\tselect -- from -- where -- GROUP BY -- having -- order by -- limit\n\t\n执行的顺序\n\tfrom -- where -- group by -- having -- select -- order by -- limit\n\t\n\tfrom:需要哪张表中查询数据\n\twhere:根据条件过滤表中的数据 \t\t\t\t---分组之前,过滤的是表中所有的数据\n\tgroup by:将where过滤后的数据进行分组\n\thaving:对上面已经分组的每一组数据进行过滤  \t---分组之后,过滤的是分组之后每一组数据\n\tselect:查看结果集的哪些列\n\torder by:把结果集按照指定的顺序排列\n\tlimit:需要取到结果集的前几行\n\n\n\n多表约束多表之间是通过外键进行关联的\n\t\n外键作用\n\t保证数据的完整性和有效性,有了外键约束,就不能随意的删除表中的数据\n\t\n添加外键代码\n\t在员工表上添加约束.让员工表中的dep_id作为外键指向部门表的主键\n\tALTER table employee add constraint fk_001 foreign key(dep_id) references department(id)\n\n\n\n多表关系一对一\n\t建表原则\n\t\t在任意一方,添加外键指向另一方的主键,并且让外键唯一\n\t应用\n\t\t数据库的优化 分表(把一张表分为2张表)\n一对多\n\t建表原则\n\t\t在多的一方添加外键,指向一的一方的主键\n\n多对多\n\t建表原则\n\t\t需要借助第三张中间表,中间表至少有两个字段,作为第三张表的外键,分别指向另外两张表的主键\n\n\n\n多表查询1,交叉查询\n\t所有表的组合情况\n\n2,内连接查询(所有表的交集(inner))\n\t隐式内连接\n\t\t表与表之间使用,连接,条件使用where连接\n\t显示内连接\n\t\t表与表之间使用inner连接,条件使用on连接\n\n3,外连接查询\n\t左外连接\n\t\t使用left join 连接,查的是左边表的全部和两张表的交集\n\t右外连接\n\t\t使用right join 连接,查的是右边表的全部和两张表的交集\n4,子查询\n\t结果是单行单列:使用运算符连接\n\t结果是多行单列:使用in any all exist 连接\n\t结果是多行多列:作为一张虚拟的表参与运算\n5,自关联查询\n\t是一张特殊的表,可以将它当做两张表,起不同的别名,用条件关联上\n\n\n\n","slug":"day23课程笔记","date":"2022-12-01T13:26:27.747Z","categories_index":"服务端","tags_index":"sql","author_index":"团子"},{"id":"d0cd3b69cac8d24123497120cff3bdf6","title":"22_数据库安装_建表_增删改查","content":"昨日回顾闭包\n\t概念\n\t\t是一个函数,有权访问另外一个函数作用域里面的变量,这个变量所在的函数就是闭包\n\t作用\n\t\t延伸变量的作用范围\n\t应用\n\t\t立即执行函数\n\nlet和const\n\t特点\n\t\t1,都有块级作用域\n\t\t2,没有变量提升\n\t\t3,在同一个域中不能重复定义\n\t\t4,有暂时性死区\n\t使用场景\n\t\t1,const &gt; let &gt; var\n\t\t2,const一般用于引用数据类型, let一般用于基本数据类型\n\t\n类和继承\n\t定义\n\t\tclass 类名&#123;\n\t\t\tconstructor(参数列表)&#123;\n\t\t\t\tthis.属性名 &#x3D; 参数名\n\t\t\t&#125;\n\t\t\t方法名()&#123;&#125;\n\t\t&#125;\n\t继承\n\t\textends\n\t静态\n\t\tstatic修饰,可以直接使用类名调用\n\n解构\n\t将数据结构进行分解,赋给对应的变量\n\t\n\tconst[变量列表] &#x3D; [1,2,3]\n\tconst&#123;属性列表&#125; &#x3D; &#123;name:&#39;张三&#39;,age:23&#125;\n\n箭头函数\n\t简化对函数书写\n\t(参数列表) &#x3D;&gt; &#123;函数体&#125;\n\t参数只有一个 ()可以省\n\t函数体只有一条 &#123;&#125;可以省略\n\npromise\n\t属性\n\t\t状态属性\n\t\t\t默认是准备状态\n\t\t\t调用resolve(),变成成功状态\n\t\t\t调用reject(),变成失败状态\n\t\t结果属性\n\t\t\t默认是undefined,调用方法加上参数,结果就有值了\n\t方法\n\t\tthen\n\t\t\t两个参数\n\t\t\t\t第一个成功的时候,第二个就是失败的时候调用\n\t\t\t如果拿到数据\n\t\t\t\t在then的函数中,添加一个参数,就可以拿到数据\n\tthen返回值\n    \t是一个promise对象,继续调用then方法,实现链式编程\n    \t链式编程能够执行的前提条件是,第一个promise的状态要发生改变\n    \t\n\n数据库概念数据库\n\t存储数据的仓库,也是一个文件系统,可以方便我们对数据的操作\n数据库软件\n\t就是一个软件,类似于库管员,用来管理数据库(mysql)\n数据库的应用\n\t在开发中,一般一个应用会创建一个数据库\n\t在这个数据库里面可以创建很多张表,一般一个实体就会创建一张表\n\t一个表中可以插入很多条记录,一般一个对象的实例就会添加一个新的记录\n数据库的安装\n\t安装mysql软件\n\t安装Navicat连接工具\nsql\t\n\t概念\n\t\t结构化的查询语句\n\t作用\n\t\t对数据库进行增删改查\n\t分类\n\t\tDDL 数据库定义语句\n\t\tDML 数据库操作语句(增删改)\n\t\tDQL 数据库查询语句(查询)\n\t\tDCL 数据库控制语句(权限)\n\n\n\n数据类型整形\n\ttinyint\n\tsmallint\n\tint\n\tbigint\n\t\n小数\n\tfloat\n\tdouble\n\tdecimal\n\n字符串\n\tchar\n\tvarchar\n\ttext\n\tenum\n\n日期时间\n\tdate\n\ttime\n\tdatetime\n\ttimestamp\n\n\n\n字段属性1,能否为空\n\t默认是为null\n\t使用not null 设置不为空\n2,默认值\n\t使用default设置\n3,主键\n\t作用: 用来标识唯一的一行,默认是非空并且唯一的\n\t使用 primary key标识\n4,自增\n\t作用: 和主键一起使用,可以让序号自动增长\n\t使用 AUTO_INCREMENT 来设置\n\t序号设置自增之后,就不能重复使用\n5,注释\t\n\t作用:解释说明,给程序员看\n\t使用 comment来设置\n6,唯一\n\t作用:让列中的数据保存唯一\n\t使用 unique 设置\n\n\n\n综合建表案例博客表(表名 blog)\n\t字段\t\t\t字段类型\t\t\t字段属性\n\tid\t\t\t   int\t\t\t\t主键 自增\n\ttitle\t\t  varchar(255)        非空\n\tpublic_time\t   date\t\t\t\t  非空\n\tauthor       varchar(255)         非空\n\tlooks\t\t   int\t\t\t\t  非空  default 0\n\tcomment\t\t   int\t\t\t\t  非空  default 0\n\tcontent\t\t  text  \t\t\t  非空\n\t\n用户表\n\t-- 创建一个数据库\n    create DATABASE db02;\n\n    -- 使用这个数据库\n    use db02;\n\n    -- 创建一个用户表\n    CREATE table user(\n        id int primary key auto_increment,\n        username varchar(20) not null,\n        password varchar(20) not null\n    );\n\n\n\n数据增删改增\n\tINSERT into user values (null,&#39;张三&#39;,&#39;123&#39;);\n\t\n\t注意\n\t\t插入的数据要和表中的数据类型保持一致\n\t\t插入数据要在有效范围之内(规定20个字节,不能超过20个字节)\n\t\t如果插入的时候给null,就会自动填充默认值\n\t\t如果设置了自增,就会在原来的基础上 +1\n删\n\tDELETE from user where username &#x3D; &#39;张三&#39;\n\t\n改\n\tupdate user set password &#x3D; &#39;888&#39; where username &#x3D; &#39;张三&#39;;\n\t\n注意\n\t修改和删除一定要加上条件,否则会影响所有的数据\n\n\n\n数据基本查询-- 查询所有\n\tselect * from user;\n\n-- 条件查询\n\tselect * from user where username&#x3D;&#39;张三&#39; and password&#x3D;&#39;888&#39;;\n\t\n---------------------------------------------------\n\n查询所有\n\tselect * from 表名\n\t\n条件查询\n\tselect * from 表名 where 条件\n\t\n模糊查询(like)\n\t%代表 零个,一个或者多个字符\n\t_代表 匹配一个字符\n\tlike &#39;x%&#39;  以x开头\n\tlike &#39;%x&#39;  以x结尾\n\tlike &#39;%x%&#39;  包含x\n\tlike &#39;x_&#39;  以x开头,后面只有一个字符\n\tlike &#39;_x&#39;  以x结尾,前面只有一个字符\n\t\n聚合函数查询  结果是一个单值(只有一个值)\n\tmax() 最大值\n\tmin() 最小值\n\tsum() 求和\n\tavg()\t求平均值\n\tcount(*) 统计个数\n\t\n排序查询\n\torder by 字段名称\n\t\tasc默认升序 \n\t\tdesc降序\n\n","slug":"day22_课堂笔记","date":"2022-12-01T13:22:58.585Z","categories_index":"服务端","tags_index":"sql","author_index":"团子"},{"id":"838ae74e3a76757d637de803a615bfd9","title":"MySQL","content":"前言. 数据库1.数据库的意义\n\n\n\n\n\n\n\n\n数据库就是存放数据的仓库\n想像一下, 在没有计算机之前, 我们如何统计人口数据的, 通常都是用纸和笔登记, 填写像这样的一张表格.\n\n再将这些表格按照一定的顺序整理\n\n最后放到一个档案室里集中管理\n\n这个档案室实际上就是一个存放数据的仓库.\n但是这种管理方式是非常低效的, 如果要从100万人中找出某一个人的信息, 是非常慢的.\n数据库的产生实际上就是利用计算机, 方便高效的管理数据.\n\n\n\n\n\n\n\n\n\n数据库是信息系统的重要组成部分\n任何信息系统都离不开对数据的处理.\n比如\n\n新闻系统最核心的是一篇一篇的文章, 文章也就是数据\n电商系统最核心的是商品, 商品也可以用数据来描述, 比如价格, 颜色, 重量…\n\n2.数据库的基本概念数据库最基本的组成单元就是一条一条数据记录, 这个就是数据行\n为了让数据更加方便管理, 通常我们会使用表格来描述, 这个就是数据表\n很多数据表放在一起就形成数据库\n3.数据库的基本操作\n\n\n\n\n\n\n\n\n添加操作\n我们还是以人口统计为例. \n比如, 一个小孩出生了, 我们需要给小孩上户口. \n从数据库的角度就是将小孩的信息添加到数据库中保存起来. \n可能是保存在某一张表里(假设叫人口表)\n一般都有哪些信息呢? 姓名, 性别, 籍贯, 身份证, 户口所在地…这些就是字段, 也就是表头\n\n\n\nid\n姓名\n性别\n籍贯\n户口所在地\n\n\n\n1\n张三\n男\n武汉\n北京\n\n\n2\n\n\n\n\n\n\n3\n\n\n\n\n\n\n4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n更新操作\n又有一天, 小孩上大学了, 户口要迁移到学校, 需要修改户口所在地信息. \n从数据库的角度就是找到对应的小孩的信息, 更新户口所在地\n\n\n\n\n\n\n\n\n\n删除操作\n比如, 某个老人过世了, 需要删除这个老人的信息.\n从数据库的角度就是找到对应的信息, 删除\n\n\n\n\n\n\n\n\n\n查询操作\n有的时候, 需要查询张三这个人的具体的信息, 怎么办?\n每个人都有身份证号, 身份证号是唯一的. 每个人都不同, 可以根据身份证号做为查询条件, 查找张三的全部信息\n一. MySQL概述1.什么是MySQL\n\n\n\n\n\n\n\n\n定义\nMySQL是一种关系型数据库软件, 基于C/S架构\n\n数据库: 存储数据的仓库\n关系型: 数据与数据之间存在关系\nC/S架构: Client(客户端)和Server(服务端)\n\n2.为什么学MySQL对于后端工程师, 数据库是必备技能. \n对于前端工程师, 会一些数据库方面的知识\n\n可以在接口联调的时候占主动\n可以向全栈发展\n\nMySQL是数据库中使用最广范的, 学了MySQL后再学其他的数据库也是非常容易的\n\n数据来源于: StackOverflow2020调查报告\n3.如何理解关系型\n\n\n\n\n\n\n\n\n关系型数据库有明确的库/表/行的关系\n数据库由数据表组成\n数据表由数据行(记录)组成\n\n4.MySQL的安装1) 安装MySQL服务端\n\n\n\n\n\n\n\n\n演示\n2) 安装MySQL客户端MySQL的客户端有很多种. 这里, 我主要使用的是Navicate\n5.如何理解C/S架构MySQL分为MySQL客户端和MySQL服务端\n不管是客户端还是服务端, 本质上依然是一个程序\n服务端: 提供服务的程序\n客户端: 连接服务端执行操作的程序\n\n\n\n\n\n\n\n\n\n演示\n\n\n在命令行中输入mysql -uroot -p, 连接服务端, 因此, 当前的这个窗口就是一个MySQL的客户端\n\n\n\n\n\n\n\n\n\n思考\nMySQL主要操作是在哪些完成的? 客户端!\n二. MySQL基本操作一般MySQL操作都是在操作MySQL客户端\n这里, 我们可以使用一些图形化的软件, 如Navicate/MySQL-Front. \n如果需要操作MySQL, 需要先使用MySQL客户端连接到服务端\n\n1.客户端连接与基本操作1) 连接数据库\n点击后弹出如下窗口\n\n2) 创建数据库3) 选择数据库\n两种操作\n\n双击\n右键-&gt;打开数据库\n\n3) 建库建表看演示\n2.SQL概念(了解)1) 什么是SQLStructured Query Language 结构化查询语言\n2) SQL的作用\n是一种所有关系型数据库的查询规范, 不同的数据库都支持\n通用的数据库操作语言, 可以用在不同的数据库中\n\n3) SQL语句分类\nData Definition Language(DDL数据定义语言) 如: 建库, 建表\nData Manipulation Language(DML 数据操纵语言) 如: 对表记录的增/删/改\nData Query Language(DQL 数据查询语言) 如: 对表的查询操作\nData Control Language(DCL 数据控制语言) 如: 对用户权限的设置\n\n使用频率\nCURD(增删改查)占到了数据库操作80%\n查询占到CURD的80%\n4) MySQL的语法\n每条语句以分号结尾\nSQL中不区分大小写, 推荐关键字大写以区分\n\n三. 数据类型0.前言在现实世界中, 数据的种类有很多, \n比如, 人的姓名(字符), 人的年龄(整型), 人的身高(小数), 出生日期(日期)\n而MySQL就是用来保存这些数据的, 所以在 MySQL中, 将数据分为三大类: \n\n数值型\n字符串\n日期与时间\n\n\n\n\n\n\n\n\n\n\n学习目的\n通过学习, 大概了解怎么选择合适的数据类型\n\n1.数值–整型\n\n\n类型\n名称\n说明\n无符号范围\n有符号范围\n\n\n\n整型\ntinyint\n微整型, 占8位二进制\n0~255\n-127~128\n\n\n\nsmallint\n小整型, 占16位二进制\n0~65535(6万)\n-32767~32768\n\n\n\nint\n整型\n0~42亿\n\n\n\n\nbigint\n大整型\n0~200亿亿\n\n\n\n\n\n\n\n\n\n\n\n\n选型\n一个人的年龄:  tinyint\n小型blog的序号: smallint\n大学一个学校的学生序号: int\n大型电商网站的商品表的序号: int\n马云的资产: bigint\n\n\n\n\n\n\n\n\n\n说明\n在mysql中, 默认的整型是带符号的, 如果要定义无符号整型, 需要加上unsigned\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_int&#96; (\n    age tinyint unsigned,\n    stu_sn smallint unsigned,\n    goods_sn int unsigned,\n    mayun bigint\n);\n\n2.数值–小数小数分为\n\n浮点\n单精度\n双精度\n\n\n定点\n\n浮点型的数据不精确, 所以一般表示价格, 我们使用定点型\n\n\n\n类型\n名称\n说明\n\n\n\n小数\nfloat(m,d)\nm(精度), 表示总位数, d(标度), 表示小数点后的位数\n\n\n\ndouble(m,d)\nm(精度), 表示总位数, d(标度), 表示小数点后的位数\n\n\n\ndecimal(m,d)\nm(精度), 表示总位数, d(标度), 表示小数点后的位数\n\n\n\n\n\n\n\n\n\n\n\n选型\n距离: 3.4 km float(10,2) \n人的体重: 80.5kg  float(5,2)\n价格: 9.9 RMB decimal(10,2)\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_float&#96; (\n    distance float(10,2),\n    weight float(5,2),\n    price decimal(10,2)\n);\n\n3.字符串\n\n\n类型\n名称\n说明\n\n\n\n字符型\nchar(M)定长\n无论使用几个字符都占满全部, 范围0~255字符\n\n\n\nvarchar(M)变长\n使用几个字符就占用几个, 理论范围0~65535字符\n\n\n\ntext\n允许长度 0~65535 字节\n\n\n\nenum(集合)\n枚举, 集合表示选项, 以逗号隔开\n\n\n\n\n\n\n\n\n\n\n\n选型\nchar类型: 固定长度, 一般用于存储固定长度的字符串, 如\n\n手机号 char(11)\n通过md5加密后的密码值char(32)\n\nvarchar类型: 可变长度, 存储长度不确定的字符字符串, 如\n\n姓名 varchar(16)\n邮箱 varchar(255)\n\ntext类型: 存储大段内容, 如\n\n文章内容 text\n\nenum类型: 单选, 如\n\n性别\n\n\n\n\n\n\n\n\n\n\n说明\nchar与varchar的区别\n\nchar是固定的长度 char(5) 保存 abc, 实际占用的空间5个\nvarchar最大长度 varchar(5)保存abc, 实际占用的空间3个\n\nvarchar用多少就占多少\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_char&#96; (\n    phone char(11),\n    password char(32),\n    name varchar(16),\n    email varchar(255),\n    content text,\n    sex enum(&#39;男&#39;,&#39;女&#39;)\n);\n\n\n\n\n\n\n\n\n\n\n说明\nchar(M)与varchar(M)中的M表示的字符数\n4.日期与时间\n\n\n类型\n名称\n说明\n\n\n\n日期\ndate\n范围1000-01-01~9999-12-31\n\n\n\ndatetime\n范围1000-01-01 00:00:00~9999-12-31 23:59:59\n\n\n\ntimestamp\n从1970年开始至今的秒数\n\n\n\n\n\n\n\n\n\n\n\n选型\n出生日期: date\n商品抢购的开始结束时间: datetime\n文章的创建更新时间: timestamp(时间戳)\n\n\n\n\n\n\n\n\n\n说明\n时间戳: 从1970年1月1日0时0分0秒到当前时间的秒数(整数)\n一般时间类型更常见的是保存时间戳, 时间戳就是一个整型数, 为什么保存时间戳呢?\n\n效率更高\n方便处理\n\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_time&#96; (\n    birthday date,\n    start_time datetime,\n    end_time datetime,\n    created_time timestamp\n);\n\n\n\n六. 字段属性字段属性又叫字段约束, 通常用来限定(约束)当前列\n\n能否为空\n默认值\n\n1.能否为空如果需要当前字段不能为空, 默认情况下是可以为空的\n\n\n\n\n\n\n\n\n\n关键词\nnot null\n\n\n\n\n\n\n\n\n\n语法\nCREATE TABLE &#96;表名&#96; (\n    字段 字段类型 not null\n);\n\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_null&#96; (\n    id int,\n    name varchar(16) not null\n);\n\n\n\n2.默认值有些情况下，我们希望某个字段拥有默认值，比如\n\n性别的字段，拥有默认值为“男”\n籍贯的字段，拥有默认值为“汉”\n\n\n\n\n\n\n\n\n\n\n关键词\ndefault\n\n\n\n\n\n\n\n\n\n语法\nCREATE TABLE &#96;表名&#96; (\n    字段 字段类型 default 默认值\n);\n\n\n\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_default&#96; (\n    name varchar(16),\n    sex enum(&#39;男&#39;,&#39;女&#39;) default &#39;男&#39;\n);\n\n3.主键如果我们可以通过某一列进行唯一的标识每一条记录，我们就可以把这个字段当做主键\n\n\n\n\n\n\n\n\n\n关键词\nprimary key\n\n\n\n\n\n\n\n\n\n语法\nCREATE TABLE &#96;表名&#96; (\n    字段 字段类型 primary key\n);\n\n4.自增如果数据表中的某个字段，需要进行自动增长，我们可以将其定义为自动增长, 一般自增跟主键连用\n\n\n\n\n\n\n\n\n\n关键词\nauto_increment\n\n\n\n\n\n\n\n\n\n语法\nCREATE TABLE &#96;表名&#96; (\n    字段 字段类型 primary key auto_increment\n);\n\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_primary&#96; (\n    id int primary key auto_increment\n);\n\n5.备注在创建字段时, 一般需要给一定的说明\n\n\n\n\n\n\n\n\n\n关键词\ncomment\n\n\n\n\n\n\n\n\n\n语法\nCREATE TABLE &#96;表名&#96; (\n    字段 字段类型 字段属性 comment &#39;备注&#39;\n);\n\n\n\n\n\n\n\n\n\n\n示例\nCREATE TABLE &#96;t_comment&#96; (\n    id int primary key auto_increment comment &#39;主键&#39;,\n    name varchar(16) not null comment &#39;姓名&#39;\n);\n\n\n\n\n\n\n\n\n\n\n完整的建表语句\nCREATE TABLE &#96;表名&#96; (\n    字段1 字段类型1 字段属性1 字段属性2 字段属性3,\n    ...\n);\n\n七. 综合建表案例1.文章表blog\n\n\n\n\n\n\n\n\n分析\nblog表需要哪些字段\n\n主键id\n作者(author)\n标题(title)\n内容(content)\n浏览数(click)\n评论数(comment)\n发布时间(publish_time)\n\nCREATE TABLE &#96;blog&#96; (\n  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,\n  &#96;title&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;标题&#39;,\n  &#96;content&#96; text NOT NULL COMMENT &#39;内容&#39;,\n  &#96;author&#96; varchar(32) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;作者&#39;,\n  &#96;click&#96; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;浏览数&#39;,\n  &#96;comment&#96; smallint(6) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;评论数&#39;,\n  &#96;publish_time&#96; date DEFAULT NULL COMMENT &#39;发布日期&#39;,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;\n\n\n\n2.商品表goods\n\n\n\n\n\n\n\n\n分析\ngoods表需要哪些字段\n\n主键id\n分类id(cate_id)\n商品名称(goods_name)\n本店价格(shop_price)\n市场价格(market_price)\n商品数量(goods_number)\n点击数(click)\n\nCREATE TABLE &#96;goods&#96; (\n    id int unsigned primary key auto_increment comment &#39;主键&#39;,\n    cate_id int not null comment &#39;所属分类&#39;,\n    goods_name varchar(255) not null comment &#39;商品品称&#39;,\n    shop_price decimal(10,2) not null default 0 comment &#39;本店价格&#39;,\n    market_price decimal(10,2) not null default 0 comment &#39;市场价格&#39;,\n    goods_number int not null comment &#39;商品数量&#39;,\n    click int not null default 0 comment &#39;点击数&#39;\n);\n\n\n\n3.学生表stu\n\n\n\n\n\n\n\n\n分析\nstu表需要哪些字段\n\n主键id\n学号(sn) \n姓名(name)\n性别(sex) enum\n学科(subject)\n身高(height) float\n\nCREATE TABLE &#96;stu&#96; (\n    id int unsigned primary key auto_increment comment &#39;主键&#39;,\n    sn char(8) unique not null comment &#39;学号&#39;,\n    name varchar(32) not null comment &#39;姓名&#39;,\n    sex enum(&#39;男&#39;, &#39;女&#39;) not null default &#39;男&#39; comment &#39;性别&#39;,\n    subject varchar(16) not null comment &#39;学科&#39;,\n    height float(3,2) not null comment &#39;身高&#39;\n);\n\n八. 数据的写操作(重点)0.前言MySQL最主要的功能是管理数据, 也就是增/删/改/查, 也叫CURD, 从大的方面划分就是写操作和读操作\n首先, 我们来学习写操作\n1.添加操作1) 基本用法把握3点\n\n插入哪张表?\n插入表的哪些列(字段)?\n这些列的值?\n\n\n\n\n\n\n\n\n\n\n语法\nINSERT INTO &#96;表名&#96;\n(&#96;字段1&#96;, ... &#96;字段n&#96;)\nVALUES\n(值1, 值2, 值n)\n\n\n\n\n\n\n\n\n\n\n示例一. 插入单条记录\n# 先选择db1数据库\nUSE &#96;db1&#96;;\n# 向t1表中添加一条数据\nINSERT INTO &#96;t1&#96;\n(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;)\nVALUES\n(1, &#39;xiaoming&#39;, 20);\n\n如何查看数据是否添加成功?\n先了解一个基本的查询操作\n# 查询表中的所有记录\nselect * from &#96;表名&#96;;\n\n\n\n\n\n\n\n\n\n\n示例二. 一次插入多条记录\n# 向t1表中一次添加多条记录\nINSERT INTO &#96;t1&#96;\n(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;)\nVALUES\n(2, &#39;xiaomei&#39;, 18),\n(3, &#39;xiaoqiang&#39;, 22);\n\n一个() : 代表一条记录\n多个()使用,隔开\n\n\n\n\n\n\n\n\n\n扩展\n如果已经在db1数据库下, 不用执行USE命令, 也可以显式的指定库名, 如\nINSERT INTO db1.t1\n(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;)\nVALUES\n(1, &#39;xiaoming&#39;, 20);\n\n\n\n2) 允不允许只插入部分字段和值?\n\n\n\n\n\n\n\n\n尝试\nINSERT INTO &#96;student&#96;\n(&#96;name&#96;, &#96;age&#96;)\nVALUES\n(&#39;xiaomei&#39;, 18);\n\n结论: _____________\n3) 允不允许不写字段?\n\n\n\n\n\n\n\n\n尝试\nINSERT INTO &#96;student&#96;\nVALUES\n(&#39;laowang&#39;, 30);\n\n\n\n\n\n\n\n\n\n\n尝试\nINSERT INTO &#96;student&#96;\nVALUES\n(null, &#39;laowang&#39;, 30);\n\n结论: _________\n4) 添加案例\n超出整型范围\n\nINSERT INTO &#96;t_int&#96; (age) VALUES (300);\n\n\n浮点型精度丢失问题\n\nINSERT INTO &#96;t_float&#96; VALUES (12345678.12, 123.12, 12345678.12);\n\n\n插入中文数据\n\nINSERT INTO &#96;t_char&#96; (name) VALUES (&#39;小明&#39;);\n\n\n如果插入的字符串超过长度, 会怎样?\n\nINSERT INTO &#96;t_char&#96; (phone) VALUES (&#39;130123456789&#39;);\n\n\n如果插入的值不在enum的选型类, 会怎样?\n\nINSERT INTO &#96;t_char&#96; (sex) VALUES (&#39;女博士&#39;);\n\n\n如果字段类型是字符型, 插入的数据是整型或者小数型会怎样?\n\nINSERT INTO &#96;t_char&#96; (phone) VALUES (13012345678);\nINSERT INTO &#96;t_char&#96; (phone) VALUES (123456789.1);\n\n\n如果字段不能为null, 但是添加的时候没有指定会怎样?\n\nINSERT INTO &#96;t_null&#96; (id) VALUES (1);\n\n设置了not null的字段, 在插入数据时必须出现在字段列表中\n\n如果设置了默认值, 但是添加的时候没有指定会怎样?\n\nINSERT INTO &#96;t_default&#96; (name) VALUES (&#39;xiaoming&#39;);\n\n\n\n\n\n\n\n\n\n\n添加案例小结\n\n插入数据的类型最好与要求的类型一致\n插入的数据必须在有效范围内\n插入的数据为null时给默认值\n自增会在原来的基础上+1\n\n2.修改操作4点\n\n修改哪张表?\n修改表的哪些列(字段)?\n这些列的值?\n条件\n\n\n\n\n\n\n\n\n\n\n语法\nUPDATE &#96;表名&#96;\nSET\n&#96;字段1&#96;&#x3D;值1,\n&#96;字段2&#96;&#x3D;值2,\n...\nWHERE 条件\n\n\n\n\n\n\n\n\n\n\n示例\nUPDATE &#96;student&#96;\nSET\n&#96;name&#96;&#x3D;&#39;xiaoming-new&#39;\nWHERE &#96;id&#96;&#x3D;1;\n\n\n\n\n\n\n\n\n\n\n演示\n3.删除操作2点\n\n删除哪张表?\n删除哪些行?\n\n\n\n\n\n\n\n\n\n\n语法\nDELETE FROM &#96;表名&#96; WHERE 条件\n\n\n\n\n\n\n\n\n\n\n示例\nDELETE FROM &#96;student&#96; WHERE &#96;id&#96;&#x3D;3;\n\n\n\n\n\n\n\n\n\n\n演示\n九. 查询–基本查询相对于写操作, 读操作(查询操作)使用的更为频繁, 大部分的业务都体现在读操作上, 内容比较多\n我们先学习基本查询\n1.基本用法1) 基本查询3点:\n\n查哪张表的数据?\n查哪些列的数据?\n条件\n\n\n\n\n\n\n\n\n\n\n语法\nSELECT 字段1, 字段2, ...字段n \nFROM 表名\n[WHERE 条件]\n\n\n\n\n\n\n\n\n\n\n示例1–查询指定的列\n# 查询t1表中的name和age字段\nSELECT &#96;name&#96;, &#96;age&#96; FROM &#96;t1&#96;;\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n\n\n\n\n\n\n\n示例2–查询所有的列\n# 查询t1表中的所有数据\nSELECT * FROM &#96;t1&#96;;\n\n\n* : 表示所有字段\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n\n\n\n\n\n\n\n示例3–根据条件查询\n# 查询xiaomei的年龄\nSELECT &#96;age&#96; FROM &#96;t1&#96; WHERE &#96;name&#96;&#x3D;&#39;xiaomei&#39;;\n\n\n\n\n\n\n\n\n\n\n演示\n2) 别名可以给指定的列取一个别名, 一般用于多表查询中\n\n\n\n\n\n\n\n\n\n语法\nSELECT 字段1 as 别名1, 字段2 as 别名2 FROM 表名 as 表别名\n\n其中, as关键字可以省略\n\n\n\n\n\n\n\n\n\n示例\nSELECT &#96;name&#96; as &#96;username&#96; FROM &#96;t1&#96; as stu;\n\n\n\n\n\n\n\n\n\n\n演示\n2.查询模型1) 基本点3个点\n\n列当作变量\n列可以参与计算\nwhere条件判断真假\n\n\n\n\n\n\n\n\n\n\n如何理解\n逐行比较, 当where条件为真的时候, 把列(变量)的值取出来\n\n\n\n\n\n\n\n\n\n示例\nSELECT name, age FROM &#96;student&#96;;\n\n\n\n\n\n\n\n\n\n\n演示\n\n\n\n\n\n\n\n\n\n示例2\n# 查询本店价比市场价低多少(计算差价)\nSELECT market_price - shop_price FROM &#96;goods&#96;;\n\n\n\n\n\n\n\n\n\n\n演示\n3) where条件MySQL中常用的运算符如下表:\n\n\n\n运算符\n说明\n\n\n\n&gt;, &lt;, &lt;=, &gt;=, =, &lt;&gt;\n&lt;&gt;表示不等于, 也可以使用!=\n\n\nBETWEEN…AND\n在某个范围内, between 100 and 200, 包含100和200, 闭区间[100, 200]\n\n\nIN (1,2, … n)\n集合表示多个值，使用逗号分隔\n\n\nLIKE\n模糊查询\n\n\nis null\n查询某一列为null\n\n\nis not null\n查询某一列不为null\n\n\n\n\n\n逻辑运算符\n说明\n\n\n\nand 或者 &amp;&amp;\n与， SQL 中建议使用前者，后者并不通用\n\n\nor 或者 ||\n或\n\n\nnot 或者 !\n非\n\n\n\n\n\n通配符\n说明\n\n\n\n%\n匹配任意多个字符\n\n\n_\n匹配一个字符\n\n\n3.查询案例以商品表为例, 做如下查询练习\n1.1 查询主键id为32的商品\nSELECT * FROM &#96;goods&#96; WHERE &#96;id&#96;&#x3D;32;\n\n1.2 不属第3栏目的所有商品id和名称\nSELECT &#96;id&#96;, &#96;goods_name&#96;, &#96;cate_id&#96;\nFROM &#96;goods&#96;\nWHERE &#96;cate_id&#96; !&#x3D; 3;\n\n1.3 本店价格高于3000元的商品\nSELECT &#96;goods_name&#96;, &#96;shop_price&#96;\nFROM &#96;goods&#96;\nWHERE &#96;shop_price&#96; &gt; 3000;\n\n1.4 本店价格低于或等于100元的商品\nSELECT &#96;goods_name&#96;, &#96;shop_price&#96;\nFROM &#96;goods&#96;\nWHERE &#96;shop_price&#96; &lt;&#x3D; 100;\n\n1.5 取出第4栏目或第11栏目的商品(使用or或者使用in)\n# 使用or\nSELECT &#96;goods_name&#96;, &#96;cate_id&#96;\nFROM &#96;goods&#96;\nWHERE &#96;cate_id&#96;&#x3D;4 or &#96;cate_id&#96;&#x3D;11;\n\n# 不使用or\nSELECT &#96;goods_name&#96;, &#96;cate_id&#96;\nFROM &#96;goods&#96;\nWHERE &#96;cate_id&#96; in (4, 11);\n\n1.6 取出100&lt;=本店价格&lt;=500的商品(使用and或者between)\n# 使用and\nSELECT &#96;goods_name&#96;, &#96;shop_price&#96;\nFROM &#96;goods&#96;\nWHERE &#96;shop_price&#96; &gt;&#x3D; 100 and &#96;shop_price&#96; &lt;&#x3D; 500;\n\n# 不使用and\nSELECT &#96;goods_name&#96;, &#96;shop_price&#96;\nFROM &#96;goods&#96;\nWHERE &#96;shop_price&#96; between 100 and 500;\n\n1.7 取出不属于第3栏目且不属于第11栏目的商品(使用and或使用not in分别实现)\n# 使用and\nSELECT &#96;goods_name&#96;, &#96;cate_id&#96;\nFROM &#96;goods&#96;\nWHERE &#96;cate_id&#96; !&#x3D; 3 and &#96;cate_id&#96; !&#x3D; 11;\n\n# 使用 not in\nSELECT &#96;goods_name&#96;, &#96;cate_id&#96;\nFROM &#96;goods&#96;\nWHERE &#96;cate_id&#96; not in (3, 11);\n\n1.8 取出第3个栏目下面价格&lt;1000或&gt;3000,并且点击量&gt;5的商品\nSELECT &#96;goods_name&#96;, &#96;cate_id&#96;, &#96;shop_price&#96;, &#96;click_count&#96;\nFROM &#96;goods&#96;\nWHERE &#96;cate_id&#96;&#x3D;3\nand (&#96;shop_price&#96; &lt; 1000 or &#96;shop_price&#96; &gt; 3000)\nand &#96;click_count&#96; &gt; 5;\n\n1.9 取出名字以”诺基亚”开头的商品\nSELECT &#96;goods_name&#96;\nFROM &#96;goods&#96;\nWHERE &#96;goods_name&#96; LIKE &#39;诺基亚%&#39;;\n\n1.10 取出名字为”诺基亚Nxx”的手机\nSELECT &#96;goods_name&#96;\nFROM &#96;goods&#96;\nWHERE &#96;goods_name&#96; LIKE &#39;诺基亚N__&#39;;\n\n十. 进阶查询操作(select子句)0.前言MySQL除了能做基本的条件查询操作外, 还可以用来过滤数据, 比如分组统计, 排序等\n通过, SELECT的子句, 可以完成复杂的操作, 除了where子句, 还有如下4个, 一般称select 子句\n\ngroup by\nhaving\norder by\nlimit\n\n\n\n\n\n\n\n\n\n\n注意\n子句的顺序不能颠倒, 如下\nSELECT 字段 FROM 数据表  \nwhere子句  \ngroup by子句  \nhaving子句  \norder by 子句  \nlimit 子句;\n\n1.group by子句分组的目的是为了统计, 因此分组通常和聚合函数连用\n\n\n\n\n\n\n\n\n\n聚合函数\n\ncount: 计算总数\nsum: 求和\nmax: 最大值\nmin: 最小值\navg: 平均值\n\n\n\n\n\n\n\n\n\n\n聚合函数用法示例\n查出最贵的商品价格\nSELECT max(shop_price) FROM &#96;goods&#96;;\n\n查出最便宜的商品的价格\nSELECT min(shop_price) FROM &#96;goods&#96;;\n\n查询该店所有商品的库存总量\nSELECT sum(goods_number) FROM &#96;goods&#96;;\n\n查询所有商品的平均价\nSELECT avg(shop_price) FROM &#96;goods&#96;;\n\n查询该店一共有多少种商品\nSELECT count(*) FROM &#96;goods&#96;;\n\nSELECT sex, count(*) FROM &#96;stu&#96; GROUP BY &#96;sex&#96;; &#x2F;&#x2F; 更推荐\nSELECT sex, count(sex) FROM &#96;stu&#96; GROUP BY &#96;sex&#96;;\n\n\n\n\n\n\n\n\n\n\n练习\n需求: 统计每个栏目下最贵的商品\n思路:\n\n第一步: 按照栏目(cate_id)对所有的数据进行分组\n第二步: 使用聚合函数求最大值\n\n\n\n\n\n\n\n\n\n\n分组统计\n第一步: 分组\nSELECT cate_id FROM goods group by cate_id;\n\n第二步: 统计\nSELECT &#96;cate_id&#96;, max(shop_price)\nFROM &#96;goods&#96;\nGROUP BY &#96;cate_id&#96;;\n\n\n\n2.having子句having跟where一样, 用来做条件的判断和数据的筛选过滤\n在MySQL中，我们可以使用where进行条件的过滤, 也可以使用having.\n\n\n\n\n\n\n\n\n\n示例\n# 可以用where也可以用having\nSELECT * FROM &#96;t1&#96; WHERE &#96;age&#96; &gt; 18;\nSELECT * FROM &#96;t1&#96; HAVING &#96;age&#96; &gt; 18;\n\n\n\n\n\n\n\n\n\n\n演示\nwhere和having的区别\n\nwhere中的条件是表字段\nhaving中的条件是结果集\n\n\n\n\n\n\n\n\n\n\n示例\n查询差价&gt;200的商品信息\n# 使用where\nSELECT &#96;goods_name&#96;,  market_price-shop_price as &#96;chajia&#96;\nFROM &#96;goods&#96;\nWHERE market_price-shop_price &gt; 200;\n\n# 使用having\nSELECT &#96;goods_name&#96;,  market_price-shop_price as &#96;chajia&#96;\nFROM &#96;goods&#96;\nHAVING chajia &gt; 200;\n\n\n\n\n\n\n\n\n\n\ngroup和having综合示例\n查询该店每个栏目下面积压的总货款\nSELECT &#96;cate_id&#96;, sum(goods_number*shop_price) as &#96;jiya&#96;\nFROM &#96;goods&#96;\nGROUP BY &#96;cate_id&#96;;\n\n查询积压货款&gt;1000的栏目\nSELECT &#96;cate_id&#96;, sum(goods_number*shop_price) as &#96;jiya&#96;\nFROM &#96;goods&#96;\nGROUP BY &#96;cate_id&#96;\nHAVING &#96;jiya&#96;&gt;1000;\n\n\n\n\n\n\n\n\n\n\n结论\n\nhaving通常和group by连用\nhaving的判断条件是结果集\n\n3.order by子句order by就是实现对数据的排序操作. 一共有两种情况:\n\n一种是升序排列(asc)\n一种是降序排列(desc)\n\n应用场景:\n各种排序场合,如新闻按点击量排序, 商品按价格排序, 文章按更新时间排序等\n\n\n\n\n\n\n\n\n\n示例\n按价格由高到低排序\nSELECT &#96;goods_name&#96;, &#96;shop_price&#96;\nFROM &#96;goods&#96;\nORDER BY &#96;shop_price&#96; desc;\n\n\n\n\n\n\n\n\n\n\n多个字段同时排序\n按栏目由低到高排序,栏目内部按价格由高到低排序\nSELECT &#96;cate_id&#96;, &#96;goods_name&#96;, &#96;shop_price&#96;\nFROM &#96;goods&#96;\nORDER BY &#96;cate_id&#96; asc, &#96;shop_price&#96; desc;\n\n\n\n4.limit 子句limit子句用于限定数目\n应用场景:\n最新的5遍文章, 成绩倒数3名的学生, 点击量最高的10件商品\n分页!!!\nlimit子句有两种语法\n\n\n\n\n\n\n\n\n\n语法\n# 带一个参数, 表示显示多少条\nlimit N\n# 带二个参数, 表示从N条(偏移量)开始, 显示M条\nlimit N,M\n\n\n\n\n\n\n\n\n\n\n示例\n查询价格最高的前三的商品\nSELECT &#96;goods_name&#96;, &#96;shop_price&#96;\nFROM &#96;goods&#96;\nORDER BY &#96;shop_price&#96; DESC\nLIMIT 3;\n\n\n\n\n\n\n\n\n\n\n分页示例\n每页5件商品, 显示第2页的数据\nSELECT &#96;id&#96;, &#96;goods_name&#96;\nFROM &#96;goods&#96;\nLIMIT 5,5;\n\n分页公式: 偏移量 = (当前页码-1) * 每页显示数\n\n\n\n\n\n\n\n\n\n尝试\n每页3件商品, 显示第4页的数据\nSQL: _________\n十一. E-R实体关系模型1.什么是实体E: entity(实体)\nR: relation(关系)\n1) 实体\n\n\n\n\n\n\n\n\n实体的定义\n​    客观存在并相互区别的一个事物称为实体（Entity）\n举例: 如一个学生、一件商品、一个部门、一个课程, 相当于数据表中一条记录\n2) 实体属性\n\n\n\n\n\n\n\n\n属性的定义\n​    实体的某些特性称为实体的属性（Attribute），一个实体可以拥有多个属性\n举例: 如学生有学号、姓名、性别、出生日期等, 相当于字段\n\n3) 实体集\n\n\n\n\n\n\n\n\n定义\n​    实体的集合, 相当于一张表\n2.关系表与表之间的关系一共有4种\n\n一对一\n一对多\n多对一\n多对多\n\n1) 一对一关系\n\n\n\n\n\n\n\n\n定义\n一张表的一条记录对应另一张表的一条记录\n\n\n\n\n\n\n\n\n\n举例\n看如下两张表\n用户表(user)和用户详情表(user_info)\nuser表中的一条记录, 比如xiaoming, 对应的user_info的一条记录\n\n\n\n\n\n\n\n\n\n关联条件\nuser.id=user_info.user_id\n2) 一对多关系\n\n\n\n\n\n\n\n\n定义\n一张表的一条记录对应另一张表的多条记录\n\n\n\n\n\n\n\n\n\n举例\n看如下两张表\n用户表(user)和文章表(article)\nuser表中的一条记录, 比如xiaoming, 对应的article中的多条记录\n说明: 一个用户可以拥有(has)多篇文章 hasMany\n\n\n\n\n\n\n\n\n\n关联条件\nuser.id=article.user_id\n3) 多对一关系\n\n\n\n\n\n\n\n\n定义\n一张表的多条记录对应另一张表的一条记录\n\n\n\n\n\n\n\n\n\n举例\n看如下两张表\n用户表(user)和国家表(country)\nuser表中的多条记录, 对应的country中的一条记录\n说明: 多个用户属于(belongsto)一个国家\n\n\n\n\n\n\n\n\n\n关联条件\nuser.country=country.id\n4) 多对多关系\n\n\n\n\n\n\n\n\n定义\n表A的一条记录对应表B的多条记录\n同时, 表B的一条记录也对应表A的多条记录\n\n\n\n\n\n\n\n\n\n举例\n看如下两张表\n用户表(user)和角色表(role)\n说明: 一个用户拥有多个角色, 一个角色也拥有多个用户\n\n\n\n\n\n\n\n\n\n关联条件\n建立中间表, 将多对多转换成两个一对多处理\n父表: 一的那方叫做父表\n子表: 多的那方叫做子表\n在子表中建立一个字段, 让这个字段=父表的id, 那么在子表中建立的这个字段就叫做外键\n","slug":"MySQL","date":"2022-12-01T13:13:57.870Z","categories_index":"服务端","tags_index":"sql","author_index":"团子"},{"id":"2ffd85dcab5fecc36d930380bb5ac946","title":"20_闭包_解构_类_promise","content":"昨日回顾作用域\n\t作用\n\t\t限定变量的作用范围\n\t分类\n\t\t全局作用域(script标签,浏览器关闭的时候销毁)\n\t\t局部作用域(函数里面,函数调用完成之后销毁)\n\t\t块级作用域(if,for循环的&#123;&#125;里面,ES6中语法)\n作用域链\n\t概念\n\t\t函数内部可以嵌套函数,每一次嵌套都会形成一个作用域\n\t\t把这些作用域串起来,就形成了作用域链\n\t作用\n\t\t根据&#39;内部函数可以访问外部函数的变量&#39;,使用链式查找来决定哪些数据能被内部函数访问\n\n原型和this指向\n\t解决的问题\t\n\t\t使用this来定义方法,每new一次,就会为对象的方法开辟空间,浪费内存\n\t解决的思路\n\t\t将公共的方法定义到原型对象中(构造函数名.prototype.方法名 &#x3D; 匿名函数)\n\t原型\n\t\t原型对象\n\t\t\t本质\n\t\t\t\t属于构造函数的一个属性,每一个构造函数里面都有\n\t\t\t作用\n\t\t\t\t可以把一些公共的属性或者方法,放在里面,将来创建对象的时候,可以节省内存\n\t\t对象的原型\n\t\t\t本质\n\t\t\t\t属于对象的一个属性,每一个创建出来的对象都有\n\t\t\t作用\n\t\t\t\t为对象查找方法,提供了一个方向\n\t\t\t\t先从构造函数里面找,没有的话,通过对象的原型找到原型对象,\n\t\t\t\t如果没有,就通过原型链找到上一层,一直找到object\n\t\t构造函数\n\t\t\t在原型对象 和 对象的原型,里面都有一个属性constructor,指向构造函数本身\n\t\t\t可以记录该对象引用于哪个构造函数\n\t原型链\n\t\t每一个实例对象,都有一个属性(__proto__),指向构造函数的原型对象,构造函数原型对象也是\n\t\t一个对象,也有__proto__,指向他的上一层,这样就形成了原型链\n\t\t\n\t\t原型链为对象查找和调用方法提供了一条路径\n\t\t\n函数进阶\n\t命名函数\t\t\t函数名调用\t\twindow\n\t匿名函数\t\t\t变量名调用\t\twindow\n\t构造函数\t\t\tnew调用\t\t  创建的实例对象\n\t字面量对象中的方法    字面量对象\t\t 字面量对象\n\t事件中的函数         事件触发调用\t  事件源对象\n\t定时器中的函数       定时调用\t\t   window\n\t立即执行函数\t\t   立即调用         window\n\t\n\t改变函数内this的指向\n\t\tcall\n\t高阶函数\n\t\t也是一个函数(将函数作为参数 或者是 返回值的函数)\n\n闭包概念\n\t是一个函数,有权访问另外一个函数作用域里面的变量,这个变量所在的函数就叫做闭包\n作用\n\t延伸变量的作用范围,之前定义在函数里面的num只能在函数内部调用,现在可以在外部调用\n应用\n\t立即执行函数(只要在立即执行函数里面的任意一个函数,都可以使用立即执行函数里面的变量)\n\n\n\nlet和const概念\n\tlet 声明的变量只在 let 命令所在的代码块内有效。\n\tconst 声明一个只读的常量，一旦声明，常量的值就不能改变。\n\t\n区别\n\t\t\t\t\t\tvar\t\t\t\tlet\t\t\t\tconst\n\t作用域\t\t\t\t函数级作用域\t\t块级作用域\t\t块级作用域\n\t变量提升\t\t\t 有\t\t\t\t 没有\t\t\t\t没有\n\t能否被修改\t\t\t可以\t\t\t\t可以\t\t\t  不可以\n\t\n使用场景\n\tlet一般用于定义变化的数据(基本数据类型)\n\tconst一般用于定义引用数据类型\n\t优先选用const 如果数据后面要修改,就选用let\n\n\n\n类和继承概念\n\t在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。\n\tclass 的本质是 function。\n\t它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。\n语法\n\t定义类\n\t\tclass 类名&#123;\n\t\t\tconstructor(参数1,参数2)&#123;\n\t\t\t\tthis.属性名1 &#x3D; 参数1\n\t\t\t\tthis.属性名2 &#x3D; 参数2\n\t\t\t&#125;\n\t\t\t方法名()&#123;\n\t\t\t\t方法体\n\t\t\t&#125;\n\t\t&#125;\n继承\n\tclass A extends B &#123;&#125;\n\t\n静态成员\n\t定义\n\t\t使用static修饰\n\t使用\n\t\t直接用类名调用,无需创建对象\n\n\n\n解构赋值概念\n\t一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值\n语法\n\t数组\n\t\tconst[变量列表] &#x3D; 要解构的数组\n\t对象\n\t\tconst&#123;变量列表&#125; &#x3D; 要解构的对象\n好处\n\t可以让调用者更方便的提取数组或者对象的值,或者调用里面的属性和方法\n\t\t\n\n\n\n箭头函数概念\n\t提供了一种更加简洁的函数书写方式\n语法\n\t最简单格式\n\t\t参数 &#x3D;&gt; 函数体 \n\t完整格式\n\t\t(参数1,参数2) &#x3D;&gt; &#123; 函数体 &#125;\n省略格式\n\t如果参数只有一个,()可以省略\n\t如果函数体只有一个语句.&#123;&#125;也可以省略\n\n\n\nPromise概念\n\t本质就是一个对象,对象有属性和方法,他有两个属性和一个方法\n\t一个是状态属性,一个结果属性.方法就是then方法\n创建\n\tconst p &#x3D; new Promise((resovle,reject) &#x3D;&gt; &#123;&#125;)\n属性\n\t状态属性 PromiseState \n        默认值是pending  准备状态,初始状态\n        调用resolve()方法,可以将状态改成完成状态\n        调用reject()方法,可以将状态改成拒绝状态\n       \n    结果属性 PromiseResult\n        默认值是undefined \n        调用方法的时候传一个参数,就可以将参数保存在结果属性中\n方法\n\t接收两个函数,如果p的状态是成功的,就会调用第一个函数,如果是失败的,就会调用第二个函数\n\tthen()方法只有在状态发生改变的时候才会调用\n\t给then方法中的函数加一个参数,就可以拿到结果属性中的值\n\t\nthen返回值\n\t又是一个新的promise对象,可以继续调用then方法,进而实现链式编程\n\t链式编程能够执行的前提条件:第一个promise对象,状态不是pending,必须要发生改变\n\n","slug":"day21_课堂笔记","date":"2022-12-01T13:11:29.368Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"469779a6e8484934bee8ecd3db81351f","title":"20_作用域_原型_函数进阶","content":"昨日回顾全局对象GO\n\t概念\n\t\tjs引擎整合所有的script标签产生的一个对象,window对象\n\t全局变量\n\t\t在script标签里面声明的变量\n\t全局函数\n\t\t在script标签里面声明的函数\n\t关系\n\t\t全局变量--&gt;GO对象一个属性\n\t\t全局函数--&gt;GO对象一个方法\n\n活动对象AO\n\t概念\n\t\t在函数被调用的那一刻产生的一个对象,用来保存当前函数的内部的执行环境\n\t局部变量\n\t\t在函数内部里面声明的变量\n\t局部函数\n\t\t在函数内部里面声明的函数\n\t关系\n\t\t局部变量--&gt;AO对象一个属性\n\t\t局部函数--&gt;AO对象一个方法\n\t\t\n全局预编译\n\t概念\n\t\tscript标签下,代码执行之前的一个预处理\n\t流程\n\t\t0,产生GO对象\n\t\t1,先找变量声明\n\t\t2,再找函数声明\n\t\t3,从上到下执行\n\t结论\n\t\t在全局环境中,如果存在同名的变量和函数,函数的优先级高\n\t\n函数预编译\n\t概念\n\t\t在函数里面,代码执行之前的一个预处理\n\t流程\n\t\t0,产生AO对象\n\t\t1,先找形参和变量的声明\n\t\t2,使用实参的值替换形参的值\n\t\t3,再找函数的声明\n\t\t4,从上到下依次执行函数体\n\t结论\n\t\t只要声明了局部函数,函数的优先级最高(同名的情况下)\n\t\t没有声明局部函数,实参的优先级高\n\t\t整体优先级: 局部函数 &gt; 实参 &gt; 形参和局部变量\n\n作用域作用\n\t限定变量在某个范围内起作用\n好处\n\t提高程序的可靠性,减少命名冲突(在ES6中,同一个域不能定义相同变量.否则报错)\n分类\n\t全局作用域\n\t\t由script标签产生的区域,从计算机角度可以理解为window对象管控的区域\n\t\t全局的变量和函数都是在全局作用域下,在浏览器关闭的时候销毁\n\t局部作用域\n\t\t由函数产生的区域,从计算机的角度可以理解为当前函数AO对象管控的区域\n\t\t局部的变量和函数都是在局部作用域下,在函数执行完成后销毁\n\t块级作用域\n\t\tES6中的语法,存在于if语句,for循环管控的&#123;&#125;所在的区域,对ES5没限制\n\n作用域链概念\n\t只要是代码,都是一个作用域中,写在函数内部的是局部作用域,没有写在函数内部的是在全局作用域中,\n\t如果这个函数,他的内部还有函数,那么在这个作用域中又可以诞生一个作用域.就形成了一个作用域链\n\t\n\t根据 &#39;内部函数可以访问外部函数的变量&#39; 这种机制,使用链式查找来决定哪些数据能被内部函数访问\n\t\n本质\n\t本质也是一个数据结构,函数内部可以嵌套函数,每一次嵌套都会形成一个作用域,把这些作用域串起来\n\t就形成了作用域链\n\n\n\n原型和this指向前置知识\n\t对象的三种创建方式\n\t\t1,构造函数\n\t\t2,字面量形式\n\t\t3,new Object形式\n\t成员分类\n\t\t实例成员\n\t\t\t构造函数内部,通过this添加,通过实例对象来调用\n\t\t静态成员\n\t\t\t在构造函数本身上添加,通过构造函数名来调用\n\t\t\t\n原型对象prototype\n\t概念\n\t\t原型是一个对象,每一个构造函数都有一个prototype属性,指向这个对象(本身)\n\t作用\n\t\t可以把那些不变的方法,直接定义到原型对象(prototype上),这样所有的对象的实例都可以共享这些方法,节省了内存\n\t\t\n对象的原型proto\n\t概念\n\t\t每一个对象都会有一个属性 __proto__,指向函数的原型对象(prototype)\n\t\t__proto__ 习惯称之为 对象的原型\n\t\t\nconstructor构造函数\n\t概念\n\t\t原型对象(Stat.prototype) 和 对象的原型(对象.__proto__),里面都一个属性constructor(constructor称为构造函数,指向构造函数本身)\n\t作用\n\t\t主要是记录该对象引用于哪一个构造函数,可以让原型对象重新指向原来的构造函数(了解)\n\t\n原型链\n\t概念\n\t\t每一个实例对象又有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有__proto__属性，这样一层一层往上找就形成了原型链。\n\t\t\n\t作用\n\t\t当实例对象调用方法的时候,首先在自身的this中定义的方法找\n\t\t如果没有的话,就通过__proto_找到,原型对象,看原型对象里面有没有定义\n\t\t如果没有的话,就通过原型对象的__proto__到上一层(父类中找这个方法)\n\t\t一直找到object,如果都没有的话,就报错\n\t\t\n\t\t__proto__ 对象原型的存在,就是为对象成员的查找机制提供了一个方向\n\n\n\n函数进阶定义总结\n\t命名函数\n\t匿名函数\n\tnew Function(参数1,参数2,函数体)\n调用总结\n\t命名函数   函数名调用\n\t匿名函数   变量名调用\n\t对象的方法  对象\n\t构造函数    对象\n\t绑定事件函数 事件对象调用\n\t定时器函数   自动调用\n\t立即执行函数  立即调用\nthis的指向总结\n\t命名函数   window\n\t匿名函数   window\n\t对象的方法  实例对象\n\t构造函数    实例对象\n\t绑定事件函数 事件对象\n\t定时器函数   window\n\t立即执行函数  window\ncall\n\t执行函数\n\t改变this的指向\n高阶函数\n\t函数作为参数或者返回值,这种函数,叫做高阶函数\n","slug":"day20_课堂笔记","date":"2022-12-01T13:09:33.617Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"c2ca0fd8b53bedb58b7bbb78ffccd016","title":"19_预编译","content":"昨日回顾DOM操作\n\t操作属性\n    \tprop()  固有属性\n    \t\t设置 prop(属性名,属性值)\n    \t\t获取 prop(属性名)\n    \tattr()  自定义属性\n    \t\t设置 attr(属性名,属性值)\n    \t\t获取 attr(属性名)\n\t操作样式\n\t\tcss方法\n\t\t\t获取 css(样式属性名)\n\t\t\t设置 css(样式属性名,属性值)\n\t\t类方法\n\t\t\taddClass()\n\t\t\tremoveClass() \n\t\t\ttoggleClass()\n\t操作文本\n\t\thtml() 标签体,有样式\n\t\t\t获取 jquery对象.html()\n\t\t\t设置 jquery对象.html(内容)\n\t\ttext() 标签体,有样式\n\t\t\t获取 jquery对象.text()\n\t\t\t设置 jquery对象.text(内容)\n\t\tval() 文本框\n\t\t\t获取 jquery对象.val()\n\t\t\t设置 jquery对象.val(内容)\n\t操作节点\n\t\t创建元素\n\t\t\t$(&#39;字符串类型的标签&#39;)\n\t\t添加元素\n\t\t\tappend() 末尾\n\t\t\tprepend() 前面\n\t\t删除元素\n\t\t\tremove() 删除\n\t效果\n\t\t显示和隐藏\n\t\t\tshow()\n\t\t\thide()\n\t\t\ttoggle()\n\t\t上拉和下拉滑动\n\t\t\tslideup()\n\t\t\tslidedown()\n\t\t\tslidetoggle()\n\t\t淡入淡出\n\t\t\tfadeIn()\n\t\t\tfadeOut()\n\t\t\tfadetoggle()\n\t\t\tfadeTo()\n\t遍历\n\t\tjquery对象.each(function(i,e)&#123;&#125;)\n\t\t$.each(jquery对象,function(i,e)&#123;&#125;)\n\t\t\n\t绑定和解绑\n\t\ton\n\t\t\t1,一次可以绑定多个不同类型的事件\n\t\t\t\tjquery对象.on(&#123;\n\t\t\t\t\t事件名称1:匿名函数1,\n\t\t\t\t\t事件名称2:匿名函数2\n\t\t\t\t&#125;)\n\t\t\t2,可以实现事件委托(将事件绑定到父元素上)\n\t\t\t3,可以实现动态绑定\n\t\t\t\tjquery对象.on(事件名称,子类元素的选择器,事件处理函数)\n\n全局对象GO全局对象(GO对象)\n    在浏览器环境中, js引擎会整合所有的&lt;script&gt;标签中的内容, 产生&#96;window对象&#96;\n全局变量\n    在script标签中声明的变量\n全局函数\n\t在script标签中声明的函数\n关系\n    全局变量其实是作为全局对象(GO对象)的一个属性来存在的\n    全局函数其实是作为全局对象(GO对象)的一个方法来存在的\n\n活动对象AO活动对象(AO对象)\n\t在函数被调用时产生的一个对象, 用来保存当前函数内部的执行环境\n局部变量\n\t在函数内部声明的变量\n局部函数\n\t在函数内部声明的函数\n关系\n\t局部变量其实是作为局部对象(AO对象)的一个属性来存在的\n\t局部函数其实是作为局部对象(AO对象)的一个方法来存在的\n\n全局预编译概念\n\t就是在全局环境下(script标签下),js引擎的预处理方式\n流程\n\t1,先查找变量的声明,作为GO对象的属性名,值为undefined\n\t2,再查找函数的声明,作为GO对象的属性名,值为function\n\t3,从上到下依次执行(声明的语句就会被略过)\n结论\n\t在全局环境中,如果存在同名的变量和函数,函数的优先级高\n\n函数预编译概念\n\t就是在局部环境下(函数里面),js引擎的预处理方法\n流程\n\t1,在函数被调用的那一刻,就会为当前函数产出AO对象\n\t2,查找形参和变量的声明作为AO对象的属性名,值为undefined\n\t3,使用实参的值,替换形参的值\n\t4,查找函数的声明,作为AO对象的属性名,值为function\n\t5,从上到下依次执行函数体\n\n\n\n作用域作用域链原型和this指向","slug":"day19_课堂笔记","date":"2022-12-01T13:03:31.746Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"f6ef7836a37fb0cf1951b89b46effc56","title":"18_juery操作和属性","content":"昨日回顾jquery\n\t概念\n\t\tjs的函数库\n\t作用\n\t\t选取元素\n\t\t操作dom\n\t\t添加一些特效\n\t\tajax\n\t使用\n\t\t先引入(本地或者网络)\n\t 语法\n\t \t$(匿名函数)  \n\t \t\t入口函数,将来页面加载完成之后,就可以调用匿名函数中的代码\n\t \t$(dom元素)\n\t \t\t可以将js对象转成jquery对象\n\t \t$(选择器)\n\t \t\t选择指定的元素,得到的是jquery对象\n\t 跟js对象互转\n\t \tjs对象 -&gt;  jquery对象  $(dom元素)\n\t    jquery对象 -&gt; js对象  jquery[0] 或者 jquery.get(0)\n\t事件操作\n    \tjquery对象.事件名称(匿名函数) \n    选择元素\n     \t通过传统的css选择器来选择元素\n     \t\t基本选择器\n     \t\t复合选择器\n     \t通过自带的筛选方法来选择元素\n     \t\tfirst()\n     \t\tlast()\n     \t\tparent()\n     \t\tchildren()\n     \t\tfind()\n     \t\tsiblings()\n\nDOM操作操作样式\n\tcss方法\n\t\tcss(属性名) 获取样式属性的值\n\t\tcss(属性名,属性值) 设置指定样式属性的值\n\t类方法\n\t\taddClass() 添加类\n\t\tremoveClass() 移除类\n\t\ttoggleClass() 切换类\n\n操作属性\n\tprop() 操作的是元素固有的属性\n\t\tprop(属性名,属性值)  设置\n\t\tprop(属性名)  获取\n\tattr() 操作的是元素自定义的属性\n\t\tattr(属性名,属性值)  设置\n\t\tattr(属性名)  获取\n操作文本\n\thtml() 有样式\n\t\thtml() 获取\n\t\thtml(内容) 设置\n\ttext() 纯文本\n\t\ttext() 获取\n\t\ttext(内容) 设置\n\tval()  操作文本框内容\n\t\tval() 获取\n\t\tval(内容) 设置\n\t\t\n操作节点\n\t创建节点\n\t\t$(&#39;字符串类型的元素&#39;)\n\t添加元素\n\t\tappend()添加到末尾\n\t\tprepend()添加到前面\n\t删除元素\n\t\tremove() 可以自己删除自己\n\njquery效果显示和隐藏\n\tshow([s,[e],[fn]])\n\thide([s,[e],[fn]])\n\ttoggle([s],[e],[fn]) \n\n上滑和下滑\n\tslideDown([s],[e],[fn]) \n\tslideUp([s,[e],[fn]]) \n\tslideToggle([s],[e],[fn]) \n\n淡入淡出\n\tfadeIn([s],[e],[fn]) \n    fadeOut([s],[e],[fn]) \n    fadeToggle([s,[e],[fn]]) \n    fadeTo([[s],o,[e],[fn]]) \n\n\njquery遍历使用场景\n\t针对同一类元素,做不同操作的时候,需要用到遍历\n语法\t\n\tjquery对象.each(匿名函数)\n\t$.each(jquery对象,匿名函数)\n\n事件绑定和解绑事件绑定\n\ton\n\t\t1,可以绑定多个不同类型事件\n\t\t2,可以实现事件委托(可以把子元素事件绑定到父元素上)\n\t\t3,可以实现动态绑定\n事件解绑\n\toff\n\n","slug":"day18_课堂笔记","date":"2022-12-01T12:41:34.942Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"a5b97ab8932b5f038d4330f012aa0a62","title":"jQuery","content":"一. jQuery介绍1 什么是jQuery\n\n\n\n\n\n\n\n\njQuery是一个JavaScript函数库\n在早期的时候, 浏览器有很多不同的版本, 如果要做各种浏览器兼容是很头疼的事. \njQuery的出现解决了这个问题, 处理了兼容问题, 并提供了一系列简洁的, 统一的操作DOM的方式\n\n\n\n\n\n\n\n\n\njQuery的口号是”write less, do more”\n2 jQuery包含哪些功能jQuery库包含以下功能：\n\nHTML 元素选取\nHTML 元素操作\nCSS 操作\nHTML 事件函数\nJavaScript 特效和动画\nHTML DOM 遍历和修改\nAJAX\n\n除此之外, 还提供了大量的插件. \n虽然现在3大框架的出现在一定程度上影响了jQuery的市场份额. 但是jQuery对于学习DOM编程还是非常有帮助的. 同时也不排除jQuery依然活跃于大型项目中\n二. jQuery快速上手1 jQuery的安装jQuery的安装只需要引入jQuery的js文件即可, 常用的获取jquery.js文件的方式:\n\n从 jquery.com 下载 jQuery 库\n从 CDN 中载入 jQuery, 如从 jsDelivr 中加载 jQuery\n\n这里, 更推荐大家使用CDN的方式引入\n\n\n\n\n\n\n\n\n\n推荐的CDN公共资源网站\njsDelivr\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.6.0&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\nbootCDN\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;3.6.0&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n\n更多公共资源CDN可以参考: 菜鸟驿站-jQuery安装\n\n\n\n\n\n\n\n\n\n扩展\n许多用户在访问其他站点时，已经从百度、又拍云、新浪、谷歌或微软加载过 jQuery。所以结果是，当他们访问您的站点时，会从缓存中加载  jQuery，这样可以减少加载时间。同时，大多数 CDN  都可以确保当用户向其请求文件时，会从离用户最近的服务器上返回响应，这样也可以提高加载速度\n2 jQuery语法jQuery最主要的作用就是操作DOM\n步骤:\n\n选择DOM元素\n执行操作(事件, 属性, 效果…)\n\n\n\n\n\n\n\n\n\n\n语法\n$(&#39;选择器&#39;).action\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;慢慢就看不见我了!!!&lt;&#x2F;div&gt;\n    &lt;script&gt;\n      &#x2F;&#x2F; 选择div元素, 在3s内隐藏\n      $(&#39;div&#39;).hide(3000)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3 入口函数当DOM元素加载完成后执行. 不用等所有内容(包括图片, css)加载完成\n\n\n\n\n\n\n\n\n\n示例\n$(function()&#123;\n    &#x2F;&#x2F; 执行代码\n&#125;)\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script&gt;\n      $(&#39;div&#39;).hide(3000)\n    &lt;&#x2F;script&gt;\n    &lt;div&gt;慢慢就看不见我了!!!&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n没有起效果.\n如果我们希望jQuery的代码生效, 可以考虑将代码放在入口函数中\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;script&gt;\n      $(function () &#123;\n        $(&#39;div&#39;).hide(3000)\n      &#125;)\n    &lt;&#x2F;script&gt;\n    &lt;div&gt;慢慢就看不见我了!!!&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4 DOM对象与jQuery对象DOM对象是通过原生的DOM API得到的对象\njQuery对象是通过$()得到的对象\n两者可以使用方法不一样\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;box&lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      var div &#x3D; document.querySelector(&#39;div&#39;)\n      div.onclick &#x3D; function () &#123;\n        alert(123)\n      &#125;\n\n      var jqObj &#x3D; $(&#39;div&#39;)\n      &#x2F;&#x2F; jqObj 并没有onclick方法, 不会生效\n      jqObj.onclick &#x3D; function () &#123;\n        console.log(123)\n      &#125;\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nDOM对象和jQuery对象是可以相互转换的\n\n通过$()得到的对象是jq对象, 通过下标得到dom对象\n通过dom API得到dom对象, 通过$()转换为jq对象\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;box1&lt;&#x2F;div&gt;\n    &lt;div&gt;box2&lt;&#x2F;div&gt;\n    &lt;div&gt;box3&lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      &#x2F;&#x2F; 通过$()得到的对象是jq对象, 通过下标得到dom对象\n      var jqObj &#x3D; $(&#39;div&#39;)\n      console.dir(jqObj)\n      console.dir(jqObj[0])\n\n      &#x2F;&#x2F; 通过dom API得到dom对象, 通过$()转换为jq对象\n      var divs &#x3D; document.querySelectorAll(&#39;div&#39;)\n      console.log(divs)\n      console.log($(divs))\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n三. jQuery选择器类似于CSS选择器, jQuery提供丰富的选择器, 可以快速准确的选出DOM元素.\n这里, 我们也只是给出常用的选择器, 更多组合大家自行探索\n\n\n\n名称\n用法\n描述\n\n\n\nID选择器\n$(‘#id’)\n获取指定ID的元素\n\n\n类选择器\n$(‘.class’)\n获取一类class的元素\n\n\n标签选择器\n$(‘div’)\n获取所有div元素\n\n\n后代选择器\n$(‘ul li’)\n获取ul下所有的li元素\n\n\n:first\n$(‘li:first’)\n获取第一个li元素\n\n\neq(index)\n$(‘li:eq(2)’)\n获取索引号为2的元素, 从0开始\n\n\nfind(selector)\n$(‘ul’).find(‘li’)\n在ul下找所有的li元素\n\n\neq(index)\n$(‘li’).eq(2)\n相当于$(‘li:eq(2)’)\n\n\nsiblings(selector)\n$(this).siblings()\n选择自己的兄弟元素, 不包括自己\n\n\n属性选择器\n$(“a[target=’_blank’]”)\ntarget 属性值等于 “_blank” 的 a元素\n\n\n四. jQuery事件1 什么是事件当用户浏览网页时, 网页上一些可以交互的元素(按钮)对用户操作的反应就是事件.\n比如\n\n用户点击登录按钮\n看小说, 漫画时按键盘的左右键进行翻页\n\n这些都是事件\n2 常见的事件常见的事件可以分为\n\n鼠标事件\n键盘事件\n表单事件\n窗口事件\n\n\n3 jQuery如何处理事件\n\n\n\n\n\n\n\n\n语法\n$(&quot;选择器&quot;).事件名(function()&#123;\n    &#x2F;&#x2F; 事件处理函数\n&#125;);\n\n\n\n\n\n\n\n\n\n\n示例\n$(&quot;btn&quot;).click(function()&#123;\n    alert(&#39;我被点击了&#39;)\n&#125;);\n\n五. jQuery CSS操作通过jQuery可以快速的添加CSS样式\n1 CSS操作\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; 设置单个属性\n$(&quot;选择器&quot;).css(&#39;属性名&#39;, &#39;属性值&#39;)\n&#x2F;&#x2F; 设置多个属性\n$(&quot;选择器&quot;).css(&#123;\n  属性名1: 属性值1,\n  属性名2: 属性值2\n&#125;)\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;box&quot;&gt;box&lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      &#x2F;&#x2F; 对于-, 改成驼峰命名\n      &#x2F;&#x2F; 设置单个属性\n      $(&#39;#box&#39;).css(&#39;backgroundColor&#39;, &#39;skyblue&#39;)\n\n      &#x2F;&#x2F; 设置多个属性\n      $(&#39;#box&#39;).css(&#123;\n        width: &#39;400px&#39;,\n        height: &#39;400px&#39;,\n        color: &#39;#fff&#39;,\n        fontSize: &#39;32px&#39;,\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n2 类操作更多的时候, 我们使用类操作\n\n添加一个类样式: addClass\n删除一个类样式: removeClass\n切换类样式: toggleClass\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;style&gt;\n      div &#123;\n        width: 150px;\n        height: 150px;\n        background-color: skyblue;\n      &#125;\n\n      .current &#123;\n        background-color: greenyellow;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;box&lt;&#x2F;div&gt;\n    &lt;button id&#x3D;&quot;btnAdd&quot;&gt;点击添加颜色&lt;&#x2F;button&gt;\n    &lt;button id&#x3D;&quot;btnRemove&quot;&gt;点击删除颜色&lt;&#x2F;button&gt;\n    &lt;button id&#x3D;&quot;btnToggle&quot;&gt;点击切换颜色&lt;&#x2F;button&gt;\n\n    &lt;script&gt;\n      $(&#39;#btnAdd&#39;).click(function () &#123;\n        &#x2F;&#x2F; 添加颜色\n        $(&#39;div&#39;).addClass(&#39;current&#39;)\n      &#125;)\n\n      $(&#39;#btnRemove&#39;).click(function () &#123;\n        &#x2F;&#x2F; 删除颜色\n        $(&#39;div&#39;).removeClass(&#39;current&#39;)\n      &#125;)\n\n      $(&#39;#btnToggle&#39;).click(function () &#123;\n        &#x2F;&#x2F; 切换颜色\n        $(&#39;div&#39;).toggleClass(&#39;current&#39;)\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n\n综合练习: 仿京东Tab栏切换\n实现如下效果:\n\n思路:\n\n点击上部的li，当前li 添加current类，其余兄弟移除类。\n点击的同时，得到当前li 的索引号\n让下部里面相应索引号的item显示，其余的item隐藏\n\n\n\n\n\n\n\n\n\n\n答案\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- 1. 引入jQuery --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;style&gt;\n      * &#123;\n        margin: 0;\n        padding: 0;\n      &#125;\n      li &#123;\n        list-style: none;\n      &#125;\n      .tab &#123;\n        width: 800px;\n        height: 300px;\n        margin: 100px auto;\n      &#125;\n      .tab-title &#123;\n        height: 36px;\n        background-color: #f1f1f1;\n        border: 1px solid #ccc;\n      &#125;\n      .tab-title ul li &#123;\n        float: left;\n        padding: 0 20px;\n        height: 36px;\n        line-height: 36px;\n        text-align: center;\n        cursor: pointer;\n      &#125;\n      .active &#123;\n        background-color: #c81623;\n        color: #fff;\n      &#125;\n      .item &#123;\n        display: none;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;tab&quot;&gt;\n      &lt;div class&#x3D;&quot;tab-title&quot;&gt;\n        &lt;ul&gt;\n          &lt;li class&#x3D;&quot;active&quot;&gt;商品介绍&lt;&#x2F;li&gt;\n          &lt;li&gt;规格与包装&lt;&#x2F;li&gt;\n          &lt;li&gt;售后保障&lt;&#x2F;li&gt;\n          &lt;li&gt;商品评价(50000)&lt;&#x2F;li&gt;\n          &lt;li&gt;手机社区&lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n      &lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;tab-item&quot;&gt;\n        &lt;div class&#x3D;&quot;item&quot; style&#x3D;&quot;display: block&quot;&gt;商品介绍&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;item&quot;&gt;规格与包装&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;item&quot;&gt;售后保障&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;item&quot;&gt;商品评价&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;item&quot;&gt;手机社区&lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      $(&#39;.tab-title li&#39;).click(function () &#123;\n        var i &#x3D; $(this).index()\n        $(this).addClass(&#39;active&#39;).siblings().removeClass(&#39;active&#39;)\n        $(&#39;.item&#39;).eq(i).show().siblings().hide()\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n这里使用到了链式操作\n$(this): 表示当前选中的li元素\n通过index(): 获取当前选中的li元素的下标\n\n总的思路是:\n给当前选中的添加样式\n给兄弟移除样式\n六. jQuery效果1 显示与隐藏三个方法\n\nshow()\nhide()\ntoggle()\n\n\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; 不带参数, 直接显示\n$(&#39;选择器&#39;).show()\n\n&#x2F;&#x2F; 带一个参数, 在time(毫秒)内显示\n$(&#39;选择器&#39;).show(time)\n\n&#x2F;&#x2F; 带二个参数, 在time(毫秒)内显示, 显示完后执行回调\n$(&#39;选择器&#39;).show(time, callback)\n\n\n\n\n\n\n\n\n\n\n示例\n$(&quot;button&quot;).click(function() &#123;\n  $(&quot;div&quot;).show(1000, function() &#123;\n    alert(1);\n  &#125;);\n&#125;)\n\n2 滑入滑出三个方法\n\nslideDown() \nslideUp() \nslideToggle()\n\n语法跟show()一样\n3 淡入淡出自学淡入淡出函数\n综合案例: 带下拉效果的导航条\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;!-- 2. 样式 --&gt;\n    &lt;style&gt;\n      &#x2F;* reset *&#x2F;\n      * &#123;\n        margin: 0;\n        padding: 0;\n      &#125;\n      li &#123;\n        list-style: none;\n      &#125;\n      a &#123;\n        text-decoration: none;\n      &#125;\n      &#x2F;* 布局 *&#x2F;\n      .nav &#123;\n        width: 400px;\n        margin: 50px auto;\n      &#125;\n      .nav .nav-item &#123;\n        float: left;\n        position: relative;\n      &#125;\n      .nav .nav-item .nav-title &#123;\n        display: block;\n        width: 80px;\n        height: 40px;\n        line-height: 40px;\n        text-align: center;\n        color: #333;\n        &#x2F;* background-color: #eee; *&#x2F;\n      &#125;\n      .nav .nav-item .nav-title:hover &#123;\n        background-color: #edeef0;\n        color: #ff8400;\n      &#125;\n      .nav .nav-menu &#123;\n        display: none;\n        position: absolute;\n        color: #333;\n        border-left: 1px solid #fecc5b;\n        border-right: 1px solid #fecc5b;\n      &#125;\n      .nav .nav-menu li &#123;\n        line-height: 40px;\n        padding: 0 20px;\n        white-space: nowrap;\n        border-bottom: 1px solid #fecc5b;\n      &#125;\n      .nav .nav-menu li:hover &#123;\n        background-color: #fff5da;\n        color: #e67902;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 1. 结构 --&gt;\n    &lt;nav class&#x3D;&quot;nav&quot;&gt;\n      &lt;ul&gt;\n        &lt;li class&#x3D;&quot;nav-item&quot;&gt;\n          &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;nav-title&quot;&gt;微博&lt;&#x2F;a&gt;\n          &lt;ul class&#x3D;&quot;nav-menu&quot;&gt;\n            &lt;li&gt;私信&lt;&#x2F;li&gt;\n            &lt;li&gt;评论&lt;&#x2F;li&gt;\n            &lt;li&gt;@我&lt;&#x2F;li&gt;\n          &lt;&#x2F;ul&gt;\n        &lt;&#x2F;li&gt;\n        &lt;li class&#x3D;&quot;nav-item&quot;&gt;\n          &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;nav-title&quot;&gt;博客&lt;&#x2F;a&gt;\n          &lt;ul class&#x3D;&quot;nav-menu&quot;&gt;\n            &lt;li&gt;博客评论&lt;&#x2F;li&gt;\n            &lt;li&gt;未读提醒&lt;&#x2F;li&gt;\n          &lt;&#x2F;ul&gt;\n        &lt;&#x2F;li&gt;\n        &lt;li class&#x3D;&quot;nav-item&quot;&gt;\n          &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;nav-title&quot;&gt;邮箱&lt;&#x2F;a&gt;\n          &lt;ul class&#x3D;&quot;nav-menu&quot;&gt;\n            &lt;li&gt;免费邮箱&lt;&#x2F;li&gt;\n            &lt;li&gt;VIP邮箱&lt;&#x2F;li&gt;\n            &lt;li&gt;企业邮箱&lt;&#x2F;li&gt;\n            &lt;li&gt;新浪企业邮箱客户端&lt;&#x2F;li&gt;\n          &lt;&#x2F;ul&gt;\n        &lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;nav&gt;\n    &lt;script&gt;\n      &#x2F;&#x2F; $(&#39;.nav-item&#39;).mouseenter(function () &#123;\n      &#x2F;&#x2F;   $(this).children(&#39;.nav-menu&#39;).slideDown(200)\n      &#x2F;&#x2F; &#125;)\n      &#x2F;&#x2F; $(&#39;.nav-item&#39;).mouseleave(function () &#123;\n      &#x2F;&#x2F;   $(this).children(&#39;.nav-menu&#39;).slideUp(200)\n      &#x2F;&#x2F; &#125;)\n      &#x2F;&#x2F; $(&#39;.nav-item&#39;).hover(\n      &#x2F;&#x2F;   function () &#123;\n      &#x2F;&#x2F;     $(this).children(&#39;.nav-menu&#39;).slideDown(200)\n      &#x2F;&#x2F;   &#125;,\n      &#x2F;&#x2F;   function () &#123;\n      &#x2F;&#x2F;     $(this).children(&#39;.nav-menu&#39;).slideUp(200)\n      &#x2F;&#x2F;   &#125;\n      &#x2F;&#x2F; )\n\n      $(&#39;.nav-item&#39;).hover(function () &#123;\n        $(this).children(&#39;.nav-menu&#39;).slideToggle(200)\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4 停止动画stop()\n如果不停止动画就会出现上面的情况. 我们可以使用stop停止动画\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;!-- 2. 样式 --&gt;\n    &lt;style&gt;\n      &#x2F;* reset *&#x2F;\n      * &#123;\n        margin: 0;\n        padding: 0;\n      &#125;\n      li &#123;\n        list-style: none;\n      &#125;\n      a &#123;\n        text-decoration: none;\n      &#125;\n      &#x2F;* 布局 *&#x2F;\n      .nav &#123;\n        width: 400px;\n        margin: 50px auto;\n      &#125;\n      .nav .nav-item &#123;\n        float: left;\n        position: relative;\n      &#125;\n      .nav .nav-item .nav-title &#123;\n        display: block;\n        width: 80px;\n        height: 40px;\n        line-height: 40px;\n        text-align: center;\n        color: #333;\n        &#x2F;* background-color: #eee; *&#x2F;\n      &#125;\n      .nav .nav-item .nav-title:hover &#123;\n        background-color: #edeef0;\n        color: #ff8400;\n      &#125;\n      .nav .nav-menu &#123;\n        display: none;\n        position: absolute;\n        color: #333;\n        border-left: 1px solid #fecc5b;\n        border-right: 1px solid #fecc5b;\n      &#125;\n      .nav .nav-menu li &#123;\n        line-height: 40px;\n        padding: 0 20px;\n        white-space: nowrap;\n        border-bottom: 1px solid #fecc5b;\n      &#125;\n      .nav .nav-menu li:hover &#123;\n        background-color: #fff5da;\n        color: #e67902;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 1. 结构 --&gt;\n    &lt;nav class&#x3D;&quot;nav&quot;&gt;\n      &lt;ul&gt;\n        &lt;li class&#x3D;&quot;nav-item&quot;&gt;\n          &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;nav-title&quot;&gt;微博&lt;&#x2F;a&gt;\n          &lt;ul class&#x3D;&quot;nav-menu&quot;&gt;\n            &lt;li&gt;私信&lt;&#x2F;li&gt;\n            &lt;li&gt;评论&lt;&#x2F;li&gt;\n            &lt;li&gt;@我&lt;&#x2F;li&gt;\n          &lt;&#x2F;ul&gt;\n        &lt;&#x2F;li&gt;\n        &lt;li class&#x3D;&quot;nav-item&quot;&gt;\n          &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;nav-title&quot;&gt;博客&lt;&#x2F;a&gt;\n          &lt;ul class&#x3D;&quot;nav-menu&quot;&gt;\n            &lt;li&gt;博客评论&lt;&#x2F;li&gt;\n            &lt;li&gt;未读提醒&lt;&#x2F;li&gt;\n          &lt;&#x2F;ul&gt;\n        &lt;&#x2F;li&gt;\n        &lt;li class&#x3D;&quot;nav-item&quot;&gt;\n          &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;nav-title&quot;&gt;邮箱&lt;&#x2F;a&gt;\n          &lt;ul class&#x3D;&quot;nav-menu&quot;&gt;\n            &lt;li&gt;免费邮箱&lt;&#x2F;li&gt;\n            &lt;li&gt;VIP邮箱&lt;&#x2F;li&gt;\n            &lt;li&gt;企业邮箱&lt;&#x2F;li&gt;\n            &lt;li&gt;新浪企业邮箱客户端&lt;&#x2F;li&gt;\n          &lt;&#x2F;ul&gt;\n        &lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;nav&gt;\n    &lt;script&gt;\n      $(&#39;.nav-item&#39;).hover(function () &#123;\n        $(this).children(&#39;.nav-menu&#39;).stop().slideToggle(200)\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n七. jQuery属性操作1 jQuery元素属性操作这里主要是两个方法\n\nprop()\nattr()\n\n虽然attrubite和property都有属性的意思, 但是\n\nprop() – 操作js对象的属性\nattr() – 操作html属性节点\n\nprop更适用于表单属性, 如：disabled / checked / selected 等\n\n\n\n\n\n\n\n\n\n示例\nprop示例\n$(&#39;button&#39;).on(&#39;click&#39;,function()&#123;\n  if ($(&#39;input&#39;).prop(&#39;checked&#39;)) &#123;\n    $(&#39;input&#39;).prop(&#39;checked&#39;,false);\n  &#125;else&#123;\n    $(&#39;input&#39;).prop(&#39;checked&#39;,true);\n  &#125;\n&#125;)\n\n attr示例\n&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; title&#x3D;&quot;baidu&quot;&gt;百度&lt;&#x2F;a&gt;\n&lt;button id&#x3D;&quot;btn&quot;&gt;点击&lt;&#x2F;button&gt;\n&lt;script&gt;\n  $(&#39;#btn&#39;).click(function () &#123;\n    console.log($(&#39;a&#39;).attr(&#39;title&#39;))\n    $(&#39;a&#39;).attr(&#39;title&#39;, &#39;百度&#39;)\n  &#125;)\n&lt;&#x2F;script&gt;\n\n2 jQuery文本操作主要涉及两个方法\n\nhtml()\ntext()\nval()\n\nhtml相当于原生的innerHTML\ntext相当于原生的innerText\nval相当于原生的value\n\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; 不带参数, 获取值\n$(&#39;选择器&#39;).html()\n\n&#x2F;&#x2F; 带参数, 设置值\n$(&#39;选择器&#39;).html(&#39;值&#39;)\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;div id&#x3D;&quot;test1&quot;&gt;1&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;test2&quot;&gt;2&lt;&#x2F;div&gt;\n&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;test3&quot; &#x2F;&gt;\n\n&lt;div&gt;\n  &lt;button id&#x3D;&quot;btn1&quot;&gt;1&lt;&#x2F;button&gt;\n  &lt;button id&#x3D;&quot;btn2&quot;&gt;2&lt;&#x2F;button&gt;\n  &lt;button id&#x3D;&quot;btn3&quot;&gt;3&lt;&#x2F;button&gt;\n&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n  $(&#39;#btn1&#39;).click(function () &#123;\n    &#x2F;&#x2F; html标签不会被解析, 原样输出\n    $(&#39;#test1&#39;).text(&#39;&lt;b&gt;Hello world!&lt;&#x2F;b&gt;&#39;)\n  &#125;)\n  $(&#39;#btn2&#39;).click(function () &#123;\n    &#x2F;&#x2F; html标签会被解析\n    $(&#39;#test2&#39;).html(&#39;&lt;b&gt;Hello world!&lt;&#x2F;b&gt;&#39;)\n  &#125;)\n  $(&#39;#btn3&#39;).click(function () &#123;\n    &#x2F;&#x2F; 修改test3中的值\n    $(&#39;#test3&#39;).val(&#39;用户名&#39;)\n  &#125;)\n&lt;&#x2F;script&gt;\n\n3 jQuery元素操作1) 添加元素有4个方法\n\nappend() - 在被选元素的内部插入子元素, 在最后\nprepend() - 在被选元素的内部插入子元素, 在最前\nafter() - 在被选元素的外部插入兄弟元素, 在后面\nbefore() - 在被选元素的外部插入兄弟元素, 在前面\n\n2) 删除元素如需删除元素和内容，一般可使用以下两个方法：\n\nremove() - 删除被选元素（及其子元素）\nempty() - 从被选元素中删除子元素\n\n\n\n\n\n\n\n\n\n\n案例: Todolist\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.5.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;style&gt;\n      * &#123;\n        margin: 0;\n        padding: 0;\n      &#125;\n      li &#123;\n        list-style: none;\n      &#125;\n      a &#123;\n        text-decoration: none;\n      &#125;\n      .todo &#123;\n        width: 400px;\n        margin: 50px auto;\n      &#125;\n      .todo .header &#123;\n        padding: 0 20px;\n        &#x2F;* height: 40px; *&#x2F;\n        line-height: 40px;\n        color: #fff;\n        background-color: skyblue;\n      &#125;\n      .todo .header input &#123;\n        height: 30px;\n        padding-left: 10px;\n        color: #333;\n        border: none;\n        outline: none;\n      &#125;\n      .todo .list &#123;\n        min-height: 100px;\n        margin-top: 20px;\n        border: 1px solid #ccc;\n      &#125;\n\n      .todo .list li &#123;\n        margin: 10px 0;\n        padding: 5px 20px;\n        background-color: #eee;\n      &#125;\n      .todo .list p &#123;\n        display: inline-block;\n        width: 200px;\n      &#125;\n      .todo .list a &#123;\n        float: right;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;todo&quot;&gt;\n      &lt;div class&#x3D;&quot;header&quot;&gt;\n        添加待办: &lt;input id&#x3D;&quot;add&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按回车添加待办&quot; &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;list&quot;&gt;\n        &lt;ul&gt;&lt;&#x2F;ul&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      &#x2F;&#x2F; 添加操作\n      $(&#39;#add&#39;).keyup(function (e) &#123;\n        if (e.keyCode &#x3D;&#x3D; &#39;13&#39;) &#123;\n          &#x2F;&#x2F; 得到add的值\n          var todo &#x3D; $(&#39;#add&#39;).val()\n\n          if (!todo) return\n\n          &#x2F;&#x2F; 创建元素\n          $(&#39;.list&#39;)\n            .find(&#39;ul&#39;)\n            .prepend(&#96;&lt;li&gt;&lt;p&gt;$&#123;todo&#125;&lt;&#x2F;p&gt;&lt;a href&#x3D;&quot;#&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#96;)\n\n          $(&#39;#add&#39;).val(&#39;&#39;)\n        &#125;\n      &#125;)\n\n      &#x2F;&#x2F; 修改操作\n      $(&#39;ul&#39;).on(&#39;click&#39;, &#39;p&#39;, function () &#123;\n        var p &#x3D; $(this)\n        var todo &#x3D; p.text()\n        var input &#x3D; $(&#96;&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;$&#123;todo&#125;&quot;&#x2F;&gt; &#96;)\n\n        p.html(input)\n\n        input.click(function () &#123;\n          input.focus()\n          return false\n        &#125;)\n\n        input.blur(function () &#123;\n          var newTxt &#x3D; $(this).val()\n          p.html(newTxt)\n        &#125;)\n        input.keyup(function (e) &#123;\n          if (e.keyCode &#x3D;&#x3D; &#39;13&#39;) &#123;\n            var newTxt &#x3D; $(this).val()\n            p.html(newTxt)\n          &#125;\n        &#125;)\n      &#125;)\n\n      &#x2F;&#x2F; 删除操作\n      $(&#39;ul&#39;).on(&#39;click&#39;, &#39;a&#39;, function () &#123;\n        $(this).parent().remove()\n      &#125;)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n","slug":"jQuery","date":"2022-12-01T12:37:29.091Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"fbfddebc2434ce626b9f5720fcc8dd42","title":"17_juery基础语法_选择器","content":"JS回顾DOM\n\t概念\n\t\t文档对象模型,定义了查找,新增,修改,删除元素的标准\n\t获取\n\t\tquerySelector()\n\t\tquerySelectorAll()\n\t操作元素\n\t\t操作属性\n\t\t\t元素对象.属性名\n\t\t操作标签体\n\t\t\t元素对象.innerHTML\n\t\t操作样式\n\t\t\t元素对象.style.样式属性名(单独)\n\t\t\t元素对象.className\n\t操作节点\n\t\t创建元素节点\n\t\t\tcreateElement()\n\t\t添加节点\n\t\t\tappendChild()\n\t\t\tinsertBefore()\n\t\t删除节点\n\t\t\tremoveChild()\n\t事件\n\t\t三个要素\n\t\t\t事件源\n\t\t\t事件\n\t\t\t事件处理程序\n\t\t三个步骤\n\t\t\t写一个事件源\n\t\t\t写一个事件处理程序\n\t\t\t绑定事件源和事件处理程序\n\t\t事件注册\n\t\t\t传统方式  使用属性 \n\t\t\tH5方式   调用方法 \n\t\t常见事件\n\t\t\t点击 click\n\t\t\t焦点 blur\n\t\t\t鼠标移入移出  mouseover\n\t\t\t键盘事件 keydown  keyup keypress\n\t\t\t页面加载事件 load   自学\n\t\t\t内容改变事件 change\n\t\t\t表单提交事件 submit\n\t\t事件对象\n\t\t\t概念\n\t\t\t\t触发事件的时候,就会产生一个事件对象,这个事件对象包含了当前事件所有信息\n\t\t\t属性\n\t\t\t\ttarget\t返回触发此事件的元素（事件的目标节点）。\n\t\t\t\ttype\t返回当前 Event 对象表示的事件的名称。\n\t\t\t\tkeyCode\t返回键盘事件触发的键的值的字符代码\n\t\t\t方法\n\t\t\t\tpreventDefault()\t通知浏览器不要执行与事件关联的默认动作。\n\t\t\t\tstopPropagation()\t不再派发事件。\nBOM\n\t概念\n\t\t浏览器对象模型\n\t组成\n\t\twindow\n\t\t\t定时器相关\n\t\t\t\tsetTimeout clearTimeout()\n\t\t\t\tsetInterval clearInterval()\n\t\t\t弹框相关\n\t\t\t\talert()\n\t\t\t\tprompt()\n\t\t\t\tconfirm()\t显示带有一段消息以及确认按钮和取消按钮的对话框。\n\t\tlocation\n\t\t\t属性\n\t\t\t\thref 设置或者获取跳转的路径\n\t\t\t方法\n\t\t\t\treload 刷新\n\t\thistory\n\t\tscreen\n\t\tnavigator\n\n\n\nJquery概念概念\n\t一个js的函数库,对原生的js进行了封装,可以处理兼容性问题,方便对dom的操作\n作用\n\tHTML 元素选取\n    HTML 元素操作\n    CSS 操作\n    HTML 事件函数\n    JavaScript 特效和动画\n    HTML DOM 遍历和修改\n    AJAX\n\n\n\n入门案例引入方式\n\t1,本地引入(先下载,然后在页面中引入本地文件)\n\t2,网络引入(直接在页面中引入网络地址),推荐\n\t&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.6.0&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\t\n相关语法\n\t$(&#39;选择器&#39;) 选择元素,将来这元素就是jquery对象\n\thide()  显示隐藏的方法,jquery对象里面的方法\n\t$(匿名函数)  jquery的入口函数,可以实现在页面加载完成之后,执行匿名函数中的代码\n\n\n\n基础语法$的含义\n\tjQuery的别名,方法名的别名,是jquery语法的标志,可以简化我们的书写\n\t\njquery对象和dom对象(原生的js对象)区别\n\t来源方面\n\t\tdom对象主要是通过document获取的\n\t\tjquery对象是通过$(选择器)来获取的\n\t调用机制\n         dom对象本质是操作元素的属性\n         jquery对象本质是调用方法\n     \t 两者是不能混用的\n     \t \njquery对象和dom对象的转换\n\tdom对象 --&gt; jquery对象  $(dom对象)\n\tjquery对象 --&gt; dom对象  jquery对象[0] 或者 jquery对象.get(0)\n\t\njquery事件的入门\n\t格式\n       jq对象.方法名(匿名函数)\n\t   将来事件发生之后要进行操作写在匿名函数中就行了\n\n\n\n选择器1,使用和css通用的选择器来选择器元素\n\t基本选择器\n\t\tid选择器\n\t\t类选择器\n\t\t元素选择器\n\t复合选择器\n\t\t并集选择器\n\t\t交集选择器\n\t\t后代选择器\n\t\t子选择器\n\t筛选选择器\n\t\t:first\n\t\t:last\n\t\t:even\n\t\t:odd\n\t\t\n2,jquery自带的筛选方法\n\tfirst() 第一个\n\tlast()最后一个\n\tparent() 父元素\n\tchildren() 子元素\n\tfind() 查找后代元素\n\tsiblings()其他兄弟元素\n\n","slug":"day17_课堂笔记","date":"2022-12-01T12:11:52.967Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"ab2246c1172434c6023a55b8c939a44f","title":"16_事件对象_BOM","content":"昨日回顾DOM\n\t文档对象模型\n\t\t加载html文件的时候,浏览器将html文档封装成一个树形结构\n\t\tdocument-html-head,body 形成dom树\n\t作用\t\n\t\t定义了如何获取,操作元素属性(样式),添加和删除元素的规范\n\t思想\n\t\t把html页面中的各个组成部分,抽成对象,以面向对象的方式来操作\n获取元素\n\t获取单个\n\t\tdocument.getElementById()\n\t\tdocument.querySelector(选择器)\n\t获取多个\n\t\tdocument.getElementsByTagName()\n\t\tdocument.getElementsByClassName()\n\t\tdocument.querySelectorAll(选择器)\n操作元素\n\t1,操作属性\n\t\t设置\n\t\t\t元素对象.属性名 &#x3D; 属性值\n\t\t获取\n\t\t\t元素对象.属性名\n\t2,操作标签体\n\t\t设置\n\t\t\t元素对象.innerHTML &#x3D; 属性值\n\t\t获取\n\t\t\t元素对象.innerHTML\n\t3,操作样式\n\t\t单独设置\n\t\t\t元素对象.style.属性名 &#x3D; 属性值\n\t\t批量设置\n\t\t\t元素对象.className &#x3D; class值\n事件\n\t三个要素\n\t\t事件源\n\t\t事件\n\t\t事件处理程序\n\t三个步骤\n\t\t写一个事件源\n\t\t写一个监听器\n\t\t绑定事件源和监听器\n\t常见事件\n\t\t点击事件\n\t\t\tonclick\n\n\n\n节点操作概念\n\t在 HTML DOM (Document Object Model) 中 , 每一个元素都是 节点:\n\n    文档是一个文档节点。\n    所有的HTML元素都是元素节点。\n    所有 HTML 属性都是属性节点。\n    文本插入到 HTML 元素是文本节点\n    注释是注释节点。\n    \n操作\n\t创建元素节点\n\t\tdocument.createElement() 创建元素节点。\n\t添加节点\n\t\telement.appendChild()\t为元素添加一个新的子元素\n\t\telement.insertBefore()\t现有的子元素之前插入一个新的子元素\n\t删除节点\n\t\telement.removeChild()\t删除一个子元素\n\n\n\n其他事件点击事件\n\tonclick\n焦点事件\n\t获取焦点 onfocus\n\t失去焦点 onblur\n鼠标移入移出事件\n\tonmouseover\t鼠标移到某元素之上。\n\tonmouseout\t鼠标从某元素移开。\n\n\n\n事件对象概念\n\t事件发生之后,跟事件相关的一系列信息数据的集合都会被放到这个对象中,这个对象就是事件对象\n\t比如\n\t\t1,谁绑定了这个事件\n\t\t2,如果是鼠标触发事件,可以得到鼠标相关信息,比如鼠标的位置\n\t\t3,如果是键盘触发事件,可以得到键盘相关信息,比如按了那个键\n获取\n\t事件触发的时候就会产生事件对象,并且系统会以实参的形式传递给事件处理函数\n\t我们可以在事件处理函数中声明一个参数来接收事件对象\n\n作用\n\t1,可以获取当前事件的类型(e.type)\n\t2,在键盘事件中可以获取按了哪个键(e.keycode)\n\t3,可以阻止某些标签的默认行为(e.preventDefault())\n\t4,可以获取具体点击了哪一个子元素(e.target)\n\t5,可以阻止事件冒泡(e.stopPropagation())\n\t\n事件冒泡\n\t由于事件有传递性的,最开始是由最具体的元素接收,然后逐级向上传播到DOM的最顶层节点\n阻止事件冒泡\n\t有些情况下,我们只想让最具体的元素接收,而不想让事件向上传播,就可以使用e.stopPropagation()阻止事件冒泡\n\n\n\nBOM简介概念\n\t浏览器对象模型(Browser Object Model)\n作用\n\t使 JavaScript 有能力与浏览器&quot;对话&quot;。(操作浏览器)\n\t例如:弹框,新建一个窗口,跳转到其他窗口,实现定时操作\n组成\n\twindow\n\t\t窗口对象  表示浏览器窗口\n\tscreen \n\t\t屏幕对象  包含有关用户屏幕的信息\n\tlocation \n\t\t地址栏对象 用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。\n\thistory \n\t\t历史记录对象  包含浏览器的历史。\n\tnavigator \n\t\t浏览器对象   包含有关访问者浏览器的信息\n操作思想\n\t将浏览器的各个组成部分抽成对象,以面向对象的方式来操作(对象有属性和方法),提高开发效率\n\n\n\nwindow对象概念\n\t窗口对象\n\t包含页面中的很多东西(变量,函数,弹框,document等)\n方法\n\t定时一次\n\t\tsetTimeOut() 清除clearTimeout()\n\t循环定时\n\t\tsetinterval() 清除clearInterval()\n\n\n\nlocation对象概念\n\t地址栏对象,可以实现刷新和跳转\n属性\n\t href\n     \t设置\n     \t\tlocation.href &#x3D; 新的地址\n\t\t获取\n\t\t\tlocation.href   返回完整的url地址\n\n方法         \n\treload()  刷新\n\n","slug":"day16_课堂笔记","date":"2022-12-01T12:09:51.872Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"1a1853128f85ed795b64680874636106","title":"15_DOM概念_事件_操作元素","content":"昨日回顾面向对象\n\t类和对象\n\t内存执行情况\n内置类(自带的类)\n\tMath类\n\t\tPI\n\t\tmax()\n\t\tmin()\n\t\tabs()\n\t\tceil()\n\t\tfloor()\n\t\tround()\n\t\trandom()\n\t\tMath.floor(Math.random()*[max-min+1])+min\n\tDate类\n\t\tnew Date(参数列表)\n\t\tgetFullYear()\n\t\tgetMonth\n\t\t...\n\t\tgetTime()\n\tArray类\n\t\tpush() pop()\n\t\tsplice()\n\t\tsort()\n\t\treverse()\n\t\tindexOf()\n    Sting类\n    \tindexOf()\n    \tcharAt()\n    \tsubStr()\n    \treplace()\n\nDOM概念DOM:文档对象模型（Document Object Model）的简称\n\n文档对象模型\n\t当网页被加载时，浏览器会创建页面的文档对象模型\n\t这个模型是一个树形的结构,最上面是document文档对象,下面是根标签RootElement(HTML)\n\t然后依次往下展开,就形成了一个树形的结构\n\t\nDOM作用\n\t通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素\n\tJavaScript 能够改变页面中的所有 HTML 元素\n    JavaScript 能够改变页面中的所有 HTML 属性\n    JavaScript 能够改变页面中的所有 CSS 样式\n    JavaScript 能够对页面中的所有事件做出反应\n    \nDOM操作页面元素的思想\n\t就是将html页面中的所有组成部分(标签,属性,标签体,注释)都抽取成对象,用面向对象的方式来操作\t 因为对象中有属性和方法,比单纯操作字符串方便的多\n\t\nDocument 对象\n\t是js的一个内置对象,不需要new去创建,直接写,就能使用\n\t当浏览器载入 HTML 文档, 它就会成为 Document 对象。\n\tDocument 对象是 HTML 文档的根节点。\n\tDocument 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。\n\n\n\nDOM获取元素其实就是使用 document对象的方法来获取元素\n\n获取单个元素\n\tdocument.getElementById(id的值)  \n获取多个元素\n\tdocument.getElementsByTagName()\t返回带有指定标签名的对象集合。\n\tdocument.getElementsByClassName()\t返回文档中所有指定类名的元素集合\nH5新增\n\tdocument.querySelector() 返回文档中匹配指定的CSS选择器的第一元素\n    document.querySelectorAll() 返回文档中匹配的CSS选择器的所有元素节点列\n\n事件入门三个要素\n\t1,事件源(发生事件的那个东西)\n\t2,事件(触发的具体事情)\n\t3,事件处理程序(事件发生之后需要做的事情)\n\t\n\t例如:点击一个按钮,弹出一个消息框\n\t\t事件源:按钮\n\t\t事件:点击这件事情\n\t\t事件处理程序:点击之后弹出的消息(就是执行一个方法)\n\t\t\n三个步骤\n\t1,写一个事件源(写一个按钮)\n\t2,写一个监听器(事件处理程序,一个函数)\n\t3,绑定监听器和事件源(通过一个属性将二者绑定到一块)\n\n\n\nDOM操作属性设置\n\t元素对象.属性名 &#x3D; 属性值\n获取\n\t元素对象.属性名\n\n例如\n\t操作图片的src属性\n\t操作input的value属性\n\t操作input的checked属性\n\nDOM操作标签体innerHTML\n\t设置\n\t\t元素对象.innerHTML &#x3D; 值\n\t获取\n\t\t元素对象.innerHTML\n\t\t\ninnerText(操作的是纯文本)\n\t设置\n\t\t元素对象.innerText &#x3D; 值\n\t获取\n\t\t元素对象.innerText\n\nDOM操作样式一次设置一种样式\n\t元素对象.style.属性名称 &#x3D; 属性值\n\t\n批量设置样式\n\t元素对象.className &#x3D; class属性值\n\n","slug":"day15_课程笔记","date":"2022-12-01T12:08:50.709Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"fe2db7f298638367464a243c91a60f0e","title":"14_Math_Date_Array_String","content":"昨日回顾数组\n\t概念\n\t\t容器,存储数据\n\t定义和初始化\n\t\tvar arr1 &#x3D; new Array()\n\t\tvar arr2 &#x3D; new Array(1,2,3)\n\t\tvar arr3 &#x3D; [1,2,3]\n\t增\n\t\tarr[新的索引] &#x3D; 值\n\t删\n\t\tdelete arr[索引]\n\t改\n\t\tarr[索引] &#x3D; 值\n\t查\n\t\tarr[索引]\n\t\tarr.length\n\t其他操作\n\t\t遍历\n\t\t求和\n\t\t求最值\t\n函数\n\t概念\n\t\t封装了一段具有特定功能的代码块\n\t使用\n\t\t先定义 在调用\n\t格式\n\t\tfunction 函数名(参数列表)&#123;\n\t\t\t函数体\n\t\t\treturn 要返回的数据\n\t\t&#125;\n\t参数\n\t\t想当于一个媒介,调用就可以通过它将要操作的数据传递到函数内部进行操作\n\t返回值\n\t\t调用者可以通过它拿到函数执行的结果,进行下一步操作\n\t获取函数的参数的数组\n\t\targuments 内置对象\n\t分类\n\t\t命名函数\n\t\t匿名函数\n\n面向对象\n\t概念\n\t\t是一种思维方式,重在找对象,找不同的对象,找合适的对象,帮我们去做事情\n\t类\n\t\t对现实生活中具有相同属性和行为的事物的一个统称\n\t对象\n\t\t类中的一个具体存在\n\t类的三要素\t\n\t\t类名 属性  行为\n\n\n\nMath对象概念\n\t算术相关的对象\n属性\n\tMath.PI\n方法\n\tmax()\n\tmin()\n\tabs()\n\tceil()\n\tfloor()\n\tround()\n生成随机数\n\trandom() [0,1)\n\tMath.floor(Math.random()*(max-min+1))+min  生成[min,max]随机数\n\n\n\nDate对象概念\n\tDate 对象用于处理日期与时间。\n创建\t\n\tnew Date()\n\tnew Date(年,月,日)\n\tnew Date(&#39;日期类型的字符串&#39;)\n获取年月日\n\tgetFullYear()\n\tgetMonth()\n\tgetDate()\n\tgetDay()\n获取时分秒\n\tgetHours()\n\tgetMinutes()\n\tgetSeconds()\n获取毫秒值(从1970年开始)\n\tgetTime()\t返回 1970 年 1 月 1 日至今的毫秒数。\n\tvalueOf()\t返回 Date 对象的原始值。(原始值返回1970年1月1日午夜以来的毫秒数！)\n\n\n\nArray对象创建\n\tnew Array(长度)\n\tnew Array(元素1,元素2...)\n方法\n\tpush()\n\tpop()\n\tsplice()\n\tsort()\n\treverse()\n\tindexOf()\n\n\n\nString对象拼接\n\tconcat()\n查找索引\n\tindexOf\n查找字符\n\tcharAt()\n截取\n\tsubStr()\n\tsubString()\n替换\n\treplace()\n","slug":"day14_课堂笔记","date":"2022-12-01T12:07:16.863Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"b243feace6810f027b0a43495f082861","title":"13_数组_函数_面向对象","content":"昨日回顾选择语句\n\tif\n\t\tif\n\t\tif-else\n\t\tif-else-if\n\tswitch\n\t\t语法\n\t\t\tswitch(变量&#x2F;表达式)&#123;\n\t\t\t\tcase 值1:\n\t\t\t\t\t语句1\n\t\t\t\t\tbreak\n\t\t\t\tcase 值2:\n\t\t\t\t\t语句2\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\t语句\n\t\t\t\t\tbreak\n\t\t\t&#125;\n\t\t穿透\n\t\t\t原因:忘记写break\n\t\t\t好处:利用穿透简化代码\n\t应用场景\n\t\tif主要做范围的判断,switch主要用于等值判断\n循环语句\n\tfor循环\n\twhile循环\n\tdo-while循环\n\n\t区别\n\t\tfor,while先判断条件,在执行循环体\n\t\tdo-while先执行循环体,再判断条件\n\t应用场景\n\t\t循环次数确定使用for循环,次数不确定用while循环\n关键字\n\tbreak 终止循环\n\tcontinue 跳过本次循环,继续下一次循环\n\n\n\n数组概念\n\t存放数据的容器,方便管理数据(本质是引用数据类型)\n定义和初始化\n\tvar arr1 &#x3D; []&#x2F;&#x2F;空数组\n\tvar arr2 &#x3D; [1,2,3]&#x2F;&#x2F;创建的同时赋值\n增\n\tarr[新的索引] &#x3D; 值\n删\n\tdelete arr[要删除的索引]\n改\n\tarr[要修改的索引] &#x3D; 值\n查\n\t取值 arr[索引]\n\t长度 arr.length\n遍历\n\t普通for循环\n求和\t\n\t遍历累加\n求最值\n\t遍历进行比较\n二维数组\n\t概念\n\t\t本质还是一个数组,只不过是里面元素是一维数组\n\t取值\n\t\tarr[索引1] 取得是里面的一维数组\n\t\tarr[索引1][索引2]  取得是里面的一维数组的具体的元素\n\t遍历\n\t\t双重for循环\n\n\n\n函数概念\n\t封装了一段具有特定功能的代码块\n作用\n\t方便用户重复调用\n使用\n\t先定义,再调用\n参数\n\t就相当于一个媒介,调用者可以通过它将要操作的数据传递到函数内部进行操作,提高了程序的灵活性\n返回值\n\t将函数操作完的数据返回给调用者,将来调用者拿到数据之后就可以进行其他操作\n数组作为函数参数\n\t形式参数:任意的变量名 \n\t实际参数:传一个数组名,或者直接把数组传进去([1,2,3])\n在函数内部获取函数的参数\n\t通过一个变量argument获取,是一个伪数组\n分类\n\t命名函数\n\t匿名函数\n注意点\n\t1,如果函数没有显示的调用return,函数就没有返回值\n\t2,函数名代表整个函数\n\t3,实参的个数小于形参,多余的形参就不会被赋值,就是undefined\n\n\n\n面向对象面向过程和面向对象\n\t面向过程:完成一件事需要多少个步骤(重点关注的是步骤)\n\t面向对象:完成一件事需要多少个对象(重点关注的是对象,找合适的对象,帮我们去做)\n\n类和对象存在的意义\n\t就是使用代码来描述现实生活中的事物,进行编程(编程来源于生活)\n类的概念\n\t对现实生活中具有相同属性和行为的事物的一个统称(抽象的,相当于模板)\n对象的概念\n\t现实生活中的一个具体存在(具体的,通过模板创建出来的)\n类和对象的关系\n\t类相当于模板,对象就是通过这个模板创建出来的一个个真实存在的个体\n\t类中有什么,对象中就有什么,不会多也不会少\n类的定义\n\tfunction 类名(参数1,参数2)&#123;\n\t\t&#x2F;&#x2F;定义属性\n\t\tthis.属性1 &#x3D; 参数1\n\t\tthis.属性2 &#x3D; 参数2\n\t\t\n\t\t&#x2F;&#x2F;定义方法\n\t\tthis.方法名 &#x3D; function()&#123;\n\t\t\t方法体\n\t\t&#125;\n\t&#125;\n\t\n对象的创建\n\tvar 对象名 &#x3D; new 类名(实际参数1,实际参数2)\n\t\n调用属性和方法\n\t对象名.属性\n\t对象名.方法名(参数)\n\n","slug":"day13_课堂笔记","date":"2022-12-01T12:02:48.954Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"16735bd04b2de2188f178596bcaf05be","title":"12_选择循环语句","content":"昨日回顾概念\n\t运行在客户端的脚本语言\n作用\n\t校验表单\n\t网页行为\n\t服务端开发\n组成\n\tECMAScript基础语法\n\tDOM 文档对象模型\n\tBOM 浏览器对象模型\n引入方式\n\t内嵌式\n\t外链式\n变量\n\t概念\n\t\t其实就是内存中存取数据的那块空间\n\t作用\n\t\t存储变化的数据\n\t使用\n\t\t先定义在初始化\n\t\t定义同时初始化\n数据类型\n\t分类\n\t\t基本数据类型\n\t\t\t数值\n\t\t\t字符串\n\t\t\tboolean类型\n\t\t\t未定义\n\t\t\tnull\n\t\t引用数据类型\n\t\t\t数组 正则\n\t转换\n\t\t强制转换\n\t\t\tString()\n\t\t\tNumber()\n\t\t\tBoolean()  0 null undefined &#39;&#39; ---&gt; false\n\t\t自动转换\n\t\t\ttrue false null在运算的时候会自动转成数值\n\t\t\t字符串+ \n运算符\n\t算术运算符\n\t自增自减运算符\n\t\t++ 在前,先加1再运算\n\t\t++ 在后,先运算再加1\n\t比较运算符\n\t\t&gt; &lt; &#x3D;&#x3D; !&#x3D;\n\t逻辑运算符\n\t\t&amp;&amp; || !\n\t\t结果是boolean类型\n\t\t短路问题,提高效率\n\t三元运算符\n\t\t表达式1 ? 表达式2 : 表达式3\n\t赋值运算符\n\t\t基本 &#x3D; \n\t\t扩展 +&#x3D; -&#x3D; \n\n流程控制根据代码的结构情况分类\n\t顺序结构:从上到下依次执行\n\t选择结构:选择性的执行某些语句\n\t\tif语句\n\t\tif-else语句\n\t\tif-else-if语句\n\t\tswitch语句\n\t循环结构:根据条件重复的执行某些语句\n\t\tfor循环\n\t\twhile循环\n\t\tdo-while循环\n\t\n目标\n\t1,搞清楚每个结构的语法\n\t2,搞清他们的执行流程\n\t3,搞清他们的应用场景\n\n选择语句if语句\n\tif(条件表达式)&#123;\n\t\t语句体\n\t&#125;\n\t\nif-else语句\n\tif(条件表达式)&#123;\n\t\t语句体1\n\t&#125;else&#123;\n\t\t语句体2\n\t&#125;\n\t\nif-else-if语句\n\tif(条件表达式1)&#123;\n\t\t语句体1\n\t&#125;else if(条件表达式2)&#123;\n\t\t语句体2\n\t&#125;else if(条件表达式3)&#123;\n\t\t语句体3\n\t&#125;else if(条件表达式4)&#123;\n\t\t语句体4\n\t&#125;\n\t...\n\telse&#123;\n\t\t语句体2\n\t&#125;\n\t\nswitch语句\n\tswitch(表达式)&#123;\n        case 值1:\n            执行代码块 1\n            break;\n        case 值2:\n            执行代码块 2\n            break;\n        default:\n            与 case 1 和 case 2 不同时执行的代码\n    &#125;\n    \n 区别\n \tif语句和if-else语句,只能判断一个条件, if-else-if和switch可以判断多个条件\n \t所有switch语句都可以使用if-else-if改写,但是if-else-if语句不一定能够使用switch改写\n \tif语句只要用于范围的判断,switch主要用于等值判断(结果只有固定的几个取值,可以使用switch)\n\n\n\n循环语句for循环\n\tfor(初始化语句;条件判断语句;循环增量语句)&#123;\n\t\t循环体语句\n\t&#125;\n\nwhile循环\n\t基本格式\n\t\twhile(条件)&#123;\n           循环体语句\n        &#125;\n     完整格式\n     \t初始化语句\n        while(条件判断语句)&#123;\n        \t循环体语句\n        \t循环增量语句\n        &#125;\n\ndo-while循环\n \t基本格式\n\t\tdo&#123;\n           \t循环体语句\n        &#125;while(条件)\n        \n    完整格式\n        初始化语句\n        do&#123;\n        \t循环体语句\n        \t循环增量语句\n        &#125;while(条件判断语句)\n        \n区别\n\tfor循环和while循环\n\t\t先判断循环条件,在执行循环体\n\twhile循环\n\t\t先执行循环体,再判断循环条件(不管条件是否成立,都会先执行一次循环体)\n\t\t\n使用场景\n\t循环次数确定,建议使用for循环,结构简单紧凑\n\t循环次数不确定,但是循环条件确定,建议使用while循环\n\n\n\n循环关键字continue\n\t用于跳过循环中的一个迭代。(跳过当前循环,继续下一次循环)\n\nbreak\n\t用于跳出循环。\n\n","slug":"day12课程笔记","date":"2022-12-01T11:54:51.613Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"415519e90c14ac35f714ee5f282d32fe","title":"JavaScript基础","content":"一. JavaScript简介1 JS的发展历程回顾整个JavaScript的发展历程, 实际上就是Web发展的历程\n从最开始的拨号上网方式到现在的100M光纤, 4G/5G移动Web的发展\n在近20年, 上网的方式发生了翻天复地的变化, 可以说是科技大爆炸.\n人们在享受越来越便捷的上网的同时, 对Web产品的需求越来越高\n从单纯的对访问速度的需求, 越来越多的转移到视觉美感, 智能操作交互, 沉浸式虚拟现实, 这些需求又反过来推动了技术的不断创新与进步.\n1) JS的诞生在互联网初期(20世纪90年代) —-web1.0\n主要通过拨号上网的方式浏览网页, 提交信息. 上网的速度只有28.8 kbit/s\nJavaScript最初是网景公司的工程师Brandan Eich花了10天的时间设计出来的, 主要是为了在浏览器上先验证用户输入的信息是否符合格式. \n\n\n\n\n\n\n\n\n\n为什么要这样做呢?\n因为当时的网络是非常慢的, 如果用户填写了大量的信息, 提交到服务器, 在服务器端验证发现不合格, 用户要再次重新填写, 这个是很让人抓狂的. \n设想一下，用户填完一个表单，点击提交按钮，等待了 30 秒的处理后，看到的却是一条告诉你忘记填写一个必要的字段\n最开始的时候, Eich把自己设计的这种运行在浏览器上的脚本叫做liveScript, 在发布的时候为了蹭Java的热度, 就改名叫做JavaScript, 实际上跟Java没有半毛钱关系\n2) JS的成长在PC互联网(2010年之前)—-web2.0\n这个时候, 个人电脑PC开始普及, 网络速度突飞猛进, 上网的成本越来越低\n人们开始大量的使用PC访问web应用, 包括: \n\nblog(博客)–新浪\nRSS(订阅)\n社交网络(SNS)–FaceBook/人人网\nP2P(下载)–迅雷\n搜索引擎–Google/baidu\n即时通讯(IM)–QQ\n电子商务–Taobao\n\n在这个时代, JavaScript都只是一种不起眼的小脚本, 没有人把他当成真正的编程语言.\n JavaScript在这个时候依然只是用来处理PC网页的简单动画和验证, 也没有单独的前端岗位, 大部分前端的工作都是由php程序员或者UI人员完成的\n3) JS的新生\n\n\n\n\n\n\n\n\nweb3.0\n随着乔帮主推出的IPhone智能手机, 改变了人们的生活方式\n以智能手机为代表的移动互联网应运为生, 称为web3.0\n\n\n\n\n\n\n\n\n\nHTML5与CSS3\n到2015年左右, HTML5和CSS3的标准化, 大大推进了前端的发展\n前端做为一个独立的方向真正开始被重视\n\n\n\n\n\n\n\n\n\nECMA2015\n在2015年, JavaScript的规范组织ECMA(欧洲计算机制造商协会)推出了ECMA2015, 也被称为ES6\n这一版本的出现, 极大的改进了JavaScript语言, 使得JavaScript具备开发大型项目的能力\n\n\n\n\n\n\n\n\n\nV8引擎与Node.js\nChrome推出的V8引擎将JavaScript的速度提升了几个数量级\nNode.js的出现, 完善了JavaScript在服务端的能力, 使得JavaScript编写服务端程序作为可能\n\n\n\n\n\n\n\n\n\n未来的发展\n自2016年以来, 前端发展非常迅速,  开源社区越来越活跃, 出现了大量的工作岗位, 薪资也水涨船高\nJavaScript现在应用的范围越来越广\n\n微信小程序\nH5游戏\n桌面应用(Electron)\nwebApp\nAI+物联网( AIot)\n\n\n2  JS的组成一般认为JavaScript由三部分组成\n\nECMAScript: 基础语法\nDOM: 文档数据模型\nBOM: 浏览器对象模型\n\n\n1) ECMAScriptECMAScript 是由ECMA（ 原欧洲计算机制造商协会）进行标准化的一门编程语言, 主要规定了像变量, 数据类型, 流程控制, 函数等基础语法\n2) DOM和BOMW3C: 万维网联盟 (World Wide Web Consortium) 主要是完成HTML和CSS及浏览器标准化的研究, 是一个非盈利性的公益组织, 主要由大公司和开发人员组成\n其中, \n\nDOM是由W3C组织制定的标准, 通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色、事件等）\nBOM是由各个浏览器厂商根据DOM在各自浏览器上的实现, 不同的浏览器会略有差异, 通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等\n\n3 JS的写在哪里跟CSS一样, JS也有3种书写方式\n\n外部: 将JS文件单独保存, 再通过&lt;script src=&quot;xxx.js&quot;&gt;引入\n内嵌: 在HTML文件中, 将JS代码写在&lt;script&gt;标签中\n行内: 现在几乎不用\n\n\n\n\n\n\n\n\n\n\n示例\n外部\n&lt;script src&#x3D;&quot;my.js&quot;&gt;&lt;&#x2F;script&gt;\n\n内嵌\n&lt;script&gt;\n  alert(&#39;Hello  World~!&#39;)\n&lt;&#x2F;script&gt;\n\n在实际工作中, 通常将js代码写在文件中, 再使用外部方式引入.\n在学习阶段, 为了调试方便, 主要采用内嵌的方式\n4 体验JS为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：\n\n\n\n方法\n说明\n归属\n\n\n\nalert(msg)\n浏览器弹出警示框\n浏览器BOM\n\n\nconsole.log(msg)\n浏览器控制台打印输出信息\n浏览器BOM\n\n\nprompt(info)\n浏览器弹出输入框，用户可以输入\n浏览器BOM\n\n\n\n注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n\n  &lt;body&gt;\n    &lt;script&gt;\n      &#x2F;&#x2F; 这是一个输入框\n      var name &#x3D; prompt(&#39;请输入您的姓名&#39;)\n      &#x2F;&#x2F; alert 弹出警示框 输出的 展示给用户的\n      alert(name + &#39; 你好!&#39;)\n      &#x2F;&#x2F; console 控制台输出 给程序员测试用的\n      console.log(&#39;我是程序员能看到的:&#39; + name)\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n\n调试技巧\n在Chrome浏览器中, 使用F12或者Ctrl+Shift+I打开调试窗口, 在console控制台中查看\n\n在控制台中, 也可以编写JS的代码\n\n二. 变量1 什么是变量变量是一个存放数据的容器(盒子), 由变量名和变量值组成\n就好比, 通过房间号(变量名)可以找到某个人(变量值)\n\n\n\n\n\n\n\n\n\n\n扩展\n变量是程序在内存中申请的一块用来存放数据的空间\n2 变量的使用1) 变量的声明\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; var 变量名\nvar uname\nvar age\n\n\nvar ( variable )是一个 JS关键字, 用来声明变量, 后面跟变量名\nuname/age就是变量名, 计算机通过这个名字就可以找到对应的内存空间, 进而访问到空间里的数据\n\n2) 变量的赋值\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; 变量名 &#x3D; 变量值\nage &#x3D; 10  &#x2F;&#x2F; 将数值10放到age对应的空间\n\n3) 声明的同时赋值\n\n\n\n\n\n\n\n\n示例\nvar age &#x3D; 18\n\n变量可以重新赋值, 新值会覆盖旧值\nage &#x3D; 81\n\n\n\n\n\n\n\n\n\n\n注意\n一般, 变量先声明再使用\n3 变量命名规则在JS中, 变量的命名是有一定的规则的\n\n标识符: 由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name\n变量名严格区分大小写, 如 app和App是两个不同的变量\n不能以数字开头\n不能是 关键字 或者 保留字\n\n推荐使用 驼峰法 (首字母小写，后面单词的首字母需要大写)\n如: myFirstName\n4 关键字与保留字\n更多相关的内容, 参考JavaScript 保留关键字\n三. 数据类型1 什么是数据类型\n\n\n\n\n\n\n\n\n现实\n描述不同的数据时, 人们往往会使用不同的类型, 比如:\n\n姓名: 字符\n年龄: 数字\n一个命题的结论: 真假\n\n\n\n\n\n\n\n\n\n\n程序\n在程序中, 不同类型的数据在存储和传输时占用空间的大小是不同的. 因此, 会存在数据类型的区别\n\n\n\n\n\n\n\n\n\n变量的数据类型\n变量的数据类型就是在变量中保存的数据的类型\n\n\n\n\n\n\n\n\n\n示例\nvar uname &#x3D; &#39;小小胖&#39; &#x2F;&#x2F; uname变量的数据类型就是字符型\nvar age &#x3D; 1 &#x2F;&#x2F; age变量的数据类型就是数字型\n\nJavaScript是弱类型语言, 并没有严格的规定变量的类型, 换句话说, 变量的类型是可以改变的, 但是强烈不建议这么做, \n不推荐\nvar age &#x3D; 1 &#x2F;&#x2F; 初始类型是数字型\nage &#x3D; &#39;你好&#39; &#x2F;&#x2F; age现在是字符型\n\n2 常用的数据类型1) 简单数据类型\nNumber: 数字型\nString: 字符型\nBoolean: 布尔型\nUndefined: 未定义\nNull: 空\n\n\n\n\n简单数据类型\n说明\n默认值\n\n\n\nNumber\n数字型, 包含整型和小数型, 如21, 0.2333\n0\n\n\nString\n字符型, 如’张三’, 字符串带引号\n‘’(空字符)\n\n\nBoolean\n布尔型, 如true, false; 等价于1和0\nfalse\n\n\nUndefined\n未定义, 变量声明, 未赋值就是undefined\nundefined\n\n\nNull\n空\nnull\n\n\n数字型\n\n\n\n\n\n\n\n\n\n示例\nvar num &#x3D; 10 &#x2F;&#x2F; num 数字型\nvar PI &#x3D; 3.14 &#x2F;&#x2F; PI 数字型\nvar num3 &#x3D; 0xFF &#x2F;&#x2F; 0x开头的是16进制数\n\nconsole.log(Number.MAX_VALUE) &#x2F;&#x2F; 数字型的最大值\nconsole.log(Number.MIN_VALUE) &#x2F;&#x2F; 数字型的最小值\nconsole.log(Number.MAX_VALUE * 2) &#x2F;&#x2F; Infinity 无穷大\nconsole.log(-Number.MAX_VALUE * 2) &#x2F;&#x2F; -Infinity 无穷大\n\nconsole.log(&#39;小小胖&#39; - 100) &#x2F;&#x2F; NaN 非数\n\n这里注意一种特殊的数: NaN(Not a Number)非数\n字符型\n使用引号来表示一个字符串\n\n单引号, 双引号都可以, 推荐使用单引号, HTML中一般使用双引号\n引号成对使用\n\n\n\n\n\n\n\n\n\n\n示例\nvar str &#x3D; &#39;我是一个&quot;高富帅&quot;的程序员&#39;;\nconsole.log(str);\n&#x2F;&#x2F; 字符串转义字符  都是用 \\ 开头 但是这些转义字符写道引号里面\nvar str1 &#x3D; &quot;我是一个&#39;高富帅&#39;的程序员&quot;;\nconsole.log(str1);\n\n转义字符\n\n\n\n转义符\n解释说明\n\n\n\n\\n\n换行符，n   是   newline   的意思\n\n\n\\\\\n斜杠   \\\n\n\n\\&#39;\n‘  单引号\n\n\n\\&quot;\n” 双引号\n\n\n\\t\ntab  缩进\n\n\n\\b\n空格 ，b   是   blank  的意思\n\n\n\n\n\n\n\n\n\n\n\n字符串拼接\n在JavaScript中, +是一个很特别的符号, 可以用于字符串的拼接\nvar str &#x3D; &#39;hello &#39; + &#39;world&#39;\nconsole.log(str) &#x2F;&#x2F; hello world\n\n\n\nvar hello &#x3D; &#39;hello &#39;\nvar world &#x3D; &#39;world&#39;\nvar str &#x3D; hello + world\nconsole.log(str)\n\n\n\nvar str &#x3D; &#39;10&#39; + &#39;20&#39;\nconsole.log(str) &#x2F;&#x2F; 1020\n\n\n\n\n\n\n\n\n\n\n小技巧\n在Chrome调试控制台中, \n\n蓝色: 数字\n黑色: 字符\n\n\n\n\n\n\n\n\n\n\n示例\n\n布尔型\n布尔类型有两个值：true 和 false. 其中\n\ntrue 表示真\nfalse 表示假\n\nconsole.log(true);  &#x2F;&#x2F; true\nconsole.log(false); &#x2F;&#x2F; false\n\nUndefined\n一个变量声明了, 但是没有被赋值, 这时变量里会使用默认值undefined\nNull\n空, 在讲对象的时候再讲\n2) 引用数据类型\nObject: 对象\n\n关于引用数据类型是相对比较难的问题, 在后面的章节, 我们会专门来讲解\n这里, 有一句名言, 大家可以先记下来, 后面慢慢体会\n\n\n\n\n\n\n\n\n\n在JavaScript中, 一切都是对象\n3 如何判断数据类型通过typeof 可用来获取检测变量的数据类型\n\n\n\n\n\n\n\n\n\n示例\nvar num &#x3D; 18;\nconsole.log(typeof num) &#x2F;&#x2F; 结果 number\n\n4 数据类型转换1) 显式转换最常见的是字符型转数值型\n\n\n\n\n\n\n\n\n\n需求\n\n先弹出第一个输入框，提示用户输入第一个值 保存起来\n再弹出第二个框，提示用户输入第二个值 保存起来\n把这两个值相加，并将结果赋给新的变量\n弹出警示框（alert) ， 把计算的结果输出 （输出结果）\n\n\n\n\n\n\n\n\n\n\n示例\nvar num1 &#x3D; prompt(&#39;请您输入第一个值：&#39;)\nvar num2 &#x3D; prompt(&#39;请您输入第二个值：&#39;)\nvar result &#x3D; num1 + num2\nalert(&#39;您的结果是:&#39; + result)\n\n我们发现prompt返回的类型是字符型, 两个字符型相加, 其实是拼接, 并不是我们想要的结果, 这时我们需要先将字符型转换成数字型, 再运算\nvar num1 &#x3D; prompt(&#39;请您输入第一个值：&#39;)\nvar num2 &#x3D; prompt(&#39;请您输入第二个值：&#39;)\nvar result &#x3D; parseInt(num1) + parseInt(num2)\nalert(&#39;您的结果是:&#39; + result)\n\n\n第3行, 用到了一个函数, parseInt作用是将字符转换成整数\n\n更多转换函数, 参考手册: JavaScript类型转换\n2) 隐式转换\n\n\n\n\n\n\n\n\n什么是隐式转换\n隐式转换就是JS引擎偷偷将类型转换了, 不让你知道\n由于JavaScript是一种非常灵活的语言, 导致数据类型存在大量隐式转换, 这里面有很多坑.\n我不打算在这里细讲, 这对初学者来说是个灾难. 但是一些技术的面试题里又特别喜欢扣这些细节\n因此, 我们先知道这里有坑, 再后续的面试准备课时, 我们会做一个专题专门来针对性的练习\n这些问题, 说实话, 在真实的工作中遇到的概率极低, 但是在面试中(尤其是笔试)中考查的很多. 不得不吐槽一下天朝的面试\n\n\n\n\n\n\n\n\n\n面试造航母, 上班拧螺丝\n通过几个例子, 大家先理解一些常用的\n\n\n\n\n\n\n\n\n\n示例\n+的隐式转换\n&#x2F;&#x2F; 只要+号的一边是字符, 最终的结果就是字符\nconsole.log(&#39;123&#39; + &#39;456&#39;) &#x2F;&#x2F; &#39;123456&#39;\nconsole.log(&#39;123&#39; + 456) &#x2F;&#x2F; &#39;123456&#39;\nconsole.log(&#39;123&#39; + true) &#x2F;&#x2F; &#39;123true&#39;\n\n&#x2F;&#x2F; 特殊\nundefined + 1 &#x2F;&#x2F; NaN\n\n==的隐式转换\n大体的原则是\n\n字符型 转换成 数字型\n布尔型 转换成 数字型\n\n\n\n\n\n\n\n\n\n\n示例\n&#39;1&#39; &#x3D;&#x3D; 1 &#x2F;&#x2F; true\ntrue &#x3D;&#x3D; 1 &#x2F;&#x2F; true\n&#39;1&#39; &#x3D;&#x3D; true &#x2F;&#x2F; true\n\n&#x2F;&#x2F; 特殊的\nNaN !&#x3D; NaN &#x2F;&#x2F; true\nundefined &#x3D;&#x3D; null &#x2F;&#x2F; true\n\n关于Boolean类型的转换\n空字符串(‘’), NaN, 0, null, undefined =&gt; false\n其余的全部 =&gt; true\n四. 运算符1 运算符的分类运算符（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号, 常用的有:\n\n 算数运算符\n 自增自减运算符\n 比较运算符\n 逻辑运算符\n 赋值运算符\n\n1) 表达式和返回值表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合\n简单理解：是由数字、运算符、变量等组成的式子\n表达式最终都会有一个结果，返回给开发者，称为返回值\n\n\n\n\n\n\n\n\n\n示例\n1 + 1 &#x2F;&#x2F; 是一个表达式, 返回值是2\n\nvar a &#x3D; 100\na + 100 &#x2F;&#x2F; 返回值是200\n\n1 &#x3D;&#x3D; &#39;1&#39; &#x2F;&#x2F; 返回值是true\n\n2 算数运算符算数运算符就是数学运算中的加减乘除\n\n\n\n运算符\n描述\n实例\n\n\n\n+\n加\n20 + 10 = 30\n\n\n-\n减\n20 - 10 = 10\n\n\n*\n乘\n20 * 10 = 200\n\n\n/\n除\n20 / 10 = 2\n\n\n%\n取模\n返回余数18 % 2 = 0 ; 15 % 2 = 1\n\n\n小数会存在精度丢失的问题\n0.1 + 0.2 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 0.30000000000000004\n\n\n因此, 不要直接拿小数进行比较!!!\n3 自增自减运算符自增自减都是对数字变量的操作\n\n\n\n\n\n\n\n\n\n示例\nvar num &#x3D; 1\nnum++\n++num\n\n下面这种是错误的\n1++\n\n1) 前置自增++num: 先+1, 再返回结果\nvar num &#x3D; 10\n++num &#x2F;&#x2F; 表达式返回11, 执行完后num的值是11\n\n2) 后置自增num++: 先返回结果, 再+1\nvar num &#x3D; 10\nnum++ &#x2F;&#x2F; 表达式返回10, 执行完后num的值是11\n\n\n\n\n\n\n\n\n\n\n练习\nvar a &#x3D; 10;\n++a; \nvar b &#x3D; ++a + 2;\nconsole.log(b);\n\nvar c &#x3D; 10;\nc++;\nvar d &#x3D; c++ + 2;\nconsole.log(d);\n\nvar e &#x3D; 10;\nvar f &#x3D; e++ + ++e;\nconsole.log(f);\n\n4 比较运算符比较运算符是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true / false）作为比较运算的结果\n\n\n\n运算符\n说明\n案例\n返回值\n\n\n\n&lt;\n小于\n1 &lt; 2\ntrue\n\n\n&gt;\n大于\n1 &gt; 2\nfalse\n\n\n&lt;=\n小于等于\n1 &lt;= 2\ntrue\n\n\n&gt;=\n大于等于\n1 &gt;= 2\nfalse\n\n\n==\n等于(会隐式转换)\n‘1’ == true\ntrue\n\n\n!=\n不等于\nNaN != NaN\ntrue\n\n\n===\n全等, 判断类型和值\n‘1’ === true\nfalse\n\n\n\n\n\n\n\n\n\n\n\n字符的比较\n字符的比较是按照ASCII码表依次比较的\n\n\n\n\n\n\n\n\n\n示例\n&#39;100&#39; &gt; &#39;99&#39; &#x2F;&#x2F; false\n100 &gt; 99 &#x2F;&#x2F; true\n\n\n\n5 逻辑运算符逻辑运算符是用来进行布尔值运算的运算符\n后面开发中经常用于多个条件判断\n\n\n\n运算符\n说明\n案例\n返回值\n\n\n\n&amp;&amp;\n逻辑与 and\n2&gt;1 &amp;&amp; 3 &gt;2\ntrue\n\n\n||\n逻辑或 or\n2&gt;1 || 3&gt;2\ntrue\n\n\n!\n逻辑非 not\n!true\nfalse\n\n\n1) 逻辑与全真为真, 一假为假\n\n\n\n案例\n返回值\n\n\n\ntrue &amp;&amp; true\ntrue\n\n\nfalse &amp;&amp; true\nfalse\n\n\ntrue &amp;&amp; false\nfalse\n\n\nfalse &amp;&amp; false\nfalse\n\n\n2) 逻辑或全假为假, 一真为真\n\n\n\n案例\n返回值\n\n\n\ntrue || true\ntrue\n\n\nfalse || true\ntrue\n\n\ntrue || false\ntrue\n\n\nfalse || false\nfalse\n\n\n3) 逻辑非真假互换\n\n\n\n案例\n返回值\n\n\n\n!true\nfalse\n\n\n!false\ntrue\n\n\n4) 短路运算当有多个表达式（值）做逻辑运算时\n第一个表达式值可以确定结果时,就不再继续运算后边的表达式的值\n\n逻辑与\n语法： 表达式1 &amp;&amp; 表达式2\n如果第一个表达式的值为真，则返回表达式2\n如果第一个表达式的值为假，则返回表达式1\n\nconsole.log( 123 &amp;&amp; 456 );        &#x2F;&#x2F; 456\nconsole.log( 0 &amp;&amp; 456 );          &#x2F;&#x2F; 0\nconsole.log( 123 &amp;&amp; 456 &amp;&amp; 789 ); &#x2F;&#x2F; 789\n逻辑或\n语法： 表达式1 || 表达式2\n如果第一个表达式的值为真，则返回表达式1\n如果第一个表达式的值为假，则返回表达式2\n\n &#x2F;&#x2F; 通常用来给默认值, 如\nfunction setName(name) &#123;\n  var uname &#x3D; name || &#39;&#39;\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\nvar num &#x3D; 0;\nconsole.log(123 || num++);\nconsole.log(num);\n\n\n\n\n\n\n\n\n\n\n练习\n判断是否为润年, 满足以下两个条件之一就是润年\n\n能被4整除且不能整除100\n能够被 400 整除\n\nvar year &#x3D; 2000\nvar res &#x3D; (year % 4 &#x3D;&#x3D; 0 &amp;&amp; year % 100 !&#x3D; 0) || (year % 400 &#x3D;&#x3D; 0)\n\n6 赋值运算符把数据赋值给变量的运算符\n\n\n\n运算符\n说明\n案例\n\n\n\n=\n赋值\nvar a = 100\n\n\n+=, -=\n加, 减一个数后再赋值\nvar age = 10; age += 5\n\n\n*=, /= ,%=\n乘, 除, 取模后再赋值\nvar a = 5; age *= 2\n\n\n7 运算符的优先级\n\n\n优先级\n运算符\n顺序\n\n\n\n1\n小括号\n()\n\n\n2\n一元运算符\n++ – !\n\n\n3\n算数运算符\n先 * / % 后 + -\n\n\n4\n关系运算符\n&gt; &gt;= &lt; &lt;=\n\n\n5\n逻辑运算符\n先 &amp;&amp; 后 ||\n\n\n6\n赋值运算符\n=\n\n\n五. 流程控制1 概念流程控制就是来控制代码按照一定结构顺序来执行\n主要有3种结构\n\n顺序\n条件\n循环\n\n程序的流程图, 可以通过使用processon在线编辑: ProcessOn\n\n2 顺序顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的\n3 条件根据不同的条件，执行不同的路径代码(执行代码多选一的过程) 从而得到不同的结果\n1) if语句\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; 条件成立执行代码，否则什么也不做\nif (条件表达式) &#123;\n    &#x2F;&#x2F; 条件成立执行的代码语句\n&#125;\n\n&#x2F;&#x2F; 条件成立  执行 if 里面代码，否则执行else 里面的代码\nif (条件表达式) &#123;\n    &#x2F;&#x2F; [如果] 条件成立执行的代码\n&#125; else &#123;\n    &#x2F;&#x2F; [否则] 执行的代码\n&#125;\n\n\n\n\n\n\n\n\n\n示例\nvar age &#x3D; prompt(&#39;请输入您的年龄:&#39;);\nif (age &gt;&#x3D; 18) &#123;\n  alert(&#39;已成年&#39;);\n&#125; else &#123;\n  alert(&#39;未成年&#39;);\n&#125;\n\n\n\n&#x2F;&#x2F; 适合于检查多重条件\nif (条件表达式1) &#123;\n    语句1\n&#125; else if (条件表达式2)  &#123;\n    语句2\n&#125; else if (条件表达式3)  &#123;\n   语句3\n ....\n&#125; else &#123;\n    &#x2F;&#x2F; 上述条件都不成立执行此处代码\n&#125;\n\n\n\n2) switch语句switch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码\n当要针对变量设置一系列的特定值的选项时，就可以使用 switch\nswitch( 表达式 )&#123; \n    case value1:\n        &#x2F;&#x2F; 表达式 等于 value1 时要执行的代码\n        break;\n    case value2:\n        &#x2F;&#x2F; 表达式 等于 value2 时要执行的代码\n        break;\n    default:\n        &#x2F;&#x2F; 表达式 不等于任何一个 value 时要执行的代码\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\n将数字1~7转换成星期一到星期天\nvar num &#x3D; prompt(&#39;请输入一个数字:&#39;)\nswitch (num) &#123;\n  case &#39;1&#39;:\n    alert(&#39;星期一&#39;)\n    break\n  case &#39;2&#39;:\n    alert(&#39;星期二&#39;)\n    break\n  case &#39;3&#39;:\n    alert(&#39;星期三&#39;)\n    break\n  case &#39;4&#39;:\n    alert(&#39;星期四&#39;)\n    break\n  case &#39;5&#39;:\n    alert(&#39;星期五&#39;)\n    break\n  case &#39;6&#39;:\n    alert(&#39;星期六&#39;)\n    break\n  case &#39;7&#39;:\n    alert(&#39;星期天&#39;)\n    break\n  default:\n    alert(&#39;输入有误, 请输入1~7的数字&#39;)\n&#125;\n\n4 循环重复多次执行有规律的代码, 可以使用循环来表示, 通过一个变量可以记录第几次循环, 已经循环的总次数\n1) for循环\n\n\n\n\n\n\n\n\n语法\nfor(初始化变量; 条件表达式; 操作表达式 )&#123;\n    &#x2F;&#x2F;循环体\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 基本写法\nfor(var i &#x3D; 1; i &lt;&#x3D; 10; i++)&#123;\n    console.log(&#39;媳妇我错了~&#39;)\n&#125;\n&#x2F;&#x2F; 用户输入次数\nvar num &#x3D; prompt(&#39;请输入次数:&#39;)\nfor (var i &#x3D; 1 ; i &lt;&#x3D; num; i++) &#123;\n    console.log(&#39;媳妇我错了~&#39;)\n&#125; \n\n\n\n\n\n\n\n\n\n\n示例\n累加求和\nvar sum &#x3D; 0\nfor(var i&#x3D;1; i&lt;&#x3D;10; i++) &#123;\n  sum +&#x3D; i\n&#125;\nconsole.log(sum)\n\n\n\n\n\n\n\n\n\n\n练习\n提示用户输入两个数, 计算累加求和\nvar num1 &#x3D; parseInt(prompt(&#39;请输入第一个数&#39;))\nvar num2 &#x3D; parseInt(prompt(&#39;请输入第二数&#39;))\n\nvar sum &#x3D; 0\nfor (var i &#x3D; num1; i &lt;&#x3D; num2; i++) &#123;\n  sum +&#x3D; i\n&#125;\nalert(&#39;从&#39; + num1 + &#39;到&#39; + num2 + &#39;的和是: &#39; + sum)\n\n在for循环中, 可以使用if和for循环\n\n\n\n\n\n\n\n\n\n示例\n分别求1~100的奇数和, 偶数和\nvar even &#x3D; 0;\nvar odd &#x3D; 0;\nfor (var i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;\n  if (i % 2 &#x3D;&#x3D; 0) &#123;\n    even &#x3D; even + i;\n  &#125; else &#123;\n    odd &#x3D; odd + i;\n  &#125;\n&#125;\nconsole.log(&#39;1~100 之间所有的偶数和是&#39; + even);\nconsole.log(&#39;1~100 之间所有的奇数和是&#39; + odd);\n\n\n\n\n\n\n\n\n\n\n示例\n 打印3行3列的星星\nvar star &#x3D; &#39;&#39;;\nfor (var j &#x3D; 1; j &lt;&#x3D; 3; j++) &#123;\n    for (var i &#x3D; 1; i &lt;&#x3D; 3; i++) &#123;\n      star +&#x3D; &#39;☆&#39;\n    &#125;\n    &#x2F;&#x2F; 每次满 3个星星 就 加一次换行\n    star +&#x3D; &#39;\\n&#39;\n&#125;\nconsole.log(star);\n\n\n\n\n\n\n\n\n\n\n练习\n打印n行m列的星星\n&#x2F;&#x2F; 打印n行m列的星星\nvar rows &#x3D; prompt(&#39;请您输入行数:&#39;);\nvar cols &#x3D; prompt(&#39;请您输入列数:&#39;);\nvar str &#x3D; &#39;&#39;;\nfor (var i &#x3D; 1; i &lt;&#x3D; rows; i++) &#123;\n  for (var j &#x3D; 1; j &lt;&#x3D; cols; j++) &#123;\n    str &#x3D; str + &#39;★&#39;;\n  &#125;\n  str +&#x3D; &#39;\\n&#39;;\n&#125;\nconsole.log(str);\n\n\n\n\n\n\n\n\n\n\n示例\n打印9*9乘法表\nvar str &#x3D; &#39;&#39;;\nfor (var i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123; &#x2F;&#x2F; 外层循环控制行数\n  for (var j &#x3D; 1; j &lt;&#x3D; i; j++) &#123; &#x2F;&#x2F; 里层循环控制每一行的个数  j &lt;&#x3D; i\n    str +&#x3D; j + &#39;×&#39; + i + &#39;&#x3D;&#39; + i * j + &#39;\\t&#39;;\n  &#125;\n  str +&#x3D; &#39;\\n&#39;;\n&#125;\nconsole.log(str);\n\n2) while循环\n\n\n\n\n\n\n\n\n语法\nwhile (条件表达式) &#123;\n  &#x2F;&#x2F; 当...条件满足时, 一直执行循环体\n  &#x2F;&#x2F; 循环体代码 \n&#125;\n\ndo…while\ndo &#123;\n    &#x2F;&#x2F; 循环体代码 - 条件表达式为 true 时重复执行循环体代码\n&#125; while(条件表达式);\n\n当条件满足时, 执行\n区别是do…while会先执行一次, 再判断\n3) 跳出循环continue: 跳出当前循环\nbreak: 跳出整个循环\n\n\n\n\n\n\n\n\n\n示例\nfor (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;\n  if (i &#x3D;&#x3D; 3) &#123;\n    console.log(&#39;这个包子有虫子，扔掉&#39;);\n    continue; &#x2F;&#x2F; 跳出本次循环，跳出的是第3次循环 \n  &#125;\n  console.log(&#39;我正在吃第&#39; + i + &#39;个包子呢&#39;);\n&#125;\n\nfor (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;\n  if (i &#x3D;&#x3D; 3) &#123;\n    console.log(&#39;发现半条虫子，再也吃不下了&#39;);\n    break; &#x2F;&#x2F; 直接退出整个for 循环，跳到整个for下面的语句\n  &#125;\n  console.log(&#39;我正在吃第&#39; + i + &#39;个包子呢&#39;);\n&#125;\n\n六. 数组1 基本概念1) 定义数组数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式\n\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F;1. 使用[]创建空数组\nvar  数组名 &#x3D; []；\n&#x2F;&#x2F;2. 在创建数组时, 给初始值\nvar  数组名 &#x3D; [&#39;小白&#39;,&#39;小黑&#39;,&#39;小胖&#39;];\n\n数组中可以存放任意类型的数据，例如字符串，数字，布尔值等\n\n\n\n\n\n\n\n\n\n示例\nvar arr &#x3D; [&#39;小小胖&#39;,12,true,28.9]\n\n2) 访问数组元素通过下标(索引)访问数组元素, 下标从0开始\nconsole.log(arr[0])\n\n3) 添加数组元素\n\n\n\n\n\n\n\n\n示例\nvar arr &#x3D; [&#39;小小胖&#39;, 12, true, 28.9]\narr[4] &#x3D; &#39;newValue&#39;\narr[6] &#x3D; &#39;第7个值&#39;\nconsole.log(arr) &#x2F;&#x2F; 数组的长度为7\nconsole.log(arr[5]) &#x2F;&#x2F; undefined\n\n4) 删除数组元素\n\n\n\n\n\n\n\n\n示例\ndelete arr[1] &#x2F;&#x2F; 删除数组元素, 不改变数组长度\nconsole.log(arr)\n\n2 遍历\n\n\n\n\n\n\n\n\n遍历: 依次访问数组的每一个元素\nvar arr &#x3D; [&#39;red&#39;,&#39;green&#39;, &#39;blue&#39;];\nfor(var i &#x3D; 0; i &lt; arr.length; i++)&#123;\n    console.log(arr[i]);\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\n求数组中的最大值\nvar arr &#x3D; [1, 2, 11, 3, 4]\n\nvar max &#x3D; arr[0]\nfor (var i &#x3D; 0; i &lt; arr.length; i++) &#123;\n  if (arr[i] &gt;&#x3D; max) &#123;\n    max &#x3D; arr[i]\n  &#125;\n&#125;\nconsole.log(max)\n\n3 多维数组如果一个数组a的一个元素也是一个数组, 数组a就叫多维数组\n\n\n\n\n\n\n\n\n\n示例\nvar arr &#x3D; [1, 2, [&#39;xiaopang&#39;, &#39;小小胖&#39;]]\n&#x2F;&#x2F; 如何获得小小胖的值\nconsole.log(arr[2][1])\n\n七. 函数1 基本概念可能会有非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用\n我们把实现特定功能的代码块叫做一个函数\n\n函数可以需要的任何时候调用\n函数不调用不执行\n\n1) 函数声明\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; 声明函数\nfunction 函数名() &#123;\n    &#x2F;&#x2F;函数体代码\n&#125;\n\n2) 调用函数\n\n\n\n\n\n\n\n\n语法\n函数名();\n\n\n\n\n\n\n\n\n\n\n示例\n将累加求和的功能\n封装成一个函数, 求1到100和\n&#x2F;&#x2F; 声明函数\nfunction getSum()&#123;\n  var sumNum &#x3D; 0;&#x2F;&#x2F; 准备一个变量，保存数字和\n  for (var i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;\n    sumNum +&#x3D; i;&#x2F;&#x2F; 把每个数值 都累加 到变量中\n  &#125;\n  alert(sumNum);\n&#125;\n&#x2F;&#x2F; 调用函数\ngetSum();\n\n2 参数参数可以使函数实现更加强大的功能\n1) 实参与形参\n\n\n\n\n\n\n\n\n语法\n&#x2F;&#x2F; 带参数的函数声明\nfunction 函数名(形参1, 形参2 , 形参3...) &#123; &#x2F;&#x2F; 可以定义任意多的参数，用逗号分隔\n  &#x2F;&#x2F; 函数体\n&#125;\n&#x2F;&#x2F; 带参数的函数调用\n函数名(实参1, 实参2, 实参3...); \n\n\n形参: 函数声明时参数\n实参: 函数调用时参数\n\n2) 传参的过程传参的过程就是赋值的过程, 将实参的值赋值给形参\n\n\n\n\n\n\n\n\n\n示例\n进一步改造, 计算从n到m的和\n&#x2F;&#x2F; 声明函数\nfunction getSum(n, m)&#123;\n  var sumNum &#x3D; 0;&#x2F;&#x2F; 准备一个变量，保存数字和\n  for (var i &#x3D; n; i &lt;&#x3D; m; i++) &#123;\n    sumNum +&#x3D; i;&#x2F;&#x2F; 把每个数值 都累加 到变量中\n  &#125;\n  alert(sumNum);\n&#125;\n&#x2F;&#x2F; 调用函数\ngetSum(5, 10);\n\n3 返回值一般一个函数在调用后, 会产生一个固定的结果, 一般将结果返回出来, 具体要怎么使用这个结果, 不是由函数决定的. 这就是编程里的”单一职责”原则\n进一步改造\n&#x2F;&#x2F; 声明函数\nfunction getSum(n, m)&#123;\n  var sumNum &#x3D; 0;&#x2F;&#x2F; 准备一个变量，保存数字和\n  for (var i &#x3D; n; i &lt;&#x3D; m; i++) &#123;\n    sumNum +&#x3D; i;&#x2F;&#x2F; 把每个数值 都累加 到变量中\n  &#125;\n  return sumNum\n&#125;\n&#x2F;&#x2F; 调用函数\nvar res &#x3D; getSum(5, 10)\nalert(res)\nconsole.log(res)\n\n尝试封装一些函数\n\n求n到m的奇数和\n封装一个函数求n到m的平均值\n封装一个函数求数组中的最大值\n\n八. 对象1 类和对象1) 对象的概念\n\n\n\n\n\n\n\n\n对象: 一个具体的实体\n在现实世界中, 对象随处可见, 一个人,  一个学生, 一个杯子, 一辆汽车, 游戏里的一个英雄… 都是一个对象\n2) 对象的组成\n\n\n\n\n\n\n\n\n如何描述一个对象呢\n比如, \n\n每个人都有姓名, 年龄, 性别这些特征. \n游戏里的英雄都有生命值, 攻击力, 防御力这些特征.\n\n对象除了这些特征外, 还有一些行为/动作\n比如, \n\n人可以吃饭, 睡觉    \n游戏里的英雄可以移动, 可以放技能\n\n在程序里,\n\n把对象的特征叫做==属性==, 使用变量来描述\n把对象的行为叫做==方法==, 使用函数来描述\n\n因此, 我们得出一个重要结论:\n\n\n\n\n\n\n\n\n\n对象是由属性和方法组成的!!\n3) 类的概念\n\n\n\n\n\n\n\n\n类: 具有相同特征的事物的集合\n我们把具有相同特征和行为的实体抽象出来, 就形成了一个类. \n比如: 把人集合在一起, 就形成了人类, 把王者荣耀里的英雄集合起来, 就形成了英雄类\n\n每一个人类都有一些相同的特征, 比如: 姓名, 性别, 年龄, 身高, 体重…等\n每一个英雄也有一些相同的特征, 比如: 生命值, 攻击力, 防御力…等\n\n4) 程序中的类与对象\n\n\n\n\n\n\n\n\n那么如何使用程序来描述这些相同的特征呢?\n可以定义一个模板/规范/设计图纸, 然后通过这个模板/规范/设计图纸来==生产==一个个的实体. \n比如: 我们可以通过宝马车的设计图纸来生产一辆宝马车\n\n\n我们把定义的这个模板叫做==类==\n把生产出来的实体叫做==对象==\n把生产的过程叫做==实例化==\n\n5) 类和对象的关系类和对象的关系, 可以认为是==整体和个体, 抽象和具体的关系==\n通过上面的描述, 总结起来说, 就是\n\n类是对象的集合\n对象是类的实例化\n\n6) 小结\n对象是由属性和方法组成的\n属性就是变量, 方法就是函数\n类是对象的集合, 对象是类的实例化\n\n补充: 由于类是对象的集合, 通常我们也可以说类由属性和方法组成~\n2 初步认识JS中的类和对象1) 构造函数的定义在JS中, 没有类(class)的概念, 主要是通过构造函数来模拟的.[^1]\n\n\n\n\n\n\n\n\n\n语法\nfunction 构造函数名 () &#123;\n    &#x2F;&#x2F; 函数体\n&#125;\n\n\n使用function关键字表示定义一个构造函数\n构造函数名一般==首字母大写==\n\n\n\n\n\n\n\n\n\n\n示例: 2-1构造函数的定义.html\nfunction Person() &#123;\n    \n&#125;\n\n通过以上方式就可以定义一个Person构造函数, 相当于定义好了一个Person类\n2) 构造函数的作用通过构造函数实例化对象在JS中, 我们通过构造函数(类)来实例化对象\n\n\n\n\n\n\n\n\n\n语法\nnew 构造函数名()\n\n\n\n\n\n\n\n\n\n\n示例: 2-2通过构造函数实例化对象.html\n&#x2F;&#x2F; 一. 定义一个构造函数\nfunction Person() &#123;\n    \n&#125;\n&#x2F;&#x2F; 二. 实例化一个对象, 赋值给变量p\nvar p &#x3D; new Person();\nconsole.log(typeof p); &#x2F;&#x2F; object\n\n以上代码\n\n通过new关键字, 产生了一个对象, 并赋值给变量p\n通过typeof p测试变量p的类型为object, 说明p是一个对象\n\n在构造函数中定义属性\n\n\n\n\n\n\n\n\n构造函数规定了由该类实例化出来的对象应该包含哪些属性\n比如, 由学生类实例化出来的学生对象都应该有姓名, 年龄这些属性\nfunction Student () &#123;\n    this.uname &#x3D; null;\n    this.age &#x3D; null;\n&#125;\n\n在构造函数的内部, 我们通过this.属性名的方式来定义属性\n在这里, 大家先把这个看作固定写法, 后面我们再具体分析\n\n\n\n\n\n\n\n\n\n构造函数虽然可以规定实例对象应该包含哪些属性, 但是并不能确定实例对象的属性值\n比如 人类都应该有名字这个属性, 但是具体叫什么名字, 只有在一个人出生的时候才去确定\n因此, 在实例化对象的时候, 需要将具体的数据传递给构造函数\n\n\n\n\n\n\n\n\n\n示例: 2-3在构造函数中定义属性.html\n&#x2F;&#x2F; 一. 定义一个学生类\nfunction Student(n, a) &#123;\n    this.uname &#x3D; n;\n    this.age &#x3D; a;\n&#125;\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\n\n\n\n\n\n\n\n\n\n\n重要结论\n​    ==构造函数主要完成属性的初始化!!!==\n\n\n\n\n\n\n\n\n\n练习\n一. 通过构造函数Phone定义一个手机类, 包含型号(type), 价格(price), 颜色(color), 屏幕大小(size)\n二. 实例化两个对象\n\n一个iphone对象, 型号: iphoneX, 价格: 6999, 颜色: 土豪金, 屏幕大小: 5.8英寸\n一个huawei对象, 型号:p30 pro, 价格: 5988, 颜色: 极光蓝, 屏幕大小: 6.1英寸\n\n\n\n\n\n\n\n\n\n\n参考答案\n&#x2F;&#x2F; 一. 定义手机类\nfunction Phone(type, price, color, size) &#123;\n    &#x2F;&#x2F; 属性\n    this.type &#x3D; type;\n    this.price &#x3D; price;\n    this.color &#x3D; color;\n    this.size &#x3D; size;\n&#125;\n&#x2F;&#x2F; 二. 实例化对象\nvar iphone &#x3D; new Phone(&#39;iphoneX&#39;, 6999, &#39;土豪金&#39;, &#39;5.8英寸&#39;);\nvar huawei &#x3D; new Phone(&#39;p30 pro&#39;, 5988, &#39;极光蓝&#39;, &#39;6.1英寸&#39;);\n\n\n\n\n\n\n\n\n\n\n作业\n一.通过构造函数Hero定义一个英雄类, 包含血量(HP), 类型(type), 攻击力(attack)\n二.实例化两个对象\n\n一个lianpo对象, 血量:700, 类型: 力量型, 攻击力: 70\n一个houyi对象, 血量:300, 类型: 射手, 攻击力: 130\n\n3) 小结\n通过构造函数定义类(规定应该包含哪些属性名)\n通过new实例化对象(在实例化时, 确定属性值)\n构造函数主要完成==属性==的初始化\n\n3 对象的方法1) 方法的定义与使用我们已经知道\n\n类由属性和方法组成\n在JS中, 通过构造函数定义类\n在构造函数中可以通过this.属性名定义属性\n\n那么, 在构造函数中是否也可以通过this.方法名定义方法呢?\n在构造函数中定义方法\n\n\n\n\n\n\n\n\n示例: 3-1在构造函数中定义方法.html\n按照之前的方式, 尝试编写如下代码\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; function () &#123;\n    console.log(&#39;大家好&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n\nuname和age是属性\nsayHi是方法, 方法就是一个==函数==\n\n方法的使用(调用)\n\n\n\n\n\n\n\n\n语法\n对象.方法名()\n\n\n由于方法就是一个函数, 在后面加小括号表示方法的调用\n\n\n\n\n\n\n\n\n\n\n示例: 3-2调用对象的方法.html\n&#x2F;&#x2F; 三. 调用方法 -- 对象.方法名()\nstu.sayHi(); &#x2F;&#x2F; 大家好\n\n2) 存在的问题虽然可以在构造函数中定义方法, 但是一般不这么做, 为什么呢?\n看如下示例:\n\n\n\n\n\n\n\n\n\n示例: 3-3为什么不在构造函数中定义方法.html\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; function () &#123;\n    console.log(&#39;大家好&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; 三.判断stu.sayHi &#x3D;&#x3D;&#x3D; stu1.sayHi ?\nconsole.log(stu.sayHi &#x3D;&#x3D;&#x3D; stu1.sayHi); &#x2F;&#x2F;false\n\n\n上面这个比较表示stu对象和stu1对象的sayHi方法在内存中的首地址是不同的!!!\n\n我们发现\nfunction () &#123;\n  console.log(&#39;大家好&#39;);\n&#125;\n\n这段代码是相同的, 但是在每次实例化新对象时, 都会分配新的内存空间, 造成浪费.\n3) 小结\n一般不在构造函数中定义方法, 为什么?\n方法的调用语法: 对象.方法名()\n\n4 对象实例化原理分析1) 引用数据类型对象是一种特殊的数据, 看如下代码\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 定义一个学生类\nfunction Student(n, a) &#123;\n    this.uname &#x3D; n;\n    this.age &#x3D; a;\n&#125;\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\n\n\n这里并不是把所有的数据直接保存在变量中\n而是先在堆区开辟一个空间, 把这个空间的引用保存在变量中. \n在js中, ==函数==和==对象==都是引用数据类型\n\n\n这里有个词–”==引用==”\n\n\n\n\n\n\n\n\n\n什么是引用呢, 引用有什么用呢?\n一句话解释: ==引用就是来找数据的==\n类似于路径的概念, 就像我们可以通过路径E:\\docment\\image\\img.jpg找到电脑中的一个文件, \n又或者酒店的房间号, 通过房间号就可以找到房间\n通过引用就可以找到内存中的数据.\n引用本质上是内存首地址. 通过这个地址就可以找到对应的内存空间, 进而获取数据\n2) new实例化的过程\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 定义一个学生类\nfunction Student(n, a) &#123;\n    this.uname &#x3D; n;\n    this.age &#x3D; a;\n&#125;\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\n\n\n当代码执行到行7行时. \n\n在堆内存中开辟一段内存空间, 假设这段内存空间是从0x1111~0x2000\n因此通过0x1111就可以找到对应的这段内存空间, 进而获取其中的数据\n\n将0x1111保存在this中, 我们也可以说让this指向这个空间\n\n执行函数. 通过this=0x1111找到内存空间, 在这个空间中保存数据name:xiaoming,age:20\n\n最后, 将0x1111返回, 保存在stu中\n\n\n\n\n\n\n\n\n\n\n\n练习\n如果再实例化一个对象stu1, (假设内存地址是0x2222), 画出实例化的过程\n&#x2F;&#x2F; 一. 定义一个学生类\nfunction Student(n, a) &#123;\n    this.uname &#x3D; n;\n    this.age &#x3D; a;\n&#125;\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n\n\n\n\n\n\n\n\n\n参考答案\n\n这样, 我们就可以通过一个模板(Student构造函数)得到多个不同的对象(stu对象和stu1对象). 对象中保存的数据也不一样.\n3) 为什么不在构造函数中定义方法我们在上面的基础上进一步深入.\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; function () &#123;\n    console.log(&#39;大家好&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n上述代码的图解如下:\n\n这就解释了我们前面的问题. 虽然sayHi方法的代码是相同的, 但是每次实例化时会开辟一个新的内存空间, 造成浪费. \n4) 初步解决既然方法是相同的, 我们可不可以单独定义一个函数赋值给sayHi呢?\n\n\n\n\n\n\n\n\n\n示例: 4-1初步解决方法定义.html\n&#x2F;&#x2F; 初步解决方案\n\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; sayHi;\n&#125;\n\nfunction sayHi() &#123;\n  console.log(&#39;大家好&#39;);\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n上述代码图解如下:\n\n这样做确实可以解决, 但是这种做法很奇怪. 一般也不会使用, 为什么这么说呢. \n照理说, sayHi函数应该仅仅是属于Student类. 只有通过Student类实例化出来的对象可以调用. 而如果把sayHi放在全局下. 可以当成普通函数调用. 因此, 我们称这种做法破坏了类的封装性. \n\n\n\n\n\n\n\n\n\n什么是封装性?\n​    ==类的成员尽量封闭在类的内部, 隐藏细节与实现==\n看下面这个示例\n\n\n\n\n\n\n\n\n\n示例: 4-2初步解决方案带来的问题.html\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; sayHi;\n&#125;\n\nfunction sayHi() &#123;\n  console.log(&#39;大家好, 我叫&#39;+this.uname);\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; 使用对象调用可以得到希望的结果\nstu.sayHi(); &#x2F;&#x2F; 大家好, 我叫xiaoming\n\n&#x2F;&#x2F; 当普通函数直接调用, 会得到&#39;奇怪&#39;的结果\nsayHi(); &#x2F;&#x2F; 大家好, 我叫undefined\n\n为什么会出现这种’奇怪’的现象. 要搞明白这个问题, 就要了解js中的this指向[^2]\n5) 初步了解this指向为了搞清楚构造函数中的this, 我们还是先通过图解的方式来分析\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; sayHi;\n&#125;\n\nfunction sayHi() &#123;\n  console.log(&#39;大家好, 我叫&#39;+this.uname);\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; 使用对象调用可以得到希望的结果\nstu.sayHi(); &#x2F;&#x2F; 大家好, 我叫xiaoming\n\n\n\n\n\n\n\n\n\n\n图解\n\n通过上面的分析. 我们至少可以得出这样的结论\n\nthis也是一种引用数据类型\nthis的指向是在函数调用时确定的\n\n上述代码, 更为准确的写法是\n\n\n\n\n\n\n\n\n\n示例: \n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; sayHi;\n&#125;\n\nfunction sayHi() &#123;\n  console.log(&#39;大家好, 我叫&#39;+this.uname);\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; call表示调用函数, 并确定this指向stu对象\nstu.sayHi.call(stu); &#x2F;&#x2F; 大家好, 我叫xiaoming\n\n\n\n\n\n\n\n\n\n\n思考: 4-3思考题答案.html\n​    如果在调用sayHi的时候, 让this指向stu1, 大家思考一下会得到什么结果\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; sayHi;\n&#125;\n\nfunction sayHi() &#123;\n  console.log(&#39;大家好, 我叫&#39;+this.uname);\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; call表示调用函数, 并规定this指向stu1对象\nstu.sayHi.call(stu1); &#x2F;&#x2F; ???\n\n\n\n\n\n\n\n\n\n\n思考题答案\n​    大家好, 我叫xiaomei\n过程分析\n\n通过stu找到0x1111\n调用sayHi函数\n确定this指向stu1\n通过this找到this.uname, 也就是stu1.uname等于xiaomei\n\n最后, 我们分析把sayHi当普通函数调用的过程\n如果把sayHi当普通函数调用, 相当于在全局对象(在浏览器环境中是window)添加了属性和方法\n因此, 更准确的写法如下\n\n\n\n\n\n\n\n\n\n示例: 4-4当做普通函数调用.html\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; sayHi;\n&#125;\n\nfunction sayHi() &#123;\n  console.log(&#39;大家好, 我叫&#39;+this.uname);\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; call表示调用函数, 并确定this指向window对象\n&#x2F;&#x2F; 在window对象中并没有uname这个属性, 因此值为undefined\nwindow.sayHi()\nsayHi.call(window); &#x2F;&#x2F; 大家好, 我叫undefined\n\n\n\n\n\n\n\n\n\n\n思考\n​    如果我们人为在window中添加一个uname属性会怎样呢?\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 定义类\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n  this.sayHi &#x3D; sayHi;\n&#125;\n\nfunction sayHi() &#123;\n  console.log(&#39;大家好, 我叫&#39;+this.uname);\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; 定义一个全局变量, 相当于在window对象中添加了一个uname属性\nvar uname &#x3D; &#39;全局uname&#39;;\nsayHi(); &#x2F;&#x2F; 大家好, 我叫全局uname\n\n5 原型前面, 我们了解到属性可以定义在构造函数中, 但是==方法的定义==没有很好的解决方案. \n为了解决这个问题, 提出了原型模式\n或者, 换句话说: ==原型的产生主要是为了解决方法共享的问题==\n1) 什么是原型模式系统在创建构造函数的同时, 会自动在内存中生成一个与之相应的对象, 这个对象就是原型对象\n比如: \n&#x2F;&#x2F; 定义一个构造函数\nfunction Person() &#123;&#125;\n\n系统在创建Person构造函数的同时, 自动在内存中生成一个与之对应的Person原型对象\n\n由上图可知, 构造函数与原型对象是两个独立的内存空间\n2) 构造函数与原型对象的关系他们是相对独立的. 但是又存在联系\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 构造函数\nfunction Person(n) &#123;\n  this.uname &#x3D; n;\n&#125;\n&#x2F;&#x2F; 二. 打印构造函数的结构\nconsole.dir(Person);\n\n在Person构造函数的内部存在一个属性 prototype指向Person的原型对象\n在Person原型对象的内部也存在一个属性constructor指向Person的构造函数\n\n证明Person构造函数中存在prototype属性\n\n由上图可知, Person构造函数中, 确实存在prototype属性, 该属性指向一个对象\n3) 实例对象与原型对象的关系在由Person类实例化出来的对象person1和person2中也有一个属性__proto__(隐式原型)指向原型对象\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 构造函数\nfunction Person(n) &#123;\n  this.uname &#x3D; n;\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar person1 &#x3D; new Person(&#39;xiaoming&#39;);\nvar person2 &#x3D; new Person(&#39;xiaomei&#39;);\n\n&#x2F;&#x2F; 三. 打印person1和person2的内部结构\nconsole.dir(person1);\nconsole.dir(person2);\n\n\n\n\n\n\n\n\n\n\n证明\n由Person实例化出来的实例对象person1中存在__proto__属性指向Person的原型对象\n\n4) 三者的关系构造函数的prototype属性和实例对象的__proto__属性指向同一个对象\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 定义构造函数\nfunction Person(n) &#123;\n  this.uname &#x3D; n;\n&#125;\n\n&#x2F;&#x2F; 二. 实例化对象\nvar p &#x3D; new Person(&#39;xiaoming&#39;);\n\n&#x2F;&#x2F; 三. 测试\nconsole.log(Person.prototype &#x3D;&#x3D;&#x3D; p.__proto__); &#x2F;&#x2F; true\n\n\n\n\n\n\n\n\n\n\n图解\n\n5) 使用原型定义方法我们先大致了解下如何通过原型模式定义方法, 再具体分析\n\n\n\n\n\n\n\n\n\n示例\n&#x2F;&#x2F; 一. 在构造函数中定义属性\nfunction Student(n, a) &#123;\n  this.uname &#x3D; n;\n  this.age &#x3D; a;\n&#125;\n\n&#x2F;&#x2F; 二. 在原型中定义方法\nStudent.prototype.sayHi &#x3D; function () &#123;\n  console.log(&#39;大家好, 我叫&#39;+this.uname);\n&#125;\n\n&#x2F;&#x2F; 三. 实例化对象\nvar stu &#x3D; new Student(&#39;xiaoming&#39;, 20);\nvar stu1 &#x3D; new Student(&#39;xiaomei&#39;, 18);\n\n&#x2F;&#x2F; 比较不同的对象的方法是否相同\nconsole.log(stu.sayHi &#x3D;&#x3D;&#x3D; stu1.sayHi); &#x2F;&#x2F; true\n&#x2F;&#x2F; 我们发现stu中并没有sayHi这个方法, 但是为什么可以使用呢?\n\n6) 小结\n在构造函数中定义属性\n在原型对象中定义方法\n\n九. 常用的内置对象1 常用的内置对象\nMath对象\nDate对象\n字符串对象\n数组对象\n\n\n\n\n\n\n\n\n\n\n学习方法\n查文档! 查文档! 查文档!\n学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN/W3C来查询。        Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。        MDN:https://developer.mozilla.org/zh-CN/\n2 Math对象的常用方法\n\n\n方法名\n功能\n\n\n\nMath.floor()\n向下取整\n\n\nMath.max()/Math.min()\n求最大和最小值\n\n\nMath.random()\n获取范围在[0,1)内的随机值\n\n\n3 Date对象的常用方法\n\n\n方法名\n功能\n\n\n\ngetFullYear()\n获取年份\n\n\ngetMonth()\n获取月份(0~11)\n\n\ngetDate()\n获取日期(1~31)\n\n\ngetDay()\n获取星期(0~6)\n\n\ngetHours()\n获取小时\n\n\ngetMinutes()\n获取分钟\n\n\ngetSeconds()\n获取秒\n\n\n4 数组对象的常用方法\n\n\n方法名\n功能\n返回值\n\n\n\npush()\n在末尾添加元素\n新数组的长度\n\n\npop()\n删除最后一个元素\n删除的元素的值\n\n\nslice()\n截取子数组\n新数组\n\n\nsplice()\n通常用于删除某个指定元素\n新数组\n\n\n5 JSON对象的常用方法\n\n\n方法名\n功能\n返回值\n\n\n\nJSON.parse(str)\n将JSON字符串转换成JS对象\nJS对象\n\n\nJSON.stringify(obj, null, 2)\n将 JS 对象转换为 JSON 字符串\nJSON字符串\n\n\n","slug":"JavaScript基础","date":"2022-12-01T11:51:08.408Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"8bc067569f8f6351f0ef53903883b0a2","title":"11_js变量_数据类型_运算符","content":"概念及入门概念\n\t一种运行在客户端的脚本语言(script脚本意思)\n作用\n\t表单的动态校验\n\t网页的特效(轮播图)\n\t服务端的开发(nodejs)\n\t桌面程序\n\t控制硬件-物联网\n组成\n\tECMAScript 基础语法\n\tDOM 文档数据模型\n\tBOM 浏览器数据模型\n书写方式\n\t1,内嵌式\n\t\t在html页面中创建一个script标签,将js代码放进去\n\t2,外链式\n\t\t新建一个js文件,把js代码放进去\n\t\t以后需要用的时候,使用script标签引入就行,提高了代码的复用性\n注释\n\t单行注释\n\t\t&#x2F;&#x2F;\n\t多行注释\n\t\t&#x2F;* *&#x2F;\n输入输出\n\t输入\n\t\tprompt(内容)\n\t输出\n\t\talert()\n\t\tconsole.log()\n\t\tdocument.write()\n\n\n\n变量概念\n\t本质就是内存中存取数据的那一块空间(容器)\n作用\n\t存储变化的数据\n使用\n\t1,先声明在赋值\n\t2,声明的同时再赋值\n特点\n\t里面的数据可以修改\n注意点\n\t1,不能以数字开头(必须以字母开头,以 $ 和 _ 符号开头不推荐)\n\t2,严格区分大小写\n\t3,不能是关键字或者保留字\n\t4,尽量的见名知意\n\n\n\n数据类型作用\n\t给数据进行分类,方便管理\n分类\n\t基本数据类型\n\t\tnumber 数值\n\t\tString 字符串\n\t\tboolean 布尔型\n\t\tundefined 未定义\n\t\tnull 空\n\t引用数据类型\n\t\t类\n\t\t数组\n\t\t日期,正则\n转换\n\t强制转换\n\t\tString() 转换为字符串\n        Number() 转换为数字\n        Boolean() 转换为布尔值。\n        \t可以将0 null undefined &#39;&#39;(空字符串)会被转成false,其他转成true\n        \t\n    自动转换\n    \t任意类型的数据加上字符串都会被转成字符串\n        true,false,null和数值进行运算的时候,都会被转成数值\n        \n    + 运算的规律\n        如果+两端有一段是字符串,就会执行字符串的拼接\n        如果+两端都不是字符串,就会默认使用Number()进行强转,然后进行加法运算\n\n运算符算术运算符\n\t+ - * &#x2F;  %\n\t% 取的两个数相除的余数\n\t\n自增自减运算符\n\t++在前,先变量+1,然后在返回计算后的结果\n\t++在后,先把变量的值返回,然后变量再加1\n\t\n\t不管++在前还是在后,最终变量的值都会加1\n\t\n比较运算符\n\t&gt; &lt; &gt;&#x3D; &lt;&#x3D; !&#x3D; &#x3D;&#x3D;\n\t结果是boolean类型\n\n逻辑运算\n\t&amp;&amp; || !\n\t结果是Boolean类型\n\n赋值运算符\n\t基本 &#x3D;\n\t复合 +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;\n\t\t\t\n三元运算符\n\t表达式1 ? 表达式2 : 表达式3\n\n\n\n","slug":"day11_课堂笔记","date":"2022-12-01T11:48:38.759Z","categories_index":"前端三剑客","tags_index":"javascript","author_index":"团子"},{"id":"e994d58426d1973329baeeb9f5fd4931","title":"08_旋转_动画_flex布局","content":"昨日回顾定位\n\t概念\n\t\t布局方式,盒子层叠,固定显示\n\t使用\n\t\t定位方式\n\t\t设置偏移值\n\t分类\n\t\t相对定位\n\t\t\t相对于自身\n\t\t\t原点:原来的左上角的位置\n\t\t\t不脱标\n\t\t绝对定位\n\t\t\t相对于最近有定位祖先元素\n\t\t\t原点:定位祖先元素左上角(都没有,就是body左上角)\n\t\t\t脱标\n\t\t固定定位\n\t\t\t相对于body的左上角\n\t\t\t原点:body的左上角\n\t\t\t脱标\n\t应用\n\t\t子绝父相\nvertical-align\n\t概念\n\t\t设置行内元素,行内块元素垂直对齐方式\n\t取值\n\t\tbaseline\n\t\ttop\n\t\tbottom\n\t\tmiddle\n\t应用\n\t\timg撑开div之后,底部有间隙\n\t\timg垂直居中问题(只设置line-height&#x3D;父元素高度不行的)\noverflow\n\t概念\n\t\t控制内容区域超出之后的显示效果\n\t取值\n\t\thidden\n\t\tauto\n元素隐藏\n\tdisplay none 不占位置\n\tvisibility hidden 占位置\n字体图标\n\t本质是字体,用于页面中一些小的标签\n\t使用\n\t\t拖入字体包\n\t\t引入字体样式\n\t\t调用类名去显示\n\nCSS新特性过渡\n\t语法\n\t\ttransition: 属性名或者all 过渡时间\n\t注意\n\t\t过渡属性一般写在过渡元素上面\n\t\t\n位移\n\t语法\n\t\ttransform:translateX()  x轴\n\t\ttransform:translateY()  y轴 --- 可能会覆盖上面的\n\t\ttransform:translate(x轴,y轴) --  避免被覆盖\n\t注意\t\n    \t使用百分比,是相对于他自身\n旋转\n\t语法\n\t\ttransform:rotate(angle)\t定义 2D 旋转，在参数中规定角度。\n\t取值\n\t\t正数 顺时针\n\t\t负数 逆时针\n\t\t\n渐变\n\t语法\n\t\tbackground-image:linear-gradient(颜色1,颜色2...) \n\t\t\n\tlinear-gradient() 函数\n\t\t用于创建一个表示两种或多种颜色线性渐变的图片。\n\t\t创建一个线性渐变，需要指定两种颜色，还可以实现不同方向（指定为一个角度）的渐变效果，如\t\t   果不指定方向，默认从上到下渐变。\n\t\t\n动画\n\t语法\n\t\t1,先定义动画\n\t\t\t@keyframes 动画名称&#123;\n\t\t\t\t0%&#123;&#125;&#x2F;&#x2F;开始的状态\n\t\t\t\t100%&#123;&#125;&#x2F;&#x2F;结束的状态\n\t\t\t&#125;\n\t\t2,使用动画\n\t\t\t在需要添加动画的元素上,加一个animation,设置动画的名称 和动画的时长\n\t\t\t\n\t注意\n\t\t动画名称 和 动画持续的时长 必须要赋值\n\n\n\nflex布局概念\n\t一种弹性布局方式,他布局页面更加的简单,灵活,避免浮动脱标的影响\n\t\n组成\n\t弹性容器(父元素)\n\t弹性盒子(子元素)\n\t主轴(默认是水平方向,子元素就会默认水平排布)\n\t侧轴&#x2F;交叉轴(默认是垂直方向)\n\t\n使用\n\t1,需要在父元素上添加display:flex属性\n\t2,根据需要添加对应轴的属性来实现布局\n\t\n主轴对齐方式\n\tjustify-content\n\t\tcenter 居中\n\t\tspace-between 两边没有间隙,中间间隙等分\n\t\tspace-around 中间间隙是两边间隙的2倍\n\t\tspace-evenly 所有间隙等分\n\t\t\n侧轴对齐方式\n\talign-items\t\n\t\tcenter 居中\n\t\tstretch 拉伸 默认\n伸缩比\n\t实现子元素宽度不一样\n\tflex:数值 取父元素剩余宽度的份数\n\t\n子级元素的换行显示\n\tflex-wrap:wrap换行\n\t\n换行之后,行的显示方式\n\talign-content\n\t\tcenter 居中\n\t\tspace-between 上下两边没有间隙,中间间隙等分\n\t\tspace-around 中间间隙是上下两边间隙的2倍\n\n修改轴向\n\tflex-direction:column\n\t\n\t修改之后 实现水平对齐 align-items:center\n\t\t    实现垂直对齐 justify-content:center\n\n","slug":"day08_课堂笔记","date":"2022-12-01T11:35:05.354Z","categories_index":"前端三剑客","tags_index":"css","author_index":"团子"},{"id":"55ae4994231e43a4884c40522a431107","title":"07_定位_字体图标_新特性","content":"昨日回顾伪元素\n\t概念\n\t\tcss模拟生成的一些非主体部分\n\t语法\n\t\t::before\n\t\t::after\n\t注意\n\t\tcontent\n\t\t默认行内元素\n伪类选择器\n\t概念\n\t\t根据元素在html中的结构查询\n\t语法\n\t\t:first-child\n\t\t:last-child\n\t\t:nth-child(n)\n\t\t\t2n+1\n\t\t\t2n\n\t\t\t-n+5\n\t\t\tn+5\n浮动\t\n\t概念\n\t\t布局方式\n\t属性\t\n\t\tfloat:浮动\n\t\tclear清除\n\t特点\n\t\t脱标,覆盖标准流\n\t\t会受到上面元素边界的影响\n\t\t行内可以设置宽高,块级可以在一行显示\n\t清除浮动\n\t\t原因\n\t\t\t影响后面元素的布局\n\t\t做法\n\t\t\t设置父元素高度\n\t\t\t额外标签\n\t\t\t单伪元素\n\t\t\t双伪元素\n\n定位概念概念\n\t也是一种布局方式,可以让元素自由摆放在页面中的任意位置\n应用场景\n\t1,盒子之间的层叠问题,因为定位之后的元素层级是最高的,可以叠加在其他盒子上面\n\t2,可以将盒子始终固定在屏幕的某一位置\n使用\n\t1,设置定位的方式:position属性\n\t2,设置偏移值:水平和垂直就近各取一个\n\n相对定位概念\n\t自恋型定位,相对于他之前的位置进行移动\n语法\n\tposition:relative\n特点\n\t 1.没有脱标,占据空间的\n     2,参照坐标原点:以前在标准流左上角为原点\n应用场景\n\t1,子绝父相(常见的布局技巧)\n\t2,用于小范围的移动\n\n绝对定位概念\n\t拼爹型定位,相对于最近的有定位的祖先元素进行移动\n语法\n\tposition:absolute\t\n特点\n\t1,脱标,不占位置\n    2,参照的坐标原点:最近有定位的父元素\n                  如果父元素没有定位,一层层往上找,如果都没有,就参照body(浏览器正文左上角)\n应用场景\n\t1,子绝父相(常见的布局技巧)\n\n子绝父相概念\n\t一种常用跟定位相关的布局技巧,子元素是绝对定位,父元素是相对定位\n作用\n\t让子元素相对于父元素进行自由移动\n好处\n\t父元素是相对定位,没有脱标,对网页的布局影响是最小的\n应用场景\n\t一,元素水平居中\n\t\t1,子绝父相\n\t\t2,left: 50%;&#x2F;* 50%是相对于父元素 *&#x2F;\n\t\t3,transform: translateX(-50%);\n\t二,元素水平垂直居中\n\t\t1,子绝父相\n\t\t2,top: 50%;\n\t\t3,transform: translate(-50%,-50%);\n\n固定定位概念\n\t死心眼定位,相对于浏览器进行定位\n语法\n\tposition:fixed\n特点\n\t脱标,不占位置\n    参照的原点:浏览器正文的左上角\n场景\n\t让盒子固定在屏幕的某个位置\n\n层级关系1,不同布局之间的层级关系\n\t标准流 &lt; 浮动 &lt; 定位\n2,不同定位之间的层级关系\n\t相对,绝对,固定 默认的层级是相同的\n\t写在最下面的元素层级越高,会覆盖上面的元素\n\t可以使用z-index属性更改元素的层级,值越大,层级越高,这样就不需要更改html的结构\n\n\n\nvertical-align概念定义行内元素&#x2F;行内块元素 的基线相对于 该元素所在行的基线 的垂直对齐方式,默认是基线对齐\n\n作用可以解决 行内元素&#x2F;行内块元素 垂直对齐的问题\n\n取值baseline\t默认。元素放置在父元素的基线上。\nmiddle\t把此元素放置在父元素的中部。\nbottom\t使元素及其后代元素的底部与整行的底部对齐。\ntop\t把元素的顶端与行中最高元素的顶端对齐\n\n\n\n其他效果溢出效果属性\n\toverflow\n作用\n\t控制内容部分的显示效果\n取值\n\tvisible\t默认值。内容不会被修剪，会呈现在元素框之外。\n    hidden\t内容会被修剪，并且其余内容是不可见的。\n    scroll\t内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。\n    auto\t如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。\n\n隐藏效果display: none  在网页中不占位置\nvisibility:hidden  在网页中占据位置\n\n\n\n字体图标概念\n\t用于展示图标,本质是一个字体\n好处\n\t灵活地修改样式,降低服务器的请求次数\n\n使用\n\t1,将字体包拖到项目中\n\t2,引入字体图标的样式\n\t3,调用图标对应的类名去展示\n\n\n\nCSS新特性过渡作用\n\t让元素的样式慢慢发生改变\n使用\n\ttransition: all 1s;\n注意\n\t这个属性需要给过渡元素本身添加\n\n位移作用\n\t让元素沿着x轴或者y轴移动\n语法\n\ttransform:translate(水平移动举例,垂直移动距离)\n\ttransform:translateX()\n\ttransform:translateY()\n取值\n\t像素值,或者百分比(相对于自身的)\n\n","slug":"day07_课堂笔记","date":"2022-12-01T11:31:32.927Z","categories_index":"前端三剑客","tags_index":"css","author_index":"团子"},{"id":"43ea23256ce2c18e132735ea490d5a7f","title":"06_伪元素_伪类_浮动","content":"昨日回顾盒子模型\n\t像素级调整\n\t\n\t分类\t\n\t\t行盒:行级元素\n\t\t\t设置宽度没有效果,由内容决定\n\t\t块盒:块级元素\n\t\t\t设置宽度有效果,没有设置宽度,跟父元素一致,没有设置高度,由内容决定\n\t\t\t\n\t组成\n\t\t边框\n\t\t内边距\n\t\t外边距\n\t边框\n\t\t复合属性:border\n\t\t\t\tborder-width\n\t\t\t\t\t复合属性:1-4个取值 上右下左顺时针,某一边没有赋值,看对面\n\t\t\t\tborder-style\n\t\t\t\tborder-color\n\t\t单一方向border+方位词\n\t\tboder-radius 从左上角开始 顺时针赋值\n\t内边距\n\t\t设置边框和内容之间的间距\n\t\t取值也是1-4值,上右下左顺时针\n\t\t单一方向padding+方位词\n\t\t设置边框和内边距都会撑大盒子\n\t\t\t1.手动内减\n\t\t\t2,自动内减 box-sizing:border-box\n\t\t\t\n\t外边距\n\t\t设置盒子与盒子之间的距离\n\t\t取值也是1-4值,上右下左顺时针\n\t\t单一方向margin+方位词\n\t\t外边框合并:\n\t\t\t垂直布局的块级元素,只设置一个就可以\n\t\t外边距塌陷\n\t\t\t父子元素,子元素的margin-top作用在父元素上了\n\t\t\t给父元素设置margin-top,或者添加标签体\n\n\n\n伪元素概念\n\t伪元素在html骨架中并没有通过代码去实现,而是在css中实现的\n作用\n\t一般在页面中的非主体内容可以使用伪元素\n区别\n\t普通元素:通过html设置的标签生成的\n\t伪元素:由css模拟出来的标签效果\n\t本质区别:是否创建了新的元素\n语法\n\t::before 在父元素位置的最前面添加一个伪元素\n\t::after 在父元素位置的最后面添加一个伪元素\n注意点\n\t1,必须设置content属性才能生效\n\t2,伪元素默认是行内元素\n\n\n\n伪类作用\n\t无需添加额外属性,就可以根据元素在html中的结构关系来查找元素\n区别\n\t普通选择器:在html结构有标识的,id选择器,类选择器,在html标签中都有额外属性\n\t伪类选择器:在html结构中没有标识,根据逻辑上的关系来选择元素\n语法\n\t选择一个\n\t\t:first-child 选择第一个子元素\n\t\t:last-child 选择最后一个子元素\n\t\t:nth-child(n) 选择第n个(从1开始)\n\t\t:nth-last-child(n) 选择第n个(倒着数)\n\t选择多个\n\t\tn:关键字 取值为0,1,2,4...\n\t\t通过n组成一些常见的公式实现选择多个\n\t\t\t奇数:2n+1 2n-1  odd\n\t\t\t偶数:2n  even\n\t\t\t前5个: -n+5 (n必须要写在前面)\n\t\t\t从第5个往后:n+5(包含第5个)\n好处\n\t减少对html中类选择器的依赖,可以简化代码\n场景\n\t常用查找父级元素中的子元素\n\n\n\n标准流概念\n\t又称为文档流,浏览器默认采用的一套排版规则,规定了元素该如何排布\n规则\n\t块级元素\n\t\t从上到下,垂直布局,独占一行\n\t行级元素\n\t\t从左到右,水平布局,不能独占一行,只有上行空间不够才换行\n\n\n\n浮动作用\n\t早期 图文混排\n\t现在 页面布局(让块元素水平排布)\n语法\n\tleft\t元素向左浮动。\n\tright\t元素向右浮动。\n\tnone\t默认值。元素不浮动，并会显示在其在文本中出现的位置。\n特点\n\t1,浮动元素会脱离标准流(脱标),在标准流中不占位置,相当于从地面飘到了天空\n\t2,浮动元素比标准流级别高,可以覆盖标准流中的元素\n\t3,下一个浮动的元素,会在上一个浮动的元素后面进行左右浮动(就形成水平排布)\n\t4,浮动元素会受到上面元素边界的影响\n\t5,浮动元素有特殊的显示效果\n\t\t块级元素,浮动之后,就不会独占一行,一行可以显示多个\n\t\t行级元素,浮动之后,可以设置宽高(将来在布局的时候,不需要加上display:block)\n\n\n\n清除浮动概念\n\t因为子元素浮动了,就不能撑开标准流中的父元素的高度,后面元素的布局就会受影响,需要清除浮动对后面元素的影响\n\t\n原因\n\t子元素浮动后脱标,不占据标准流的位置\n\t\n目的\n\t就是为了让父元素有高度,从而不影响页面中其他元素的布局\n\t\n解决方式一:\n\t直接给父元素添加高度\n\t\t特点:\n\t\t\t简单粗暴,方便\n\t\t缺点\n\t\t\t有些布局中,不能固定父元素的高度,比如新闻列表\n解决方式二:\n\t额外标签法\n\t\t做法\n\t\t\t1,在父元素内容的最后面添加一个块元素\n\t\t\t2,给添加的块元素设置属性 clear:both\n\t\t缺点\n\t\t\t会在页面中添加额外的标签,会让页面结构变得复杂\n解决方式三:\n\t单伪元素清除法\n\t\t做法\n\t\t\t用伪元素替代了额外标签\n\t\t优点\n\t\t\t可以在项目中使用,直接给标签加上clearfix类就可以了\n解决方式四:\n\t双伪元素清除法\n\t\t做法\n\t\t\t添加前后两个伪元素,前面的伪元素用于解决margin塌陷问题,后面的伪元素用于清除浮动\n\t\t优点\n\t\t\t比单伪元素新增解决margin塌陷的问题\n","slug":"day06_课堂笔记","date":"2022-12-01T11:28:27.571Z","categories_index":"前端三剑客","tags_index":"css","author_index":"团子"},{"id":"e0eab4cf5da0462fb961c80cc5b3ffef","title":"05_核子模型详解","content":"昨日回顾常见属性\n\t尺寸属性\n\t\twidth\n\t\theight\n\t背景属性\n\t\tbackground-color\n\t\tbackground-image\n\t字体属性\n\t\tfont-size\n\t文本属性\n\t\tcolor\n\t边框属性\n\t\tborder\n\t盒子模型\n\t\tmargin\n\t\t\n字体属性\n\t分开\n\t\tfont-style\n\t\tfont-weight\n\t\tfont-size\n\t\tfont-family\n\t连写\n\t\tfont:style weight size&#x2F;line-height family\n\t\t\n文本属性\n\tcolor 文本颜色 \n\ttext-align\n\ttext-indent\n\ttext-decoration\n\tline-height  设置行间距和垂直居中\n\t\n背景属性\n\t分开写\n\t\tbackground-color\n\t\tbackground-image\n\t\tbackground-repeat\n\t\tbackground-position  ---精灵图\n\t连写\n\t\tbackground:color image repeat position\n\t\t\n三大特性\n\t层叠性\n\t继承性 文本 字体  对齐方式\n\t优先级 继承 &lt; 元素 &lt; 类 &lt; id &lt; 行内 &lt; !impotant\n\t\n\n盒子模型行盒和块盒分类行级元素对应的就是行盒\n\t不能独占一行,设置宽高没有效果,宽高是由内容来决定的\n\n块级元素对应的就是块盒\n\t独占一行,设置宽高有效果\n\t如果不设置宽度,跟父元素宽度保持一致\n\t如果不设置高度,默认是由内容撑开\n\t\n互转\n\t行级-&gt;块级 display:block\n\t块级-&gt;行级 display:inline\n\t行内块 display:inline-block(可以设置宽高,可以在一行显示)\n\n盒子模型组成边框 border\n内边距 padding\n外边距 margin\n\n边框详解分开写\n\tborder-width\n\tborder-style\n\tborder-color\n连写\t\n\tborder: border-width border-style border-color\n单独设置某一方向上的边框\n\tborder-bottom: 10px solid red;\n圆角\n\tborder-radius\n\n盒子大小初始计算盒子宽度 &#x3D; 左边框 + 内容的宽度 + 右边框\n\n设置边框,会撑大盒子\n\n解决:计算多余的大小,手动在内容区域中减去(手动内减)\n\n内边距详解作用\n\t设置边框和内容区域的距离\n赋值\n\t从上边距开始,顺时针,如果某一边没有赋值,看对面\n单一方向赋值\n\tpadding-方位词\n\n盒子大小最终计算盒子宽度 &#x3D; 左边框 + 左内边距 + 内容的宽度  + 右内边距 + 右边框\n\n设置内边距,会撑大盒子\n\n解决:计算多余的大小,手动在内容区域中减去(手动内减)\n\n盒子尺寸自动内减做法\n\tbox-sizing: border-box;\n\t\n原理\n\t浏览器自动计算需要减去的尺寸,在内容区域减去(自动内减)\n\n外边距详解作用\n\t设置 盒子 与 盒子 之间的距离\n赋值\n\t从上边距开始,顺时针,如果某一边没有赋值,看对面\n单一方向赋值\n\tmargin-方位词\n\n清除默认内外边距应用场景\n\t浏览器会为部分标签设置默认的margin和padding,其实我们不需要,一般在项目开始之前需要先清除这些标签的默认样式\n\n例如\n\tbody标签的默认margin\n\tp标签的默认上下margin\n\tul标签的默认上下margin和padding-left\n\t\n淘宝的处理方式\n\tblockquote, body, button, dd, dl, dt, fieldset, form, h1, h2, h3, h4, h5, h6, hr, input, legend, li, ol, p, pre, td, textarea, th, ul &#123;\n    margin: 0;\n    padding: 0;\n&#125;\n\n京东的处理方式\n* &#123;\n    margin: 0;\n    padding: 0;\n&#125;\n\n外边距正常情况场景\n\t水平布局的盒子,左右的margin正常的,互不影响\n结果\n\t最终两者的间距为左右margin之和\n\n外边距合并情况场景\n\t垂直布局的盒子,上下的margin会合并\n结果\n\t最终两者的距离为margin中的最大值\n解决方法\n\t避免就好\n\t只给其中一个盒子设置margin即可\n\n外边距塌陷情况场景\n\t互相嵌套的块级元素,子元素的margin-top会作用在父元素上\n结果\n\t导致父子元素一起向下移动\n解决\n\t1,给父元素设置border-top或者padding-top(分割父子元素的margin-top)\n\t2,设置父元素的overflow: hidden\n\t3,转成行内块元素\n\t4,设置浮动\n\n","slug":"day05_课堂笔记","date":"2022-12-01T11:27:32.923Z","categories_index":"前端三剑客","tags_index":"css","author_index":"团子"},{"id":"6ebca54f38fa8fefa2acc1b9ec6647ba","title":"04_字体文本背景属性","content":"昨日回顾表单\n\tform\n\t\taction\n\t\tmethod\n\t\n\tinput\n\t\ttype\n\t\t\ttext\n\t\t\tpassword\n\t\t\tradio\n\t\t\tcheckbox\n\t\t\tfile\n\t\t\treset\n\t\t\tsubmit\n\t\t\tbutton\n\t\tchecked\n\t\t\tchecked\n\tselect\n\t\toption 子标签\n\t\t\tselected\n\t\t\t\tselected  选中\n\ttextarea\n\t\tcols 列数\n\t\trows 行数\n\t\n\t共同属性\n\t\tname\n\t\t\t将数据提交到后台\n\t\t\t单选复选框分组\n\t\tvalue\n        \t设置单选复选框提交到后台的值\n\t\t\t设置按钮上的值\n\t\t\t设置下拉选择框提交到后台的值\n\t\t\t\n\t新增\n\t\tlabel 提升用户体验 让光标聚焦到关联的控件上\n\t\tbutton  定义按钮,加上type属性\n\t\t\n表格\n\ttable\n\t\twidth\n\t\theight\n\t\tborder\n\ttr\n\t\talign\n\tth,td\n\t\trowspan\n\t\tcolspan\ncss\n\t概念\n\t\t层叠样式表 样式+布局\n\t引入方式\n\t\t行内样式\n\t\t内部样式\n\t\t外部样式\n\t选择器\n\t\t基本\n\t\t\tid选择器\n\t\t\t类选择器\n\t\t\t元素选择器\n\t\t扩展\n\t\t\t并集选择器 ,\n\t\t\t交集选择器 \n\t\t\t后代选择器\n\t\t\t子选择器\n\t\t\t兄弟选择器 +\n\t\t\t属性选择器 []\n\t\t\t伪类选择器 hover\n\t\n\n\n\n常见属性入门尺寸属性\n\twidth 宽度\n\theight 高度\n背景属性\n\tbackground-color 背景颜色\n\tbackground-image 背景图片\n字体属性\n\tfont-size 字体大小\n文本属性\n\tcolor 文本颜色\n边框属性\n\tborder 边框\n盒子模型\n\tmargin 外边距\n\n\n\n字体相关属性分开写\n\tfont-style 字体样式\n\tfont-weight 字体粗细\n\tfont-size 字体大小\n\tfont-family 字体系列\n连写\n\tfont:style weight size family\n\n文本相关属性基本属性\n\tcolor 颜色\n\ttext-align 对齐方式\n\ttext-decoration 装饰线\n\ttext-indent 首行缩进\n\tline-height 行高\n\t\nline-height\n\t1,设置文本上下间距\n\t2,可以让单行文本垂直居中(line-height &#x3D; 文本所在父元素的高度)\n\n\t注意点\n\t\t设置line-height:1,取消上下默认间距,实现精准布局\n\t\t跟font连写的时候,可能会被覆盖,一般将line-height放在字体连写的后面\n\n\n\n背景相关属性基本属性\n\t背景颜色\n\t\tbackground-color\n\t背景图片\n\t\tbackground-image\n\t背景平铺\n\t\tbackground-repeat\n\t背景位置\n\t\tbackground-position\n\t背景尺寸\n\t\tbackground-size\n\t\t\n背景连写\n\tbackground: color image repeat position\n\t\n颜色取值\n\t1,关键字\n\t2,rgb\n\t3,rgba\n\t4,#16进制值\n\t\n精灵图\n\t场景\n\t\t将项目中多张小图,合并成一张大图,这张大图就叫做精灵图\n\t好处\n\t\t减少服务器发送图片的次数,提高页面的加载速度\n\t步骤\n        1,创建一个盒子\n        2,设置盒子的大小为要展示的图片的大小\n        3,设置精灵图为盒子的背景图片\n        4,将小图片左上角的坐标取负值,设置给图片的background-position属性\n\nCSS三大特性层叠性\n\t后写的样式会覆盖先写的样式(相同的样式会覆盖,不同的样式会叠加)\n\n继承性\n\t子元素会继承父元素的相关属性,可以在一定程度上减少代码\n\t\n\t应用场景\n\t\t1,直接给ul设置list-style:none,就可以去掉无序列表中的小圆点\n\t\t2,直接给body设置font-size,可以统一浏览器默认文字的大小\n优先级\n\t不同的选择器具有不同优先级,优先级高的选择器会覆盖优先级低的选择器样式\n\t\n\t规律\n\t\t继承 &lt; 元素选择器 &lt; 类选择器 &lt; id选择器 &lt; 行内样式 &lt; !important\n\t注意点\n\t\t1,!important写在属性值的后面,分号的前面\n\t\t2,!important不能提升继承的优先级,只要继承,优先级是最低的\n\t\t3,实际开发中不建议使用!important\n\n","slug":"day04_课堂笔记","date":"2022-12-01T11:14:19.660Z","categories_index":"前端三剑客","tags_index":"css","author_index":"团子"},{"id":"bdae8df5a111dedc49e69aa7490b0c37","title":"Css基础知识","content":"一. CSS简介1 CSS的基本概念1) 什么是CSSCSS(Cascading Style Sheets)  ，通常称为CSS样式表或层叠样式表\n2) CSS的作用CSS的作用就是用来规定每个HTML元素表现的样子, 比如\n\n字体的大小\n颜色\n摆放位置…\n\n\n\n\n\n\n\n\n\n\nCSS也被称为网页的化妆师\n\n再比如, 如果说HTML是毛坯房的话, 加上CSS就是精装修房\n\n\n随着web的发展, 出现一种非常重要的思想\n\n\n\n\n\n\n\n\n\n结构(html)与样式(css)相分离\n这样设计的好处, 实现代码的复用, 利用工程化开发.\n比如, 老板觉得网站的风格不看好, 可以换一个”皮肤”, 其实只需要修改css样式就可以了, 网站的结构和数据可以不变\n3) CSS的书写位置\n外联\n内嵌\n行内\n\n在工作中最常见的方式是, 将CSS文件单独做为一个文件存储, 再通过&lt;link&gt;标签引入\n在目前的学习阶段, 为了调试方便, 我们将CSS写在html文件的&lt;style&gt;标签中\n行内几乎不用, 可以自行了解\n\n\n\n样式表\n优点\n缺点\n使用情况\n控制范围\n\n\n\n行内样式表\n书写方便，权重高\n没有实现样式和结构相分离\n较少\n控制一个标签（少）\n\n\n内部样式表\n部分结构和样式相分离\n没有彻底分离\n较多\n控制一个页面（中）\n\n\n外部样式表\n完全实现结构和样式相分离\n需要引入\n最多，强烈推荐\n控制整个站点（多）\n\n\n4) CSS的基础语法\n\n\n\n\n\n\n\n\n语法\n&lt;head&gt;\n&lt;style&gt;\n    选择器（选择的标签） &#123; \n      属性1: 属性值1;\n      属性2: 属性值2; \n      属性3: 属性值3;\n    &#125;\n&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n\n主要由 选择器+声明块 组成\n\n\n\n\n\n\n\n\n\n示例\n将h1的字体改成红色\n&lt;style&gt;\n\t h1 &#123;\n\t \tcolor: red;\n\t &#125;\n&lt;&#x2F;style&gt;\n\n二. 选择器1 什么是选择器\n\n\n\n\n\n\n\n\n选择器的主要作用就是从一堆元素中选出特定的符合要求的元素\n\n比如, 上图中有一堆小黄人, 现在需要统一改变单眼小黄人的颜色为红色, 该如何操作呢?\n\n第一步: 选出所有的单眼小黄人\n第二步: 修改颜色为红色\n\nCSS的思想也是类似的\n\n第一步: 通过选择器, 找出符合要求的HTML元素\n第二步: 修改找出来的元素的属性\n\n常见的选择器包括\n\n元素选择器\n类选择器\nid选择器\n\n2 基本选择器1) 元素选择器\n\n\n\n\n\n\n\n\n作用\n根据标签名, 将同一种标签元素选择出来\n\n\n\n\n\n\n\n\n\n语法\n标签名 &#123;\n 属性: 值\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\n修改所有p标签的颜色为红色\np*3&gt;lorem10\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      p &#123;\n        color: red;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    将所有p标签的颜色改为红色\n    &lt;p&gt;\n      Lorem ipsum dolor, sit amet consectetur adipisicing elit. Minima,\n      consequuntur.\n    &lt;&#x2F;p&gt;\n    &lt;p&gt;\n      Facere, earum eum voluptates explicabo aut tempora eveniet voluptate. Eos!\n    &lt;&#x2F;p&gt;\n    &lt;p&gt;\n      Fugit cupiditate ea doloremque quidem obcaecati. Rerum quam explicabo\n      quod.\n    &lt;&#x2F;p&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n2) 类选择器\n\n\n\n\n\n\n\n\n作用\n选择某一类元素, 该元素通过class属性指定\n\n\n\n\n\n\n\n\n\n语法\n.类名 &#123;\n\t属性: 值\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\ndiv*5&gt;lorem3\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;类选择器&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .red &#123;\n        color: red;\n      &#125;\n      .blue &#123;\n        color: blue;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;Lorem, ipsum dolor.&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;red&quot;&gt;Facere, possimus laboriosam.&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;blue&quot;&gt;Ducimus, ea perferendis!&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;red&quot;&gt;Accusamus, accusantium dolores.&lt;&#x2F;div&gt;\n    &lt;div&gt;Eius, eaque magni.&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n多类名使用空格隔开\n\n3) id选择器\n\n\n\n\n\n\n\n\n作用\n选择某一个元素, 该元素通过id属性指定\n\n\n\n\n\n\n\n\n\n语法\n#id名 &#123;\n\t属性: 值\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;p id&#x3D;&quot;username&quot;&gt;&lt;&#x2F;p&gt;\n\n练习实现’Google’图标\n提示\n\n使用span让多个元素在同一行排列\n使用class类选择器\n使用color定义颜色\n使用font-size:100px指定大小\n\n\n\n\n\n\n\n\n\n\n\n答案\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      span &#123;\n        font-size: 100px;\n      &#125;\n\n      .red &#123;\n        color: red;\n      &#125;\n      .blue &#123;\n        color: blue;\n      &#125;\n      .yellow &#123;\n        color: yellow;\n      &#125;\n      .green &#123;\n        color: green;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;\n      &lt;span class&#x3D;&quot;blue&quot;&gt;G&lt;&#x2F;span&gt;\n      &lt;span class&#x3D;&quot;red&quot;&gt;o&lt;&#x2F;span&gt;\n      &lt;span class&#x3D;&quot;yellow&quot;&gt;o&lt;&#x2F;span&gt;\n      &lt;span class&#x3D;&quot;blue&quot;&gt;g&lt;&#x2F;span&gt;\n      &lt;span class&#x3D;&quot;green&quot;&gt;l&lt;&#x2F;span&gt;\n      &lt;span class&#x3D;&quot;red&quot;&gt;e&lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n方法更多选择器的用法, 查手册CSS手册\n\n3 复合选择器1) 后代选择器\n\n\n\n\n\n\n\n\n作用\n选择某一个元素的子孙后代, 使用 空格\n\n\n\n\n\n\n\n\n\n语法\n父选择器 子选择器 &#123;\n\t属性: 值\n&#125;\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      nav li &#123;\n        color: red;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 主导航 --&gt;\n    &lt;nav&gt;\n      &lt;ul&gt;\n        &lt;li&gt;Lorem.&lt;&#x2F;li&gt;\n        &lt;li&gt;Nobis!&lt;&#x2F;li&gt;\n        &lt;li&gt;Exercitationem?&lt;&#x2F;li&gt;\n        &lt;li&gt;Voluptas.&lt;&#x2F;li&gt;\n        &lt;li&gt;Nulla!&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;nav&gt;\n\n    &lt;!-- 新闻列表 --&gt;\n    &lt;ul&gt;\n      &lt;li&gt;Lorem.&lt;&#x2F;li&gt;\n      &lt;li&gt;Magni!&lt;&#x2F;li&gt;\n      &lt;li&gt;Sed?&lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2) 并集选择器\n\n\n\n\n\n\n\n\n作用\n同时选择多个选择器, 使用 逗号\n\n\n\n\n\n\n\n\n\n语法\n选择器1, 选择器2 &#123;\n\t属性: 值\n&#125;\n\n3) 交集选择器\n\n\n\n\n\n\n\n\n作用\n同时满足条件, 使用 点号\n\n\n\n\n\n\n\n\n\n语法\n选择器1.选择器2 &#123;\n\t属性: 值\n&#125;\n\n现在有这样一个需求\nh1和p都是应用的同一个类表示强调, 但是我们希望h1的强调是红色, p的强调是蓝色\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      h1.import &#123;\n        color: red;\n      &#125;\n      p.import &#123;\n        color: blue;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1 class&#x3D;&quot;import&quot;&gt;Lorem.&lt;&#x2F;h1&gt;\n    &lt;p class&#x3D;&quot;import&quot;&gt;\n      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Impedit\n      molestias, odio doloremque ab neque numquam animi, ipsum qui natus aut\n      dignissimos quo nobis sequi architecto nemo tempore cum ipsa possimus!\n    &lt;&#x2F;p&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n4) a元素的伪类选择器\n\n\n\n\n\n\n\n\n作用\n选择同一元素的不同状态\n\n\n\n\n\n\n\n\n\n语法\n\na:link      /* 未访问的链接 */\na:visited   /* 已访问的链接 */\na:hover     /* 鼠标移动到链接上 */\na:active    /* 选定的链接 */\n\n书写顺序: lvha, 爱恨法则, love &amp; hate\n\n\n\n\n\n\n\n\n\n示例\na &#123;   \n  font-weight: 700;\n  font-size: 16px;\n  color: gray;\n&#125;\na:hover &#123;   &#x2F;* :hover 是链接伪类选择器 鼠标经过 *&#x2F;\n\tcolor: red; &#x2F;*  鼠标经过的时候，由原来的 灰色 变成了红色 *&#x2F;\n&#125;\n\n5) 自学\n属性选择器\n子代选择器\n兄弟选择器\n\n练习&lt;!-- 主导航栏 --&gt;\n&lt;nav class&#x3D;&quot;top-nav&quot;&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;公司首页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;公司简介&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;公司产品&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;联系我们&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n&lt;&#x2F;nav&gt;\n&lt;!-- 侧导航栏 --&gt;\n&lt;aside class&#x3D;&quot;side-nav&quot;&gt;\n  &lt;div class&#x3D;&quot;left&quot;&gt;左侧侧导航栏&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;right&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;登录&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;aside&gt;\n\n在不修改以上结构代码的前提下，完成以下任务：\n\n链接 登录 的颜色 为 红色\n鼠标经过 登录 时颜色 为 蓝色\n主导航栏里面的所有的链接改为橙色   \n\n三. 文本相关属性1 font相关1) 大小font-size\n\n\n\n\n\n\n\n\n作用\n设置字体大小\n\n\n\n\n\n\n\n\n\n示例\nh1 &#123;  \n\tfont-size:20px; \n&#125;\n\n2) 字体font-family\n\n\n\n\n\n\n\n\n作用\n设置字体\n\n\n\n\n\n\n\n\n\n示例\nbody &#123;\n  font-family: Arial,Microsoft Yahei,sans-serif\n&#125;\n\n\nsan-serif : 非衬线字体(文字的笔画粗细是一样的, 如黑体)\nserif: 衬线字体(文字的笔画有尖角, 如宋体)\n\n会依次查找电脑上的字体, 如果都没有, 就使用一种非衬线字体\n3) 粗细font-weight\n\n\n\n\n\n\n\n\n作用\n设置文本的粗细\n\n\n\n\n\n\n\n\n\n示例\ndiv &#123;\n  font-weight: bold\n&#125;\n\n\n\n\n属性值\n描述\n\n\n\nnormal\n默认值（不加粗的）\n\n\nbold\n定义粗体（加粗的）\n\n\n100~900\n400 等同于 normal，而 700 等同于 bold  我们重点记住这句话\n\n\n4) 风格font-style\n\n\n\n\n\n\n\n\n作用\n设置文本的倾斜\ndiv &#123;\n  font-style: italic\n&#125;\n\n5) 常用连写font是可以连写的, 通常连写也是很常见的\n选择器 &#123; font: font-style  font-weight  font-size&#x2F;line-height  font-family;&#125;\n\n\n\n\n\n\n\n\n\n\n示例\nbody &#123;\n  font: 16px &quot;Microsoft Yahei&quot;\n&#125;\n\n2 外观1) color\n\n\n\n\n\n\n\n\n作用\ncolor属性用于定义文本的颜色\n\n\n\n表示表示\n属性值\n\n\n\n预定义的颜色值\nred，green，blue\n\n\n十六进制(使用的最多)\n#rrggbb, #FF0000，#FF6600，#29D794\n\n\nRGB代码\nrgb(255,0,0)或rgb(100%,0%,0%)\n\n\n\nR: red红色, #00~#FF(0~255), 前两位\nG: green绿色, #00~#FF(0~255), 中间两位\nB: blue蓝色,#00~#FF(0~255), 后两位\n2) 文本对齐text-align\n\n\n\n\n\n\n\n\n\n作用\n设置文本内容的水平对齐方式\n\n\n\n属性\n解释\n\n\n\nleft\n左对齐（默认值）\n\n\nright\n右对齐\n\n\ncenter\n居中对齐\n\n\n3) 行高line-height\n\n\n\n\n\n\n\n\n\n作用\n属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高\n4) 装饰线text-decoration   通常我们用于给链接修改装饰效果\n\n\n\n值\n描述\n\n\n\nnone\n默认。定义标准的文本。 取消下划线（最常用）\n\n\nunderline\n定义文本下的一条线。下划线 也是我们链接自带的（常用）\n\n\noverline\n定义文本上的一条线。（不用）\n\n\nline-through\n定义穿过文本下的一条线。（不常用）\n\n\n5) 单位\n\n\n值\n\n\n\n\npx\n像素值\n\n\nem\n1em 等于当前的字体尺寸. 例如，如果某元素以 12px 显示，那么 2em 是24px\n\n\n%\n百分比\n\n\n数值\n倍数\n\n\n小综合练习实现如下效果:\n\n提示:\n\n标题文本都居中, 可以考虑提取一个公共样式\n腾讯新闻有下划线, 但是并不是一个链接\n收藏本文是链接, 但是没有下划线\n在段落里有一个首行缩进的效果, 是两个汉字, 如何实现\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;综合案例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        font: 16px &#39;Microsoft Yahei&#39;;\n      &#125;\n      article .title &#123;\n        font-size: 28px;\n        font-weight: 400;\n      &#125;\n      article .tac &#123;\n        text-align: center;\n      &#125;\n      article .date &#123;\n        color: #ccc;\n      &#125;\n      article .author &#123;\n        color: #990000;\n        text-decoration: underline;\n      &#125;\n      article .sub-title a &#123;\n        color: #00f;\n        text-decoration: none;\n      &#125;\n      article .sub-title input &#123;\n        color: red;\n      &#125;\n      article .sub-title button &#123;\n        color: green;\n        font-weight: 700;\n      &#125;\n      article p &#123;\n        line-height: 26px;\n        text-indent: 2em;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;article&gt;\n      &lt;h1 class&#x3D;&quot;title tac&quot;&gt;加强反垄断监管是为了更好发展&lt;&#x2F;h1&gt;\n      &lt;div class&#x3D;&quot;sub-title tac&quot;&gt;\n        &lt;span class&#x3D;&quot;date&quot;&gt;2020年12月20日&lt;&#x2F;span&gt;\n        &lt;span class&#x3D;&quot;author&quot;&gt;腾讯新闻 （20人参与）&lt;&#x2F;span&gt;\n        &lt;a href&#x3D;&quot;&quot;&gt;收藏本文&lt;&#x2F;a&gt;\n        &lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;请输入查询条件&quot; &#x2F;&gt;\n        &lt;button&gt;搜索&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n      &lt;hr &#x2F;&gt;\n      &lt;p&gt;\n        近日，市场监管总局根据举报，在前期核查研究的基础上，对阿里巴巴集团控股有限公司实施“二选一”等涉嫌垄断行为立案调查。这是我国在互联网领域加强反垄断监管的一项重要举措，有利于规范行业秩序、促进平台经济长远健康发展。\n      &lt;&#x2F;p&gt;\n      &lt;p&gt;\n        近年来，我国线上经济蓬勃发展，新业态、新模式层出不穷，对推动经济高质量发展、满足人民日益增长的美好生活需要发挥了重要作用。但与此同时，线上经济凭借数据、技术、资本优势也呈现市场集中度越来越高的趋势，市场资源加速向头部平台集中，关于平台垄断问题的反映和举报日益增加，显示线上经济发展中存在一些风险和隐患。近期召开的中央政治局会议和中央经济工作会议均明确要求强化反垄断和防止资本无序扩张，得到社会热烈反响和广泛支持。可见，反垄断已成为关系全局的紧迫议题。\n      &lt;&#x2F;p&gt;\n    &lt;&#x2F;article&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n四. 背景相关属性\n\n\n\n\n\n\n\n\n什么是叫背景\n背景的概念最早提出是在摄影和图像处理领域, \n主要目的是为了突出主体, 通常会用一个背景来衬托. 比如证件照\n\n网页一开始主要也是来处理文字和图片, 就借鉴了背景这个概念\n背景可以纯色的, 也可以是一张图片\n1 背景颜色(color)\n\n\n\n\n\n\n\n\n语法\nbackground-color:颜色值;   默认的值是 transparent  透明的\n\n如果要设置背景, 元素必须有宽高!\n2 背景图片(image)\n\n\n\n\n\n\n\n\n语法 \nbackground-image : none | url (url) \n\n\n\n\n参数\n作用\n\n\n\nnone\n无背景图（默认值）\n\n\nurl\n使用相对地址指定背景图像\n\n\nbackground-image : url(images&#x2F;demo.png);\n\n1) 背景图片与插入图片的区别\nimg元素: 属于HTML的范畴, 当图片是HTML结构的一个组成部分时, 使用img\n背景图片: 属于CSS的范畴, 当图片只是为了美化, 使用背景图片\n\n\n\n\n\n\n\n\n\n\n示例\n比如一篇文章, 除了文字描述外, 为了更好的表达要说明的内容, 配了一张图, 这张图就是网页的组成部分,是一个HTML的元素, 就使用img\n\n这里是一个按钮(属于HTML功能), 但是为了让这个按钮更漂亮, 使用背景图片\n\n2) 路径在CSS中的路径是相对于CSS文件的. \n3 背景平铺（repeat）默认情况下背景图片是铺满整个容器的, 就好比贴地板, 这样做的好处是可以减小整个图片的体积, 加快网站的访问速度\n\n\n\n\n\n\n\n\n\n语法\nbackground-repeat : repeat | no-repeat | repeat-x | repeat-y \n\n\n\n\n参数\n作用\n\n\n\nrepeat\n背景图像在纵向和横向上平铺（默认的）\n\n\nno-repeat\n背景图像不平铺\n\n\nrepeat-x\n背景图像在横向上平铺\n\n\nrepeat-y\n背景图像在纵向平铺\n\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        background-image: url(&#39;.&#x2F;images&#x2F;bg.jpg&#39;);\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4 背景位置(position)\n\n\n\n\n\n\n\n\n语法 \nbackground-position : length || length\n\nbackground-position : position || position \n\n\n\n\n参数\n值\n\n\n\nlength\n百分数 | 由浮点数字和单位标识符组成的长度值\n\n\nposition\ntop | center | bottom | left | center | right   方位名词\n\n\n\n注意：\n必须先指定background-image属性\nposition 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。\n如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left  top和top  left效果一致\n如果只指定了一个方位名词，另一个值默认居中对齐。\n如果position 后面是精确坐标， 那么第一个，肯定是 x  第二的一定是y\n如果只指定一个数值,那该数值一定是x坐标，另一个默认垂直居中\n如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标\n\n\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      div &#123;\n        width: 600px;\n        height: 600px;\n        background-color: #aaa;\n        background-image: url(.&#x2F;images&#x2F;money.jpg);\n        background-repeat: no-repeat;\n        background-position: center center;\n        &#x2F;* background-position: 100px 100px; *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n5 背景简写\n\n\n\n\n\n\n\n\n建议\nbackground: 背景颜色 背景图片地址 背景平铺 背景位置\n\n\n\n\n\n\n\n\n\n示例\nbackground: transparent url(image.jpg) repeat-y center top ;\n\n6 背景图的应用精灵图, 很多时候, 我们可以把多个小图标整合到一起, 再通过position调节找出我们想要的背景图. \n\n\n\n\n\n\n\n\n\n优势\n可以减少请求次数\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      div &#123;\n        height: 40px;\n        width: 40px;\n        background-image: url(&#39;.&#x2F;images&#x2F;icon.png&#39;);\n        background-position: -130px -35px;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div&gt;&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n五. CSS的特性1 层叠性所谓层叠性是指多种CSS样式的叠加在一起, 同时作用在一个元素时, 最终浏览器以谁为主的问题\n\n\n\n\n\n\n\n\n\n原则\n后写的样式会覆盖先写的样式\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n\t&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n\t&lt;title&gt;Document&lt;&#x2F;title&gt;\n\t&lt;style&gt;\n\t\tdiv &#123;\n\t\t\tcolor: red;\n\t\t\tfont-size: 30px;\n\t\t&#125;\n\n\t\tdiv &#123;\n\t\t\tcolor: blue;\n\t\t&#125;\n\t&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\t&lt;div&gt;\n\t\t 长江后浪推前浪，前浪死在沙滩上。\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n2 继承性子元素会继承父元素==文本==相关的属性\n\nfont-\ntext-\nline-\ncolor\n\n\n\n\n\n\n\n\n\n\n示例\n一般, 我们会统一给body设置font-size\nbody &#123;\n  font: 16px &quot;Mircosoft Yahei&quot;\n&#125;\n\n给父元素设置color\n3 优先级1) 权重公式定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时，\n\n选择器相同，则执行层叠性\n选择器不同，就会出现优先级的问题\n\n关于优先级，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）权重公式\n\n\n\n标签选择器\n计算权重公式\n\n\n\n继承或者 *\n0,0,0,0\n\n\n每个元素（标签选择器）\n0,0,0,1\n\n\n每个类，伪类\n0,0,1,0\n\n\n每个ID\n0,1,0,0\n\n\n每个行内样式 style=””\n1,0,0,0\n\n\n每个!important  重要的\n∞ 无穷大\n\n\n总的原则是, 影响范围越小, 选出的元素越特殊, 权重越高\n2) 权重叠加我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。\n就是一个简单的加法计算\n\ndiv ul  li   ——&gt;      0,0,0,3\n.nav ul li   ——&gt;      0,0,1,2\na:hover      —–—&gt;   0,0,1,1\n.nav a       ——&gt;      0,0,1,1\n\n\n\n\n\n\n\n\n\n\n注意\n不存在进位\n比如, 10个元素选择器叠加在一起, 权重依然没有一个类选择器高\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      a &#123;\n        color: red;\n      &#125;\n      ul a &#123;\n        color: blue;\n      &#125;\n      .mylink &#123;\n        color: green;\n      &#125;\n      #myli a &#123;\n        color: grey;\n      &#125;\n      #mydiv .mylink &#123;\n        color: skyblue;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;mydiv&quot;&gt;\n      &lt;ul id&#x3D;&quot;myul&quot;&gt;\n        &lt;li id&#x3D;&quot;myli&quot;&gt;&lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;mylink&quot;&gt;举例&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n六. 盒子模型1 盒子分类每个元素都有默认的显示方式, 包括\n\n块盒: 独占一行, 可以设置宽高\n行盒: 不独占一行, 高度由字体大小撑开\n\n显示方式都是由display属性控制的\ndisplay常见的值:\n\nblock: 块盒\ninline: 行盒\ninline-block: 行内块\n\n重要结论块盒(div)可以设置宽高\n行盒(span)设置宽高不生效, 由内容决定\n行内块(img)可以设置宽高, 又跟其它元素在同一行显示\n2 盒子模型1) 网页的布局网页布局中，我们是如何把里面的文字，图片，按照美工给我们的效果图排列的整齐有序呢？\n\n\n网页布局\n\n 首先利用CSS设置好盒子的大小，然后摆放盒子的位置\n 最后把网页元素比如文字图片等等，放入盒子里面\n\n\n\n因此, 我们需要先了解如何摆放盒子\n2) 盒子模型现实中的盒子有\n\n边框(厚度): border\n填充泡沫: padding\n内容: content\n\n盒子与盒子之间的距离就是外边距\n\n代码中的盒子模型, 打开浏览器, 通过调试窗口, 可以看到\n\n\n\n\n\n\n\n\n\n\n示例\ndiv &#123;\n\twidth: 100px;\n\theight: 100px;\n\tborder: 1px solid;\n\tmargin: 10px;\n\tpadding: 10px;\n&#125;\n\n3) 边框border\n\n\n\n\n\n\n\n\n语法\nborder : border-width || border-style || border-color \n\n\n\n\n属性\n作用\n\n\n\nborder-width\n定义边框粗细，单位是px\n\n\nborder-style\n边框的样式\n\n\nborder-color\n边框颜色\n\n\n边框的样式包括:\n\nnone：没有边框即忽略所有边框的宽度（默认值）\nsolid：边框为单实线(最为常用的)\ndashed：边框为虚线 \ndotted：边框为点线\n\n\n\n\n\n\n\n\n\n\n示例\ndiv &#123;\n   border: 1px solid red;\n&#125;\n\n\n\n\n\n\n\n\n\n\n圆角边框\n在新的设计语言里, 圆角边框也是非常常见的表现形式, 在CSS3中新增了border-radius\n比如:\n\n\n\n\n\n\n\n\n\n\n示例\np &#123;\n  width: 80px;\n  height: 30px;\n  background-color: red;\n  font-size: 16px;\n  color: #fff;\n  text-align: center;\n  line-height: 30px;\n  border-radius: 15px;\n&#125;\n\n通过调整border-radius的值改变弧度, 当值为height的一半时, 就是表现为一个半圆形\n也可以通过border-radius: 50%画一个圆\ndiv &#123;\n  width: 200px;\n  height: 200px;\n  background-color: skyblue;\n  border-radius: 50%;\n&#125;\n\n4) 内边距padding内边距也叫内填充, 是内容和边框border之间的距离\n\n\n\n属性\n作用\n\n\n\npadding-left\n左内边距\n\n\npadding-right\n右内边距\n\n\npadding-top\n上内边距\n\n\npadding-bottom\n下内边距\n\n\n\n\n\n\n\n\n\n\n\n简写\n按顺时针的方向: 上右下左\n\n\n\n\n\n\n\n\n\n示例\ndiv &#123;\n  &#x2F;* 上:10px 右:20px 下:10px 左:20px *&#x2F;\n  padding: 10px 20px 10px 20px;\n&#125;\n\n一般, 写两个值的情况比较常见\n分别表示: 上下和左右\n\n\n\n\n\n\n\n\n\n示例\ndiv &#123;\n  &#x2F;* 上:10px 右:20px 下:10px 左:20px *&#x2F;\n  padding: 10px 20px;\n&#125;\n\n\n\n\n\n\n\n\n\n\n实战案例\n新浪导航栏的核心就是因为里面的字数不一样多，所以我们不方便给具体的宽度\n这个时候, 我们就可以通过设置padding的方式撑开盒子\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n\t&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n\t&lt;title&gt;新浪导航栏案例&lt;&#x2F;title&gt;\n\t&lt;style&gt;\n\t&#x2F;*清除元素默认的内外边距*&#x2F;\n\t\t* &#123;\n\t\t\tmargin: 0;\n\t\t\tpadding: 0;\n\t\t&#125;\n\t\t.nav &#123;\n\t\t\theight: 41px;\n\t\t\tbackground-color: #FCFCFC;\n\t\t\t&#x2F;*上边框*&#x2F;\n\t\t\tborder-top: 3px solid #FF8500;\n\t\t\t&#x2F;*下边框*&#x2F;\n\t\t\tborder-bottom: 1px solid #EDEEF0;\n\t\t&#125;\n\t\t.nav a &#123;\n\t\t\t&#x2F;*转换为行内块*&#x2F;\n\t\t\tdisplay: inline-block;\n\t\t\theight: 41px;\n\t\t\tline-height: 41px;\n\t\t\tcolor: #4C4C4C;\n\t\t\t&#x2F;*代表 上下是 0  左右是 20 内边距*&#x2F;\n\t\t\tpadding: 0 20px;\n\t\t\ttext-decoration: none;\n\t\t\tfont-size: 12px;\n\t\t&#125;\n\t\t.nav a:hover &#123;\n\t\t\tbackground-color: #eee;\n\t\t&#125;\n\t&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\t&lt;div class&#x3D;&quot;nav&quot;&gt;\n\t\t&lt;a href&#x3D;&quot;#&quot;&gt;设为首页&lt;&#x2F;a&gt;\n\t\t&lt;a href&#x3D;&quot;#&quot;&gt;手机新浪网&lt;&#x2F;a&gt;\n\t\t&lt;a href&#x3D;&quot;#&quot;&gt;移动客户端&lt;&#x2F;a&gt;\n\t\t&lt;a href&#x3D;&quot;#&quot;&gt;博客&lt;&#x2F;a&gt;\n\t\t&lt;a href&#x3D;&quot;#&quot;&gt;微博&lt;&#x2F;a&gt;\n\t\t&lt;a href&#x3D;&quot;#&quot;&gt;关注我&lt;&#x2F;a&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n影响\n设置padding会使盒子的宽度变大, 而影响布局\n比如, 使最后一个盒子被挤到下一行, 这里需要学了浮动后再给大家演示\n\n\n\n\n\n\n\n\n\n演示\n盒子的宽度改变\n\n\n\n\n\n\n\n\n\n设置box-sizing\n默认情况下, 盒子是content-box, 宽高都是基于内容计算的, 但是这样计算不方便\n为了解决这个问题, CSS3引入了box-sizing, 宽高的计算可以根据border-box计算\n5) 外边距margin外边距通常用来设置两个盒子之间的距离, 可以用来确定盒子之间的相对位置关系\n\n\n\n属性\n作用\n\n\n\nmargin-left\n左外边距\n\n\nmargin-right\n右外边距\n\n\nmargin-top\n上外边距\n\n\nmargin-bottom\n下外边距\n\n\n\n\n\n\n\n\n\n\n\n块盒水平居中\n\n盒子必须指定了宽度（width）\n左右的外边距都设置为auto\n\n\n\n\n\n\n\n\n\n\n示例\n.container &#123;\n  width: 1100px;\n  margin: 0 auto;\n&#125;\n\n\n\n\n\n\n\n\n\n\n清除默认内外边距\n由于浏览器会有一个默认的样式, 为了使我们的网页在所有的浏览器中看起来是一样的效果, 通常我们会先清除一些默认样式, 这个过程叫reset\n最简单的reset\n\n\n\n\n\n\n\n\n\n示例\n* &#123;\n  margin: 0;\n  padding: 0;\n&#125;\n\n使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。\n相邻块元素垂直外边距的合并\n当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom\n下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和\n取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。\n\n \n\n解决方案：尽量给只给一个盒子添加margin值。\n嵌套块元素垂直外边距的合并（塌陷）\n对于两个嵌套关系的块元素，如果父元素没有上内边距及边框\n父元素的上外边距会与子元素的上外边距发生合并\n合并后的外边距为两者中的较大者\n\n \n\n解决方案：\n\n可以为父元素定义上边框\n可以为父元素定义上内边距\n\n七. 浮动1 为什么需要浮动首先, 思考一下下面的问题:\n\n如何让多个块盒(div)水平排列成一行？\n如何实现块盒的左右对齐?\n\n2 什么是浮动\n\n\n\n\n\n\n\n\n概念\n设置了浮动属性的元素会\n\n脱离标准普通流\n移动到指定位置\n\n浮动最早的出现, 是为了实现图文混排的, 但是随后, 大家发现可以通过浮动来实现布局\n3 语法选择器 &#123; \n\tfloat: left&#x2F;right; \n&#125;\n\n\n\n\n属性值\n描述\n\n\n\nnone\n元素不浮动（默认值）\n\n\nleft\n元素向左浮动\n\n\nright\n元素向右浮动\n\n\n让一个元素向左或向右浮动\n4 特性1) 脱标设置了浮动的元素会脱离标准流, 不再占用原来的位置, 后面的盒子会向上跑\n.box1 &#123;\n  float: left;\n  width: 200px;\n  height: 200px;\n  background-color: rgba(255, 0, 0, 0.5);\n&#125;\n.box2 &#123;\n  width: 150px;\n  height: 300px;\n  background-color: skyblue;\n&#125;\n\n\n2) 改变displayfloat属性会改变元素display属性。\n任何元素都可以浮动。浮动元素会生成一个块盒，而不论它本身是何种元素。 \n生成的块盒和我们前面的行内块极其相似\n\n同在一行显示\n可以设置宽高\n\n5 应用我们知道，浮动是脱标的，会影响下面的标准流青霉素\n因此, 我们需要给浮动的元素添加一个标准流的父元素，这样可以最大化的减小了对其他标准流的影响\n1) 实现头部布局\n左边是一个logo\n右边是导航\n\n\n2) 实现内容布局\n3) 演示padding改变的影响6 清除浮动1) 为什么要清除浮动因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为0，就影响了下面的标准流盒子\n2) 如何清除浮动目前使用最多的方式, 使用:after伪元素\n\n\n\n\n\n\n\n\n\n示例\n.clearfix:after &#123;  \n  content: &quot;&quot;; \n  display: block; \n  clear: both;\n&#125;   \n\n八. 定位1 为什么需要定位如果想实现下面的效果, 只靠浮动是没有办法实现的\n\n\n像上面这种, 让一个盒子固定在某个位置的情况, 需要使用定位来实现\n2 什么是定位定位也是用来布局的，它有两部分组成：\n\n\n\n\n\n\n\n\n\n定位 = 定位模式 + 边偏移\n定位模式包括:\n\n绝对定位: posistion: absolute\n相对定位: position: relative\n固定定位: position: fixed\n\n边偏移包括\n\n\n\n边偏移属性\n示例\n描述\n\n\n\ntop\ntop: 80px\n顶端偏移量，定义元素相对于其父元素上边线的距离。\n\n\nbottom\nbottom: 80px\n底部偏移量，定义元素相对于其父元素下边线的距离。\n\n\nleft\nleft: 80px\n左侧偏移量，定义元素相对于其父元素左边线的距离。\n\n\nright\nright: 80px\n右侧偏移量，定义元素相对于其父元素右边线的距离\n\n\n定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。\n3 定位模式详解1) 相对定位相对定位参考自己在标准流中的位置偏移 \n效果图\n\n特点\n\n相对于自己原来在标准流中位置来移动的\n原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n\t&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n\t&lt;title&gt;Document&lt;&#x2F;title&gt;\n\t&lt;style&gt;\n\t\tdiv &#123;\n\t\t\twidth: 200px;\n\t\t\theight: 200px;\n\t\t\tbackground-color: pink;\n\t\t&#125;\n\t\t.two &#123;\n\t\t\tbackground-color: purple;\n\t\t\tposition: relative;\n\t\t\ttop: 100px;\n\t\t\tleft: 100px;\n\t\t&#125;\n\t&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\t&lt;div&gt;1&lt;&#x2F;div&gt;\n\t&lt;div class&#x3D;&quot;two&quot;&gt;2&lt;&#x2F;div&gt;\n\t&lt;div&gt;3&lt;&#x2F;div&gt;\n\t\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2) 绝对定位绝对定位参考最近的带有定位的父级元素偏移\n\n如果父级没有定位, 就参考浏览器的左上角偏移\n\n\n\n如果父元素有定位, 参考父元素的左上角偏移\n\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n\t&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n\t&lt;title&gt;绝对定位以带有定位的父级元素来移动位置&lt;&#x2F;title&gt;\n\t&lt;style&gt;\n\t\t.yeye &#123;\n\t\t\twidth: 500px;\n\t\t\theight: 500px;\n\t\t\tbackground-color: skyblue;\n\t\t\tposition: absolute;\n\t\t&#125;\n\t\t.father &#123;\n\t\t\twidth: 350px;\n\t\t\theight: 350px;\n\t\t\tbackground-color: pink;\n\t\t\tmargin: 100px;\n\t\t\t&#x2F;*position: relative;*&#x2F;\n\t\t&#125;\n\t\t.son &#123;\n\t\t\twidth: 200px;\n\t\t\theight: 200px;\n\t\t\tbackground-color: purple;\n\t\t\t&#x2F;*margin-left: 100px;*&#x2F;\n\t\t\tposition: absolute;\n\t\t\ttop: 50px;\n\t\t\tleft: 50px;\n\t\t&#125;\n\t&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\t&lt;div class&#x3D;&quot;yeye&quot;&gt;\n\t\t&lt;div class&#x3D;&quot;father&quot;&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;son&quot;&gt;&lt;&#x2F;div&gt;\n\t\t&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n规律\n如果给一个元素设置绝对定位, 一定要记得给其父元素设置相对定位, 否则会出现意料之外的情况\n简记: 子绝父相 —— 子级是绝对定位，父级要用相对定位\n3) 固定定位固定定位参考浏览器可视窗口偏移\n\n\n\n\n\n\n\n\n\n示例\n微信公众号底部布局\n4 应用1) 小图标2) 侧栏广告3) 盒子居中\n\n\n\n\n\n\n\n\n绝对定位的盒子居中\n\n\n\n\n\n\n\n\n\n相对定位的盒子居中\n5 z-index在使用定位布局时，可能会出现盒子重叠的情况\n加了定位的盒子，默认后来者居上， 后面的盒子会压住前面的盒子\n应用 z-index 层叠等级属性可以调整盒子的堆叠顺序\n\n","slug":"CSS","date":"2022-12-01T11:11:22.073Z","categories_index":"前端三剑客","tags_index":"css","author_index":"团子"},{"id":"94ff201ca1ae476922b8d2b0356a8a36","title":"03_css选择器","content":"昨日回顾标签的分类\n\t行级标签 不能独占一行 span \n\t块级标签 独占一行  div \n常见的标签\n\t文档结构标签 html head title body\n\t文本相关标签 h1-h6 p font\n\t格式相关标签 hr br b i u \n\t列表相关标签 ul ol li\n\t图片媒体相关 img audio video\n\t超链接标签   a href target\n\t语义化标签 header footer main aside section article\n\t表单相关的标签\n\t\tform标签 定义表单提交的地址和范围\n\t\t\taction 提交地址\n\t\t\tmethod 提交方式\n\t\t\t\tget \n\t\t\t\tpost\n\t\tinput标签 用于输入或者选择信息\n\t\t\ttype \n\t\t\t\ttext 文本框\n\t\t\t\tpassword 密码框\n\t\t\t\tradio 单选\n\t\t\t\tcheckbox 多选\n\t\t\t\tfile 文件框\n\t\t\t\tsubmit 提交\n\t\t\t\treset 重置\n\t\t\t\tbutton 普通按钮\n\t\t\tname\n\t\t\t\t将数据提交到后台\n\t\t\t\t给单选和复选框进行分组\n\t\t\tvalue\n\t\t\t\t可以区分单选和复选框选中的数据\n\n\n\n表单标签form 表单标签 定义表单要提交的范围和提交的地址\n\t重要属性\n\t\taction:提交的地址,默认提交的是当前页面\n\t\tmethod:规定用于发送表单数据的 HTTP 方法\n\t\t\tget:把数据拼接在地址栏的后面,相对的不安全,只能提交少量数据(默认就是get)\n\t\t\tpost:把数据拼接在请求体中,相对的安全,可以提交大量数据,主要用于文件上传下载\n\ninput 输入项标签 根据type属性值的不同,呈现不同的样式,让用户输入或者选择\n\t重要属性\n\t\ttype\n\t\t\ttext    文本框(默认)\n\t\t\tpassword 密码框(里面的内容不以明文显示)\n\t\t\tradio   单选框\n\t\t\tcheckbox    复选框\n\t\t\tfile    文件框(用于上传文件)\n\t\t\tsubmit  提交按钮(提交页面数据)\n\t\t\treset   重置按钮(恢复页面刚打开时的效果)\n\t\t\tbutton  普通按钮(结合js一起使用)\n\n\t\tchecked \n\t\t\tchecked  单选和复选框的默认选中状态\n\nselect 下拉选择框  对于取值只有固定的几个,可以考虑使用下拉选择框\n\toption 选择项标签\n\t\t重要属性\n\t\t\tselected\n\t\t\t\tselected  下拉选择框的默认选中\n\ntextarea 文本域 类似于大的文本框\n\t重要的属性\n\t\tcols 列数(宽度)\n\t\trows 行数(高度)\n\n通用属性\n\tname\n\t\t表单项元素要提交到后台,必须要有name属性\n\t\t对于单选和复选框,可以使用name进行分组\n\t\t可以设置submit,reset,button按钮上的默认文字\n\n\tvalue\n\t\t对于单选和复选框,需要指定value属性的值,用于区分用户选择了哪一个选项\n\t\t可以设置下拉选择框里面选择项option标签的值,设置之后提交到后台使用就是value里的值,否则用的是标签体\n\n表格标签表格标签\n\ttable\t\n\t\tborder 边框\n\t\twidth 宽度\n\t\theight 高度\n\t\tcellpadding 单元格边沿和内容之间的空白\n\t\tcellspacing 单元格之间的空白\n\t\talign 定义表格与周围元素的对齐方式\n\ttr\n\t\talign 定义内容的对齐方式\n\tth\t\n\t\t表头,在单元格的基础上加粗和居中\n\ttd\n\t\trowspan 跨行\n\t\tcolspan 跨列\n\n\n\nCSS概念及入门概念层叠样式表,用于设置样式,布局控制   主流的布局方式:div+css\n\n区别1,css更加专业,可以实现html属性实现不了的效果\n2,可以实现标签和样式的分离,提高样式的重用性,提高开发效率\n\nCSS引入方式行内样式概念\n\t使用style属性,在html标签上添加样式,也叫内联样式\n\t&lt;font style&#x3D;&quot;font-size: 1000px; color:green&quot;&gt;新茶上市,欢迎品尝&lt;&#x2F;font&gt;\n特点\n\t简单,耦合性强,不利于代码和样式的分离,没有复用性\n\n内部样式概念\n\t使用style标签,结合css选择器,来给元素添加样式\n\t&lt;style&gt;\n        font&#123; &#x2F;* 选择器:用来选择元素的 *&#x2F;\n            font-size: 48px;\n            color: green;\n        &#125;\n    &lt;&#x2F;style&gt;\n    \n特点\n\t实现了代码和样式的分离,可以在当前页面进行复用\n\n外部样式概念\n\t将css样式封装到一个css文件,然后通过link标签引入\n\t\n做法\n\t1,将样式抽取到一个css文件中\n        font&#123; &#x2F;* 选择器:用来选择元素的 *&#x2F;\n            font-size: 48px;\n            color: green;\n        &#125;\n    2,在页面中引入\n    \t&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;font.css&quot;&gt;\n    \t\n特点\n\t实现了代码和样式的分离,可以在多个页面中进行复用,可以统一网站的风格,或者实现换肤功能\n\n三种引入优先级行内样式的优先级是最高的,因为他只为这一行服务\n内部样式和外部样式的优先级是一样的,谁最后解析,显示谁\n\nCSS基本选择器id选择器概念\n\t通过id的属性值来选择元素,一般选择的是唯一的一个元素\n语法\n\t#id值\n注意\n\tid值不要以数字开头,同一个页面中id值也不要相同\n\n类选择器概念\n\t通过class属性的值来选择元素,一般选择的是一批元素(开发中最常用的)\n语法\n\t.class属性值\n\n元素选择器概念\n\t通过标签名来选择元素,一般选择的是一批元素\n语法\n\t元素名称(标签名)\n\n基本选择器优先级行内样式 &gt; id选择器 &gt; 类选择器 &gt; 元素选择器\n\n结论: 越是具体的优先级越高,越是通用模糊的优先级越低\n\nCSS扩展选择器并集选择器作用\n\t同时选择多个选择器\n语法\n\t选择器a,选择器b\n\n交集选择器作用\n\t同时选择多个条件的选择器\n语法\n\t选择器a选择器b\n\n后代选择器作用\n\t选择某一个元素的子孙后代\n语法\n\t选择器a 选择器b\n\n子选择器作用\n\t选择某一个元素的子代选择器\n格式\n\t选择器a &gt; 选择器b\n\n兄弟选择器作用\n\t选择某一个元素相邻的下一个元素\n格式\n\t选择器a + 选择器b\n\n属性选择器作用\n\t通过属性来选择元素,经常用在表单元素中\n格式\n\t[属性名] 或者 [属性名&#x3D;属性值]\n\n伪类选择器作用\n\t用来添加一些选择器的特殊效果。\n格式\n\ta:link &#123;color:#FF0000;&#125; &#x2F;* 未访问的链接 *&#x2F;\n\ta:visited &#123;color:#00FF00;&#125; &#x2F;* 已访问的链接 *&#x2F;\n\ta:hover &#123;color:#FF00FF;&#125; &#x2F;* 鼠标划过链接 *&#x2F;\n\ta:active &#123;color:#0000FF;&#125; &#x2F;* 已选中的链接 *&#x2F;\n\n","slug":"day03_上课笔记","date":"2022-12-01T11:09:11.926Z","categories_index":"前端三剑客","tags_index":"css","author_index":"团子"},{"id":"627ae9b93973501953e5d4b34d6ad23f","title":"02_html常用标签","content":"昨日回顾概念\n\t超文本标记语言,主要用于描述一个页面\n操作思想\n\t容器的思想(标签就相当于容器)\n特点\n\t语法宽松\n\t不区分大小写\n\t标签是预定义好\n组成\n\t标签\n\t标签体\n\t属性\n\t注释\n\t特殊字符\n\n标签分类按是否独占一行来划分\n行级元素如果上一行有空间,就在上一行显示,如果没有空间,才会另起一行(font,b)\nspan是纯粹的行级元素,默认是不可以换行,主要用于存放少量数据\n\n块级元素不管上一行有没有空间,直接另起一行显示(p,h1)\ndiv是纯粹的块级元素,默认是自动换行,主要用于布局(结合css)\n\n常用标签文档结构标签&lt;html&gt;\n\t&lt;head&gt;文档的头部&lt;&#x2F;head&gt;\n\t&lt;body&gt;文档的正文&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n文本相关标签字体标签 font\n标题标签 h1 - h6\n段落标签 p\n\n格式相关标签水平线 hr\n换行 br\n粗体 b strong\n斜体 i em\n下划线 u\n删除线 del\n高亮 mark\n\n列表相关标签无序列表 ul\n\t属性 type\n\t\n有序列表 ol\n\t属性 type\n\t\tstart\n列表项 li\n\n图片媒体标签图片标签\n\t标签名 img\n\t\t重要属性 \n\t\t\tsrc 图片路径,推荐使用相对路径\n\t\t\t\t如果图片和当前文件在同一个目录下,直接使用 图片名(.&#x2F;图片名)显示\n\t\t\t\t如果图片在当前文件的下一层目录,使用 目录名&#x2F;图片名(.&#x2F;目录名&#x2F;图片名)显示\n\t\t\t\t如果图片在当前文件的上一层目录,使用 ..&#x2F;图片名(..&#x2F;代表回退到上一层)显示\n\t\t其他属性\n\t\t\twidth:宽度\n\t\t\theight:高度\n\t\t\talt:图片无法显示的时候替代图片\n\t\t\ttitle:鼠标经过图片的时候提示文字\n音频标签\n\t标签名 audio\n\t重要的属性\n\t\tsrc 音频的路径\n\t\tcontrols 显示播放的控制面板\n\t\t\n视频标签\n\t标签名 video\n\t重要的属性\n\t\tsrc 视频的路径\n\t\tcontrols 显示播放的控制面板\n\n\n\n链接相关标签标签名 a\n\t重要的属性\n\t\thref 定义要跳转的资源的链接\n\t\t\t站外资源\n\t\t\t站内资源\n\t\t\t锚链接\n\t\ttarget 定义页面的打开方式\n\t\t\t_bank 在新的窗口打开\n\t\t\t_self 在当前窗口打开\n\n\n\n布局相关标签概念\n\t也叫语义化标签,没有任何样式,主要用于划分不同的区域,便于布局管理\n\n使用\n\t&lt;header&gt;\t定义了文档的头部区域\n\t&lt;main&gt;\t\t定义了文档的主体部分\n\t&lt;footer&gt;\t定义 section 或 document 的页脚。\n\t&lt;aside&gt;\t定义页面的侧边栏内容。\n\t&lt;section&gt;\t定义文档中的节（section、区段）[区域]。\n\t&lt;article&gt;\t定义页面独立的内容区域。\n\n注意\n\t这些都是块级元素,用于划分区域,主要跟css结合来布局页面\n\n表单相关标签概念\n\t主要是用于收集用户信息的\n分类\n\tform 表单标签 定义表单要提交的范围和提交的地址\n       重要属性\n          action:提交的地址,默认提交的是当前页面\n          method:规定用于发送表单数据的 HTTP 方法\n                get:把数据拼接在地址栏的后面,相对的不安全,只能提交少量数据(默认就是get)\n                post:把数据拼接在请求体中,相对的安全,可以提交大量数据,主要用于文件上传下载\n\n   input 输入项标签 根据type属性值的不同,呈现不同的样式,让用户输入或者选择\n           重要属性\n             type\n                text    文本框(默认)\n                password 密码框(里面的内容不以明文显示)\n                radio   单选框\n                checkbox    复选框\n                file    文件框(用于上传文件)\n                submit  提交按钮(提交页面数据)\n                reset   重置按钮(恢复页面刚打开时的效果)\n                button  普通按钮(结合js一起使用)\n\n             checked \n                  checked  单选和复选框的默认选中状态\n\n            通用属性\n                name\n                    表单项元素要提交到后台,必须要有name属性\n                    对于单选和复选框,可以使用name进行分组\n\n                value\n                    对于单选和复选框,需要指定value属性的值,用于区分用户选择了哪一个选项\n\n","slug":"day02_上课笔记","date":"2022-12-01T11:07:16.448Z","categories_index":"前端三剑客","tags_index":"html","author_index":"团子"},{"id":"e6b640e4d28251deb6bc8140b6579928","title":"Html基础","content":"一.HTML起步前言-认识网页1) 什么是网页网页就是一个.html的文件, 里面按照一定的规范书写了一些代码\n2) 网页是如何显示出来很多没有接触过 web 的学员可能会有这样一个疑问\n为什么 html 文件里写的是代码, 看到的网页却有具体的样子呢\n网页文件一般使用浏览器打开, 浏览器在加载网页文件后会根据代码 渲染 成我们看到的样子\n渲染: 也叫解析, 翻译, 加工 \n3) 网页的组成网页一般由三个方面构成\n\n结构(Structure): 网页中包含哪些内容\n样式(Style): 这些内容如何呈现出来\n行为(Behavior): 网页上的内容如何跟用户交互\n\n\n\n\n标准\n说明\n备注\n\n\n\n结构\n结构用于对网页元素进行整理和分类，主要指HTML\n\n\n\n样式\n表现用于设置网页元素的版式、颜色、大小等外观样式，主要指 CSS\n\n\n\n行为\n行为是指网页模型的定义及交互的编写，主要指 Javascript\n\n\n\n1 HTML 是什么\n\n\n\n\n\n\n\n\nHTML(Hyper Text Markup Language): 超文本标记语言\n\n超文本:\n超越文本: 不仅仅只有文本, 还有多媒体文件, 如: image 图片, audio 音频, video 视频\n超链接: 可以从一个页面跳到另一个页面\n\n\n标记语言: 带有固定的格式, 只是用来标记某种含义, 不是编程语言\n\n\n\n\n\n\n\n\n\n\n\n举例\n&lt;from&gt;我&lt;&#x2F;from&gt;\n&lt;to&gt;公司&lt;&#x2F;to&gt;\n&lt;title&gt;辞职申请&lt;&#x2F;title&gt;\n&lt;content&gt;世界那么大, 我想去看看&lt;&#x2F;content&gt;\n&lt;time&gt;2015.4.13&lt;&#x2F;time&gt;\n\n2 HTML 的组成HTML 由一系列的 元素 elements 组成, 在元素中包含 属性（Attribute）\n1) 元素\n\n\n\n\n\n\n\n\n示例\n&lt;p&gt;我的猫咪脾气爆:)&lt;&#x2F;p&gt;\n\n\n2) 属性元素中可以包含属性\n\n\n\n\n\n\n\n\n\n示例\n&lt;p class&#x3D;&quot;editor-note&quot;&gt;我的猫咪脾气爆:)&lt;&#x2F;p&gt;\n\n\n在有些教程里不分元素和标签, 都是混用的. 但是根据 HTML5 的规范, 元素(element)更加准确\n参考 MDN 文档: HTML 是何方神圣\n3 HTML 文档的基本结构HTML 有自己固定的基本格式\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;我的第一个页面&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    主体内容\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n\n\nHTML 标签名、属性名和大部分属性值统一用小写, 一般使用双引号\n推荐：\n&lt;head&gt;\n  &lt;title&gt;我的第一个页面&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt;\n&lt;&#x2F;body&gt;\n\n不推荐：\n&lt;Head&gt;\n  &lt;TITLE&gt;我的第一个页面&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n\n\n\n\n\n\n\n\n\n\n@扩展阅读\n更多关于文档的详细内容, 参考MDN文档: HTML 文档详解\n4 元素的分类HTML 的元素分为两类\n\n双标签元素\n单标签元素\n\n1) 双标签元素在 HTML 中, 绝大部分元素(99%)都是双标签元素, 即有开始, 有结束, 在标签内部可以包含内容\n&lt;标签名&gt; 内容 &lt;&#x2F;标签名&gt;\n比如: &lt;body&gt;我是文字&lt;&#x2F;body&gt;\n\n2) 单标签元素极少部分(常见就几个)元素不包含任何内容, 叫做空元素, 也叫单标签元素\n&lt;标签名 &#x2F;&gt; 比如: &lt;img &#x2F;&gt;\n\n5 元素的关系针对双标签元素, 主要存在两种关系\n\n嵌套关系(父子关系)\n并列关系(兄弟关系)\n\n\n嵌套关系\n\n&lt;head&gt;\n  &lt;title&gt;&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n\n\n2.并列关系\n&lt;head&gt;&lt;&#x2F;head&gt;\n&lt;body&gt;&lt;&#x2F;body&gt;\n\n\n二.HTML 入门1 HTML 的由来\n\n\n\n\n\n\n\n\n为什么发明 HTML? 或者说发明 HTML 是为了解决什么问题\n在早些年的时候. 人们获取信息的主要途径是看 报纸\n后来, 随着互联网的普及, 人们主要通过 电脑浏览网页 来获取信息(新闻)\n因此, 发明 HTML 最初的目的其实是为了解决人们如何通过电脑来看新闻的问题\n当然, 现在及未来, 移动互联网的兴起, 大家更多的会使用移动设备(手机, 平板)来看新闻\n\n\n\n\n\n\n\n\n\n移动互联网会取代互联网吗? 或者说手机会取代电脑吗\n移动互联网技术本质上还是是基于互联网的. 是对互联网的延伸和补充, 让大家能更方便的, 随时随地的使用互联网, 享受互联网的便捷\n\n通过上面的分析, 我们大概就能猜到 HTML 在设计的时候或多或少会参考报纸的一些理念.\n\n大致分析一下, 报纸上有哪些元素\n\n总标题\n文章\n段落\n图片\n页头页脚\n\n其实 HTML 也是这么设计的\n\nHTML 由元素组成, 认识 HTML 其实就是学习 HTML 中的元素. 本章主要介绍常见的 HTML 元素, 大致分为\n\n文本相关元素\n超文本相关元素\n布局相关元素\n表单元素(进阶部分介绍)\n表格元素(进阶部分介绍)\n\n\n\n\n\n\n\n\n\n\n说明\n当然, 如果你想了解更多, 更完整的 HTML 元素相关的内容的话\n还是请自行查阅 MDN: HTML 元素参考\n2 文本相关元素首先, 我们来了解跟文本相关的 HTML 元素\n1) 标题元素 h这里有六个标题元素 —— h1~h6\n每个元素代表文档中不同级别的内容;\n\nh1 表示主标题（the main heading）\nh2 表示二级子标题（subheadings）\nh3 表示三级子标题（sub-subheadings）\n\n其基本语法格式如下：\n&lt;h1&gt;标题文本&lt;&#x2F;h1&gt;\n&lt;h2&gt;标题文本&lt;&#x2F;h2&gt;\n&lt;h3&gt;标题文本&lt;&#x2F;h3&gt;\n&lt;h4&gt;标题文本&lt;&#x2F;h4&gt;\n&lt;h5&gt;标题文本&lt;&#x2F;h5&gt;\n&lt;h6&gt;标题文本&lt;&#x2F;h6&gt;\n\n\n\n\n\n\n\n\n\n\n\n强调\nHTML 只规定结构和内容. 不规定样式.\n总原则: 结构和样式分离, 结构由 HTML 控制, 样式由 CSS 控制!!!\n\n\n\n\n\n\n\n\n\n为什么看到的 h1 比 h2 大呢\n浏览器会给每个元素一些默认的样式. 而这些样式都是可以被修改的.\n事实上, 我们完全可以控制h2的样式, 让它看起来像h1. 但是从语义上来说, 是不同的\n\n\n\n\n\n\n\n\n\n@扩展-语义\n语义(semantic)是一个非常重要的概念, 通常表示一个元素有特殊的含义. 比如\nh1是一个语义元素, 一般表示一个网页中最重要的内容. 最好只出现一次, 这样有利于搜索引擎的处理\n参考 MDN: 为什么我们需要语义\n\n\n\n\n\n\n\n\n\n最佳实践\n\n您应该最好只对每个页面使用一次&lt;h1&gt;— 这是顶级标题，所有其他标题位于层次结构中的下方。\n请确保在层次结构中以正确的顺序使用标题。不要使用&lt;h3&gt;来表示副标题，后面跟&lt;h2&gt;来表示副副标题 - 这是没有意义的，会导致奇怪的结果。\n在可用的六个标题级别中，您应该旨在每页使用不超过三个，除非您认为有必要使用更多。具有许多级别的文档（即，较深的标题层次结构）变得难以操作并且难以导航。在这种情况下，如果可能，建议将内容分散在多个页面上。\n\n以上内容摘自 MDN: 编辑结构层次\n2) 段落元素 p单词缩写： paragraph 段落 [ˈpærəgræf] 无须记这个单词\n作用语义：\n可以把 HTML 文档分割为若干段落\n\n\n\n\n\n\n\n\n\n语法\n&lt;p&gt;内容&lt;&#x2F;p&gt;\n\n3) 综合小案例有这样一段文本, 请按照语义添加合适的元素, 使用网页的结构更清晰\n三国演义\n\n罗贯中\n\n第一回 宴桃园豪杰三结义 斩黄巾英雄首立功\n\n话说天下大势，分久必合，合久必分。周末七国分争，并入于秦。及秦灭之后，楚、汉分争，又并入于汉……\n\n第二回 张翼德怒鞭督邮 何国舅谋诛宦竖\n\n且说董卓字仲颖，陇西临洮人也，官拜河东太守，自来骄傲。当日怠慢了玄德，张飞性发，便欲杀之……\n\n却说张飞\n\n却说张飞饮了数杯闷酒，乘马从馆驿前过，见五六十个老人，皆在门前痛哭。飞问其故，众老人答曰：“督邮逼勒县吏，欲害刘公；我等皆来苦告，不得放入，反遭把门人赶打！”……\n\n4) 强调元素在人类语言中，为了突出一句话的意思，我们通常强调某些词，并且我们通常想要标记某些词作为重点或者在某种程度上的不同。 HTML 提供了许多语义化的元素，并且允许我们通过这些元素的意义标记正文内容，在这个章节中，我们将看到最常见的一小部分元素\n\n强调: 使用&lt;em&gt;\n非常重要: 使用&lt;strong&gt;\n\n表示强调 em当我们想要在口语中添加强调，我们重读某些词，以便隐含的说出我们想要说的意思。类似的，在写作中，我们通过将文字写成 斜体 来强调它\n\n\n\n\n\n\n\n\n\n举例\n\n表示非常重要 strong为了强调重要的词，在口语方面我们往往用重音强调，在文字方面则是用 粗体字 来达到强调的效果\n\n\n\n\n\n\n\n\n\n举例\n\n\n\n\n\n\n\n\n\n\n@扩展-表示强调的元素\n参考 MDN: 重点强调\n3 超文本相关元素超文本主要包括两层含义:\n\n超越普通文本, 如多媒体: 图片(img 元素), 音频(audio 元素), 视频(video 元素)\n超链接, a 元素\n\n1) 超链接元素 a正是因为超链接元素的存在, 将世界上所有的网页联系在一起, 使互联网成为一个互相联系的网络\n\n\n\n\n\n\n\n\n\n作用\n超链接可以使我们的文档跳转到任何其他的文档（或其他资源 resource）\n\n\n\n\n\n\n\n\n\n语法\n&lt;a href&#x3D;&quot;统一资源定位符(URL)&quot;&gt;显示信息&lt;&#x2F;a&gt;\n\n什么是 URLURL(Uniform Resource Locator): 统一资源定位符\n\n\n\n\n\n\n\n\n\nURL 就是我们在浏览器地址栏输入的内容\n基本结构\nprotocol :&#x2F;&#x2F; hostname[:port] &#x2F; path\n\n\n\n\n\n\n\n\n\n\n举例\n\nhttp://127.0.0.1:5500/01_体验html.html\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;超链接元素&lt;&#x2F;h1&gt;\n    &lt;h2&gt;超链接元素a: 可以使我们从一个网页跳转到另一个网页&lt;&#x2F;h2&gt;\n    &lt;hr &#x2F;&gt;\n    我是一个超链接, 点我可以跳转到百度:&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt;\n    &lt;hr &#x2F;&gt;\n   \t&lt;a href&#x3D;&quot;.&#x2F;01-第一个页面.html&quot;&gt;点我可以跳转到本站点的其它页面&lt;&#x2F;a&gt;\n    &lt;hr &#x2F;&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2) 图片元素 img图片元素允许我们将图片放到网页中, 这样我们的网页就变得漂亮起来\n\n\n\n\n\n\n\n\n\n语法\n&lt;img src&#x3D;&quot;文件路径&#x2F;文件名.后缀名&quot; &#x2F;&gt;\n\n文件路径\n\n\n\n\n\n\n\n\n什么是文件路径\n用来 表示 文件 或者 文件夹 在计算机存储的位置\n文件路径就是找到一个文件的途径. 有两个概念\n路径分类\n\n绝对路径(完整路径)\n\n\n\n\n\n\n\n\n\n举例\n/宇宙/银河系/太阳系/地球/中国/武汉/栋哥\n\n网络绝对路径: 从http://域名对应的地址开始查找, 直到找到目标文件为止\n本地绝对路径: 从计算机的根盘符下开始查找, 直到找到目标文件为止\n\n\n相对路径: 从当前文件开始查找, 直到找到目标文件为止\n\n\n\n\n\n\n\n\n\n举例\n指路, 从当前地方出发, 向前100米, 再左转\n./: 要找的文件在同级目录下\n../: 要找的文件在上一级目录 ../资源/01.jpg\n目录名/: 要找的文件在子目录中\n\n\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;图片元素img&lt;&#x2F;h1&gt;\n    &lt;h2&gt;可以在网页中嵌入图片&lt;&#x2F;h2&gt;\n    &lt;hr &#x2F;&gt;\n    &lt;ul&gt;\n      &lt;li&gt;\n        使用绝对路径: &lt;img src&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:5500&#x2F;blog.png&quot; width&#x3D;&quot;200px&quot; &#x2F;&gt;\n      &lt;&#x2F;li&gt;\n      &lt;li&gt;使用相对路径: &lt;img src&#x3D;&quot;.&#x2F;blog.png&quot; width&#x3D;&quot;200px&quot; &#x2F;&gt;&lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n最佳实践\n在 img 标签中, 最好使用相对路径\n3) 视频元素 videovideo 元素是 HTML5 新增的元素. 用于在 HTML 文档中嵌入媒体播放器\nvideo 标签就是用来播放视频的\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;视频元素video&lt;&#x2F;h1&gt;\n    &lt;h2&gt;可以在网页上播放视频&lt;&#x2F;h2&gt;\n    &lt;video src&#x3D;&quot;.&#x2F;test_video.mp4&quot; width&#x3D;&quot;480px&quot; autoplay controls muted&gt;&lt;&#x2F;video&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4 布局相关元素一个“典型的网站”可能会这样布局\n\n\n页头(header): 通常横跨于整个页面顶部有一个大标题 和/或 一个标志\n导航(nav): 指向网站各个主要区段的超链接\n主体(main): 中心的大部分区域是当前网页大多数的独有内容\n侧边栏(aside): 一些外围信息、链接、引用、广告等\n页脚(footer): 页脚放置公共信息（比如版权声明或联系方式）\n\n1) header\n可以是body的子元素, 表示网站的全局页头(常用)\n也可以是section或article的子元素, 表示这个区域的页头\n\n2) nav通常是body的子元素, 表示网站的顶部导航\n3) main网页的主体部分, 每个页面只能用一个main. 且直接做为body的子元素, 最后不要把他嵌套到别的元素中\n4) section 和 articlesection 表示一组类似功能的区块. article 表示一篇文章\n形式一: section 包含 article\n\n&lt;section&gt;\n  &lt;article&gt;\n    &lt;h2&gt;\n      标题一\n    &lt;&#x2F;h2&gt;\n    &lt;p&gt;内容....&lt;&#x2F;p&gt;\n  &lt;&#x2F;article&gt;\n  &lt;article&gt;\n    &lt;h2&gt;\n      标题二\n    &lt;&#x2F;h2&gt;\n    &lt;p&gt;内容....&lt;&#x2F;p&gt;\n  &lt;&#x2F;article&gt;\n  ...\n&lt;&#x2F;section&gt;\n\n形式二: article 包含 section\n\n5) footer通常做为页面的页脚\n6) 综合案例\n\n\n\n\n\n\n\n\n\n示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;二次元俱乐部&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 头部header-导航nav --&gt;\n    &lt;header&gt;\n      &lt;h1&gt;二次元俱乐部&lt;&#x2F;h1&gt;\n      &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;01.jpg&quot; alt&#x3D;&quot;logo&quot; &#x2F;&gt;\n      &lt;nav&gt;\n        &lt;a href&#x3D;&quot;#&quot;&gt;首页&lt;&#x2F;a&gt;\n        &lt;a href&#x3D;&quot;#&quot;&gt;产品&lt;&#x2F;a&gt;\n        &lt;a href&#x3D;&quot;#&quot;&gt;分类&lt;&#x2F;a&gt;\n        &lt;a href&#x3D;&quot;#&quot;&gt;联系我们&lt;&#x2F;a&gt;\n      &lt;&#x2F;nav&gt;\n    &lt;&#x2F;header&gt;\n    &lt;!-- 左侧main --&gt;\n    &lt;main&gt;\n      &lt;section&gt;\n        &lt;article&gt;文章一&lt;&#x2F;article&gt;\n        &lt;article&gt;文章二&lt;&#x2F;article&gt;\n        &lt;article&gt;文章三&lt;&#x2F;article&gt;\n      &lt;&#x2F;section&gt;\n\n      &lt;section&gt;\n        &lt;article&gt;文章一&lt;&#x2F;article&gt;\n        &lt;article&gt;文章二&lt;&#x2F;article&gt;\n        &lt;article&gt;文章三&lt;&#x2F;article&gt;\n      &lt;&#x2F;section&gt;\n    &lt;&#x2F;main&gt;\n    &lt;!-- 右侧aside --&gt;\n    &lt;aside&gt;\n      &lt;section&gt;热门&lt;&#x2F;section&gt;\n      &lt;section&gt;广告&lt;&#x2F;section&gt;\n    &lt;&#x2F;aside&gt;\n    &lt;!-- 底部footer --&gt;\n    &lt;footer&gt;版本所有©2000-2077&lt;&#x2F;footer&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n7) 无语义元素这里重点介绍两个元素\n\ndiv 元素\nspan 元素\n\n标准的制定者不可能把生活中的所有内容都语义化.\n所以 80%的情况下, 不好确定某个部分的具体语义时, 一般使用无语义元素.\n\n\n\n\n\n\n\n\n\n提示\n无语义元素反而是使用的更多的元素, 在 HTML5 标准之前, 布局基本都是使用 div\n5 块元素与行元素本节是非常重要的一节!\n前面关于元素的分类是按照功能性进行划分的\n从显示上进行划分, 元素又可以被分为\n\n块元素(block element): 独占一行显示的元素\n行元素(inline element): 多个元素在同一行上显示的元素\n\n1) 默认的块元素\n标题元素: h1~h6\n段落元素: p\n列表元素: ul ol dl li\n布局元素: header nav main section article\n无语义元素: div\n\n一般块元素里可以放其它元素, 或者文本内容\n2) 默认的行元素\n超文本元素: a\n图片元素: img\n无语义元素: span\n\n\n\n\n\n\n\n\n\n\n特别说明\n\n元素是块元素还是行元素, 不是由 html 决定的. html 只定义结构, 显示是由 CSS 控制的\n决定元素是块元素还是行元素, 是通过 CSS 的 display 属性控制的.\n\n6 列表元素列表元素按使用频率可以细分为\n\n无序列表(ul: unordered list)\n有序列表(ol: ordered list)\n描述列表(dl: description list)\n\n1) 无序列表 ul表示列表项之间是没有先后顺序的\n\n\n\n\n\n\n\n\n\n示例\nemmet: ul&gt;li*3&gt;lorem1\n\n&lt;ul&gt;\n  &lt;li&gt;Lorem.&lt;&#x2F;li&gt;\n  &lt;li&gt;Quisquam.&lt;&#x2F;li&gt;\n  &lt;li&gt;Sapiente.&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n2) 有序列表 ol表示列表项之间是存在先后顺序的\n\n\n\n\n\n\n\n\n\n示例\nemmet: ol&gt;li&#123;第$项&#125;*3\n\n&lt;ol&gt;\n  &lt;li&gt;第1项&lt;&#x2F;li&gt;\n  &lt;li&gt;第2项&lt;&#x2F;li&gt;\n  &lt;li&gt;第3项&lt;&#x2F;li&gt;\n&lt;&#x2F;ol&gt;\n\n3) 描述列表 dl表示一个自定义的列表\nemmet: dl&gt;(dt&#123;标题$&#125;+dd&#123;内容$&#125;)*3\n\n&lt;dl&gt;\n  &lt;dt&gt;标题1&lt;&#x2F;dt&gt;\n  &lt;dd&gt;内容1&lt;&#x2F;dd&gt;\n  &lt;dt&gt;标题2&lt;&#x2F;dt&gt;\n  &lt;dd&gt;内容2&lt;&#x2F;dd&gt;\n  &lt;dt&gt;标题3&lt;&#x2F;dt&gt;\n  &lt;dd&gt;内容3&lt;&#x2F;dd&gt;\n&lt;&#x2F;dl&gt;\n\n7 表单1) 基本介绍\n\n\n\n\n\n\n\n\n生活中的表单\n在生活中, 比如我们去银行申请信用卡, 我们需要填写一张申请表\n\n在我们申请email的时候, 我们需要填写用户名, 密码这些信息\n\n像这些申请单在程序里就是以表单的形式的存在的\n\n\n\n\n\n\n\n\n\n表单的作用\n目的是为了收集用户的信息, 传递给服务器, 在服务器中存储\n2) 语法&lt;form action&#x3D;&quot;url地址&quot; method&#x3D;&quot;提交方式&quot; name&#x3D;&quot;表单名称&quot;&gt;\n  各种表单控件\n&lt;&#x2F;form&gt;\n\n常用属性：\n\n\n\n属性\n属性值\n作用\n\n\n\naction\nurl地址\n用于指定接收并处理表单数据的服务器程序的url地址。\n\n\nmethod\nget/post\n用于设置表单数据的提交方式，其取值为get或post。\n\n\nname\n名称\n用于指定表单的名称，以区分同一个页面中的多个表单。\n\n\n3) input元素\n\n\n\n\n\n\n\n\n语法\n&lt;input type&#x3D;&quot;属性值&quot; value&#x3D;&quot;你好&quot;&gt;\n\n\ninput 输入的意思 \ninput是单标签元素\ntype属性设置不同的属性值用来指定不同的控件类型\n除了type属性还有别的属性\n\n\n4) label元素\n\n\n\n\n\n\n\n\n语法\n&lt;label for&#x3D;&quot;sex&quot;&gt;男&lt;&#x2F;label&gt;\n&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; id&#x3D;&quot;sex&quot;&gt;\n\n5) textarea元素\n\n\n\n\n\n\n\n\n语法\n&lt;textarea &gt;\n  文本内容\n&lt;&#x2F;textarea&gt;\n\n6) select元素\n\n\n\n\n\n\n\n\n语法\n&lt;select&gt;\n  &lt;option&gt;选项1&lt;&#x2F;option&gt;\n  &lt;option&gt;选项2&lt;&#x2F;option&gt;\n  &lt;option&gt;选项3&lt;&#x2F;option&gt;\n  ...\n&lt;&#x2F;select&gt;\n\n8 表格1) 基本介绍为了更方便人们的阅读, 对于一些数据以表格的形式展现效果会更好, 比如\n\n还有: 成绩表, 工资表, 人员名单表,  商品清单表等等…\n在程序中, 我们使用table来表示\n2) 语法\n\n\n\n\n\n\n\n\n语法\n&lt;table&gt;\n  &lt;tr&gt;\n    &lt;th&gt;表头&lt;&#x2F;th&gt;\n  &lt;&#x2F;tr&gt;\n  &lt;tr&gt;\n    &lt;td&gt;单元格内的文字&lt;&#x2F;td&gt;\n    ...\n  &lt;&#x2F;tr&gt;\n  ...\n&lt;&#x2F;table&gt;\n\n\ntable用于定义一个表格标签。\ntr(table row) 用于定义表格中的行，必须嵌套在 table中\nth(table head)用于定义表格中的表头, 必须嵌套在tr中\ntd(table data) 用于定义表格中的单元格，必须嵌套在tr中\n\n3) table的常用属性\n\n\n\n\n\n\n\n\n\n示例\n&lt;table width&#x3D;&quot;600px&quot; border&#x3D;&quot;1&quot; cellspacing&#x3D;&quot;0&quot;&gt;\n  &lt;caption&gt;\n    xx中学高一课程表\n  &lt;&#x2F;caption&gt;\n  &lt;tr&gt;\n    &lt;th&gt;周一&lt;&#x2F;th&gt;\n    &lt;th&gt;周二&lt;&#x2F;th&gt;\n    &lt;th&gt;周三&lt;&#x2F;th&gt;\n    &lt;th&gt;周四&lt;&#x2F;th&gt;\n    &lt;th&gt;周五&lt;&#x2F;th&gt;\n  &lt;&#x2F;tr&gt;\n\n  &lt;tr&gt;\n    &lt;td&gt;语文&lt;&#x2F;td&gt;\n    &lt;td&gt;地理&lt;&#x2F;td&gt;\n    &lt;td&gt;语文&lt;&#x2F;td&gt;\n    &lt;td&gt;地理&lt;&#x2F;td&gt;\n    &lt;td&gt;数学&lt;&#x2F;td&gt;\n  &lt;&#x2F;tr&gt;\n  &lt;tr&gt;\n    &lt;td&gt;英语&lt;&#x2F;td&gt;\n    &lt;td&gt;美术&lt;&#x2F;td&gt;\n    &lt;td&gt;语文&lt;&#x2F;td&gt;\n    &lt;td&gt;政治&lt;&#x2F;td&gt;\n    &lt;td&gt;微机&lt;&#x2F;td&gt;\n  &lt;&#x2F;tr&gt;\n  &lt;tr&gt;\n    &lt;td&gt;数学&lt;&#x2F;td&gt;\n    &lt;td&gt;生物&lt;&#x2F;td&gt;\n    &lt;td&gt;语文&lt;&#x2F;td&gt;\n    &lt;td&gt;生物&lt;&#x2F;td&gt;\n    &lt;td&gt;微机&lt;&#x2F;td&gt;\n  &lt;&#x2F;tr&gt;\n  &lt;tr&gt;\n    &lt;td&gt;数学&lt;&#x2F;td&gt;\n    &lt;td&gt;英语&lt;&#x2F;td&gt;\n    &lt;td&gt;英语&lt;&#x2F;td&gt;\n    &lt;td&gt;体育&lt;&#x2F;td&gt;\n    &lt;td&gt;班会&lt;&#x2F;td&gt;\n  &lt;&#x2F;tr&gt;\n&lt;&#x2F;table&gt;\n\n4) 标题\n\n\n\n\n\n\n\n\n语法\n&lt;table&gt;\n   &lt;caption&gt;我是表格标题&lt;&#x2F;caption&gt;\n&lt;&#x2F;table&gt;\n\n5) 高级用法\n\n\n\n\n\n\n\n\n表格的合并\n\n跨行合并：rowspan=”合并单元格的个数”      \n跨列合并：colspan=”合并单元格的个数”\n\n","slug":"HTML","date":"2022-12-01T11:05:03.560Z","categories_index":"前端三剑客","tags_index":"html","author_index":"团子"},{"id":"8416d0c3a62e12a2fab3a68a80de7a85","title":"01_html概念入门","content":"HTML概念超文本标记语言,主要用于描述一个页面\n\n操作思想网页中有很多数据,不同的数据可能需要不同的展示效果,这个时候,就可以使用标签把要操作的数据包裹起来.通过修改标签的属性值,来实现标签内数据样式的改变\n\n一个标签就相当于一个容器,想要修改容器内的数据样式,只需要修改容器的属性值,就可以实现\n\n特点语法非常的宽松\n标签不区分大小写(建议小写)\n标签都是预定义好的,每个标签都有特殊的含义 \n\t xml语法(标签可以自定义)\n\t&lt;user&gt;\n\t\t&lt;username&gt;张三&lt;&#x2F;username&gt;\n\t\t&lt;password&gt;张三&lt;&#x2F;password&gt;\n\t&lt;&#x2F;user&gt;\n\n语法标签\n\t由尖括号括起来的关键字组成\n标签体\n\t开始标签和结束标签中间的所有内容,都叫做标签体,可以是一段普通的文本,也可以是其他标签\n属性\n\t为元素提供更多信息,可以改变元素的样式,以名称和值的形式出现\n注释\n\t解释说明, 设置行注释块级键(ctrl+&#x2F;)\n特殊字符\n\t空格\t&amp;nbsp; \t小于号\t&lt;  大于号\t&gt;\n\n\n\n常用标签文档标签(页面结构标签)\n\t&lt;html&gt;\n\t\t&lt;head&gt;\t\t\t\t\t-- html的头部\n\t\t\t&lt;title&gt;&lt;&#x2F;title&gt;     -- html的标题\n\t\t&lt;&#x2F;head&gt;\n\t\t&lt;body&gt;\t\t\t\t\t-- html的正文\n\t\t&lt;&#x2F;body&gt;\n\t&lt;&#x2F;html&gt;\n\n","slug":"day01_上课笔记","date":"2022-12-01T11:03:41.173Z","categories_index":"前端三剑客","tags_index":"html","author_index":"团子"},{"id":"73a4f8512e04fe7927935c7418b949d7","title":"在前端页面调用api时的问题","content":"1.请求路径利用.env.development文件去实现url的统一化。代码\n.env.developmentVITE_APP_BASE_API =’http://localhost:3000&#39;\n2.在request文件夹内，新建index.js文件，实现拦截器，用于封装所有请求的通用功能（get,post,patch,put..）import axios from ‘axios’\naxios.defaults.baseURL = import.meta.env.VITE_APP_BASE_APIaxios.defaults.timeout = 3000/**\n\nhttp request 拦截器\n/axios.interceptors.request.use(  (config) =&gt; {config.data = JSON.stringify(config.data)\nconfig.headers = &#123;\n  &#39;Content-Type&#39;: &#39;application/json&#39;,\n&#125;\nreturn config\n\n  },  (error) =&gt; {return Promise.reject(error)\n\n  })/**\nhttp response 拦截器\n/axios.interceptors.response.use((response) =&gt; {  if (response.data.errCode === 2) {console.log(&#39;过期&#39;)\n\n  }  return response},(error) =&gt; {  console.log(‘请求出错：’, error)})\n\n/**\n封装get方法\n@param url  请求url\n@param params  请求参数\n@returns {Promise}\n/export function get(url, params = {}) {return new Promise((resolve, reject) =&gt; {  axios.get(url, &#123;\n  params: params,\n&#125;)\n.then((response) =&gt; &#123;\n  landing(url, params, response.data)\n  resolve(response.data)\n&#125;)\n.catch((error) =&gt; &#123;\n  reject(error)\n&#125;)\n\n})}\n\n/**\n封装post请求\n@param url\n@param data\n@returns {Promise}\n/\n\nexport function post(url, data) {  return new Promise((resolve, reject) =&gt; {axios.post(url, data).then(\n  (response) =&gt; &#123;\n    //关闭进度条\n    resolve(response.data)\n  &#125;,\n  (err) =&gt; &#123;\n    reject(err)\n  &#125;\n)\n\n  })}/**\n封装patch请求\n@param url\n@param data\n@returns {Promise}\n/export function patch(url, data = {}) {return new Promise((resolve, reject) =&gt; {  axios.patch(url, data).then((response) =&gt; &#123;\n  resolve(response.data)\n&#125;,\n(err) =&gt; &#123;\n  msag(err)\n  reject(err)\n&#125;\n\n  )})}\n\n/**\n封装put请求\n@param url\n@param data\n@returns {Promise}\n/\n\nexport function put(url, data = {}) {  return new Promise((resolve, reject) =&gt; {axios.put(url, data).then(\n  (response) =&gt; &#123;\n    resolve(response.data)\n  &#125;,\n  (err) =&gt; &#123;\n    msag(err)\n    reject(err)\n  &#125;\n)\n\n  })}//统一接口处理，返回数据export default function (fecth, url, param) {  let _data = ‘’  return new Promise((resolve, reject) =&gt; {switch (fecth) &#123;\n  case &#39;get&#39;:\n    // console.log(&#39;begin a get request,and url:&#39;, url)\n    get(url, param)\n      .then(function (response) &#123;\n        resolve(response)\n      &#125;)\n      .catch(function (error) &#123;\n        // console.log(&#39;get request GET failed.&#39;, error)\n        reject(error)\n      &#125;)\n    break\n  case &#39;post&#39;:\n    post(url, param)\n      .then(function (response) &#123;\n        resolve(response)\n      &#125;)\n      .catch(function (error) &#123;\n        // console.log(&#39;get request POST failed.&#39;, error)\n        reject(error)\n      &#125;)\n    break\n  default:\n    break\n&#125;\n\n  })}/**\n查看返回的数据\n@param url\n@param params\n@param data\n/function landing(url, params, data) {  if (data.code === -1) {  }}\n\n3.对应事件写对应请求import http from ‘./index’export default {  // 请求示例  /* getBanner() {    return new Promise((resolve, reject) =&gt; {      http(‘get’, ‘/banner’).then(        (res) =&gt; {          resolve(res)        },        (error) =&gt; {          reject(error)        }      )    })  }, */\n  // 获取所有公告  getNotice() {    return new Promise((resolve, reject) =&gt; {      http(‘get’, ‘/gg_notice’).then(        (res) =&gt; {          resolve(res)        },        (error) =&gt; {          reject(error)        }      )    })  },  // 添加公告 data: {content,title,username}  addNotice(data) {    return new Promise((resolve, reject) =&gt; {      http(‘post’, ‘/gg_notice’, data).then(        (res) =&gt; {          resolve(res)        },        (error) =&gt; {          reject(error)        }      )    })  },}\n","slug":"在前端页面调用api时的问题","date":"2022-11-30T19:16:44.834Z","categories_index":"学习笔记","tags_index":"axios","author_index":"团子"},{"id":"84c5d95635333c1f19b7db5d1c2143cd","title":"箭头的缺点","content":"1、函数内部没有arguments2、不兼容call,apply,bind3、不能作为对象的方法4、代码难以阅读1、arguments函数内部没有arguments/* 1、函数内部没有arguments /function go(){    console.log(arguments)}const fn  = ()=&gt;{    console.log(arguments);}go();fn();2、不兼容call,apply,bindvar name = “window”;function go() {    console.log(this.name)}const fn = () =&gt; {    console.log(this.name)}go.call({ name: “vue” });fn.call({ name: “react” })//❌箭头函数不兼容call,bind,apply3、不能作为对象的方法/ 不能作为对象的方法 /var obj = {    name: “react”,    sayName: () =&gt; {        console.log(this.name)    }}obj.sayName(); //❌4、代码可读性差/ 代码可读性差 */var a =20;const fn = ()=&gt;a&gt;10? ‘正确’:’错误’;\n","slug":"箭头的缺点","date":"2022-11-30T19:16:44.832Z","categories_index":"学习笔记","tags_index":"javascript","author_index":"团子"},{"id":"1f8d1e15bde0d92144a385b911e17e2d","title":"节流和防抖的总结","content":"一、总结1、节流：本质上是对执行频率的限制，有节奏的在执行。(走A)2、防抖：本质上是对执行次数的限制，多次密集触发的情况下，只会执行一次。(回城)3、节流更关注”过程”，防抖关注”结果”。二、重点● 过程(限制频率) vs 结果。● 实际工作 https://www.lodashjs.com/\n","slug":"节流和防抖的总结","date":"2022-11-30T19:16:44.828Z","categories_index":"学习笔记","tags_index":"javascript","author_index":"团子"}]