{"title":"20_作用域_原型_函数进阶","uid":"469779a6e8484934bee8ecd3db81351f","slug":"day20_课堂笔记","date":"2022-12-01T13:09:33.617Z","updated":"2022-12-01T13:10:04.218Z","comments":true,"path":"api/articles/day20_课堂笔记.json","keywords":null,"cover":null,"content":"<h4 id=\"昨日回顾\"><a href=\"#昨日回顾\" class=\"headerlink\" title=\"昨日回顾\"></a>昨日回顾</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">全局对象GO\n\t概念\n\t\tjs引擎整合所有的script标签产生的一个对象,window对象\n\t全局变量\n\t\t在script标签里面声明的变量\n\t全局函数\n\t\t在script标签里面声明的函数\n\t关系\n\t\t全局变量--&gt;GO对象一个属性\n\t\t全局函数--&gt;GO对象一个方法\n\n活动对象AO\n\t概念\n\t\t在函数被调用的那一刻产生的一个对象,用来保存当前函数的内部的执行环境\n\t局部变量\n\t\t在函数内部里面声明的变量\n\t局部函数\n\t\t在函数内部里面声明的函数\n\t关系\n\t\t局部变量--&gt;AO对象一个属性\n\t\t局部函数--&gt;AO对象一个方法\n\t\t\n全局预编译\n\t概念\n\t\tscript标签下,代码执行之前的一个预处理\n\t流程\n\t\t0,产生GO对象\n\t\t1,先找变量声明\n\t\t2,再找函数声明\n\t\t3,从上到下执行\n\t结论\n\t\t在全局环境中,如果存在同名的变量和函数,函数的优先级高\n\t\n函数预编译\n\t概念\n\t\t在函数里面,代码执行之前的一个预处理\n\t流程\n\t\t0,产生AO对象\n\t\t1,先找形参和变量的声明\n\t\t2,使用实参的值替换形参的值\n\t\t3,再找函数的声明\n\t\t4,从上到下依次执行函数体\n\t结论\n\t\t只要声明了局部函数,函数的优先级最高(同名的情况下)\n\t\t没有声明局部函数,实参的优先级高\n\t\t整体优先级: 局部函数 &gt; 实参 &gt; 形参和局部变量</code></pre>\n\n<h4 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">作用\n\t限定变量在某个范围内起作用\n好处\n\t提高程序的可靠性,减少命名冲突(在ES6中,同一个域不能定义相同变量.否则报错)\n分类\n\t全局作用域\n\t\t由script标签产生的区域,从计算机角度可以理解为window对象管控的区域\n\t\t全局的变量和函数都是在全局作用域下,在浏览器关闭的时候销毁\n\t局部作用域\n\t\t由函数产生的区域,从计算机的角度可以理解为当前函数AO对象管控的区域\n\t\t局部的变量和函数都是在局部作用域下,在函数执行完成后销毁\n\t块级作用域\n\t\tES6中的语法,存在于if语句,for循环管控的&#123;&#125;所在的区域,对ES5没限制</code></pre>\n\n<h4 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">概念\n\t只要是代码,都是一个作用域中,写在函数内部的是局部作用域,没有写在函数内部的是在全局作用域中,\n\t如果这个函数,他的内部还有函数,那么在这个作用域中又可以诞生一个作用域.就形成了一个作用域链\n\t\n\t根据 &#39;内部函数可以访问外部函数的变量&#39; 这种机制,使用链式查找来决定哪些数据能被内部函数访问\n\t\n本质\n\t本质也是一个数据结构,函数内部可以嵌套函数,每一次嵌套都会形成一个作用域,把这些作用域串起来\n\t就形成了作用域链</code></pre>\n\n\n\n<h4 id=\"原型和this指向\"><a href=\"#原型和this指向\" class=\"headerlink\" title=\"原型和this指向\"></a>原型和this指向</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">前置知识\n\t对象的三种创建方式\n\t\t1,构造函数\n\t\t2,字面量形式\n\t\t3,new Object形式\n\t成员分类\n\t\t实例成员\n\t\t\t构造函数内部,通过this添加,通过实例对象来调用\n\t\t静态成员\n\t\t\t在构造函数本身上添加,通过构造函数名来调用\n\t\t\t\n原型对象prototype\n\t概念\n\t\t原型是一个对象,每一个构造函数都有一个prototype属性,指向这个对象(本身)\n\t作用\n\t\t可以把那些不变的方法,直接定义到原型对象(prototype上),这样所有的对象的实例都可以共享这些方法,节省了内存\n\t\t\n对象的原型proto\n\t概念\n\t\t每一个对象都会有一个属性 __proto__,指向函数的原型对象(prototype)\n\t\t__proto__ 习惯称之为 对象的原型\n\t\t\nconstructor构造函数\n\t概念\n\t\t原型对象(Stat.prototype) 和 对象的原型(对象.__proto__),里面都一个属性constructor(constructor称为构造函数,指向构造函数本身)\n\t作用\n\t\t主要是记录该对象引用于哪一个构造函数,可以让原型对象重新指向原来的构造函数(了解)\n\t\n原型链\n\t概念\n\t\t每一个实例对象又有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有__proto__属性，这样一层一层往上找就形成了原型链。\n\t\t\n\t作用\n\t\t当实例对象调用方法的时候,首先在自身的this中定义的方法找\n\t\t如果没有的话,就通过__proto_找到,原型对象,看原型对象里面有没有定义\n\t\t如果没有的话,就通过原型对象的__proto__到上一层(父类中找这个方法)\n\t\t一直找到object,如果都没有的话,就报错\n\t\t\n\t\t__proto__ 对象原型的存在,就是为对象成员的查找机制提供了一个方向</code></pre>\n\n\n\n<h4 id=\"函数进阶\"><a href=\"#函数进阶\" class=\"headerlink\" title=\"函数进阶\"></a>函数进阶</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">定义总结\n\t命名函数\n\t匿名函数\n\tnew Function(参数1,参数2,函数体)\n调用总结\n\t命名函数   函数名调用\n\t匿名函数   变量名调用\n\t对象的方法  对象\n\t构造函数    对象\n\t绑定事件函数 事件对象调用\n\t定时器函数   自动调用\n\t立即执行函数  立即调用\nthis的指向总结\n\t命名函数   window\n\t匿名函数   window\n\t对象的方法  实例对象\n\t构造函数    实例对象\n\t绑定事件函数 事件对象\n\t定时器函数   window\n\t立即执行函数  window\ncall\n\t执行函数\n\t改变this的指向\n高阶函数\n\t函数作为参数或者返回值,这种函数,叫做高阶函数</code></pre>\n","text":"昨日回顾全局对象GO 概念 js引擎整合所有的script标签产生的一个对象,window对象 全局变量 在script标签里面声明的变量 全局函数 在script标签里面声明的函数 关系 全局变量--&gt;GO对象一个属性 全局函数--&gt;GO对象一个方法 活动对象AO ...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"前端三剑客","slug":"前端三剑客","count":24,"path":"api/categories/前端三剑客.json"}],"tags":[{"name":"javascript","slug":"javascript","count":16,"path":"api/tags/javascript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%A8%E6%97%A5%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">昨日回顾</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">作用域</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE\"><span class=\"toc-text\">作用域链</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E5%90%91\"><span class=\"toc-text\">原型和this指向</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6\"><span class=\"toc-text\">函数进阶</span></a></li></ol>","author":{"name":"团子","slug":"blog-author","avatar":"https://blog4xk-1309331490.cos.ap-nanjing.myqcloud.com/markdown/QQ%E5%9B%BE%E7%89%8720221205215218.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"20_闭包_解构_类_promise","uid":"2ffd85dcab5fecc36d930380bb5ac946","slug":"day21_课堂笔记","date":"2022-12-01T13:11:29.368Z","updated":"2022-12-01T13:12:19.818Z","comments":true,"path":"api/articles/day21_课堂笔记.json","keywords":null,"cover":null,"text":"昨日回顾作用域 作用 限定变量的作用范围 分类 全局作用域(script标签,浏览器关闭的时候销毁) 局部作用域(函数里面,函数调用完成之后销毁) 块级作用域(if,for循环的&#123;&#125;里面,ES6中语法) 作用域链 概念 函数内部可以嵌套函数,每一次嵌套都会形成...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"前端三剑客","slug":"前端三剑客","count":24,"path":"api/categories/前端三剑客.json"}],"tags":[{"name":"javascript","slug":"javascript","count":16,"path":"api/tags/javascript.json"}],"author":{"name":"团子","slug":"blog-author","avatar":"https://blog4xk-1309331490.cos.ap-nanjing.myqcloud.com/markdown/QQ%E5%9B%BE%E7%89%8720221205215218.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}}},"next_post":{"title":"19_预编译","uid":"c2ca0fd8b53bedb58b7bbb78ffccd016","slug":"day19_课堂笔记","date":"2022-12-01T13:03:31.746Z","updated":"2022-12-01T13:04:09.825Z","comments":true,"path":"api/articles/day19_课堂笔记.json","keywords":null,"cover":null,"text":"昨日回顾DOM操作 操作属性 prop() 固有属性 设置 prop(属性名,属性值) 获取 prop(属性名) attr() 自定义属性 设置 attr(属性名,属性值) 获取 attr(属性名) 操作样式 css方法 获取 css(样式属性名) 设置 css(样式属性名,属性...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"前端三剑客","slug":"前端三剑客","count":24,"path":"api/categories/前端三剑客.json"}],"tags":[{"name":"javascript","slug":"javascript","count":16,"path":"api/tags/javascript.json"}],"author":{"name":"团子","slug":"blog-author","avatar":"https://blog4xk-1309331490.cos.ap-nanjing.myqcloud.com/markdown/QQ%E5%9B%BE%E7%89%8720221205215218.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}}}}