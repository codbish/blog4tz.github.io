{"title":"26_手写web服务_处理get_post请求参数","uid":"7bc9d1c1cb8c4ecce97b26cdf0cc3331","slug":"day26_课程笔记","date":"2022-12-01T13:46:15.874Z","updated":"2022-12-01T13:51:30.880Z","comments":true,"path":"api/articles/day26_课程笔记.json","keywords":null,"cover":[],"content":"<h4 id=\"昨日回顾\"><a href=\"#昨日回顾\" class=\"headerlink\" title=\"昨日回顾\"></a>昨日回顾</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">内置模块\n\tfs 处理文件\n\t\treadFile()\n\t\twriteFile()\n\tpath 处理路径\n\t\tjoin()\n\thttp 服务器相关\n\t\tcreateServer()\n\t\t\n包(第三方模块)\n\t概念\n\t\t由第三方个人或者团队开发出来的免费模块\n\t作用\n\t\t封装了内置模块,提高效率\n\t使用\n\t\tnpm 包管理工具\n\t\t\tnpm i 包名\n\t\t\tnpm uninstall 包名\n\t\tnrm 镜像管理工具\n\t组成\n\t\tnode-modules \n\t\t\t自定义包名\n\t\t\t\tdist 发布目录\n\t\t\t\t\tindex.js 头文件,引入其他源文件\n\t\t\t\tsrc\n\t\t\t\t\t存放源码\n\t\t\t\tpackage.json 配置文件 (npm init -y)\n\t\t\t\t\tname 包名\n\t\t\t\t\tversion 版本号\n\t\t\t\t\tmain 入口文件\n\t\t手写包步骤\n\t\t\t1,创建包名文件夹\n\t\t\t2,初始化\n\t\t\t3,创建包的目录结构\n\t\t\t\tdist\n\t\t\t\tsrc\n\t\t\t4,创建index.js,修改package.json里面main属性\n\t\t\t5,编写源码\n\t\t\t6,编写index.js\n\t\t导入规则(require(&#39;calc&#39;))\n\t\t\t1,看是不是内置模块\n\t\t\t2,到node-modules找\n\t\t\t3,先找同名文件\n\t\t\t4,再找同名文件夹,如果有,就去package.json里面main属性找入口文件\n\t\t\t5,没有package.json,找index.js\n\t\t\t6,都没有就报错\n\t服务器概念\n\t\t通讯3要素\n\t\t\tip \n\t\t\t端口\n\t\t\t协议\n\t\turl\n\t\t\t统一资源定位符\n\t\t\t协议 域名(ip) 端口 资源路径\n\t\thttp协议\n\t\t\t概念\n\t\t\t\t超文本传输协议\n\t\t\t作用\n\t\t\t\t规定服务器和浏览器传输数据的规范\n\t\t\t请求消息(浏览器传给服务器)\n\t\t\t\t格式\n\t\t\t\t\t请求行\n\t\t\t\t\t\t请求方式 请求的uri 协议版本(可以省略)\n\t\t\t\t\t请求头\n\t\t\t\t\t\t键值对,告诉服务器我浏览器的一些信息\n\t\t\t\t\t\tuser-agent:浏览器的版本型号\n\t\t\t\t\t请求体\n\t\t\t\t\t\t只有在post请求中才有\n\t\t\t响应消息(服务器传给浏览器)\n\t\t\t\t格式\n\t\t\t\t\t响应行\n\t\t\t\t\t\t协议版本 状态码 状态码描述\n\t\t\t\t\t响应头\n\t\t\t\t\t\t键值对,告诉浏览器我服务器的一些信息\n\t\t\t\t\t\tcontent-type 设置发送的数据的格式和编码\n\t\t\t\t\t响应体\n\t\t\t\t\t\t显示在body的正文\n\t\t\t\t\t\t\n\t\t\t请求对象和响应对象\n\t\t\t\trequest对象(req对象)\n\t\t\t\t\t里面封装请求的消息,主要提供获取方法\n\t\t\t\t\t\t获取请求方式 req.method\n\t\t\t\t\t\t获取请求的url req.url\n\t\t\t\tresponse对象(res对象)\n                \t里面就封装了响应消息,主要提供设置方法\n                \t\t设置响应头 res.setHeader()\n                \t\t设置响应体 res.send()\n\t\t\t</code></pre>\n\n<h4 id=\"手写web服务\"><a href=\"#手写web服务\" class=\"headerlink\" title=\"手写web服务\"></a>手写web服务</h4><h5 id=\"1-基本的web服务\"><a href=\"#1-基本的web服务\" class=\"headerlink\" title=\"1,基本的web服务\"></a>1,基本的web服务</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;1,导入模块\n&#x2F;&#x2F;2,创建web服务器\n&#x2F;&#x2F;3,绑定事件,处理请求\n&#x2F;&#x2F;4,设置端口,进行监听</code></pre>\n\n<h5 id=\"2-处理中文乱码\"><a href=\"#2-处理中文乱码\" class=\"headerlink\" title=\"2,处理中文乱码\"></a>2,处理中文乱码</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">产生的原因\n\t前后编码不一致\n\t\t服务器发送数据:使用ISO-8859-1(拉丁文),不支持中文的\n\t\t浏览器接收数据并解析:中文的window使用GBK(国标)\n解决\n\t使用响应对象,设置响应头,统一编码\n\t\tres.setHeader(&#39;content-type&#39;,&#39;text&#x2F;html;charset&#x3D;utf-8&#39;)\n\t\t告诉浏览器我发送数据的格式是utf-8,将来浏览器接收之后,就会以utf-8编码来解析</code></pre>\n\n<h5 id=\"3-处理路由\"><a href=\"#3-处理路由\" class=\"headerlink\" title=\"3,处理路由\"></a>3,处理路由</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">路由:\n\t根据不同的请求url,响应不同的数据\n\thttp:&#x2F;&#x2F;localhost:3000&#x2F; 或者 http:&#x2F;&#x2F;localhost:3000&#x2F;index  响应首页\n\thttp:&#x2F;&#x2F;localhost:3000&#x2F;list  响应列表页\n\thttp:&#x2F;&#x2F;localhost:3000&#x2F;detail 响应详情页\n\thttp:&#x2F;&#x2F;localhost:3000&#x2F;aaa    页面找不到\n\n思路\n\t1,先通过请求对象req中的url属性,获取到请求的url\n\t2,再通过url的内置模块解析获取出来的url.得到url对象\n\t3,从url对象的 pathname属性中 拿到值\n\t\n\thttp:&#x2F;&#x2F;    localhost   :   3000    &#x2F;detail   ?    id&#x3D;1\n\t 协议\t\t\tip&#x2F;域名        端口     pathname      query\n\t \nurl.parse(urlStr,true) 参数问题\n\t第二个参数是true,得到的url对象如下\n        Url &#123;\n          protocol: null,\n          slashes: null,\n          auth: null,\n          host: null,\n          port: null,\n          hostname: null,\n          hash: null,\n          search: &#39;?id&#x3D;1&#39;,\n          query: [Object: null prototype] &#123; id: &#39;1&#39; &#125;, &#x2F;&#x2F;这里的query的值是对象\n          pathname: &#39;&#x2F;detail&#39;,\n          path: &#39;&#x2F;detail?id&#x3D;1&#39;,\n          href: &#39;&#x2F;detail?id&#x3D;1&#39;\n        &#125;\n        \n    第二个参数是false(默认),得到的url对象如下\n        Url &#123;\n          protocol: null,\n          slashes: null,\n          auth: null,\n          host: null,\n          port: null,\n          hostname: null,\n          hash: null,\n          search: &#39;?id&#x3D;1&#39;,\n          query: &#39;id&#x3D;1&#39;,   &#x2F;&#x2F;这里的query的值是字符串\n          pathname: &#39;&#x2F;detail&#39;,\n          path: &#39;&#x2F;detail?id&#x3D;1&#39;,\n          href: &#39;&#x2F;detail?id&#x3D;1&#39;\n        &#125;</code></pre>\n\n\n\n<h5 id=\"4-处理get请求数据\"><a href=\"#4-处理get请求数据\" class=\"headerlink\" title=\"4,处理get请求数据\"></a>4,处理get请求数据</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">需求:\n\t假设发送的get请求是 http:&#x2F;&#x2F;localhost:3000&#x2F;detail?id&#x3D;1\n\t 需要获取 url 后面拼接的参数 id &#x3D; 1.\n\t 将来我会通过id&#x3D;1去数据库查询具体的商品数据\n\t \n思路\n\t首先需要判断请求的路径是不是以&#x2F;detail开头的\n\t如果是的话,再判断请求的方式是不是get\n\t如果是的话,解析获取到的url,拿到里面query属性的值\n\t\n应用\n\t查询单个数据的操作(后面会讲)</code></pre>\n\n\n\n<h5 id=\"5-处理post请求数据\"><a href=\"#5-处理post请求数据\" class=\"headerlink\" title=\"5,处理post请求数据\"></a>5,处理post请求数据</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">需求\n\t模拟登录,一般是post请求(可以安装REST Client 模拟客户端发送post请求)\n\t请求url就是   http:&#x2F;&#x2F;localhost:3000&#x2F;\n\t请求体 就是   username&#x3D;zhangsan&amp;password&#x3D;123\n\t\n\t如何拿到 username和password的值\n\t\n思路\n\t监听request的 date数据变化事件  和 end 数据接收完成 事件\n\t在date事件中进行累加\n\t在end事件中打印最终的数据\n\t\n应用\n\t登录操作,新增操作</code></pre>\n\n\n\n<h5 id=\"6-封装post请求-Promise\"><a href=\"#6-封装post请求-Promise\" class=\"headerlink\" title=\"6,封装post请求(Promise)\"></a>6,封装post请求(Promise)</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">原因\n\t获取post请求的数据,是一个固定写法,将来经常会用到\n\t并且获取请求数据是一个异步的操作,推荐使用promise封装\n\t\n步骤\n\t定义一个方法,方法返回一个promise对象\n\t因为创建promise对象,需要传一个函数\n\t将 要封装的代码 放在 这个函数的函数体里面\n\t将 代码的结果  放在 resolve()方法的参数里面 返回 ,将来调用then方法的时候就能拿到\n\t\n执行流程\n\t调用封装的getPostData(),得到promise对象,\n\t然后调用promise的then方法,通过then方法的第一个函数的参数date.\n\t就可以拿到之前promise对象中函数执行的结果\n\t最后进行打印</code></pre>\n\n\n\n<h5 id=\"7-处理静态资源\"><a href=\"#7-处理静态资源\" class=\"headerlink\" title=\"7,处理静态资源\"></a>7,处理静态资源</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">需求\n\t当浏览器地址栏输入 http:&#x2F;&#x2F;localhost:3000&#x2F; 或者 http:&#x2F;&#x2F;localhost:3000&#x2F;index\n\t显示新闻首页\n\t\n思路\n\t1,解析请求路径,判断pathname是(&#x2F;或者&#x2F;index)\n\t2,读取public路径下的文件,并返回</code></pre>\n\n\n\n<h4 id=\"nodemon使用\"><a href=\"#nodemon使用\" class=\"headerlink\" title=\"nodemon使用\"></a>nodemon使用</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">由来\n\t1,之前使用node执行程序,如果文件修改了,都需要重启,效率比较低\n\t2,使用nodemon,相当于node升级版本,可以监控文件的变化,自动进行重启.提高效率\n安装\n\tnpm i nodemon -g 全局安装nodemon\n使用\n\tnodemon 文件路径 启动服务\n\t\n终端启动爆红(没有管理员权限)解决\n\thttps:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43682519&#x2F;article&#x2F;details&#x2F;116788807</code></pre>\n\n\n\n<h4 id=\"端口占用解决\"><a href=\"#端口占用解决\" class=\"headerlink\" title=\"端口占用解决\"></a>端口占用解决</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">打开cmd\n\t输入 netstat -anno 就可以查看到当前程序运行的端口</code></pre>\n\n<p><img src=\"https://www.helloimg.com/images/2022/12/01/ZuOVzg.png\" alt=\"image-20220830171715160\"></p>\n","text":"昨日回顾内置模块 fs 处理文件 readFile() writeFile() path 处理路径 join() http 服务器相关 createServer() 包(第三方模块) 概念 由第三方个人或者团队开发出来的免费模块 作用 封装了内置模块,提高效率 使用 npm 包管...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"后端","slug":"后端","count":14,"path":"api/categories/后端.json"}],"tags":[{"name":"http","slug":"http","count":2,"path":"api/tags/http.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%A8%E6%97%A5%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">昨日回顾</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%86%99web%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">手写web服务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E6%9C%AC%E7%9A%84web%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">1,基本的web服务</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81\"><span class=\"toc-text\">2,处理中文乱码</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E5%A4%84%E7%90%86%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">3,处理路由</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E5%A4%84%E7%90%86get%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">4,处理get请求数据</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E5%A4%84%E7%90%86post%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">5,处理post请求数据</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-%E5%B0%81%E8%A3%85post%E8%AF%B7%E6%B1%82-Promise\"><span class=\"toc-text\">6,封装post请求(Promise)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-%E5%A4%84%E7%90%86%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90\"><span class=\"toc-text\">7,处理静态资源</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#nodemon%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">nodemon使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">端口占用解决</span></a></li></ol>","author":{"name":"团子","slug":"blog-author","avatar":"https://www.helloimg.com/images/2022/12/01/Zu250T.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"28_express增删改查","uid":"7602872111d99ce5490d2dd6567dd4a3","slug":"day28_课堂笔记","date":"2022-12-01T13:54:02.386Z","updated":"2022-12-01T14:02:54.202Z","comments":true,"path":"api/articles/day28_课堂笔记.json","keywords":null,"cover":null,"text":"昨日回顾接口编程 接口 规范,定义前后端交互的规范 接口编程 前后端按照约定好的规则(接口文档中)进行编程. restful 概念 一种接口设计风格 六要素 前端 访问路径 请求方式 get 获取 post 新增 put 修改 delete 删除 请求参数 后端 状态码和描述 错...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"后端","slug":"后端","count":14,"path":"api/categories/后端.json"}],"tags":[{"name":"express","slug":"express","count":6,"path":"api/tags/express.json"}],"author":{"name":"团子","slug":"blog-author","avatar":"https://www.helloimg.com/images/2022/12/01/Zu250T.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}}},"next_post":{"title":"25_包概念_http协议_请求响应","uid":"3c7a1f4a7818f7c459334d17943f7066","slug":"day25_课堂笔记","date":"2022-12-01T13:40:54.834Z","updated":"2022-12-01T13:45:16.932Z","comments":true,"path":"api/articles/day25_课堂笔记.json","keywords":null,"cover":[],"text":"昨日回顾nodejs 概念 提供了js代码的运行环境 可以使用它来开发后台 组成 ECMAScript语法 内置模块 第三方模块 模块化编程 概念 按照固定的规则,把一个大的js文件拆分成若干个小文件(模块) 好处 提高代码的复用性,可维护性,按需加载,便于协同开发 规则 导入 ...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"后端","slug":"后端","count":14,"path":"api/categories/后端.json"}],"tags":[{"name":"http","slug":"http","count":2,"path":"api/tags/http.json"}],"author":{"name":"团子","slug":"blog-author","avatar":"https://www.helloimg.com/images/2022/12/01/Zu250T.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}}}}