{"title":"29_express集成数据库操作并封装","uid":"841af1c8d1a60dd62055f0a0655c6017","slug":"day29_课堂笔记","date":"2022-12-01T14:04:33.270Z","updated":"2022-12-01T14:05:06.520Z","comments":true,"path":"api/articles/day29_课堂笔记.json","keywords":null,"cover":null,"content":"<h5 id=\"昨日回顾\"><a href=\"#昨日回顾\" class=\"headerlink\" title=\"昨日回顾\"></a>昨日回顾</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">中间件\n\t概念\n\t\t业务处理中间环节.(一个处理函数)\n\t规则\n\t\t(req,res,next) next可以将调用关系流转到下一个函数\n    分类\n    \t按照作用范围\n    \t\t局部生效的中间件(某些访问路径,某个路由调用)\n    \t\t全局生效的中间件(所有访问路径,通过use调用)\n    \t按照级别来分\n    \t\t内置中间件\n    \t\t\texpress.json()\n    \t\t\texpress.urlencoded()\n    \t\t\texpress.static()\n    \t\t第三方中间件\n    \t\t\tcors()\n    \t\t应用级别中间件\n    \t\t\t绑定app上,可以是全局,也可以是局部\n    \t\t路由级别中间件\n    \t\t\t绑定到路由对象 express.router() 上\n    模块化路由\n    \t由来\n    \t\t方便对路由的分类和管理\n    \t实现\n    \t\t根据不同的实体创建不同的js文件\n    \t\t在每个js文件中创建路由对象,加载具体的路由,再导出\n    \t\t在入口函数中使用app.use()注册路由模块</code></pre>\n\n<h5 id=\"node连接数据库\"><a href=\"#node连接数据库\" class=\"headerlink\" title=\"node连接数据库\"></a>node连接数据库</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">其实就是使用第三方包 mysql 操作数据库,需要下载mysql包\n\n1,导入mysql包\n2,创建连接(createConnection方法)\n\t传入 host port user password database\n3,连接数据库(connect方法)\n4,执行sql语句(query方法)\n5,关闭数据库连接(end())</code></pre>\n\n<h5 id=\"增删改查-数组实现-优化\"><a href=\"#增删改查-数组实现-优化\" class=\"headerlink\" title=\"增删改查_数组实现(优化)\"></a>增删改查_数组实现(优化)</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;使用内置中间件处理请求体\napp.use(express.json())\napp.use(express.urlencoded())\n&#x2F;&#x2F;使用第三方中间件处理跨域问题  --- 需要下载安装\napp.use(cors())  </code></pre>\n\n<h5 id=\"增删改查-数据库实现\"><a href=\"#增删改查-数据库实现\" class=\"headerlink\" title=\"增删改查_数据库实现\"></a>增删改查_数据库实现</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">思路\n\t1,将数据库导包,创建连接,连接,这三个步骤拷贝进去\n\t2,在路由里面 编写sql语句,执行sql语句并返回数据</code></pre>\n\n<h5 id=\"增删改查-提取数据库操作\"><a href=\"#增删改查-提取数据库操作\" class=\"headerlink\" title=\"增删改查_提取数据库操作\"></a>增删改查_提取数据库操作</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">目的\n\t将数据库操作的代码单独放到一个文件中,便于后期代码的维护\n做法\n\t1,将数据库导包,创建连接,连接的代码剪切过去,放在一个js文件中\n\t2,提供查询所有getAll,查询单个getById,增删改exec方法,方法里面用promise封装\n\t3,导出这3个方法\n\t4,在后台代码中,导入这个js文件,解构这3个方法并使用</code></pre>\n\n<h5 id=\"语法糖-async-await\"><a href=\"#语法糖-async-await\" class=\"headerlink\" title=\"语法糖_async_await\"></a>语法糖_async_await</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">async\n\t概念\n\t\t异步的意思\n\t作用\n\t\t可以将同步函数变成异步函数(调用函数返回就是promise对象),就可以使用then方法调用\n\t使用\n\t\t定义\n            async function m1()&#123;\n                return 222\n            &#125;\n         调用\n         \tconst p &#x3D; m1()\t\n       \t\tp.then(data &#x3D;&gt;&#123;\n                console.log(data);&#x2F;&#x2F;222\n            &#125;)\n            \nawait\n\t概念\n\t\t等待的意思\n\t作用\n\t\tawait可以等待 他后面的 promise对象执行之后,拿到返回的结果\n\t注意\n\t\tawait不能单独使用,必须跟async连用,存在于异步函数中\n\t\tawait后面必须要跟一个promise对象,如果不是promise对象,自动转成promise对象\n\t\tawait表达式,返回的是promise执行后的结果\n\t使用\n\t\t&#x2F;&#x2F;在外面套一个异步的函数的壳子fn\n        async function fn()&#123;\n\n            async function m1()&#123;\n                return 222\n            &#125;\n\n            const res &#x3D; await m1() \n            console.log(res);\n        &#125;\n\n        &#x2F;&#x2F;执行fn\n        fn()\t</code></pre>\n\n\n\n<h5 id=\"增删改查-es7语法改写\"><a href=\"#增删改查-es7语法改写\" class=\"headerlink\" title=\"增删改查_es7语法改写\"></a>增删改查_es7语法改写</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">app.get(&#39;&#x2F;users&#39;, async function(req,res)&#123;\n    &#x2F;&#x2F;获取请求参数(这里不需要)\n\n    &#x2F;&#x2F;编写sql语句\n    let sql &#x3D; &#39;select * from student&#39;\n\n    &#x2F;&#x2F;执行sql语句\n    const data &#x3D; await getAll(sql) \n\n    &#x2F;&#x2F;发给浏览器\n    res.send(data)\n    \n&#125;)</code></pre>\n\n","text":"昨日回顾中间件 概念 业务处理中间环节.(一个处理函数) 规则 (req,res,next) next可以将调用关系流转到下一个函数 分类 按照作用范围 局部生效的中间件(某些访问路径,某个路由调用) 全局生效的中间件(所有访问路径,通过use调用) 按照级别来分 内置中间件 e...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"后端","slug":"后端","count":14,"path":"api/categories/后端.json"}],"tags":[{"name":"express","slug":"express","count":6,"path":"api/tags/express.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%98%A8%E6%97%A5%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">昨日回顾</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#node%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93\"><span class=\"toc-text\">node连接数据库</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0-%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">增删改查_数组实现(优化)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">增删改查_数据库实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-%E6%8F%90%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">增删改查_提取数据库操作</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95%E7%B3%96-async-await\"><span class=\"toc-text\">语法糖_async_await</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-es7%E8%AF%AD%E6%B3%95%E6%94%B9%E5%86%99\"><span class=\"toc-text\">增删改查_es7语法改写</span></a></li></ol>","author":{"name":"团子","slug":"blog-author","avatar":"https://www.helloimg.com/images/2022/12/01/Zu250T.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"30_用户管理系统后台实现及前台查询所有","uid":"dec91e97c264ed31b95d6e5abfa5eeb8","slug":"day30_课堂笔记","date":"2022-12-01T14:07:10.846Z","updated":"2022-12-01T14:07:47.403Z","comments":true,"path":"api/articles/day30_课堂笔记.json","keywords":null,"cover":null,"text":"昨日回顾改造了express后台的增删改查 一,使用数组实现 弊端 数据不能持久存储,只是在内存中存储 二,中间件优化 1,优化处理请求体 app.use(express.json()) app.use(express.urlencoded()) 2,处理跨域请求 app.use...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"后端","slug":"后端","count":14,"path":"api/categories/后端.json"}],"tags":[{"name":"express","slug":"express","count":6,"path":"api/tags/express.json"}],"author":{"name":"团子","slug":"blog-author","avatar":"https://www.helloimg.com/images/2022/12/01/Zu250T.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}}},"next_post":{"title":"restful","uid":"8a9733c9b1d5d35d078b2db4ec97b51b","slug":"restful","date":"2022-12-01T13:59:58.678Z","updated":"2022-12-01T14:00:12.924Z","comments":true,"path":"api/articles/restful.json","keywords":null,"cover":[],"text":"一. 接口编程简介1 背景​ 随着互联网的发展, 尤其是移动互联为代表的Web3.0时代. 客户端层出不穷, 以APP、微信、PC浏览器为代表, 服务端业务逻辑是基本一致的. ​ 那么有没有一种方式可以做到”一次编写,随时接入”呢? 目前比较流行的方案就是”接口编程“ 2 什么是...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"后端","slug":"后端","count":14,"path":"api/categories/后端.json"}],"tags":[{"name":"restful","slug":"restful","count":1,"path":"api/tags/restful.json"}],"author":{"name":"团子","slug":"blog-author","avatar":"https://www.helloimg.com/images/2022/12/01/Zu250T.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}}}}