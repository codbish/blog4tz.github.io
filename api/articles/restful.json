{"title":"restful","uid":"8a9733c9b1d5d35d078b2db4ec97b51b","slug":"restful","date":"2022-12-01T13:59:58.678Z","updated":"2022-12-02T03:13:03.905Z","comments":true,"path":"api/articles/restful.json","keywords":null,"cover":[],"content":"<h1 id=\"一-接口编程简介\"><a href=\"#一-接口编程简介\" class=\"headerlink\" title=\"一. 接口编程简介\"></a>一. 接口编程简介</h1><h2 id=\"1-背景\"><a href=\"#1-背景\" class=\"headerlink\" title=\"1 背景\"></a>1 背景</h2><p>​    随着互联网的发展, 尤其是移动互联为代表的Web3.0时代. 客户端层出不穷, 以APP、微信、PC浏览器为代表, 服务端业务逻辑是基本一致的. </p>\n<p>​    那么有没有一种方式可以做到”<strong>一次编写,随时接入</strong>”呢?</p>\n<p>目前比较流行的方案就是”<strong>接口编程</strong>“</p>\n<p><img src=\"http://image.brojie.cn/images/wpsB278.tmp.jpg\" alt=\"img\"> </p>\n<h2 id=\"2-什么是接口编程\"><a href=\"#2-什么是接口编程\" class=\"headerlink\" title=\"2 什么是接口编程\"></a>2 什么是接口编程</h2><p>​    一般来说接口编程是基于HTTP协议, <u>通过URL请求对应的服务器资源(Resource)</u>.</p>\n<h3 id=\"1-什么是URL\"><a href=\"#1-什么是URL\" class=\"headerlink\" title=\"1) 什么是URL\"></a>1) 什么是URL</h3><p>在HTTP协议中, URL的组成如下</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">Schema:&#x2F;&#x2F;host[:port]&#x2F;path[?query-string]</code></pre>\n\n<ul>\n<li>Schema: 使用的协议类型, 如http/https/ftp等</li>\n<li>host:     主机域名或IP</li>\n<li>port:     端口号(可选)</li>\n<li>path:     路径</li>\n<li>query-string: 查询参数(可选)</li>\n</ul>\n<p>例子:</p>\n<p><a href=\"http://api.local.com/movies\">http://api.local.com/movies</a></p>\n<p><a href=\"https://api.local.com:8080/articles?id=100\">https://api.local.com:8080/articles?id=100</a></p>\n<h3 id=\"2-什么是资源\"><a href=\"#2-什么是资源\" class=\"headerlink\" title=\"2) 什么是资源\"></a>2) 什么是资源</h3><ul>\n<li>狭义上讲, 所有在服务器保存的数据(如:音乐/视频/文章/个人信息…)都是服务器端资源.</li>\n<li>广义上讲, 任何服务器端的对象(如:应用程序/数据库记录/算法…)都可以看作资源.</li>\n</ul>\n<h2 id=\"3-接口编程的作用\"><a href=\"#3-接口编程的作用\" class=\"headerlink\" title=\"3 接口编程的作用\"></a>3 接口编程的作用</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>主要是实现了前后端的分离</p></blockquote>\n<p>后端(服务器)为前端(APP端/PC浏览器端/微信端)提供一个简单并且统一的方式(URL), 返回前端需要的数据(Resource).这样不管是APP还是Web浏览器, 只需要通过HTTP协议都可以实现同样的操作. </p>\n<h1 id=\"二-RESTful设计六要素\"><a href=\"#二-RESTful设计六要素\" class=\"headerlink\" title=\"二. RESTful设计六要素\"></a>二. RESTful设计六要素</h1><p>是不是所有前后端分离的设计都叫RESTful呢? 不是!!!</p>\n<p>ful是一个后缀, 意思是”像什么一样的” windful</p>\n<p>RESTful是一种软件设计风格, 主要用于有客户端与服务端交互的软件.  主要包括6个方面</p>\n<ul>\n<li>资源路径(URL)</li>\n<li>HTTP动词(Method)</li>\n<li>过滤信息(query-string)</li>\n<li>状态码(Status-code)</li>\n<li>错误信息(Error)</li>\n<li>返回结果(Result)</li>\n</ul>\n<p>如下图所示:</p>\n<img src=\"restful.assets/image-20220324020300384.png\" alt=\"image-20220324020300384\" style=\"zoom: 50%;\" />\n\n<p>如果一个软件符合这些约定(风格), 我们就说这个软件是RESTful的</p>\n<h2 id=\"1-资源路径\"><a href=\"#1-资源路径\" class=\"headerlink\" title=\"1 资源路径\"></a>1 资源路径</h2><p>标准的RESTful API中, 每个资源路径对应一个<strong>唯一</strong>的资源, 所以规定网址中不能有动词, 只能有名词, 并且一般来说为复数.</p>\n<p>比如:</p>\n<p><a href=\"http://api.local.com/movies----%E8%A1%A8%E7%A4%BA%E7%94%B5%E5%BD%B1%E8%B5%84%E6%BA%90\">http://api.local.com/movies----表示电影资源</a> </p>\n<p><a href=\"http://api.local.com/images----%E8%A1%A8%E7%A4%BA%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90\">http://api.local.com/images----表示图片资源</a></p>\n<p><a href=\"http://api.local.com/musics----%E8%A1%A8%E7%A4%BA%E9%9F%B3%E4%B9%90%E8%B5%84%E6%BA%90\">http://api.local.com/musics----表示音乐资源</a></p>\n<p><a href=\"http://api.local.com/articles----%E8%A1%A8%E7%A4%BA%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90\">http://api.local.com/articles----表示文章资源</a></p>\n<h2 id=\"2-Http动词\"><a href=\"#2-Http动词\" class=\"headerlink\" title=\"2 Http动词\"></a>2 Http动词</h2><p>对于资源, 一般有4个操作, CURD(增/删/改/查)</p>\n<p>GET:     从服务器获取资源(一项或多项)</p>\n<p>POST:    在服务器新建一个资源</p>\n<p>PUT:    在服务器更新资源, 服务器返回完整的属性</p>\n<p>DELETE:    从服务器删除资源</p>\n<p>HEAD:    从服务器获取信息(响应头)</p>\n<p>PATCH:    在服务器更新资源, 服务器只返回更新的属性</p>\n<hr>\n<p>例子: </p>\n<p>POST /articles     –    创建文章内容</p>\n<p>GET /articles/1    –    获取主键id为1的文章</p>\n<h2 id=\"3-过滤信息-请求数据\"><a href=\"#3-过滤信息-请求数据\" class=\"headerlink\" title=\"3 过滤信息(请求数据)\"></a>3 过滤信息(请求数据)</h2><p>当服务端需要返回的数据很多时, 服务器不可能全部返回</p>\n<p>此时, 我们可以在客户端携带过滤信息, 比如: 分页信息</p>\n<hr>\n<p>例子:</p>\n<p>?page=1                    –    第一页的信息</p>\n<p>?offset=10&amp;per_page=10    –    每页10条, 偏移10</p>\n<h2 id=\"4-响应状态码\"><a href=\"#4-响应状态码\" class=\"headerlink\" title=\"4 响应状态码\"></a>4 响应状态码</h2><p>服务端返回的信息, 用来告诉客户端操作结果</p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>含义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>200</td>\n<td>OK</td>\n<td>操作成功, 并返回数据</td>\n</tr>\n<tr>\n<td>201</td>\n<td>CREATED</td>\n<td>新建成功</td>\n</tr>\n<tr>\n<td>204</td>\n<td>NO CONTENT</td>\n<td>删除成功</td>\n</tr>\n<tr>\n<td>400</td>\n<td>BAD REQUEST</td>\n<td>请求语法错误</td>\n</tr>\n<tr>\n<td>403</td>\n<td>Forbidden</td>\n<td>请求没有权限的资源</td>\n</tr>\n<tr>\n<td>404</td>\n<td>NOT FOUND</td>\n<td>没有找到请求的资源</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-错误处理\"><a href=\"#5-错误处理\" class=\"headerlink\" title=\"5 错误处理\"></a>5 错误处理</h2><p>如果状态码是4xx或者5xx, 需要告诉客户端对应的错误信息. 以Json格式返回</p>\n<p>{</p>\n<p>“error”: “错误信息”,</p>\n<p>}</p>\n<h2 id=\"6-返回结果\"><a href=\"#6-返回结果\" class=\"headerlink\" title=\"6 返回结果\"></a>6 返回结果</h2><p>针对不同的操作, 服务需要返回的结果应该符合这样的规范</p>\n<p>GET /collections         –    返回资源列表(数组) </p>\n<p>GET /collections/:id        –    返回单个资源 eg. /collections/1</p>\n<p>POST /collections        –    返回新生成的资源</p>\n<p>PUT /collections/:id        –    返回资源的完整属性</p>\n<p>PATCH /collections/:id    –    返回被修改的属性</p>\n<p>DELETE /collections/:id    –    返回204状态码+空文档 </p>\n<h1 id=\"三-工具\"><a href=\"#三-工具\" class=\"headerlink\" title=\"三. 工具\"></a>三. 工具</h1><h2 id=\"1-服务端工具\"><a href=\"#1-服务端工具\" class=\"headerlink\" title=\"1 服务端工具\"></a>1 服务端工具</h2><h3 id=\"json-server\"><a href=\"#json-server\" class=\"headerlink\" title=\"json-server\"></a>json-server</h3><p>json-server一个快速成形的RESTful接口服务工具, 使用json-server可以快速的搭建一个RESTful服务端</p>\n<p>第一步: 使用<code>npm i json-server -g </code>全局安装</p>\n<p>第二步: 新建一个<code>data.json</code>做为数据源</p>\n<p><code>data.json</code>如下</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;users&quot;: [\n    &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;xiaoming&quot;, &quot;age&quot;: 20&#125;,\n    &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;xiaomei&quot;, &quot;age&quot;: 18&#125;,\n    &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;xiaopang&quot;, &quot;age&quot;: 1&#125;\n  ]\n&#125;</code></pre>\n\n<p>第三步: 启动服务端</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">json-server -w data.json</code></pre>\n\n<p>会在localhost:3000端口启动一个RESTful服务</p>\n<h2 id=\"2-客户端\"><a href=\"#2-客户端\" class=\"headerlink\" title=\"2 客户端\"></a>2 客户端</h2><h3 id=\"1-postman\"><a href=\"#1-postman\" class=\"headerlink\" title=\"1) postman\"></a>1) postman</h3><p>这里给大家安利一个工具postman. 这个是在接口编程中使用非常多的一个工具</p>\n<p>Postman是一个非常好用的免费API测试工具. 主要用于模拟发送Http请求.</p>\n<p>官网地址: <a href=\"https://www.getpostman.com/\">https://www.getpostman.com/</a></p>\n<h3 id=\"2-REST-Client\"><a href=\"#2-REST-Client\" class=\"headerlink\" title=\"2) REST Client\"></a>2) REST Client</h3><p><img src=\"http://image.brojie.cn/images/image-20201215095739409.png\" alt=\"image-20201215095739409\"></p>\n<p>REST Client是一个非要好用的VSCode插件, 可以快速的测试RESTful接口</p>\n<p>第一步: 安装REST Client</p>\n<p>第二步: 编写<code>test.http</code></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GET http:&#x2F;&#x2F;localhost:3000&#x2F;users HTTP&#x2F;1.1</code></pre>\n\n<p>第三步: 点击Send Request</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>演示</p></blockquote>\n<p><img src=\"http://image.brojie.cn/images/image-20201215100517320.png\" alt=\"image-20201215100517320\"></p>\n<h1 id=\"四-前后端分离与接口文档\"><a href=\"#四-前后端分离与接口文档\" class=\"headerlink\" title=\"四. 前后端分离与接口文档\"></a>四. 前后端分离与接口文档</h1><h2 id=\"1-什么是前后端分离\"><a href=\"#1-什么是前后端分离\" class=\"headerlink\" title=\"1 什么是前后端分离\"></a>1 什么是前后端分离</h2><p>所谓前后端分离, 如下图所示:</p>\n<p><img src=\"http://image.brojie.cn/images/wpsAC06.tmp.jpg\" alt=\"img\"> </p>\n<p>由上图可知, 一个项目有两个服务器</p>\n<p>前端服务器: 显示页面</p>\n<p>后端服务器: 提供数据</p>\n<p>通过API接口实现前后端的交互!</p>\n<h2 id=\"2-前后端分离的好处\"><a href=\"#2-前后端分离的好处\" class=\"headerlink\" title=\"2 前后端分离的好处\"></a>2 前后端分离的好处</h2><ol>\n<li><p>提高开发效率: 前后端开发人员可是同时开发, 互不影响</p>\n</li>\n<li><p>提高复用性: 后端通过统一的API提供数据, 这样可以同时为web前端/app前端/微信端提供数据</p>\n</li>\n</ol>\n<h2 id=\"3-接口文档\"><a href=\"#3-接口文档\" class=\"headerlink\" title=\"3 接口文档\"></a>3 接口文档</h2><p>咱们去公司之后, 经常会面临写接口文档的工作, 那么咱们看下接口文档怎么写</p>\n<p>见附件: [API接口文档.md](./API 接口文档.md)</p>\n","text":"一. 接口编程简介1 背景​ 随着互联网的发展, 尤其是移动互联为代表的Web3.0时代. 客户端层出不穷, 以APP、微信、PC浏览器为代表, 服务端业务逻辑是基本一致的. ​ 那么有没有一种方式可以做到”一次编写,随时接入”呢? 目前比较流行的方案就是”接口编程“ 2 什么是...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"后端","slug":"后端","count":14,"path":"api/categories/后端.json"}],"tags":[{"name":"restful","slug":"restful","count":1,"path":"api/tags/restful.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">一. 接口编程简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">1 背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">2 什么是接口编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AFURL\"><span class=\"toc-text\">1) 什么是URL</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B5%84%E6%BA%90\"><span class=\"toc-text\">2) 什么是资源</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">3 接口编程的作用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C-RESTful%E8%AE%BE%E8%AE%A1%E5%85%AD%E8%A6%81%E7%B4%A0\"><span class=\"toc-text\">二. RESTful设计六要素</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">1 资源路径</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-Http%E5%8A%A8%E8%AF%8D\"><span class=\"toc-text\">2 Http动词</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E8%BF%87%E6%BB%A4%E4%BF%A1%E6%81%AF-%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">3 过滤信息(请求数据)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">4 响应状态码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86\"><span class=\"toc-text\">5 错误处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">6 返回结果</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89-%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">三. 工具</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">1 服务端工具</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#json-server\"><span class=\"toc-text\">json-server</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">2 客户端</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-postman\"><span class=\"toc-text\">1) postman</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-REST-Client\"><span class=\"toc-text\">2) REST Client</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">四. 前后端分离与接口文档</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB\"><span class=\"toc-text\">1 什么是前后端分离</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A5%BD%E5%A4%84\"><span class=\"toc-text\">2 前后端分离的好处</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">3 接口文档</span></a></li></ol></li></ol>","author":{"name":"团子","slug":"blog-author","avatar":"https://www.helloimg.com/images/2022/12/01/Zu250T.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"29_express集成数据库操作并封装","uid":"841af1c8d1a60dd62055f0a0655c6017","slug":"day29_课堂笔记","date":"2022-12-01T14:04:33.270Z","updated":"2022-12-01T14:05:06.520Z","comments":true,"path":"api/articles/day29_课堂笔记.json","keywords":null,"cover":null,"text":"昨日回顾中间件 概念 业务处理中间环节.(一个处理函数) 规则 (req,res,next) next可以将调用关系流转到下一个函数 分类 按照作用范围 局部生效的中间件(某些访问路径,某个路由调用) 全局生效的中间件(所有访问路径,通过use调用) 按照级别来分 内置中间件 e...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"后端","slug":"后端","count":14,"path":"api/categories/后端.json"}],"tags":[{"name":"express","slug":"express","count":6,"path":"api/tags/express.json"}],"author":{"name":"团子","slug":"blog-author","avatar":"https://www.helloimg.com/images/2022/12/01/Zu250T.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}}},"next_post":{"title":"Express","uid":"37a590a44a5ff61ad5ed7f48e2da3615","slug":"Express","date":"2022-12-01T13:58:51.651Z","updated":"2022-12-02T04:51:20.228Z","comments":true,"path":"api/articles/Express.json","keywords":null,"cover":[],"text":"一. Express简介Express 是一个极简而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。Express中文官网 为什么说Express是一个极简的框架 Express的核心只有两个部分 路由 中间件...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"后端","slug":"后端","count":14,"path":"api/categories/后端.json"}],"tags":[{"name":"express","slug":"express","count":6,"path":"api/tags/express.json"}],"author":{"name":"团子","slug":"blog-author","avatar":"https://www.helloimg.com/images/2022/12/01/Zu250T.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}}}}