{"title":"27_接口编程_ajax_express入门","uid":"6bf0818317072d9a48cc178884cabdd5","slug":"day27_课堂笔记","date":"2022-12-01T13:54:02.386Z","updated":"2022-12-02T06:07:54.411Z","comments":true,"path":"api/articles/day27_课堂笔记.json","keywords":null,"cover":null,"content":"<h4 id=\"昨日回顾\"><a href=\"#昨日回顾\" class=\"headerlink\" title=\"昨日回顾\"></a>昨日回顾</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">一,基础的web服务器\n\t1,导模块\n\t2,创建服务器\n\t3,绑定请求事件\n\t4,设置端口监听\n\n二,解决中文乱码\n\t res.setHeader(&#39;content-type&#39;,&#39;text&#x2F;html;charset&#x3D;utf-8&#39;)\n\n三,根据不同url响应不同的数据\n\t获取请求路径\n\t\t const &#123;pathname&#125; &#x3D; url.parse(req.url,true)\n\t\t \n四,获取get请求的参数\n\tconst &#123;pathname,query&#125; &#x3D; url.parse(req.url,true)\n\t\n五,获取post请求的参数\n\t let postData &#x3D; &#39;&#39;\n     req.on(&#39;data&#39;,data &#x3D;&gt; &#123; postData +&#x3D; data&#125;)\n     req.on(&#39;end&#39;,()&#x3D;&gt;&#123;\n          console.log(postData);&#x2F;&#x2F;username&#x3D;zhangsan&amp;password&#x3D;123\n           &#x2F;&#x2F;使用querystring内置对象解析post请求的数据\n           const obj &#x3D; qs.parse(postData)\n           console.log(obj);&#x2F;&#x2F;&#123; username: &#39;zhangsan&#39;, password: &#39;123&#39; &#125;\n                \n           &#125;)\n           \n六,用promise封装 获取post请求参数的过程 \n     function getPostData(req)&#123;\n        return new Promise((resolve,reject)&#x3D;&gt;&#123;\n\n            let postData &#x3D; &#39;&#39;\n            req.on(&#39;data&#39;,data &#x3D;&gt; &#123; postData +&#x3D; data&#125;)\n            req.on(&#39;end&#39;,()&#x3D;&gt;&#123;\n                const obj &#x3D; qs.parse(postData)\n                resolve(obj)&#x2F;&#x2F;将obj放在结果属性中,将来调用then方法的时候,就能拿到结果\n            &#125;)\n        &#125;)\n    &#125;\n    \n七,访问静态资源\n\tres.end(fs.readFileSync(相对路径))</code></pre>\n\n\n\n<h4 id=\"接口编程概念\"><a href=\"#接口编程概念\" class=\"headerlink\" title=\"接口编程概念\"></a>接口编程概念</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">接口概念\n\t其实就是一个规范,比如电脑usb接口,设计好usb的标准之后,做电脑和做外设的,就可以分别生产,生产好之后,直接就可以插上去使用\n\n接口文档概念\n\t就是接口的说明文档,它是我们调用接口(请求后台数据的)的依据\n\t接口文档中包含了对接口的url,参数,以及输出内容的说明\n\t我们参照接口文档,就能方便的知道接口的作用,以及接口是如何调用的\n\n接口编程概念\n\t就是前后端按照约定好的规则(接口文档)进行编程,编好之后进行联调就可以了\n\t具体体现,其实就是http协议中的请求和响应\n\t前端,主要是发送请求(明确 请求的url 和 请求方式 以及 请求参数)\n\t后端,主要是做出响应(明确 响应状态码 和 状态码描述 以及 返回具体的数据)\n\t\n接口编程好处\n\t实现前后端分离,便于协同开发</code></pre>\n\n\n\n<h4 id=\"restful接口设计\"><a href=\"#restful接口设计\" class=\"headerlink\" title=\"restful接口设计\"></a>restful接口设计</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">概念\n\t一种接口设计风格,主要用于有客户端和服务端交互的软件\n\t\n接口设计六要素\n\t前端\n\t\t资源路径:请求的url(http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;login)\n\t\tHTTP动词:请求方式(get)\n\t\t过滤信息:请求参数(username&#x3D;zhangsan&amp;password&#x3D;123)\n\t后台\n\t\t状态码(status-code):登录成功:200\n\t\t错误信息(error):服务器内部错误\n\t\t返回结果(date或者result):返回登录用户相关信息\n\t\t\n常用的HTTP动词\n\tGET:获取资源(一个或者多个)  --获取所有图书列表,获取单个图书信息\n\tPOST:新增资源             --添加一个图书\n\tPUT:修改资源              --修改某一个图书的信息\n\tDELETE:删除资源           --删除某一个图书</code></pre>\n\n\n\n<h4 id=\"restful接口体验\"><a href=\"#restful接口体验\" class=\"headerlink\" title=\"restful接口体验\"></a>restful接口体验</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">json-server概念\n\t一个快速成形的RESTful接口服务工具, 使用json-server可以快速的搭建一个RESTful服务端\n\t\n搭建服务端\n\t1,安装json-server软件(npm i json-server -g) \n\t2,创建一个data.json作为数据源\n\t3,启动服务端(json-server -w data.json)\n\t\n模拟前端(发送Restful风格的请求)\n\t查询\n\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;users 查询所有\n\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;users?id&#x3D;1 查询一个\n\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1  查询一个\n\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;users?id&#x3D;1&amp;id&#x3D;2  查询多个\n\n\t新增\n\t\tPOST http:&#x2F;&#x2F;localhost:3000&#x2F;users  需要加上请求体\n\n\t修改\n\t\tPUT http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1 需要加上请求体\n\n\t删除\n\t\tDELETE http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1 </code></pre>\n\n<h4 id=\"AJAX概念\"><a href=\"#AJAX概念\" class=\"headerlink\" title=\"AJAX概念\"></a>AJAX概念</h4><pre class=\"line-numbers language-'\" data-language=\"'\"><code class=\"language-'\">概念\n\t异步的js和xml技术(网络通讯中xml已经被json替换了)\n\t\n\t描述一个用户\n\t\txml方式\n\t\t\t&lt;user&gt;\n\t\t\t\t&lt;username&gt;张三&lt;&#x2F;username&gt;\n\t\t\t\t&lt;password&gt;123&lt;&#x2F;password&gt;\n\t\t\t&lt;&#x2F;user&gt;\n\t\tjson\n\t\t\t&#123;&quot;username&quot;:&quot;张三&quot;,&quot;password&quot;:&quot;123&quot;&#125;\n\n作用\n\t1,实现网页和服务器间的数据交换(请求后台数据)\n\t2,在不刷新整个页面的基础上,更新部分网页内容(局部刷新)\n\t3,一般作为前后端分离中请求后台数据的解决方案\n\t\n同步和异步\n\t同步:同一时间,只能做一件事情,阻塞式\n\t异步:同一时间,可以做多件事情,非阻塞式的(多线程的)\n\t\n应用场景\n\t百度注册(失去焦点的时候校验用户是否被注册)\n\t百度搜索框(根据用户的输入提示不同信息)\n\t百度地图(按需加载)</code></pre>\n\n<h4 id=\"原生的ajax\"><a href=\"#原生的ajax\" class=\"headerlink\" title=\"原生的ajax\"></a>原生的ajax</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">使用XMLHttpRequest对象来发送请求,但是有兼容性问题\n\n&#x2F;&#x2F;1,创建ajax对象\nconst xhr &#x3D; new XMLHttpRequest()\n&#x2F;&#x2F;2,设置请求方式和url\nxhr.open(&#39;get&#39;,&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;2&#39;)\n&#x2F;&#x2F;3,发送请求\nxhr.send()\n&#x2F;&#x2F;4,设置回调函数\nxhr.onload &#x3D; function()&#123;\n\tconsole.log(xhr.responseText);\n&#125;\n\nconsole.log(&#39;执行结束.....&#39;);</code></pre>\n\n\n\n<h4 id=\"jquery的ajax\"><a href=\"#jquery的ajax\" class=\"headerlink\" title=\"jquery的ajax\"></a>jquery的ajax</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">通用格式\n\t$.ajax(&#123;\n\t\turl:&#39;&#39;,&#x2F;&#x2F;请求的地址\n\t\ttype:&#39;&#39;,&#x2F;&#x2F;请求方式\n\t\tdata:&#123;&#125;,请求的参数\n\t\tdataType:&#39;&#39;,&#x2F;&#x2F;返回的数据格式(默认是json,可以不用写)\n\t\tsuccess:function(res)&#123;&#125;,&#x2F;&#x2F;成功的回调函数\n\t\terror:function(err)&#123;&#125;,&#x2F;&#x2F;失败的回调函数\n\t&#125;)\n\t\nget简化方式\n\t$.get(url, [data], [callback], [type])   后面3个参数是可选的\n        url:待载入页面的URL地址\n        data:待发送 Key&#x2F;value 参数。\n        callback:载入成功时回调函数。\n        type:返回内容格式，xml, html, script, json, text, _default\n        \n \npost简化方式\n\t$.post(url, [data], [callback], [type])   后面3个参数是可选的\n        url:待载入页面的URL地址\n        data:待发送 Key&#x2F;value 参数。\n        callback:载入成功时回调函数。\n        type:返回内容格式，xml, html, script, json, text, _default\t</code></pre>\n\n\n\n<h4 id=\"Express简介\"><a href=\"#Express简介\" class=\"headerlink\" title=\"Express简介\"></a>Express简介</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">概念\n\tExpress 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。\n\t\n本质\n\t对之前的内置模块http进行了封装,使用起来更加的方便\n\t\n核心\n\t可以设置中间件来响应 HTTP 请求。\n\t定义了路由表用于执行不同的 HTTP 请求动作\n\t\n核心概念\n\t路由\n\t\t根据不同的url路径,调用后台不同的处理函数\n\t中间件\n\t\t从请求开始到响应结束这个业务流程中的所有中间处理环节</code></pre>\n\n<h4 id=\"安装及使用\"><a href=\"#安装及使用\" class=\"headerlink\" title=\"安装及使用\"></a>安装及使用</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">安装\n\t新建一个英文的目录(目录名不要用express或express开头)\n\t进入这个目录,进行初始化(其实是生成了一个package.json配置文件)\n\t安装express,使用npm i express命令 \n使用\n\t1,导入express包\n\t2,实例化express对象\n\t3,处理请求\n\t4,设置端口监听\n\t\n区别(跟之前用http创建web服务的区别)\n\t1,不需要处理乱码问题\n\t2,不需要判断请求方式\n\t\n\tres.send() 和 res.end()区别\n\t\tend:其实原生的http模块中的方法,express也支持,只能传字符串,不能处理乱码问题\n\t\tsend:express中封装的方法,可以传任意类型,并且可以处理乱码问题</code></pre>\n\n<h4 id=\"express路由\"><a href=\"#express路由\" class=\"headerlink\" title=\"express路由\"></a>express路由</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">概念\n\t根据不同的url路径,调用后台不同的处理函数\n\t\n语法\n\tapp.请求方式(访问路径,处理函数)\n\t\t请求方式:get,post,put,delete,常用的是前两个\n\t\t访问路径:也可以正则(* 通配符)\n\t\t处理函数:匿名函数,匹配到不同路径,就会执行\n注意事项\n\t1,匹配顺序:从上到下\n\t2,只有请求方式和访问路径,同时匹配成功,express才会将这次请求转移到对应的处理函数处理</code></pre>\n\n","text":"昨日回顾一,基础的web服务器 1,导模块 2,创建服务器 3,绑定请求事件 4,设置端口监听 二,解决中文乱码 res.setHeader(&#39;content-type&#39;,&#39;text&#x2F;html;charset&#x3D;utf-8&#39;) 三...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"服务端","slug":"服务端","count":17,"path":"api/categories/服务端.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%A8%E6%97%A5%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">昨日回顾</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">接口编程概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#restful%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">restful接口设计</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#restful%E6%8E%A5%E5%8F%A3%E4%BD%93%E9%AA%8C\"><span class=\"toc-text\">restful接口体验</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#AJAX%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">AJAX概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%94%9F%E7%9A%84ajax\"><span class=\"toc-text\">原生的ajax</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jquery%E7%9A%84ajax\"><span class=\"toc-text\">jquery的ajax</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Express%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">Express简介</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">安装及使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#express%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">express路由</span></a></li></ol>","author":{"name":"团子","slug":"blog-author","avatar":"https://blog4xk-1309331490.cos.ap-nanjing.myqcloud.com/markdown/QQ%E5%9B%BE%E7%89%8720221205215218.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ajax","uid":"d9294510272c3f8944ed00db23e606c1","slug":"ajax","date":"2022-12-01T13:55:44.684Z","updated":"2022-12-02T06:08:32.165Z","comments":true,"path":"api/articles/ajax.json","keywords":null,"cover":[],"text":"一. 什么是AJAX1 概念 Asynchronous Javascript And Xml (异步javascript和xml) AJAX 不是新的编程语言，而是一种使用现有标准的新方法 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"服务端","slug":"服务端","count":17,"path":"api/categories/服务端.json"}],"tags":[{"name":"ajax","slug":"ajax","count":1,"path":"api/tags/ajax.json"}],"author":{"name":"团子","slug":"blog-author","avatar":"https://blog4xk-1309331490.cos.ap-nanjing.myqcloud.com/markdown/QQ%E5%9B%BE%E7%89%8720221205215218.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}}},"next_post":{"title":"28_express增删改查","uid":"7602872111d99ce5490d2dd6567dd4a3","slug":"day28_课堂笔记","date":"2022-12-01T13:54:02.386Z","updated":"2022-12-02T06:07:49.909Z","comments":true,"path":"api/articles/day28_课堂笔记.json","keywords":null,"cover":null,"text":"昨日回顾接口编程 接口 规范,定义前后端交互的规范 接口编程 前后端按照约定好的规则(接口文档中)进行编程. restful 概念 一种接口设计风格 六要素 前端 访问路径 请求方式 get 获取 post 新增 put 修改 delete 删除 请求参数 后端 状态码和描述 错...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"服务端","slug":"服务端","count":17,"path":"api/categories/服务端.json"}],"tags":[{"name":"express","slug":"express","count":6,"path":"api/tags/express.json"}],"author":{"name":"团子","slug":"blog-author","avatar":"https://blog4xk-1309331490.cos.ap-nanjing.myqcloud.com/markdown/QQ%E5%9B%BE%E7%89%8720221205215218.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}}}}