{"title":"28_express增删改查","uid":"7602872111d99ce5490d2dd6567dd4a3","slug":"day28_课堂笔记","date":"2022-12-01T13:54:02.386Z","updated":"2022-12-02T06:07:49.909Z","comments":true,"path":"api/articles/day28_课堂笔记.json","keywords":null,"cover":null,"content":"<h4 id=\"昨日回顾\"><a href=\"#昨日回顾\" class=\"headerlink\" title=\"昨日回顾\"></a>昨日回顾</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">接口编程\n\t接口\n    \t规范,定义前后端交互的规范\n\t接口编程\n    \t前后端按照约定好的规则(接口文档中)进行编程.\nrestful\n\t概念\n    \t一种接口设计风格\n     六要素\n     \t前端\n        \t访问路径\n            请求方式\n            \tget 获取\n                post 新增\n                put 修改\n                delete 删除\n            请求参数\n        后端\n        \t状态码和描述\n            错误信息\n            返回数据\n            \n     具体的请求\n     \t查询\n\t\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;goods\n\t\t\tGET http:&#x2F;&#x2F;localhost:3000&#x2F;goods&#x2F;1\n     \t新增\n        \tPOST http:&#x2F;&#x2F;localhost:3000&#x2F;good  \n\t\t\tname&#x3D;xiaomi&amp;price&#x3D;1999\n     \t修改\n        \tPUT http:&#x2F;&#x2F;localhost:3000&#x2F;good&#x2F;2  \n\t\t\tname&#x3D;xiaomi&amp;price&#x3D;1999\n     \t删除\n        \tDELETE http:&#x2F;&#x2F;localhost:3000&#x2F;goods&#x2F;2\n      \najax\n\t概念\n    \t异步的js和xml技术\n    作用\n    \t请求后台数据,异步刷新\t\n\t使用\n    \t原生的ajax\n        \t使用xmlhttpRequest对象\n        jquery的ajax\n        \t通用方式\n            \t$.ajax(&#123;\n                    url:请求路径\n                    type:请求方式\n                    data:请求参数\n                    dataType:返回的数据格式(默认是json)\n\t\t\t\t\tsuccess:function(res)&#123;&#125; &#x2F;&#x2F;成功\n\t\t\t\t\terror:function(err)&#123;&#125; &#x2F;&#x2F;失败\n                &#125;)\n            简化方式\n            \t$.get(访问路径,请求参数,回调函数)\n\t\t\t\t$.post(访问路径,请求参数,回调函数)\n\nexpress\n\t概念\n    \t基于nodejs的第三方框架,快速搭建一个完整功能的网站\n\t特性\n    \t路由\n        \t根据不同url路径和请求方式,调用后台不同的处理函数\n\t\t中间件\n        \t从请求到响应中间的所有处理环节\n    安装\n    \t初始化\n        \tnpm init -y\n\t\t安装\n        \tnpm i express\n        基本使用\n        \t导包\n            实例化对象\n            处理请求\n            设置端口监听\n        简单路由\n        \tapp.请求方式(访问路径,处理函数)\n\t\t\t匹配方式:从上到下\n            只有请求方式和访问路径都匹配才会执行后面的处理函数</code></pre>\n\n<h4 id=\"跨域请求问题\"><a href=\"#跨域请求问题\" class=\"headerlink\" title=\"跨域请求问题\"></a>跨域请求问题</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">概念\n\t从一个请求跳到另外一个请求,如果这两个请求的协议,域名和端口只要有一个不同,那么这次请求就是跨域请求(演示出错的问题:从5500端口跳到3000报错)\n\n火狐报错提示\n\t已拦截跨源请求：同源策略禁止读取位于 http:&#x2F;&#x2F;localhost:3000&#x2F;users 的远程资源。（原因：CORS 头缺少 &#39;Access-Control-Allow-Origin&#39;）\n\t\n解决方案\n\tres.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;) &#x2F;&#x2F;允许跨域请求</code></pre>\n\n\n\n<h4 id=\"Express增删改查\"><a href=\"#Express增删改查\" class=\"headerlink\" title=\"Express增删改查\"></a>Express增删改查</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">查询\n\tget方式  --&gt; app.get()\n\t\n\t查询所有 http:&#x2F;&#x2F;localhost:3000&#x2F;users   后台: &#x2F;users  直接返回数组\n\t查询一个 http:&#x2F;&#x2F;localhost:3000&#x2F;users?id&#x3D;1  后台: &#x2F;users  通过req.query获取参数\n\t查询一个 http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1  后台 &#x2F;users&#x2F;:id  通过req.params获取参数\n\t\n新增\n\tpost方式 --&gt; app.post()\n\t\n\t前台\n\t\thttp:&#x2F;&#x2F;localhost:3000&#x2F;users  application&#x2F;json &#123;&quot;name&quot;:&quot;赵六&quot;,&quot;age&quot;:26&#125;\n\t后台\n\t\t获取请求体数据\n\t\t设置新增用户的id\n\t\t把新增的用户添加到数组\n修改\n\tput方式 --&gt; app.put()\n\t\n\t前台\n\t\thttp:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1  application&#x2F;json &#123;&quot;name&quot;:&quot;赵六&quot;,&quot;age&quot;:26&#125;\n\t后台\n\t\t获取要修改元素的id\n\t\t获取请求体数据\n\t\t查找id相同的元素进行修改\n\t\t\n删除\n\tdelete方式 --&gt; app.delete()\n\t\n\t前台\n\t\thttp:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;1\n\t后台\n\t\t获取要修改元素的id\n\t\t查找id相同的元素进行删除</code></pre>\n\n\n\n<h4 id=\"抽取及中间件简化\"><a href=\"#抽取及中间件简化\" class=\"headerlink\" title=\"抽取及中间件简化\"></a>抽取及中间件简化</h4><h5 id=\"抽取请求体\"><a href=\"#抽取请求体\" class=\"headerlink\" title=\"抽取请求体\"></a>抽取请求体</h5><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;封装一个中间件函数\n\n&#x2F;&#x2F;抽取获取请求体数据的方法\nfunction getPostData(req,res,next)&#123;\n    &#x2F;&#x2F;解决跨域请求\n    res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)\n\n    &#x2F;&#x2F;监听req的data和end事件\n    let postData &#x3D; &#39;&#39;\n    req.on(&#39;data&#39;,data &#x3D;&gt; postData +&#x3D; data) \n    req.on(&#39;end&#39;,()&#x3D;&gt;&#123; \n            &#x2F;&#x2F;使用JSON解析\n            const obj &#x3D; JSON.parse(postData)\n            \n            &#x2F;&#x2F;解决的第一问题:获取的请求体数据如果传递给下一个函数,使用req对象\n            &#x2F;&#x2F;(在req中自定义一个body属性,来存数据,将来在下一个函数中,就可以通过req.body拿到数据)\n            req.body &#x3D; obj\n\n            &#x2F;&#x2F;解决第二个问题:如果在当前函数中继续调用下一个函数(使用next参数)\n            next() &#x2F;&#x2F;作用:可以把函数的调用移交到下一个处理函数\n         &#125;)\n&#125;\n\n&#x2F;&#x2F;调用中间件函数\napp.post(&#39;&#x2F;users&#39;,getPostData,function(req,res)&#123;\n    \n    &#x2F;&#x2F;获取请求体数据\n    const user &#x3D; req.body\n\n    &#x2F;&#x2F;设置新增用户的id为数组长度+1\n    user.id &#x3D; db.length + 1\n\n    &#x2F;&#x2F;把新增的用户添加到数组\n    db.push(user)\n\n    &#x2F;&#x2F;发送数组给浏览器\n    res.send(db)\n    \n&#125;)</code></pre>\n\n<h5 id=\"中间件函数\"><a href=\"#中间件函数\" class=\"headerlink\" title=\"中间件函数\"></a>中间件函数</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">概念(middleWare)\n\t特指业务流程的中间处理环节,本质就是一个function处理函数\n\t\n调用流程\n\t当一个请求到达express服务器之后,可以连续调用多个中间件,从而对这次请求进行预处理\n\t\n分类\n\t按照作用范围来分\n\t\t局部生效的中间件\n\t\t全局生效的中间件\n\t按照级别来分\n\t\texpress内置中间件\n\t\texpress第三方中间件\n\t\t应用级中间件\n\t\t路由级中间件\n\t\t\n注意\n\t中间件函数的形参列表中,必须包含next参数\n\t跟之前的路由处理函数不同(路由处理函数只包含req和res参数)\n\tnext作用:实现多个中间件连续调用的关键,表示把流转关系移交到写一个中间件或者处理函数</code></pre>\n\n\n\n<h4 id=\"中间件的范围划分\"><a href=\"#中间件的范围划分\" class=\"headerlink\" title=\"中间件的范围划分\"></a>中间件的范围划分</h4><h5 id=\"局部生效的中间件\"><a href=\"#局部生效的中间件\" class=\"headerlink\" title=\"局部生效的中间件\"></a>局部生效的中间件</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">概念\n\t只在某些访问路径中使用的中间件,叫做局部生效的中间件\n举例\n\tgetPostData中间件,只在新增和修改的路由中生效,是局部生效的中间件\n注意\n\t1,一定要在路由之前注册中间件\n\t2,客户端发送过来的请求,可以连续调用多个中间件进行处理\n\t3,执行完中间件的业务代码之后,不要忘记调用next()\n\t4,为了防止代码逻辑混乱,调用next()之后,不要写额外代码\n\t5,连续调用多个中间件,多个中间件之间,共享req和res对象</code></pre>\n\n<h5 id=\"全局生效的中间件\"><a href=\"#全局生效的中间件\" class=\"headerlink\" title=\"全局生效的中间件\"></a>全局生效的中间件</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">概念\n\t客户端发起的任何请求,到达服务器后,都会触发的中间件,叫做全局生效的中间件\n使用\n\t通常使用 app.use(中间件函数),来定义一个全局生效的中间件</code></pre>\n\n\n\n<h4 id=\"中间件的级别划分\"><a href=\"#中间件的级别划分\" class=\"headerlink\" title=\"中间件的级别划分\"></a>中间件的级别划分</h4><h5 id=\"内置中间件\"><a href=\"#内置中间件\" class=\"headerlink\" title=\"内置中间件\"></a>内置中间件</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">概念\n\t由express官方提供的,主要有3个常见的内置中间件\n分类\n\texpress.json\n\t\t解析json格式的请求体数据\n\texpress.urlencoded\n\t\t解析url-encode格式的请求体数据\n\texpress.static\n\t\t快速托管静态资源,可以帮助加载html文件,图片,css样式</code></pre>\n\n<h5 id=\"第三方中间件\"><a href=\"#第三方中间件\" class=\"headerlink\" title=\"第三方中间件\"></a>第三方中间件</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">概念\n\t由第三方个人或者团体开发的,使用之前需要下载\n分类\n\tcors() 处理跨域请求\n使用\n\tnpm i cors 下载跨域请求的包\n\tconst cors &#x3D; require(&#39;cors&#39;);  导入 cors 包\n\tapp.use(cors())  引入第三方中间件处理跨域请求\n原理\n\t在每一个响应中添加响应头:Access-Control-Allow-Credentials: true</code></pre>\n\n<h5 id=\"应用级中间件\"><a href=\"#应用级中间件\" class=\"headerlink\" title=\"应用级中间件\"></a>应用级中间件</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">概念\n\t通过app.use(),或者app.get(),app.post()绑定到app实例上的中间件\n注意\n\t应用级中间件,可以是全局生效的,也可以是局部生效的,只不过都要绑定到app上</code></pre>\n\n<h5 id=\"模块化路由-额外\"><a href=\"#模块化路由-额外\" class=\"headerlink\" title=\"模块化路由(额外)\"></a>模块化路由(额外)</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">产生的原因\n\t1,当路由很多的时候,如果全部写在app入口文件,文件就会太大,不好维护\n\t2,项目中有不同类型的请求路径(用户相关,商品相关)都放在一个文件中,不好维护\n\t3,为了方便对路由进行模块化的管理,express不建议将路由直接挂载到app上,而是推荐\n\t\t将路由抽成单独的模块\n\t\t\n使用步骤\n\t1,创建路由模块对应的js文件,放在routes文件夹下\n\t2,调用express.router()创建路由器对象\n\t3,向路由对象上挂载具体的路由\n\t4,使用module.exports向外共享路由对象\n\t5,在入口文件中,使用app.use()注册路由模块</code></pre>\n\n<h5 id=\"路由级中间件\"><a href=\"#路由级中间件\" class=\"headerlink\" title=\"路由级中间件\"></a>路由级中间件</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">概念\n\t绑定到路由对象(express.router()创建的)的中间件\n注意\n\t路由级中间件用处不是很多,了解一下就行</code></pre>\n\n","text":"昨日回顾接口编程 接口 规范,定义前后端交互的规范 接口编程 前后端按照约定好的规则(接口文档中)进行编程. restful 概念 一种接口设计风格 六要素 前端 访问路径 请求方式 get 获取 post 新增 put 修改 delete 删除 请求参数 后端 状态码和描述 错...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"服务端","slug":"服务端","count":17,"path":"api/categories/服务端.json"}],"tags":[{"name":"express","slug":"express","count":6,"path":"api/tags/express.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%A8%E6%97%A5%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">昨日回顾</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">跨域请求问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Express%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5\"><span class=\"toc-text\">Express增删改查</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E5%8F%96%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AE%80%E5%8C%96\"><span class=\"toc-text\">抽取及中间件简化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E5%8F%96%E8%AF%B7%E6%B1%82%E4%BD%93\"><span class=\"toc-text\">抽取请求体</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">中间件函数</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E8%8C%83%E5%9B%B4%E5%88%92%E5%88%86\"><span class=\"toc-text\">中间件的范围划分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E7%94%9F%E6%95%88%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6\"><span class=\"toc-text\">局部生效的中间件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E7%94%9F%E6%95%88%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6\"><span class=\"toc-text\">全局生效的中间件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E7%BA%A7%E5%88%AB%E5%88%92%E5%88%86\"><span class=\"toc-text\">中间件的级别划分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%86%85%E7%BD%AE%E4%B8%AD%E9%97%B4%E4%BB%B6\"><span class=\"toc-text\">内置中间件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E6%96%B9%E4%B8%AD%E9%97%B4%E4%BB%B6\"><span class=\"toc-text\">第三方中间件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E7%BA%A7%E4%B8%AD%E9%97%B4%E4%BB%B6\"><span class=\"toc-text\">应用级中间件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97%E5%8C%96%E8%B7%AF%E7%94%B1-%E9%A2%9D%E5%A4%96\"><span class=\"toc-text\">模块化路由(额外)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E7%BA%A7%E4%B8%AD%E9%97%B4%E4%BB%B6\"><span class=\"toc-text\">路由级中间件</span></a></li></ol></li></ol>","author":{"name":"团子","slug":"blog-author","avatar":"https://www.helloimg.com/images/2022/12/01/Zu250T.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"27_接口编程_ajax_express入门","uid":"6bf0818317072d9a48cc178884cabdd5","slug":"day27_课堂笔记","date":"2022-12-01T13:54:02.386Z","updated":"2022-12-02T06:07:54.411Z","comments":true,"path":"api/articles/day27_课堂笔记.json","keywords":null,"cover":null,"text":"昨日回顾一,基础的web服务器 1,导模块 2,创建服务器 3,绑定请求事件 4,设置端口监听 二,解决中文乱码 res.setHeader(&#39;content-type&#39;,&#39;text&#x2F;html;charset&#x3D;utf-8&#39;) 三...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"服务端","slug":"服务端","count":17,"path":"api/categories/服务端.json"}],"tags":[],"author":{"name":"团子","slug":"blog-author","avatar":"https://www.helloimg.com/images/2022/12/01/Zu250T.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}}},"next_post":{"title":"26_手写web服务_处理get_post请求参数","uid":"7bc9d1c1cb8c4ecce97b26cdf0cc3331","slug":"day26_课程笔记","date":"2022-12-01T13:46:15.874Z","updated":"2022-12-02T06:07:58.181Z","comments":true,"path":"api/articles/day26_课程笔记.json","keywords":null,"cover":[],"text":"昨日回顾内置模块 fs 处理文件 readFile() writeFile() path 处理路径 join() http 服务器相关 createServer() 包(第三方模块) 概念 由第三方个人或者团队开发出来的免费模块 作用 封装了内置模块,提高效率 使用 npm 包管...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"服务端","slug":"服务端","count":17,"path":"api/categories/服务端.json"}],"tags":[{"name":"http","slug":"http","count":2,"path":"api/tags/http.json"}],"author":{"name":"团子","slug":"blog-author","avatar":"https://www.helloimg.com/images/2022/12/01/Zu250T.jpg","link":"/","description":"处变不惊   安之若素","socials":{"github":"https://github.com/codbish","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/bguihiub","juejin":"","customs":{}}}}}